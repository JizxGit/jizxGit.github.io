<!DOCTYPE html>
<html>
<head hexo-theme="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4"><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="x-dns-prefetch-control" content="on">

  <!-- 页面元数据 -->
  
  <title>awk - 玖玖的博客</title>
  
    <meta name="keywords" content="工具,awk,linux">
  

  
    <meta name="description" content=" 

linux 三剑客之一 awk 的详细介绍">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css">
  
  

  

  

  

  

  <!-- import link -->
  

  
  
    <link rel="stylesheet" href="/css/style.css">
  
  
  
  <!-- 脚本懒加载函数 -->
  <script>
  function loadScript(src, cb) {
    var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
    var script = document.createElement('script');
    script.setAttribute('type','text/javascript');
    if (cb) script.onload = cb;
    script.setAttribute('src', src);
    HEAD.appendChild(script);
  }
  //https://github.com/filamentgroup/loadCSS
  !function(c){"use strict";var e=function(e,t,n,r){var o,i=c.document,a=i.createElement("link");if(t)o=t;else{var d=(i.body||i.getElementsByTagName("head")[0]).childNodes;o=d[d.length-1]}var f=i.styleSheets;if(r)for(var l in r)r.hasOwnProperty(l)&&a.setAttribute(l,r[l]);a.rel="stylesheet",a.href=e,a.media="only x",function e(t){if(i.body)return t();setTimeout(function(){e(t)})}(function(){o.parentNode.insertBefore(a,t?o:o.nextSibling)});var s=function(e){for(var t=a.href,n=f.length;n--;)if(f[n].href===t)return e();setTimeout(function(){s(e)})};function u(){a.addEventListener&&a.removeEventListener("load",u),a.media=n||"all"}return a.addEventListener&&a.addEventListener("load",u),(a.onloadcssdefined=s)(u),a};"undefined"!=typeof exports?exports.loadCSS=e:c.loadCSS=e}("undefined"!=typeof global?global:this);
  </script>
  <script id="loadcss"></script>
</head>

<body>
  <header class="l_header auto shadow blur " style='opacity: 0' >
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div class="l_body">
    <div class="l_cover">
  
    
    
        <div class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Volantis</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              id="v4getting-started">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              id="faqs">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              id="examples">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              id="contributors">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f389.svg'><p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
            <a href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              id="https:githubcomvolantis-xhexo-theme-volantis">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg'><p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>
  
    <div class='safearea'>
      <div class='body-wrapper' id="pjax-container">
        
          <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">true</div> 
  <div id="pjax-pageTitle">awk</div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path"></div> 
  <div id="pjax-comment-placeholder"></div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover-wrapper')[0].style.display = "none"; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "half") { // 半屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'half'); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "full") { // 全屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'full'); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover-wrapper')[0].style.display = ""; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 
 

        
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        awk
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="">
    <p>请设置文章作者</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <a class='notlink'>
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <a class="category-link" href="/categories/linux/">linux</a><span class="sep"></span><a class="category-link" href="/categories/linux/awk/">awk</a><span class="sep"></span><a class="category-link" href="/categories/linux/awk/工具/">工具</a>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Sep 2, 2019</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="awk" data-path="/2019/09/02/awk/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <excerpt in="" index="" |="" 首页摘要=""> 

<p>linux 三剑客之一 awk 的详细介绍</p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="awk英文文档"><a href="#awk英文文档" class="headerlink" title="awk英文文档"></a>awk英文文档</h3><p><a href="https://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">https://www.gnu.org/software/gawk/manual/gawk.html</a></p>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>基本组成形式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk options program file1 </span><br><span class="line">awk options program file1 file2</span><br><span class="line">awk options program <span class="comment"># 进入交互模式，直到ctrl+d结束输入</span></span><br></pre></td></tr></table></figure>
<p>由于gawk命令行假定脚本是单个文本字符串，你<strong>必须将脚本放到单引号中</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; print "start";command2 &#125; pattern &#123; command1;command2 &#125; END&#123; print "end";command2 &#125;'</span> file</span><br></pre></td></tr></table></figure>
<ul>
<li>一个命令就是一个以新行或者分号分隔的语句序列。</li>
<li>由于模式和命令两者任一都是可选的，所以需要使用大括号包围动作以区分于其他模式。</li>
<li>多条语句之间用<code>;</code>分隔<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; print $1,$6 &#125;'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="/2019/09/02/awk/./awk_workflow.jpg" class="lazyload" data-srcset="./awk_workflow.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<ol>
<li><p>awk以<strong>逐行的形式</strong>处理文件</p>
</li>
<li><p><code>BEGIN</code>之后的命令会先于公共语句块执行</p>
<blockquote>
<p>  BEGIN语句块在awk开始从输入流中读取行之前被执行（除非调用了 <code>getline</code>）。这是一个<strong>可选的</strong>语句块，诸如变量初始化、打印输出表格的表头等语句通常都可以放在BEGIN语句块中。</p>
</blockquote>
</li>
<li><p>对于匹配PATTERN的行，awk会对其执行<code>PATTERN</code>之后的命令</p>
<blockquote>
<p>  这个语句块是<strong>可选的</strong>。如果不提供，则默认执行<code>{ print }</code>，即打印所读取到的每一行。 如果提供，则每个pattern依次测试每个输入行。对于匹配到行的模式，其对应的命令（也许包含多步）得到执行，然后读取下一行并继续匹配，直到所有的输入读取完毕。</p>
</blockquote>
</li>
<li><p>最后，在处理完整个文件之后，awk会执行<code>END</code>之后的命令</p>
<blockquote>
<p>  END语句块和BEGIN语句块类，也是<strong>可选的</strong>语句块。它在awk读取完输入流中所有的行之后被执行。像打印所有行的分析结果这种常见任务都是在END语句块中实现的。</p>
</blockquote>
</li>
</ol>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a><code>print</code>输出</h4><p><code>print</code>接受的变量之间以<strong>逗号分隔</strong>，在输出时会<strong>以空格作为变量之间的分隔符</strong>。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $3,$4&#125;&apos; marks.txt</span><br></pre></td></tr></table></figure>
<p><strong><code>print</code>之间的空格不会影响输出格式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $3 "\t" $4&#125;'</span> marks.txt <span class="comment"># $3与\t之间的空格不会显示在输出中</span></span><br><span class="line">awk <span class="string">'&#123;print $3 , $4&#125;'</span> marks.txt <span class="comment"># 逗号表示最终会以空格分分隔两个字段</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串拼接</strong></p>
<p>在awk的<code>print</code>语句中，<strong>双引号被当作拼接操作符</strong>（concatenation operator）使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; var1="v1"; var2="v2"; var3="v3"; \</span></span><br><span class="line"><span class="string">print var1 "-" var2 "-" var3 ; &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># v1-v2-v3</span></span><br></pre></td></tr></table></figure>
<p><strong>省略<code>print</code></strong></p>
<p>如果没有主体块——默认的动作是输出行。因此比如搜索字符串<code>Tom</code>可以使用下面简略方式实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/Tom/'</span> marks.txt</span><br></pre></td></tr></table></figure>
<p><strong>打印一行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; print &#125;</span><br><span class="line"># 或者，由于 $0 表示整行,</span><br><span class="line">&#123; print $0 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印特定列</strong></p>
<p>使用一个 print 语句可以在同一行中输出不止一个字段. 下面的程序输出了每 行输入中的第一和第三个字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $1, $3 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>NF</strong> 列总数</p>
<p>该变量表示一共有多少列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print NF, $1, $NF &#125; # 打印第一列 和最后一列</span><br></pre></td></tr></table></figure>
<p><strong>计算和打印</strong></p>
<p>你也可以对字段的值进行计算后再打印出来. 下面的程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $1, $2 * $3 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>NR 打印行号</strong></p>
<p>存储当前已经读取了多少行的计数。给每一行加上行号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print NR, $0 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>在输出中添加内容</strong></p>
<p>双引号内的文字将会在字段和计算的值中插入输出.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print &quot;total pay for&quot;, $1, &quot;is&quot;, $2 * $3 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>排序输出</strong></p>
<p>最简单的方式是使用awk将每位员工的总薪酬置于其记录之前，然后利用<strong>sort</strong>命令来处理awk的输出。Unix上，命令行如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123; printf(&quot;%6.2f    %s\n&quot;, $2 * $3, $0) &#125;&apos; emp.data | sort</span><br></pre></td></tr></table></figure>
<p><strong>打印表头，表尾</strong></p>
<p> BEGIN 用于匹配第一个输入文件的第一行之前的位置， END 则用于匹配处理过的最后一个文件的最后一行之后的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;print &quot;Name Rate Hour&quot;;print &quot;=========&quot;&#125; &#123;print $0&#125;&apos; file</span><br></pre></td></tr></table></figure>
<p><strong>字符串拼接</strong></p>
<ul>
<li>在命令中使用<strong>空格</strong>进行变量拼接</li>
<li>在<code>print</code>语句块中使用<strong>双引号</strong>拼接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将names变量与当前行的的$1以及空格进行拼接，赋值给names</span><br><span class="line"> &#123; names = names $1 &quot; &quot;&#125;</span><br><span class="line">END &#123; print names &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>只打印最后一行</strong></p>
<p><strong>打印最后一个输入行</strong></p>
<p>虽然在 END 动作中 NR 还保留着它的值，但 $0 没有。程序是打印最后一个输入行的一种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#123; last = $0 &#125;</span><br><span class="line">END &#123; print last &#125;</span><br></pre></td></tr></table></figure>
<h4 id="printf高级输出"><a href="#printf高级输出" class="headerlink" title="printf高级输出"></a><code>printf</code>高级输出</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>printf 语句的形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(format, value1, value2, ..., valuen)</span><br></pre></td></tr></table></figure>
<p>其中 format 是字符串，包含要逐字打印的文本，穿插着 format 之后的每个值该如何打印的规格(specification)。一个规格是一个 % 符，后面跟着一些字符，用来控制一个 value 的格式。第一个规格说明如何打印 value1 ，第二个说明如何打印 value2 ，… 。因此，有多少 value 要打印，在 format 中就要有多少个 % 规格。（与C语言很像）</p>
<p>这里有个程序使用 printf 打印每位员工的总薪酬：:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; printf(&quot;total pay for %s is $%.2f\n&quot;, $1, $2 * $3) &#125;</span><br></pre></td></tr></table></figure>
<h5 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h5><p><strong>退格符</strong><code>\b</code></p>
<p><strong>换页符</strong><code>\f</code></p>
<p><strong>换行符</strong><code>\n</code> ，进入下一行</p>
<p><strong>回车符</strong><code>\r</code> ，光标移动到第一列</p>
<blockquote>
<p>  这与以前的打字机相关，以前的打字机达打完一行后，机械上需要2步，先将指针移动到下一行（换行），然后将指针回到行首（回车）</p>
</blockquote>
<p>我们在每个域输出后输出一个回车符<code>\r</code>，随后输出的域会覆盖之前输出的内容。也就是说，我们只能看到最后输出的 Field 4。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; printf "Field 1\rField 2\rField 3\rField 4\n" &#125;'</span></span><br><span class="line"><span class="comment"># Field 4</span></span><br></pre></td></tr></table></figure>
<p><strong>垂直制表符</strong></p>
<p>如下示例，使用垂直制表符输出不同域：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; printf "Sr No\vName\vSub\vMarks\n" &#125;'</span></span><br><span class="line"><span class="comment"># 执行上面的命令可以得到如下的结果</span></span><br><span class="line">Sr No</span><br><span class="line">    Name</span><br><span class="line">        Sub</span><br><span class="line">            Marks</span><br></pre></td></tr></table></figure>
<h5 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符%"></a>格式说明符%</h5><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%c</td>
<td>输出<strong>单个字符</strong>。如果参数是个数值，那么数值也会被当作字符然后输出。如果参数是字符串，那么只会输出第一个字符。</td>
</tr>
<tr>
<td>%d 与 %i</td>
<td>输出十进制数的整数部分。</td>
</tr>
<tr>
<td>%f</td>
<td>输出浮点数，以 [-]ddd.dddddd 的格式</td>
</tr>
<tr>
<td>%e 与 %E</td>
<td>输出浮点数，以 [-]d.dddddde[+-]dd 的格式。区别就是输出<code>8.066000e+01</code>与<code>8.066000E+01</code>的<code>e</code>的大小写</td>
</tr>
<tr>
<td>%g 与 %G</td>
<td>输出浮点数，使用 %e 或 %E 转换。但它们会<strong>删除那些对数值无影响的 0</strong>。（推荐）</td>
</tr>
<tr>
<td>%o</td>
<td>无符号八进制输出。</td>
</tr>
<tr>
<td>%u</td>
<td>无符号十进制数输出。</td>
</tr>
<tr>
<td>%x 与 %X</td>
<td>输出十六进制无符号数。%X 中使用大写字母，%x 使用小写字母。</td>
</tr>
<tr>
<td>%%</td>
<td>输出百分号（%），不需要输入参数。</td>
</tr>
</tbody>
</table>
<h5 id="格式说明符-的可选参数"><a href="#格式说明符-的可选参数" class="headerlink" title="格式说明符% 的可选参数"></a>格式说明符% 的可选参数</h5><p><strong>列宽</strong></p>
<p><code>%8d</code>表示用空格填充占8列，如果紧接在 % 后是以0开头的数字<code>%08d</code>，表示输出应该使用0填充而不是空格字符。</p>
<p><strong>对齐</strong></p>
<p>默认是右边对齐，在 % 之后数字之前使用减号（-）即可指定输出左对齐</p>
<p><strong>符号前缀</strong></p>
<p>但是<code>+</code>不是表示右对齐，是表示输出数值的符号，正号也输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; num = -10; printf "Num = %-+10d\n", num &#125;'</span> | cat -vte</span><br></pre></td></tr></table></figure>
<p><strong>哈希<code>#</code></strong></p>
<p>将<code>#</code>放在<code>%</code>后， 可以为 %o 的结果前添加0，为 %x 或 %X 输出的结果前添加 0x 或 0X （结果不为零时），为 %e，%E，%f，%F添加小数点；对于 %g 或 %G，使用哈希可以保留尾部的零</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123; printf &quot;Octal representation = %#o\nHexadecimal representaion = %#X\n&quot;, 10, 10&#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="重定向、管道、双向管道"><a href="#重定向、管道、双向管道" class="headerlink" title="重定向、管道、双向管道"></a>重定向、管道、双向管道</h4><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>AWK 重定向操作符重定向数据到文件 message.txt 中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "Hello, World !!!" &gt; "/tmp/message.txt" &#125;'</span></span><br><span class="line">cat /tmp/message.txt</span><br></pre></td></tr></table></figure>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>下面的例子中我们使用 <code>tr</code> 命令将小写字母转换成大写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "hello, world !!!" | "tr [a-z] [A-Z]" &#125;'</span></span><br><span class="line"><span class="comment"># HELLO, WORLD !!！</span></span><br></pre></td></tr></table></figure>
<h5 id="双向通信通道"><a href="#双向通信通道" class="headerlink" title="双向通信通道"></a>双向通信通道</h5><p>（TODO 还不知道怎么用）</p>
<p>AWK 允许使用 <code>|&amp;</code> 与一个外部进程通信，并且可以双向通信。下面的例子中，使用 <code>tr</code> 命令将字母转换为大写字母。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    cmd = <span class="string">"tr [a-z] [A-Z]"</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"hello, world !!!"</span> |&amp; cmd</span><br><span class="line">    close(cmd, <span class="string">"to"</span>)</span><br><span class="line">    cmd |&amp; getline out</span><br><span class="line">    <span class="built_in">print</span> out;</span><br><span class="line">    close(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的命令可以得到如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELLO, WORLD !!!</span><br></pre></td></tr></table></figure>
<p>脚本的内容看上去很神秘吗？让我们一步一步揭开它神秘的面纱。</p>
<ul>
<li>第一条语句 cmd = “tr [a-z][A-Z]” 在AWK 中建立了一个双向的通信通道。</li>
<li>第二条语句 print 为 tr 命令提供输入。&amp;| 表示双向通信。</li>
<li>第三条语句 close(cmd, “to”) 执行后关闭 to 进程。</li>
<li>第四条语句 cmd |&amp; getline out 使用 getline 函数将输出存储到 out 变量中。</li>
<li>接下来的输出语句打印输出的内容，最后 close 函数关闭 cmd。</li>
</ul>
<h4 id="保存到不同文件中"><a href="#保存到不同文件中" class="headerlink" title="保存到不同文件中"></a>保存到不同文件中</h4><p>跳过表头，第6列是文件名，因此这样就可以将每一行分别保存在不同的文件中，进行了分类</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'NR!=1&#123;print $4,$5 &gt; $6&#125;' netstat.txt</span><br></pre></td></tr></table></figure>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>标准参数</strong></td>
</tr>
<tr>
<td>-F fs</td>
<td>fs是分隔符，默认是空白符（空格、制表符），fs可以是字符串或正则表达式。<br>如<code>-F:</code> 表示冒号为分隔符；<br>如果想指定空格为分隔符，请看下面例子。</td>
</tr>
<tr>
<td>-v var=value</td>
<td>赋值一个用户定义变量，将外部变量传递给awk</td>
</tr>
<tr>
<td>-f scripfile</td>
<td>从脚本文件中读取awk命令</td>
</tr>
<tr>
<td>-p[file]</td>
<td>用于格式化 awk 脚本文件。默认输出文件是 <strong>awkprof.out</strong>。</td>
</tr>
<tr>
<td></td>
<td><strong>gawk 参数</strong></td>
</tr>
<tr>
<td>-mf N</td>
<td>指定要处理的数据文件中的最大字段数</td>
</tr>
<tr>
<td>-mr N</td>
<td>指定数据文件中的最大数据行数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>  在BEGIN语句块中可以用OFS=”delimiter”设置输出字段分隔符。<code>awk &#39;BEGIN { FS=&quot;:&quot; }{ print }</code></p>
</blockquote>
<p><strong>指定空格为分隔符</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc d"</span>|awk -F<span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span>   <span class="comment"># 无效，还是会将\t进行分割</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc d"</span>|awk -F<span class="string">'[ ]'</span> <span class="string">'&#123;print $2&#125;'</span> <span class="comment"># 推荐</span></span><br></pre></td></tr></table></figure>
<p><strong>同时使用多个分隔符</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 使用多个分隔符, 遇到";"或者","就进行分割，因此下面的例子会得到 5 列</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1;2,3;4,5"</span>|awk -F <span class="string">'[;,]'</span> <span class="string">'&#123;print $1,$2,$3,$4,$5&#125;'</span></span><br><span class="line"><span class="comment"># 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<p>或者使用<code>|</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F&quot;\t|,&quot; &apos;&apos; file   # 以\t 或者逗号分隔</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://ipcmen.com/awk" target="_blank" rel="noopener">https://ipcmen.com/awk</a></p>
<p><strong>格式化脚本</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk --profile <span class="string">'BEGIN&#123;printf"---|Header|--\n"&#125; &#123;print&#125; END&#123;printf"---|Footer|---\n"&#125;'</span> marks.txt &gt; /dev/null </span><br><span class="line">[jerry]$ cat awkprof.out</span><br></pre></td></tr></table></figure>
<p>执行上面的命令可以得到如下的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># gawk profile, created Sun Oct 26 19:50:48 2014</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BEGIN block(s)</span></span><br><span class="line"></span><br><span class="line">    BEGIN &#123;</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"---|Header|--\n"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rule(s)</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># END block(s)</span></span><br><span class="line"></span><br><span class="line">    END &#123;</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"---|Footer|---\n"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式-pattern-种类"><a href="#模式-pattern-种类" class="headerlink" title="模式(pattern)种类"></a>模式(pattern)种类</h3><p><strong>BEGIN { 语句 }</strong></p>
<p>在读取任何输入前执行一次语句</p>
<p><strong>END { 语句 }</strong></p>
<p>读取所有输入之后执行一次语句</p>
<p><strong>表达式 { 语句 }</strong></p>
<p>对于表达式为真（即，非零或非空）的行，执行语句</p>
<p><strong>/正则表达式/ { 语句 }</strong></p>
<p>如果输入行包含字符串与正则表达式相匹配，则执行语句</p>
<p><strong>组合模式 { 语句 }</strong></p>
<p>一个 组合模式 通过与（<code>&amp;&amp;</code>），或（<code>||</code>），非（<code>!</code>），以及括弧来组合多个表达式；对于组合模式为真的每个输入行，执行 语句</p>
<p><strong>模式1，模式2 { 语句 }</strong></p>
<p>范围模式(range pattern)匹配从与模式1相匹配的行到与模式2相匹配的行（包含该行）之间的所有行，对于这些输入行，执行语句。</p>
<blockquote>
<p>  BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。BEGIN和END是仅有的必须搭配动作的模式。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;NR &lt; 5&apos;        # 行号小于5的行</span><br><span class="line">awk &apos;NR==1,NR==4&apos;   # 行号在1到5之间的行 </span><br><span class="line">awk &apos;/linux/&apos;       # 包含模式为linux的行（可以用正则表达式来指定模式）</span><br><span class="line">awk &apos;!/linux/&apos;      # 不包含模式为linux的行</span><br></pre></td></tr></table></figure>
<h3 id="选择、过滤"><a href="#选择、过滤" class="headerlink" title="选择、过滤"></a>选择、过滤</h3><p><strong>数值判断</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$2</span> * <span class="variable">$3</span> &gt; 50 &#123; <span class="built_in">printf</span>(<span class="string">"$%.2f for %s\n"</span>, <span class="variable">$2</span> * <span class="variable">$3</span>, <span class="variable">$1</span>) &#125;</span><br></pre></td></tr></table></figure>
<p><strong>文本内容选择，支持正则</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">1 == <span class="string">"Susie"</span> &#123; <span class="built_in">print</span> &#125;  <span class="comment"># 比较字段是否等于字符串时，要使用双引号包起来</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">1~/正则内容/ &#123; <span class="built_in">print</span> <span class="variable">$1</span>&#125; <span class="comment"># 对某一列进行正则</span></span></span><br><span class="line">/正则内容/ &#123; print $1&#125;	  # 对整行进行匹配</span><br><span class="line">/条件1/,/条件2/ &#123; print $1&#125;	  # 对整行进行多条件匹配</span><br></pre></td></tr></table></figure>
<p>匹配中文</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$1 ~/[一-龥]/'  匹配中文</span><br><span class="line">awk '$1 ~/[\u4e00-\u9fa5]/'  这样反而不行，要不unicode转成对应的中文</span><br></pre></td></tr></table></figure>
<p><strong>多条件组合</strong></p>
<p>逻辑操作符与 &amp;&amp; ， 或 || ， 以及非 ! 对模式进行组合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$2 &gt;= 4 || $3 &gt;= 20 &#123;print&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>!</code>是在括号前的，第1种其实与第2种一模一样，正确的是第3种</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline )&#123;dict[c]=1&#125;&#125; ! $2 in dict&#123;print&#125;' some.txt |wc</span><br><span class="line">      0       0       0</span><br><span class="line">      </span><br><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline c)&#123;dict[c]=1&#125;&#125; (! $2 in dict)&#123;print&#125;' some.txt |wc</span><br><span class="line">      0       0       0</span><br><span class="line">      </span><br><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline )&#123;dict[c]=1&#125;&#125; !($2in dict)&#123;print&#125;' some.txt |wc</span><br><span class="line">1296838 14273901 226060062</span><br></pre></td></tr></table></figure>
<h3 id="多条命令"><a href="#多条命令" class="headerlink" title="多条命令"></a>多条命令</h3><p>要在命令行上的程序脚本中使用多条命令，</p>
<ul>
<li>只要在命令之间放个<strong>分号</strong>即可。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"My name is Rich"</span> | gawk <span class="string">'&#123;$4="Christine"; print $0&#125;'</span> My name is Christine</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以用次提示符一次一行地输入程序脚本命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; \</span></span><br><span class="line"><span class="string">&gt; $4="Christine"</span></span><br><span class="line"><span class="string">&gt; print $0&#125;'</span> </span><br><span class="line">My name is Rich </span><br><span class="line"></span><br><span class="line">$ My name is Christine</span><br></pre></td></tr></table></figure>
<h3 id="将命令保存在文件中"><a href="#将命令保存在文件中" class="headerlink" title="将命令保存在文件中"></a>将命令保存在文件中</h3><p>当引号内的程序过长时，可以单独保存在文件中，假设存在文件 progfile ，输入命令行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f progfile	file</span><br></pre></td></tr></table></figure>
<p>文件中不用引号包起来，但是中括号还是需要的，多条指令在同一行中用分号分分隔，或者以多行形式书写</p>
<h4 id="读取命令的输出"><a href="#读取命令的输出" class="headerlink" title="读取命令的输出"></a>读取命令的输出</h4><p>awk可以调用命令并读取输出。把命令放入引号中，然后利用管道将命令输出传入getline：<code>&quot;command&quot; | getline output ;</code></p>
<p>下面的代码从<code>/etc/passwd</code>文件中读入一行，然后显示出用户登录名及其主目录。在BEGIN语 句块中将字段分隔符设置为:，在主语句块中调用了<code>grep</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; print $1,$6 &#125;'</span> </span><br><span class="line"><span class="comment"># root /root</span></span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td><strong>标准 AWK 变量</strong></td>
</tr>
<tr>
<td style="text-align:left">ARGC</td>
<td>命令行提供的参数的个数</td>
</tr>
<tr>
<td style="text-align:left">ARGV</td>
<td>存储命令行输入参数的数组。数组的有效索引是从 0 到 ARGC-1。</td>
</tr>
<tr>
<td style="text-align:left">ARGIND</td>
<td>命令行中当前文件的位置(从0开始算)</td>
</tr>
<tr>
<td style="text-align:left">CONVFMT</td>
<td>数据转换为字符串的格式，其默认值为 %.6g</td>
</tr>
<tr>
<td style="text-align:left">OFMT</td>
<td>数值输出的格式，它的默认值为 %.6g。</td>
</tr>
<tr>
<td style="text-align:left">OFS</td>
<td>输出域之间的分割符，其默认为空格。</td>
</tr>
<tr>
<td style="text-align:left">ORS</td>
<td>输出记录（行）之间的分割符，其默认值是换行符。</td>
</tr>
<tr>
<td style="text-align:left">RS</td>
<td>输入记录的分割符，其默认值为换行符。</td>
</tr>
<tr>
<td style="text-align:left">NR</td>
<td>表示记录编号，当awk将行作为记录时，该变量相当于当前行号。全局行数（第二个文件的第一行接着第一个文件尾行数顺序计数）</td>
</tr>
<tr>
<td style="text-align:left">FNR</td>
<td>当前文件自身的行数（不考虑前几个输入文件的自身行数及总数。NR  的值依次为：1，2……40，41，42……90。FNR的值依次为：1，2……40， 1， 2……50</td>
</tr>
<tr>
<td style="text-align:left">NF</td>
<td>表示字段数量，在处理当前记录时，相当于字段数量。默认的字段分隔符是空格。</td>
</tr>
<tr>
<td style="text-align:left">FS</td>
<td>定义分隔符，可以用在 BEGIN 语句块中，这样你就不用依靠脚本用户在命令行选项中定义字段分隔符了。</td>
</tr>
<tr>
<td style="text-align:left">$0</td>
<td>该变量包含当前记录的文本内容。</td>
</tr>
<tr>
<td style="text-align:left">$n</td>
<td>该变量包含第n个字段的文本内容。</td>
</tr>
<tr>
<td style="text-align:left">ENVIRON</td>
<td>与环境变量相关的关联数组变量，<code>awk &#39;BEGIN { print ENVIRON[&quot;USER&quot;] }&#39;</code></td>
</tr>
<tr>
<td style="text-align:left">FILENAME</td>
<td>此变量表示当前文件名称</td>
</tr>
<tr>
<td style="text-align:left">RLENGTH</td>
<td>表示 match 函数匹配的字符串长度</td>
</tr>
<tr>
<td style="text-align:left">RSTART</td>
<td>表示由 match 函数匹配的字符串的第一个字符的位置</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td><strong>GNU AWK 特定的变量</strong></td>
</tr>
<tr>
<td style="text-align:left">IGNORECASE</td>
<td>GAWK将变得大小写不敏感，<code>awk &#39;BEGIN{IGNORECASE=1} /amit/&#39; marks.txt</code></td>
</tr>
</tbody>
</table>
<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><p>变量不用初始化即可使用</p>
<h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><p>用作数字的awk<strong>变量的默认初始值为0</strong>，所以我们不需要初始化 emp 。</p>
<p>这个程序使用一个变量 emp 来统计工作超过15个小时的员工的数目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$3 &gt; 15 &#123; emp = emp + 1 &#125;</span><br><span class="line">END     &#123; print emp, &quot;employees worked more than 15 hours&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>对于第三个字段超过15的每行， emp 的前一个值加1。该程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 employees worked more than 15 hours</span><br></pre></td></tr></table></figure>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>awk变量可以保存数字也<strong>可以保存字符串</strong>。这个程序会找出时薪最高的员工：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 如果$2大于最大值，则更新为当前行的信息</span><br><span class="line">$2 &gt; maxrate &#123; maxrate = $2; maxemp = $1 &#125;</span><br><span class="line">END &#123; print &quot;highest hourly rate:&quot;, maxrate, &quot;for&quot;, maxemp &#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h4><p>awk 中其实并不存在数组类型，所谓的关联数组是一种使用字符串作为索引的字典。因此并不是 <code>[&quot;value1&quot;, &quot;value2&quot;]</code>这样，而是<code>{0: &quot;value1&quot;, 1: &quot;value2&quot;}</code>。在awk中数组之间是无序的，一个数组的key值是数值，例如1，2，3，并不代表该数组元素在数组中的出现的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123;nam[$1]=$5&#125; END &#123;for （i in nam）  &#123;print i,nam[i]&#125;&#125;'</span> /etc/passwd </span><br><span class="line"><span class="comment"># root root </span></span><br><span class="line"><span class="comment"># ftp FTP User </span></span><br><span class="line"><span class="comment"># userj Joe User</span></span><br></pre></td></tr></table></figure>
<p><strong>awk没有not in语法</strong></p>
<p>请使用下面的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!($1 in dict) # 通用情况</span><br><span class="line">!dict[$1]     # 适用于判断在不在字典里进行过滤的情况</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.chinaunix.net/uid-10540984-id-323936.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-10540984-id-323936.html</a></p>
<p><strong>判断一个元素是否在数组中</strong></p>
<p>awk 支持<code>in</code>操作，但是<code>in</code> 判断的是键 <code>key</code>，awk 自身是没有判断是否在值<code>value</code>中的方法。</p>
<p>因此为了实现判断是否在数组中，要将<code>value</code>转为<code>key</code>，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    split(<span class="string">"value1 value2"</span>, valuesAsValues)</span><br><span class="line">    <span class="comment"># valuesAsValues = &#123;0: "value1", 1: "value2"&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> valuesAsValues) valuesAsKeys[valuesAsValues[i]] = <span class="string">""</span></span><br><span class="line">    <span class="comment"># valuesAsKeys = &#123;"value1": "", "value2": ""&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now you can use `in`</span></span><br><span class="line">(<span class="variable">$1</span> <span class="keyword">in</span> valuesAsKeys) &#123;<span class="built_in">print</span>&#125;</span><br></pre></td></tr></table></figure>
<p>一行的写法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"A:B:C:D:E:F"</span> | tr <span class="string">':'</span> <span class="string">'\n'</span> | \</span><br><span class="line">awk <span class="string">'BEGIN&#123; split("A D F", parts); for (i in parts) dict[parts[i]]=""&#125;  $1 in dict'</span></span><br></pre></td></tr></table></figure>
<p><strong>遍历数组</strong></p>
<p>awk支持列表形式的<strong><code>for</code>循环</strong>，是对 key 进行遍历，然后显示出数组的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> array) &#123; <span class="built_in">print</span> array[k]; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组排序</strong></p>
<p>使用 asort 完成数组元素的排序，或者使用 asorti 实现数组索引的排序等等</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits[<span class="string">"mango"</span>]=<span class="string">"yellow"</span>;</span><br><span class="line">fruits[mango]=<span class="string">"yellow"</span>; <span class="comment"># 这种写法也可以</span></span><br><span class="line">value必须加双引号</span><br><span class="line"></span><br><span class="line">delete array_name[index]</span><br></pre></td></tr></table></figure>
<p><strong>删除数组元素</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete arr[key]</span><br></pre></td></tr></table></figure>
<p>例子：<strong>按行逆序打印</strong></p>
<p>第一个动作将输入行存为数组 line 的连续元素；即第一行放在 line[1] ，第二行放在 line[2] , 依次继续。 END 动作使用一个 while 语句从后往前打印数组中的输入行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 反转 - 按行逆序打印输入</span><br><span class="line">    &#123; line[NR] = $0 &#125;  # 记下每个输入行</span><br><span class="line">END &#123; i = NR           # 逆序打印</span><br><span class="line">      while (i &gt; 0) &#123;</span><br><span class="line">        print line[i]</span><br><span class="line">        i = i - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以 emp.data 为输入，输出为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Susie    4.25   18</span><br><span class="line">Mary     5.50   22</span><br><span class="line">Mark     5.00   20</span><br><span class="line">Kathy    4.00   10</span><br><span class="line">Dan      3.75   0</span><br><span class="line">Beth     4.00   0</span><br></pre></td></tr></table></figure>
<h4 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h4><p>方法一（推荐）：</p>
<p>借助选项<code>-v</code>，我们可以将一个外部值（并非来自stdin）传递给awk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VAR=10000  </span><br><span class="line">echo | awk -v VARIABLE=$VAR &apos;&#123; print VARIABLE &#125;&apos;  [filename]</span><br><span class="line"># 10000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  gawk 程序在引用变量值时并未像shell脚本一样使用美元符。</p>
</blockquote>
<p><strong>可以不用加引号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk -v name=<span class="string">"Jerry"</span> <span class="string">'&#123;print name&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> | awk -v name=Jerry <span class="string">'&#123;print name&#125;'</span>    <span class="comment"># 等价   </span></span><br><span class="line"><span class="built_in">echo</span> | awk -v path=<span class="variable">$PATH</span> <span class="string">'&#123;print path&#125;'</span>    <span class="comment"># 如果是环境变量，需要添加$</span></span><br></pre></td></tr></table></figure>
<p>可以将<strong>多个</strong>外部变量传递给awk。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1=<span class="string">"Variable1"</span></span><br><span class="line">var2=<span class="string">"Variable2"</span></span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line"><span class="comment"># Variable1 Variable2</span></span><br></pre></td></tr></table></figure>
<p>在上面的方法中，变量以键值对的形式给出，使用空格分隔（<code>v1=$var1 v2=$var2</code>），作为awk 的命令行参数紧随在<code>BEGIN</code>、<code>{}</code>和<code>END</code>语句块之后。</p>
<p>方法二：用引号括起来直接用，是<code>&quot;&#39;$var&#39;&quot;</code>的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;abc&quot;</span><br><span class="line">awk &apos;BEGIN&#123;print &quot;&apos;$var&apos;&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>方法三：方法二类似，但使用<code>&quot;&#39;&quot;</code>把shell变量包起来，即<code>&quot;&#39;&quot;$var&quot;&#39;&quot;</code></p>
<p>如果变量的<strong>值中包含空格</strong>，为了shell不把空格作为分隔符，则应使用方法二。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;this a test&quot;</span><br><span class="line">awk &apos;BEGIN&#123;print &quot;&apos;&quot;$var&quot;&apos;&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>方法四：export变量，然后在awk中使用<code>ENVIRON[&quot;var&quot;]</code>形式(大写)获取环境变量的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;this a test&quot;; export var;</span><br><span class="line">awk &apos;BEGIN&#123;print ENVIRON[&quot;var&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><a href="https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html" target="_blank" rel="noopener">https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html</a></p>
<p>基本与C语言的操作相同</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">= += -= *= /= %= ^= **=</td>
<td style="text-align:left">赋值</td>
</tr>
<tr>
<td style="text-align:left">?:</td>
<td style="text-align:left">C条件表达式</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">\</td>
<td></td>
<td>逻辑或</td>
</tr>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">逻辑与</td>
</tr>
<tr>
<td style="text-align:left">~ ~!</td>
<td style="text-align:left">匹配正则表达式和不匹配正则表达式</td>
</tr>
<tr>
<td style="text-align:left">&lt; &lt;= &gt; &gt;= != ==</td>
<td style="text-align:left">关系运算符</td>
</tr>
<tr>
<td style="text-align:left">空格</td>
<td style="text-align:left">拼接字符串</td>
</tr>
<tr>
<td style="text-align:left">+ –</td>
<td style="text-align:left">加，减</td>
</tr>
<tr>
<td style="text-align:left">* / %</td>
<td style="text-align:left">乘，除与求余</td>
</tr>
<tr>
<td style="text-align:left">+ – !</td>
<td style="text-align:left">一元加，减和逻辑非</td>
</tr>
<tr>
<td style="text-align:left">^ ***</td>
<td style="text-align:left">求幂</td>
</tr>
<tr>
<td style="text-align:left">++ —</td>
<td style="text-align:left">增加或减少，作为前缀或后缀</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">字段引用</td>
</tr>
<tr>
<td style="text-align:left">in</td>
<td style="text-align:left">字典成员</td>
</tr>
</tbody>
</table>
<p><code>+=</code>, 等于<code>==</code>，不等于<code>!=</code></p>
<p>逻辑与运算符为 <code>&amp;&amp;</code>。逻辑或运算符为 <code>||</code>。逻辑非 <code>!</code> 。</p>
<p>逻辑非将 expr1 的真值取反。如果 expr1 为真，则返回 0。否则返回 1。下面的示例判断字符串是否为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; name = &quot;&quot;; if (! length(name)) print &quot;name is empty string.&quot; &#125;&apos;</span><br></pre></td></tr></table></figure>
<p>三元运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; a = 10; b = 20; (a &gt; b) ? max = a : max = b; print &quot;Max =&quot;, max&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>字符串连接操作符</p>
<p>空格 (space) 操作符可以完成两个字符串的连接操作。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; str1=&quot;Hello, &quot;; str2=&quot;World&quot;; str3 = str1 str2; print str3 &#125;&apos;</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
<p>数组成员操作符</p>
<p>数组成员操作符为 in。该操作符用于访问数组元素 。下面的示例用于此操作符输出数组中所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; arr[0] = 1; arr[1] = 2; arr[2] = 3; for (i in arr) printf &quot;arr[%d] = %d\n&quot;, i, arr[i] &#125;&apos;</span><br><span class="line"></span><br><span class="line">arr[0] = 1</span><br><span class="line">arr[1] = 2</span><br><span class="line">arr[2] = 3</span><br></pre></td></tr></table></figure>
<p>awk中并没有数组对象，其实是字典，因此<code>i</code> 遍历的是arr的key，而不是value</p>
<p>匹配（Match）</p>
<p>匹配运算符为 ~。不匹配操作符为 !~。 它用于搜索包含匹配模式字符串的域。下面的示例中将输出包括 9 的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;$0 ~ 9&apos; marks.txt    # 这种写法只对数字有效，如果是字母，就会失效</span><br><span class="line">[jerry]$ awk &apos;$0 ~ /9/&apos; marks.txt  # 推荐正则写法</span><br></pre></td></tr></table></figure>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><blockquote>
<p>  仅可以在动作中使用</p>
</blockquote>
<p>一定要加<code>{}</code>与其他语言一样的用法，括号内的为同一语句块</p>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">    action-1</span><br><span class="line">    action-1</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    action-n</span><br><span class="line">&#125;</span><br><span class="line">else if (a == 30)</span><br><span class="line">  print &quot;a = 30&quot;;</span><br><span class="line">else</span><br><span class="line">  print &quot;a = 30&quot;;</span><br></pre></td></tr></table></figure>
<p>例子：将每隔几行就拼接在一起输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"cat\nbat\nfun\nfin\nfan\nend"</span> | awk <span class="string">'&#123;str=str $0&#125;;NR %2==0&#123;print str;str=""&#125;'</span></span><br></pre></td></tr></table></figure>
<p>if-else 语句中，if 后的条件会被计算。如果为真，执行第一个 print 语句。否则，执行第二个 print 语句。注意我们可以使用一个逗号将一个长语句截断为多行来书写。</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>一个 while 语句有一个条件和一个执行体。条件为真时执行体中的语句会被重复执行。这个程序使用公式 value=amount(1+rate)yearsvalue=amount(1+rate)years</p>
<p>来演示以特定的利率投资一定量的钱，其数值是如何随着年数增长的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># interest1 - 计算复利</span><br><span class="line">#   输入: 钱数    利率    年数</span><br><span class="line">#   输出: 复利值</span><br><span class="line"></span><br><span class="line">&#123;   i = 1</span><br><span class="line">    while (i &lt;= $3) &#123;</span><br><span class="line">        printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">        i = i + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件是 while 后括弧包围的表达式；循环体是条件后大括号包围的两个表达式。 printf 规格字符串中的 \t 代表制表符； ^ 是指数操作符。从 # 开始到行尾的文本是注释，会被awk忽略，但能帮助程序的读者理解程序做的事情。</p>
<p>你可以为这程序输入三个一组的数字，看看不一样的钱数、利率、以及年数会产生什么。例如，如下事务演示了1000美元，利率为6%与12%，5年的复利分别是如何增长的：:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk -f interest1</span><br><span class="line">1000 .06 5</span><br><span class="line">        1060.00</span><br><span class="line">        1123.60</span><br><span class="line">        1191.02</span><br><span class="line">        1262.48</span><br><span class="line">        1338.23</span><br><span class="line">1000 .12 5</span><br><span class="line">        1120.00</span><br><span class="line">        1254.40</span><br><span class="line">        1404.93</span><br><span class="line">        1573.52</span><br><span class="line">        1762.34</span><br></pre></td></tr></table></figure>
<h4 id="do-while"><a href="#do-while" class="headerlink" title="do -while"></a>do -while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;i = 1; do &#123; print i; ++i &#125; while (i &lt; 6) &#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p> for ，将大多数循环都包含的初始化、测试、以及自增压缩成一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; for (i = 1; i &lt;= $3; ++i)</span><br><span class="line">    printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化 i = 1 只执行一次。接下来，测试条件 i &lt;= $3 ；如果为真，则执行循环体的 printf 语句。循环体执行结束后执行自增 i = i + 1 ，接着由另一次条件测试开始下一个循环迭代。代码更加紧凑，并且由于循环体仅是一条语句，所以不需要大括号来包围它。</p>
<h4 id="跳出循环（break、continue、exit、next）"><a href="#跳出循环（break、continue、exit、next）" class="headerlink" title="跳出循环（break、continue、exit、next）"></a>跳出循环（break、continue、exit、next）</h4><p>break、continue、exit都支持</p>
<p>next </p>
<p>等价于<code>continue</code>,next 停止处理当前记录，并且进入到下一条记录的处理过程。下面的例子中，当模式串匹配成功后程序并不执行任何操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;if ($0 ~/Shyam/) next; print $0&#125;'</span> marks.txt</span><br></pre></td></tr></table></figure>
<p>nextfile</p>
<p>nextfile 停止处理当前文件，从下一个文件第一个记录开始处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; if ($0 ~ /file1:str2/) nextfile; print $0 &#125;'</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><a href="https://man.linuxde.net/awk" target="_blank" rel="noopener"><a href="https://man.linuxde.net/awk" target="_blank" rel="noopener">更多的函数说明</a></a></p>
<h4 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h4><h5 id="match"><a href="#match" class="headerlink" title="match"></a>match</h5><p>返回正则表达式在字符串 str 中第一个最长匹配的位置。如果能够找到，返回非0值；否则，返回0。match()有两个<strong>相关的特殊变量</strong>，分别是<code>RSTART</code>和<code>RLENGTH</code>。变量<code>RSTART</code>包含了匹配内容的起始位置，而变量<code>RLENGTH</code>包含了匹配内容的长度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "One Two Three"</span></span><br><span class="line"><span class="string">    subs = "Two"</span></span><br><span class="line"><span class="string">    ret = match(str, subs)</span></span><br><span class="line"><span class="string">    printf "Substring \"%s\" found at %d location.\n", subs, ret</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Substring "Two" found at 5 location.</span></span><br></pre></td></tr></table></figure>
<h5 id="asort-数组排序"><a href="#asort-数组排序" class="headerlink" title="asort 数组排序"></a>asort 数组排序</h5><p>asort(arr,[, d [,how] ])</p>
<p>asort 函数使用 GAWK 值比较的一般规则排序 arr 中的value，然后用以 1 开始的有序整数替换排序内容的索引。</p>
<p>大写的会排在前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;</span><br><span class="line">    arr[0] = &quot;Three&quot;</span><br><span class="line">    arr[1] = &quot;One&quot;</span><br><span class="line">    arr[2] = &quot;two&quot;</span><br><span class="line"></span><br><span class="line">    print &quot;Array elements before sorting:&quot;</span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asort(arr)</span><br><span class="line"></span><br><span class="line">    print &quot;Array elements after sorting:&quot;</span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h5 id="asorti-数组排序"><a href="#asorti-数组排序" class="headerlink" title="asorti 数组排序"></a>asorti 数组排序</h5><p>asorti(arr,[, d [,how] ])</p>
<p>asorti 函数的行为与 asort 函数的行为很相似，二者的差别在于 aosrt 对数组的value排序，而 asorti 对数组的index排序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    arr["Two"] = 1</span></span><br><span class="line"><span class="string">    arr["One"] = 2</span></span><br><span class="line"><span class="string">    arr["Three"] = 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    asorti(arr)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    print "Array indices after sorting:"</span></span><br><span class="line"><span class="string">    for (i in arr) &#123;</span></span><br><span class="line"><span class="string">        print arr[i]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="sub、gsub-替换"><a href="#sub、gsub-替换" class="headerlink" title="sub、gsub 替换"></a>sub、gsub 替换</h5><p>sub</p>
<p>将正则表达式regex匹配到的第一处内容<strong>替换</strong>成replacment_str。</p>
<p>gsub(regx,sub, string)</p>
<p>gsub 是全局替换( global substitution )的缩写。它将出现的子串（sub）替换为 regx。第三个参数 string 是可选的，<strong>默认值为 $0</strong>，表示在整个输入记录中搜索子串。进行一次替换的有sub(regex,sub,string)函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "Hello, World"</span></span><br><span class="line"><span class="string">    print "String before replacement = " str</span></span><br><span class="line"><span class="string">    gsub("World", "Jerry", str)</span></span><br><span class="line"><span class="string">    print "String after replacement = " str</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="index-判断子串包含"><a href="#index-判断子串包含" class="headerlink" title="index 判断子串包含"></a>index 判断子串包含</h5><p>index(str,sub)</p>
<p>index 函数用于检测字符串 sub 是否是 str 的子串。如果 sub 是 str 的子串，则返回子串 sub 在字符串 str 的开始位置；若不是其子串，则返回 0。str 的字符位置索引从 1 开始计数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "One Two Three"</span></span><br><span class="line"><span class="string">    subs = "Two"</span></span><br><span class="line"><span class="string">    ret = index(str, subs)</span></span><br><span class="line"><span class="string">    printf "Substring \"%s\" found at %d location.\n", subs, ret</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="split-分割字符串"><a href="#split-分割字符串" class="headerlink" title="split 分割字符串"></a>split 分割字符串</h5><p><code>split(str, arr, regex)</code></p>
<p>split 函数使用正则表达式 regex 分割字符串 str。分割后的所有结果存储在数组 arr 中。如果没有指定 regex 则使用 FS 切分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123;</span><br><span class="line">    str = &quot;One,Two,Three,Four&quot;</span><br><span class="line"></span><br><span class="line">    split(str, arr, &quot;,&quot;)</span><br><span class="line"></span><br><span class="line">    print &quot;Array contains following values&quot;</span><br><span class="line"></span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h5 id="substr-字符串截取"><a href="#substr-字符串截取" class="headerlink" title="substr 字符串截取"></a>substr 字符串截取</h5><p><code>substr(str, start, length)</code></p>
<p>substr 函数返回 str 字符串中从第 start 个字符开始长度为 length 的子串。如果没有指定 length 的值，返回 str 从第 start 个字符开始的后缀子串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "Hello, World !!!"</span></span><br><span class="line"><span class="string">    subs = substr(str, 1, 5)</span></span><br><span class="line"><span class="string">    print "Substring = " subs</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Substring = Hello</span></span><br></pre></td></tr></table></figure>
<h5 id="strtonum字符串转数字"><a href="#strtonum字符串转数字" class="headerlink" title="strtonum字符串转数字"></a>strtonum字符串转数字</h5><p>strtonum(str)</p>
<p>strtonum 将字符串 str 转换为数值。 如果字符串以 0 开始，则将其当作八进制数；如果字符串以 0x 或 0X 开始，则将其当作十六进制数；否则，将其当作浮点数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    print "Decimal num = " strtonum("123")</span></span><br><span class="line"><span class="string">    print "Octal num = " strtonum("0123")</span></span><br><span class="line"><span class="string">    print "Hexadecimal num = " strtonum("0x123")</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line">Decimal num = 123</span><br><span class="line">Octal num = 83</span><br><span class="line">Hexadecimal num = 291</span><br></pre></td></tr></table></figure>
<h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><p><code>tolower(str)</code>、<code>toupper(str)</code></p>
<p>将字符串 str 进行大小写字母转换，然后返回。注意，字符串 str 本身不被改变。</p>
<h4 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h4><p>getline：得到行，但是注意，<strong>得到的并不是当前行，而是当前行的下一行</strong>。原因如下：</p>
<p>从整体上来说，应这么理解它的用法：</p>
<ul>
<li><code>getline var</code> 读取一行内容给 <code>var</code>，没有变量时等价于 <code>getline $0</code></li>
<li>当其左右无重定向符 | 或 &lt; 时，getline作用于当前文件，读入当前文件的一行给其后跟的变量  <code>var</code> 或<code>$0</code>（无变量时）；由于<code>awk</code>在处理<code>getline</code>之前已经读入了一行，所以<code>getline</code>得的是下一行（第二行开始）。</li>
<li><p>当其左右有重定向符 | 或 &lt; 时，<code>getline</code>则作用于定向输入文件（用重定向符从另外一个文件中读取内容、管道符号获得UNIX命令的输出）赋值给<code>$0</code> 或<code>getline</code>后面的变量。由于该文件是刚打开，并没有被<code>awk</code>读入一行，那么<code>getline</code>返回的是该文件的第一行，而不是隔行，并赋值。</p>
<blockquote>
<p>  <code>getline</code> 会记住重定向的文件读取到哪一行了，并不会重复执行<code>getline var &lt; file</code>  重复读取文件，而是一次读取一行</p>
</blockquote>
</li>
<li><code>getline</code>执行后会更新<code>NF</code>，<code>NR</code>，<code>FNR</code>等这些内部变量。</li>
</ul>
<p>例子：</p>
<p>比较 <code>getline</code>后有无变量的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 显示奇数</span><br><span class="line">$ seq 10 | awk &apos;&#123;getline var;  print $0&#125;&apos;  # getline var 后，内部变量不变，因此$0仍然是第1行</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line"># 显示偶数</span><br><span class="line">$ seq 10 | awk &apos;&#123;getline;  print $0&#125;&apos;   # getline 等价于 getline $0 ，处理getline之前$0是第一行，因此$0变为第2行</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>同时读取2个文件，不用担心<code>getline &lt; &quot;b.txt&quot;</code>重复读取文件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;&#123;printf &quot;%s &quot;, $0; getline &lt; &quot;b.txt&quot;; print $0&#125;&apos; a.txt </span><br><span class="line"># 记住 getline 等价于 getline $0 ，因此$0变成了 b 文件的内容</span><br><span class="line">1 6</span><br><span class="line">2 7</span><br><span class="line">3 8</span><br><span class="line">4 9</span><br><span class="line">5 10</span><br><span class="line"></span><br><span class="line"># 交替打印</span><br><span class="line">awk &apos;&#123;getline var &lt; &quot;a.txt&quot;;print var;print $0&#125;&apos; b.txt   # var 是文件a的行，$0是文件b的内容</span><br></pre></td></tr></table></figure>
<p>获取命令输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;&quot;date&quot; | getline; close(&quot;date&quot;); print $0&#125;&apos;</span><br><span class="line">Tue May 10 07:50:51 PDT 2016</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，使用管道符号时，<code>getline</code> 中这样是无法获取环境变量<code>FILE</code>的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F&quot;\t&quot; &apos;BEGIN&#123;while(&quot;cat $FILE&quot;|getline c)&#123;dict[c]=1&#125;&#125; ($2 in dict)&#123;print&#125;&apos; file</span><br></pre></td></tr></table></figure>
<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> find_min(num1, num2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2)</span><br><span class="line">    <span class="built_in">return</span> num1</span><br><span class="line">  <span class="built_in">return</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Script execution starts here</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">  main(10, 20) <span class="comment"># 使用自定义函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h3><h4 id="匹配中文"><a href="#匹配中文" class="headerlink" title="匹配中文"></a>匹配中文</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$1 ~/[一-龥]/'  匹配中文</span><br><span class="line">awk '$1 ~/[\u4e00-\u9fa5]/'  这样反而不行，要不unicode转成对应的中文</span><br></pre></td></tr></table></figure>
<h4 id="awk对换行敏感"><a href="#awk对换行敏感" class="headerlink" title="awk对换行敏感"></a>awk对换行敏感</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123;while(&quot;cat company.txt&quot;|getline)&#123;dict[$1]=1&#125;&#125; &#123;if($3 in dict)print NR&#125;&apos; target.txt</span><br></pre></td></tr></table></figure>
<p>company.txt的文件是<code>\r\n</code>结尾时，无法匹配</p>
<h4 id="shell使用awk批量创建变量"><a href="#shell使用awk批量创建变量" class="headerlink" title="shell使用awk批量创建变量"></a>shell使用awk批量创建变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval $(awk &apos;BEGIN&#123;print &quot;v1=&apos;str1&apos;;v2=&apos;str2&apos;&quot;&#125;&apos;)   # 相当于执行了  v1=&apos;str1&apos;;v2=&apos;str2&apos;</span><br><span class="line">echo &quot;v1=$var1&quot;</span><br><span class="line">echo &quot;v2=$var2&quot;</span><br></pre></td></tr></table></figure></the></excerpt>
  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://jizx.vip/2019/09/02/awk/>https://jizx.vip/2019/09/02/awk/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-02-24T23:39:41+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Feb 24, 2020</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/工具/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>工具</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/awk/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>awk</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/linux/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>linux</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://jizx.vip/2019/09/02/awk/&title=awk - 玖玖的博客&summary= 

linux 三剑客之一 awk 的详细介绍"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://jizx.vip/2019/09/02/awk/&title=awk - 玖玖的博客&summary= 

linux 三剑客之一 awk 的详细介绍"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://jizx.vip/2019/09/02/awk/&title=awk - 玖玖的博客&summary= 

linux 三剑客之一 awk 的详细介绍"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2019/09/04/bash命令提示符个性化/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>bash命令提示符个性化</p>
          <p class='content'> 

详细介绍了如何配置 bashrc，使得命令行的提示符更美观，包括当前路径、时间、用户、服务器名称等



常用显示参数\d：代表日期，格式为weekday month date，例如：”M...</p>
        </a>
      
      
        <a class='next' href='/2019/08/13/linux-shell编程/'>
          <p class='title'>linux shell编程<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'> 




基本知识Shell 进程父子进程在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。 这个shell程序被称为子shell（child...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#awk英文文档"><span class="toc-text">awk英文文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本组成"><span class="toc-text">基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行流程"><span class="toc-text">运行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出"><span class="toc-text">输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#print输出"><span class="toc-text">print输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#printf高级输出"><span class="toc-text">printf高级输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#转义序列"><span class="toc-text">转义序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#格式说明符"><span class="toc-text">格式说明符%</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#格式说明符-的可选参数"><span class="toc-text">格式说明符% 的可选参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重定向、管道、双向管道"><span class="toc-text">重定向、管道、双向管道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#重定向"><span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#管道"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双向通信通道"><span class="toc-text">双向通信通道</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#保存到不同文件中"><span class="toc-text">保存到不同文件中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用参数"><span class="toc-text">常用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模式-pattern-种类"><span class="toc-text">模式(pattern)种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择、过滤"><span class="toc-text">选择、过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多条命令"><span class="toc-text">多条命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将命令保存在文件中"><span class="toc-text">将命令保存在文件中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#读取命令的输出"><span class="toc-text">读取命令的输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内置变量"><span class="toc-text">内置变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义变量"><span class="toc-text">自定义变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义变量"><span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数值"><span class="toc-text">数值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组变量"><span class="toc-text">数组变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外部变量"><span class="toc-text">外部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作符"><span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制语句"><span class="toc-text">控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if"><span class="toc-text">if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while"><span class="toc-text">while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-while"><span class="toc-text">do -while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for"><span class="toc-text">for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跳出循环（break、continue、exit、next）"><span class="toc-text">跳出循环（break、continue、exit、next）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置函数"><span class="toc-text">内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串相关"><span class="toc-text">字符串相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#match"><span class="toc-text">match</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#asort-数组排序"><span class="toc-text">asort 数组排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#asorti-数组排序"><span class="toc-text">asorti 数组排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sub、gsub-替换"><span class="toc-text">sub、gsub 替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#index-判断子串包含"><span class="toc-text">index 判断子串包含</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#split-分割字符串"><span class="toc-text">split 分割字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#substr-字符串截取"><span class="toc-text">substr 字符串截取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#strtonum字符串转数字"><span class="toc-text">strtonum字符串转数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#大小写转换"><span class="toc-text">大小写转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getline"><span class="toc-text">getline</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义函数"><span class="toc-text">自定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他知识点"><span class="toc-text">其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#匹配中文"><span class="toc-text">匹配中文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk对换行敏感"><span class="toc-text">awk对换行敏感</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shell使用awk批量创建变量"><span class="toc-text">shell使用awk批量创建变量</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>



      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <!-- required -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  










  
  <script src="/js/valine.js"></script>

<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = $.trim($('#pjax-comment-placeholder').text()) || "快来评论吧~";

    let path = $.trim($('#pjax-comment-path').text());
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>







  <script src="/js/app.js"></script>



  
    <script src="/js/search.js"></script>
  


<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );
(function ($) {
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
})(jQuery);

</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://jizx.vip' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://jizx.vip' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://jizx.vip' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>



<!-- more -->


    
      

<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>
<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
