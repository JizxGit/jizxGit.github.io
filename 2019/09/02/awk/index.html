<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="jizx">



<meta name="description" content="linux 三剑客之一 awk 的详细介绍">
<meta name="keywords" content="工具,awk,linux">
<meta property="og:type" content="article">
<meta property="og:title" content="awk">
<meta property="og:url" content="https://jizx.top/2019/09/02/awk/index.html">
<meta property="og:site_name" content="玖玖的博客">
<meta property="og:description" content="linux 三剑客之一 awk 的详细介绍">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://jizx.top/2019/09/02/awk/awk_workflow.jpg">
<meta property="og:updated_time" content="2020-02-24T15:39:41.931Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="awk">
<meta name="twitter:description" content="linux 三剑客之一 awk 的详细介绍">
<meta name="twitter:image" content="https://jizx.top/2019/09/02/awk/awk_workflow.jpg">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="玖玖的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="https://avatars1.githubusercontent.com/u/18480104?s=40&v=4">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>awk | 玖玖的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">jizx</a></h1>
        </hgroup>

        
        <p class="header-subtitle">个人学习笔记，各种杂杂碎碎O(∩_∩)O</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false">
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">分类&amp;标签</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:1822980003@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/JizxGit" title="GitHub"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/anaconda/">anaconda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atom/">atom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/awk/">awk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ing/">ing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jupyter/">jupyter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logging/">logging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notepad/">notepad++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numpy/">numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pandas/">pandas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/photoshop/">photoshop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tensorflow/">tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/time/">time</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/window/">window</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/乱码/">乱码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/从句/">从句</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/传参/">传参</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健康/">健康</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/右键/">右键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同理心/">同理心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/吵架/">吵架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/命令/">命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复合句/">复合句</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多进程/">多进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心理/">心理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/截图/">截图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/所见所闻/">所见所闻</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打印/">打印</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/批评/">批评</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/效率/">效率</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/方法调用/">方法调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/时态/">时态</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/曲线/">曲线</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块/">模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境/">环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/类/">类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统优化/">系统优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码问题/">编码问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编辑器/">编辑器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">博客主题原作者MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">在读研究生二年级</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">jizx</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">jizx</a></h1>
            </hgroup>
            
            <p class="header-subtitle">个人学习笔记，各种杂杂碎碎O(∩_∩)O</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">分类&amp;标签</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:1822980003@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/JizxGit" title="GitHub"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap"><article id="post-awk" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/02/awk/" class="article-date">
      <time datetime="2019-09-02T04:05:24.000Z" itemprop="datePublished">2019-09-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      awk
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/linux/">linux</a><a class="article-category-link" href="/categories/linux/awk/">awk</a><a class="article-category-link" href="/categories/linux/awk/工具/">工具</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/awk/">awk</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工具/">工具</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <excerpt in="" index="" |="" 首页摘要=""> 

<p>linux 三剑客之一 awk 的详细介绍</p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="awk英文文档"><a href="#awk英文文档" class="headerlink" title="awk英文文档"></a>awk英文文档</h3><p><a href="https://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">https://www.gnu.org/software/gawk/manual/gawk.html</a></p>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>基本组成形式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk options program file1 </span><br><span class="line">awk options program file1 file2</span><br><span class="line">awk options program <span class="comment"># 进入交互模式，直到ctrl+d结束输入</span></span><br></pre></td></tr></table></figure>
<p>由于gawk命令行假定脚本是单个文本字符串，你<strong>必须将脚本放到单引号中</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; print "start";command2 &#125; pattern &#123; command1;command2 &#125; END&#123; print "end";command2 &#125;'</span> file</span><br></pre></td></tr></table></figure>
<ul>
<li>一个命令就是一个以新行或者分号分隔的语句序列。</li>
<li>由于模式和命令两者任一都是可选的，所以需要使用大括号包围动作以区分于其他模式。</li>
<li>多条语句之间用<code>;</code>分隔<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; print $1,$6 &#125;'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="/2019/09/02/awk/./awk_workflow.jpg" alt="img"></p>
<ol>
<li><p>awk以<strong>逐行的形式</strong>处理文件</p>
</li>
<li><p><code>BEGIN</code>之后的命令会先于公共语句块执行</p>
<blockquote>
<p>  BEGIN语句块在awk开始从输入流中读取行之前被执行（除非调用了 <code>getline</code>）。这是一个<strong>可选的</strong>语句块，诸如变量初始化、打印输出表格的表头等语句通常都可以放在BEGIN语句块中。</p>
</blockquote>
</li>
<li><p>对于匹配PATTERN的行，awk会对其执行<code>PATTERN</code>之后的命令</p>
<blockquote>
<p>  这个语句块是<strong>可选的</strong>。如果不提供，则默认执行<code>{ print }</code>，即打印所读取到的每一行。 如果提供，则每个pattern依次测试每个输入行。对于匹配到行的模式，其对应的命令（也许包含多步）得到执行，然后读取下一行并继续匹配，直到所有的输入读取完毕。</p>
</blockquote>
</li>
<li><p>最后，在处理完整个文件之后，awk会执行<code>END</code>之后的命令</p>
<blockquote>
<p>  END语句块和BEGIN语句块类，也是<strong>可选的</strong>语句块。它在awk读取完输入流中所有的行之后被执行。像打印所有行的分析结果这种常见任务都是在END语句块中实现的。</p>
</blockquote>
</li>
</ol>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a><code>print</code>输出</h4><p><code>print</code>接受的变量之间以<strong>逗号分隔</strong>，在输出时会<strong>以空格作为变量之间的分隔符</strong>。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $3,$4&#125;&apos; marks.txt</span><br></pre></td></tr></table></figure>
<p><strong><code>print</code>之间的空格不会影响输出格式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $3 "\t" $4&#125;'</span> marks.txt <span class="comment"># $3与\t之间的空格不会显示在输出中</span></span><br><span class="line">awk <span class="string">'&#123;print $3 , $4&#125;'</span> marks.txt <span class="comment"># 逗号表示最终会以空格分分隔两个字段</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串拼接</strong></p>
<p>在awk的<code>print</code>语句中，<strong>双引号被当作拼接操作符</strong>（concatenation operator）使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; var1="v1"; var2="v2"; var3="v3"; \</span></span><br><span class="line"><span class="string">print var1 "-" var2 "-" var3 ; &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># v1-v2-v3</span></span><br></pre></td></tr></table></figure>
<p><strong>省略<code>print</code></strong></p>
<p>如果没有主体块——默认的动作是输出行。因此比如搜索字符串<code>Tom</code>可以使用下面简略方式实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/Tom/'</span> marks.txt</span><br></pre></td></tr></table></figure>
<p><strong>打印一行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; print &#125;</span><br><span class="line"># 或者，由于 $0 表示整行,</span><br><span class="line">&#123; print $0 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印特定列</strong></p>
<p>使用一个 print 语句可以在同一行中输出不止一个字段. 下面的程序输出了每 行输入中的第一和第三个字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $1, $3 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>NF</strong> 列总数</p>
<p>该变量表示一共有多少列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print NF, $1, $NF &#125; # 打印第一列 和最后一列</span><br></pre></td></tr></table></figure>
<p><strong>计算和打印</strong></p>
<p>你也可以对字段的值进行计算后再打印出来. 下面的程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $1, $2 * $3 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>NR 打印行号</strong></p>
<p>存储当前已经读取了多少行的计数。给每一行加上行号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print NR, $0 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>在输出中添加内容</strong></p>
<p>双引号内的文字将会在字段和计算的值中插入输出.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print &quot;total pay for&quot;, $1, &quot;is&quot;, $2 * $3 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>排序输出</strong></p>
<p>最简单的方式是使用awk将每位员工的总薪酬置于其记录之前，然后利用<strong>sort</strong>命令来处理awk的输出。Unix上，命令行如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123; printf(&quot;%6.2f    %s\n&quot;, $2 * $3, $0) &#125;&apos; emp.data | sort</span><br></pre></td></tr></table></figure>
<p><strong>打印表头，表尾</strong></p>
<p> BEGIN 用于匹配第一个输入文件的第一行之前的位置， END 则用于匹配处理过的最后一个文件的最后一行之后的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;print &quot;Name Rate Hour&quot;;print &quot;=========&quot;&#125; &#123;print $0&#125;&apos; file</span><br></pre></td></tr></table></figure>
<p><strong>字符串拼接</strong></p>
<ul>
<li>在命令中使用<strong>空格</strong>进行变量拼接</li>
<li>在<code>print</code>语句块中使用<strong>双引号</strong>拼接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将names变量与当前行的的$1以及空格进行拼接，赋值给names</span><br><span class="line"> &#123; names = names $1 &quot; &quot;&#125;</span><br><span class="line">END &#123; print names &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>只打印最后一行</strong></p>
<p><strong>打印最后一个输入行</strong></p>
<p>虽然在 END 动作中 NR 还保留着它的值，但 $0 没有。程序是打印最后一个输入行的一种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#123; last = $0 &#125;</span><br><span class="line">END &#123; print last &#125;</span><br></pre></td></tr></table></figure>
<h4 id="printf高级输出"><a href="#printf高级输出" class="headerlink" title="printf高级输出"></a><code>printf</code>高级输出</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>printf 语句的形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(format, value1, value2, ..., valuen)</span><br></pre></td></tr></table></figure>
<p>其中 format 是字符串，包含要逐字打印的文本，穿插着 format 之后的每个值该如何打印的规格(specification)。一个规格是一个 % 符，后面跟着一些字符，用来控制一个 value 的格式。第一个规格说明如何打印 value1 ，第二个说明如何打印 value2 ，… 。因此，有多少 value 要打印，在 format 中就要有多少个 % 规格。（与C语言很像）</p>
<p>这里有个程序使用 printf 打印每位员工的总薪酬：:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; printf(&quot;total pay for %s is $%.2f\n&quot;, $1, $2 * $3) &#125;</span><br></pre></td></tr></table></figure>
<h5 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h5><p><strong>退格符</strong><code>\b</code></p>
<p><strong>换页符</strong><code>\f</code></p>
<p><strong>换行符</strong><code>\n</code> ，进入下一行</p>
<p><strong>回车符</strong><code>\r</code> ，光标移动到第一列</p>
<blockquote>
<p>  这与以前的打字机相关，以前的打字机达打完一行后，机械上需要2步，先将指针移动到下一行（换行），然后将指针回到行首（回车）</p>
</blockquote>
<p>我们在每个域输出后输出一个回车符<code>\r</code>，随后输出的域会覆盖之前输出的内容。也就是说，我们只能看到最后输出的 Field 4。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; printf "Field 1\rField 2\rField 3\rField 4\n" &#125;'</span></span><br><span class="line"><span class="comment"># Field 4</span></span><br></pre></td></tr></table></figure>
<p><strong>垂直制表符</strong></p>
<p>如下示例，使用垂直制表符输出不同域：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; printf "Sr No\vName\vSub\vMarks\n" &#125;'</span></span><br><span class="line"><span class="comment"># 执行上面的命令可以得到如下的结果</span></span><br><span class="line">Sr No</span><br><span class="line">    Name</span><br><span class="line">        Sub</span><br><span class="line">            Marks</span><br></pre></td></tr></table></figure>
<h5 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符%"></a>格式说明符%</h5><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%c</td>
<td>输出<strong>单个字符</strong>。如果参数是个数值，那么数值也会被当作字符然后输出。如果参数是字符串，那么只会输出第一个字符。</td>
</tr>
<tr>
<td>%d 与 %i</td>
<td>输出十进制数的整数部分。</td>
</tr>
<tr>
<td>%f</td>
<td>输出浮点数，以 [-]ddd.dddddd 的格式</td>
</tr>
<tr>
<td>%e 与 %E</td>
<td>输出浮点数，以 [-]d.dddddde[+-]dd 的格式。区别就是输出<code>8.066000e+01</code>与<code>8.066000E+01</code>的<code>e</code>的大小写</td>
</tr>
<tr>
<td>%g 与 %G</td>
<td>输出浮点数，使用 %e 或 %E 转换。但它们会<strong>删除那些对数值无影响的 0</strong>。（推荐）</td>
</tr>
<tr>
<td>%o</td>
<td>无符号八进制输出。</td>
</tr>
<tr>
<td>%u</td>
<td>无符号十进制数输出。</td>
</tr>
<tr>
<td>%x 与 %X</td>
<td>输出十六进制无符号数。%X 中使用大写字母，%x 使用小写字母。</td>
</tr>
<tr>
<td>%%</td>
<td>输出百分号（%），不需要输入参数。</td>
</tr>
</tbody>
</table>
<h5 id="格式说明符-的可选参数"><a href="#格式说明符-的可选参数" class="headerlink" title="格式说明符% 的可选参数"></a>格式说明符% 的可选参数</h5><p><strong>列宽</strong></p>
<p><code>%8d</code>表示用空格填充占8列，如果紧接在 % 后是以0开头的数字<code>%08d</code>，表示输出应该使用0填充而不是空格字符。</p>
<p><strong>对齐</strong></p>
<p>默认是右边对齐，在 % 之后数字之前使用减号（-）即可指定输出左对齐</p>
<p><strong>符号前缀</strong></p>
<p>但是<code>+</code>不是表示右对齐，是表示输出数值的符号，正号也输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; num = -10; printf "Num = %-+10d\n", num &#125;'</span> | cat -vte</span><br></pre></td></tr></table></figure>
<p><strong>哈希<code>#</code></strong></p>
<p>将<code>#</code>放在<code>%</code>后， 可以为 %o 的结果前添加0，为 %x 或 %X 输出的结果前添加 0x 或 0X （结果不为零时），为 %e，%E，%f，%F添加小数点；对于 %g 或 %G，使用哈希可以保留尾部的零</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123; printf &quot;Octal representation = %#o\nHexadecimal representaion = %#X\n&quot;, 10, 10&#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="重定向、管道、双向管道"><a href="#重定向、管道、双向管道" class="headerlink" title="重定向、管道、双向管道"></a>重定向、管道、双向管道</h4><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>AWK 重定向操作符重定向数据到文件 message.txt 中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "Hello, World !!!" &gt; "/tmp/message.txt" &#125;'</span></span><br><span class="line">cat /tmp/message.txt</span><br></pre></td></tr></table></figure>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>下面的例子中我们使用 <code>tr</code> 命令将小写字母转换成大写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "hello, world !!!" | "tr [a-z] [A-Z]" &#125;'</span></span><br><span class="line"><span class="comment"># HELLO, WORLD !!！</span></span><br></pre></td></tr></table></figure>
<h5 id="双向通信通道"><a href="#双向通信通道" class="headerlink" title="双向通信通道"></a>双向通信通道</h5><p>（TODO 还不知道怎么用）</p>
<p>AWK 允许使用 <code>|&amp;</code> 与一个外部进程通信，并且可以双向通信。下面的例子中，使用 <code>tr</code> 命令将字母转换为大写字母。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    cmd = <span class="string">"tr [a-z] [A-Z]"</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"hello, world !!!"</span> |&amp; cmd</span><br><span class="line">    close(cmd, <span class="string">"to"</span>)</span><br><span class="line">    cmd |&amp; getline out</span><br><span class="line">    <span class="built_in">print</span> out;</span><br><span class="line">    close(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的命令可以得到如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELLO, WORLD !!!</span><br></pre></td></tr></table></figure>
<p>脚本的内容看上去很神秘吗？让我们一步一步揭开它神秘的面纱。</p>
<ul>
<li>第一条语句 cmd = “tr [a-z][A-Z]” 在AWK 中建立了一个双向的通信通道。</li>
<li>第二条语句 print 为 tr 命令提供输入。&amp;| 表示双向通信。</li>
<li>第三条语句 close(cmd, “to”) 执行后关闭 to 进程。</li>
<li>第四条语句 cmd |&amp; getline out 使用 getline 函数将输出存储到 out 变量中。</li>
<li>接下来的输出语句打印输出的内容，最后 close 函数关闭 cmd。</li>
</ul>
<h4 id="保存到不同文件中"><a href="#保存到不同文件中" class="headerlink" title="保存到不同文件中"></a>保存到不同文件中</h4><p>跳过表头，第6列是文件名，因此这样就可以将每一行分别保存在不同的文件中，进行了分类</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'NR!=1&#123;print $4,$5 &gt; $6&#125;' netstat.txt</span><br></pre></td></tr></table></figure>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>标准参数</strong></td>
</tr>
<tr>
<td>-F fs</td>
<td>fs是分隔符，默认是空白符（空格、制表符），fs可以是字符串或正则表达式。<br>如<code>-F:</code> 表示冒号为分隔符；<br>如果想指定空格为分隔符，请看下面例子。</td>
</tr>
<tr>
<td>-v var=value</td>
<td>赋值一个用户定义变量，将外部变量传递给awk</td>
</tr>
<tr>
<td>-f scripfile</td>
<td>从脚本文件中读取awk命令</td>
</tr>
<tr>
<td>-p[file]</td>
<td>用于格式化 awk 脚本文件。默认输出文件是 <strong>awkprof.out</strong>。</td>
</tr>
<tr>
<td></td>
<td><strong>gawk 参数</strong></td>
</tr>
<tr>
<td>-mf N</td>
<td>指定要处理的数据文件中的最大字段数</td>
</tr>
<tr>
<td>-mr N</td>
<td>指定数据文件中的最大数据行数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>  在BEGIN语句块中可以用OFS=”delimiter”设置输出字段分隔符。<code>awk &#39;BEGIN { FS=&quot;:&quot; }{ print }</code></p>
</blockquote>
<p><strong>指定空格为分隔符</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc d"</span>|awk -F<span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span>   <span class="comment"># 无效，还是会将\t进行分割</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc d"</span>|awk -F<span class="string">'[ ]'</span> <span class="string">'&#123;print $2&#125;'</span> <span class="comment"># 推荐</span></span><br></pre></td></tr></table></figure>
<p><strong>同时使用多个分隔符</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 使用多个分隔符, 遇到";"或者","就进行分割，因此下面的例子会得到 5 列</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1;2,3;4,5"</span>|awk -F <span class="string">'[;,]'</span> <span class="string">'&#123;print $1,$2,$3,$4,$5&#125;'</span></span><br><span class="line"><span class="comment"># 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<p>或者使用<code>|</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F&quot;\t|,&quot; &apos;&apos; file   # 以\t 或者逗号分隔</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://ipcmen.com/awk" target="_blank" rel="noopener">https://ipcmen.com/awk</a></p>
<p><strong>格式化脚本</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk --profile <span class="string">'BEGIN&#123;printf"---|Header|--\n"&#125; &#123;print&#125; END&#123;printf"---|Footer|---\n"&#125;'</span> marks.txt &gt; /dev/null </span><br><span class="line">[jerry]$ cat awkprof.out</span><br></pre></td></tr></table></figure>
<p>执行上面的命令可以得到如下的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># gawk profile, created Sun Oct 26 19:50:48 2014</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BEGIN block(s)</span></span><br><span class="line"></span><br><span class="line">    BEGIN &#123;</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"---|Header|--\n"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rule(s)</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># END block(s)</span></span><br><span class="line"></span><br><span class="line">    END &#123;</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"---|Footer|---\n"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式-pattern-种类"><a href="#模式-pattern-种类" class="headerlink" title="模式(pattern)种类"></a>模式(pattern)种类</h3><p><strong>BEGIN { 语句 }</strong></p>
<p>在读取任何输入前执行一次语句</p>
<p><strong>END { 语句 }</strong></p>
<p>读取所有输入之后执行一次语句</p>
<p><strong>表达式 { 语句 }</strong></p>
<p>对于表达式为真（即，非零或非空）的行，执行语句</p>
<p><strong>/正则表达式/ { 语句 }</strong></p>
<p>如果输入行包含字符串与正则表达式相匹配，则执行语句</p>
<p><strong>组合模式 { 语句 }</strong></p>
<p>一个 组合模式 通过与（<code>&amp;&amp;</code>），或（<code>||</code>），非（<code>!</code>），以及括弧来组合多个表达式；对于组合模式为真的每个输入行，执行 语句</p>
<p><strong>模式1，模式2 { 语句 }</strong></p>
<p>范围模式(range pattern)匹配从与模式1相匹配的行到与模式2相匹配的行（包含该行）之间的所有行，对于这些输入行，执行语句。</p>
<blockquote>
<p>  BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。BEGIN和END是仅有的必须搭配动作的模式。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;NR &lt; 5&apos;        # 行号小于5的行</span><br><span class="line">awk &apos;NR==1,NR==4&apos;   # 行号在1到5之间的行 </span><br><span class="line">awk &apos;/linux/&apos;       # 包含模式为linux的行（可以用正则表达式来指定模式）</span><br><span class="line">awk &apos;!/linux/&apos;      # 不包含模式为linux的行</span><br></pre></td></tr></table></figure>
<h3 id="选择、过滤"><a href="#选择、过滤" class="headerlink" title="选择、过滤"></a>选择、过滤</h3><p><strong>数值判断</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$2</span> * <span class="variable">$3</span> &gt; 50 &#123; <span class="built_in">printf</span>(<span class="string">"$%.2f for %s\n"</span>, <span class="variable">$2</span> * <span class="variable">$3</span>, <span class="variable">$1</span>) &#125;</span><br></pre></td></tr></table></figure>
<p><strong>文本内容选择，支持正则</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">1 == <span class="string">"Susie"</span> &#123; <span class="built_in">print</span> &#125;  <span class="comment"># 比较字段是否等于字符串时，要使用双引号包起来</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">1~/正则内容/ &#123; <span class="built_in">print</span> <span class="variable">$1</span>&#125; <span class="comment"># 对某一列进行正则</span></span></span><br><span class="line">/正则内容/ &#123; print $1&#125;	  # 对整行进行匹配</span><br><span class="line">/条件1/,/条件2/ &#123; print $1&#125;	  # 对整行进行多条件匹配</span><br></pre></td></tr></table></figure>
<p>匹配中文</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$1 ~/[一-龥]/'  匹配中文</span><br><span class="line">awk '$1 ~/[\u4e00-\u9fa5]/'  这样反而不行，要不unicode转成对应的中文</span><br></pre></td></tr></table></figure>
<p><strong>多条件组合</strong></p>
<p>逻辑操作符与 &amp;&amp; ， 或 || ， 以及非 ! 对模式进行组合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$2 &gt;= 4 || $3 &gt;= 20 &#123;print&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>!</code>是在括号前的，第1种其实与第2种一模一样，正确的是第3种</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline )&#123;dict[c]=1&#125;&#125; ! $2 in dict&#123;print&#125;' some.txt |wc</span><br><span class="line">      0       0       0</span><br><span class="line">      </span><br><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline c)&#123;dict[c]=1&#125;&#125; (! $2 in dict)&#123;print&#125;' some.txt |wc</span><br><span class="line">      0       0       0</span><br><span class="line">      </span><br><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline )&#123;dict[c]=1&#125;&#125; !($2in dict)&#123;print&#125;' some.txt |wc</span><br><span class="line">1296838 14273901 226060062</span><br></pre></td></tr></table></figure>
<h3 id="多条命令"><a href="#多条命令" class="headerlink" title="多条命令"></a>多条命令</h3><p>要在命令行上的程序脚本中使用多条命令，</p>
<ul>
<li>只要在命令之间放个<strong>分号</strong>即可。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"My name is Rich"</span> | gawk <span class="string">'&#123;$4="Christine"; print $0&#125;'</span> My name is Christine</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以用次提示符一次一行地输入程序脚本命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; \</span></span><br><span class="line"><span class="string">&gt; $4="Christine"</span></span><br><span class="line"><span class="string">&gt; print $0&#125;'</span> </span><br><span class="line">My name is Rich </span><br><span class="line"></span><br><span class="line">$ My name is Christine</span><br></pre></td></tr></table></figure>
<h3 id="将命令保存在文件中"><a href="#将命令保存在文件中" class="headerlink" title="将命令保存在文件中"></a>将命令保存在文件中</h3><p>当引号内的程序过长时，可以单独保存在文件中，假设存在文件 progfile ，输入命令行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f progfile	file</span><br></pre></td></tr></table></figure>
<p>文件中不用引号包起来，但是中括号还是需要的，多条指令在同一行中用分号分分隔，或者以多行形式书写</p>
<h4 id="读取命令的输出"><a href="#读取命令的输出" class="headerlink" title="读取命令的输出"></a>读取命令的输出</h4><p>awk可以调用命令并读取输出。把命令放入引号中，然后利用管道将命令输出传入getline：<code>&quot;command&quot; | getline output ;</code></p>
<p>下面的代码从<code>/etc/passwd</code>文件中读入一行，然后显示出用户登录名及其主目录。在BEGIN语 句块中将字段分隔符设置为:，在主语句块中调用了<code>grep</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; print $1,$6 &#125;'</span> </span><br><span class="line"><span class="comment"># root /root</span></span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td><strong>标准 AWK 变量</strong></td>
</tr>
<tr>
<td style="text-align:left">ARGC</td>
<td>命令行提供的参数的个数</td>
</tr>
<tr>
<td style="text-align:left">ARGV</td>
<td>存储命令行输入参数的数组。数组的有效索引是从 0 到 ARGC-1。</td>
</tr>
<tr>
<td style="text-align:left">ARGIND</td>
<td>命令行中当前文件的位置(从0开始算)</td>
</tr>
<tr>
<td style="text-align:left">CONVFMT</td>
<td>数据转换为字符串的格式，其默认值为 %.6g</td>
</tr>
<tr>
<td style="text-align:left">OFMT</td>
<td>数值输出的格式，它的默认值为 %.6g。</td>
</tr>
<tr>
<td style="text-align:left">OFS</td>
<td>输出域之间的分割符，其默认为空格。</td>
</tr>
<tr>
<td style="text-align:left">ORS</td>
<td>输出记录（行）之间的分割符，其默认值是换行符。</td>
</tr>
<tr>
<td style="text-align:left">RS</td>
<td>输入记录的分割符，其默认值为换行符。</td>
</tr>
<tr>
<td style="text-align:left">NR</td>
<td>表示记录编号，当awk将行作为记录时，该变量相当于当前行号。全局行数（第二个文件的第一行接着第一个文件尾行数顺序计数）</td>
</tr>
<tr>
<td style="text-align:left">FNR</td>
<td>当前文件自身的行数（不考虑前几个输入文件的自身行数及总数。NR  的值依次为：1，2……40，41，42……90。FNR的值依次为：1，2……40， 1， 2……50</td>
</tr>
<tr>
<td style="text-align:left">NF</td>
<td>表示字段数量，在处理当前记录时，相当于字段数量。默认的字段分隔符是空格。</td>
</tr>
<tr>
<td style="text-align:left">FS</td>
<td>定义分隔符，可以用在 BEGIN 语句块中，这样你就不用依靠脚本用户在命令行选项中定义字段分隔符了。</td>
</tr>
<tr>
<td style="text-align:left">$0</td>
<td>该变量包含当前记录的文本内容。</td>
</tr>
<tr>
<td style="text-align:left">$n</td>
<td>该变量包含第n个字段的文本内容。</td>
</tr>
<tr>
<td style="text-align:left">ENVIRON</td>
<td>与环境变量相关的关联数组变量，<code>awk &#39;BEGIN { print ENVIRON[&quot;USER&quot;] }&#39;</code></td>
</tr>
<tr>
<td style="text-align:left">FILENAME</td>
<td>此变量表示当前文件名称</td>
</tr>
<tr>
<td style="text-align:left">RLENGTH</td>
<td>表示 match 函数匹配的字符串长度</td>
</tr>
<tr>
<td style="text-align:left">RSTART</td>
<td>表示由 match 函数匹配的字符串的第一个字符的位置</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td><strong>GNU AWK 特定的变量</strong></td>
</tr>
<tr>
<td style="text-align:left">IGNORECASE</td>
<td>GAWK将变得大小写不敏感，<code>awk &#39;BEGIN{IGNORECASE=1} /amit/&#39; marks.txt</code></td>
</tr>
</tbody>
</table>
<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><p>变量不用初始化即可使用</p>
<h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><p>用作数字的awk<strong>变量的默认初始值为0</strong>，所以我们不需要初始化 emp 。</p>
<p>这个程序使用一个变量 emp 来统计工作超过15个小时的员工的数目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$3 &gt; 15 &#123; emp = emp + 1 &#125;</span><br><span class="line">END     &#123; print emp, &quot;employees worked more than 15 hours&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>对于第三个字段超过15的每行， emp 的前一个值加1。该程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 employees worked more than 15 hours</span><br></pre></td></tr></table></figure>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>awk变量可以保存数字也<strong>可以保存字符串</strong>。这个程序会找出时薪最高的员工：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 如果$2大于最大值，则更新为当前行的信息</span><br><span class="line">$2 &gt; maxrate &#123; maxrate = $2; maxemp = $1 &#125;</span><br><span class="line">END &#123; print &quot;highest hourly rate:&quot;, maxrate, &quot;for&quot;, maxemp &#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h4><p>awk 中其实并不存在数组类型，所谓的关联数组是一种使用字符串作为索引的字典。因此并不是 <code>[&quot;value1&quot;, &quot;value2&quot;]</code>这样，而是<code>{0: &quot;value1&quot;, 1: &quot;value2&quot;}</code>。在awk中数组之间是无序的，一个数组的key值是数值，例如1，2，3，并不代表该数组元素在数组中的出现的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123;nam[$1]=$5&#125; END &#123;for （i in nam）  &#123;print i,nam[i]&#125;&#125;'</span> /etc/passwd </span><br><span class="line"><span class="comment"># root root </span></span><br><span class="line"><span class="comment"># ftp FTP User </span></span><br><span class="line"><span class="comment"># userj Joe User</span></span><br></pre></td></tr></table></figure>
<p><strong>awk没有not in语法</strong></p>
<p>请使用下面的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!($1 in dict) # 通用情况</span><br><span class="line">!dict[$1]     # 适用于判断在不在字典里进行过滤的情况</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.chinaunix.net/uid-10540984-id-323936.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-10540984-id-323936.html</a></p>
<p><strong>判断一个元素是否在数组中</strong></p>
<p>awk 支持<code>in</code>操作，但是<code>in</code> 判断的是键 <code>key</code>，awk 自身是没有判断是否在值<code>value</code>中的方法。</p>
<p>因此为了实现判断是否在数组中，要将<code>value</code>转为<code>key</code>，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    split(<span class="string">"value1 value2"</span>, valuesAsValues)</span><br><span class="line">    <span class="comment"># valuesAsValues = &#123;0: "value1", 1: "value2"&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> valuesAsValues) valuesAsKeys[valuesAsValues[i]] = <span class="string">""</span></span><br><span class="line">    <span class="comment"># valuesAsKeys = &#123;"value1": "", "value2": ""&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now you can use `in`</span></span><br><span class="line">(<span class="variable">$1</span> <span class="keyword">in</span> valuesAsKeys) &#123;<span class="built_in">print</span>&#125;</span><br></pre></td></tr></table></figure>
<p>一行的写法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"A:B:C:D:E:F"</span> | tr <span class="string">':'</span> <span class="string">'\n'</span> | \</span><br><span class="line">awk <span class="string">'BEGIN&#123; split("A D F", parts); for (i in parts) dict[parts[i]]=""&#125;  $1 in dict'</span></span><br></pre></td></tr></table></figure>
<p><strong>遍历数组</strong></p>
<p>awk支持列表形式的<strong><code>for</code>循环</strong>，是对 key 进行遍历，然后显示出数组的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> array) &#123; <span class="built_in">print</span> array[k]; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组排序</strong></p>
<p>使用 asort 完成数组元素的排序，或者使用 asorti 实现数组索引的排序等等</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits[<span class="string">"mango"</span>]=<span class="string">"yellow"</span>;</span><br><span class="line">fruits[mango]=<span class="string">"yellow"</span>; <span class="comment"># 这种写法也可以</span></span><br><span class="line">value必须加双引号</span><br><span class="line"></span><br><span class="line">delete array_name[index]</span><br></pre></td></tr></table></figure>
<p><strong>删除数组元素</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete arr[key]</span><br></pre></td></tr></table></figure>
<p>例子：<strong>按行逆序打印</strong></p>
<p>第一个动作将输入行存为数组 line 的连续元素；即第一行放在 line[1] ，第二行放在 line[2] , 依次继续。 END 动作使用一个 while 语句从后往前打印数组中的输入行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 反转 - 按行逆序打印输入</span><br><span class="line">    &#123; line[NR] = $0 &#125;  # 记下每个输入行</span><br><span class="line">END &#123; i = NR           # 逆序打印</span><br><span class="line">      while (i &gt; 0) &#123;</span><br><span class="line">        print line[i]</span><br><span class="line">        i = i - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以 emp.data 为输入，输出为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Susie    4.25   18</span><br><span class="line">Mary     5.50   22</span><br><span class="line">Mark     5.00   20</span><br><span class="line">Kathy    4.00   10</span><br><span class="line">Dan      3.75   0</span><br><span class="line">Beth     4.00   0</span><br></pre></td></tr></table></figure>
<h4 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h4><p>方法一（推荐）：</p>
<p>借助选项<code>-v</code>，我们可以将一个外部值（并非来自stdin）传递给awk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VAR=10000  </span><br><span class="line">echo | awk -v VARIABLE=$VAR &apos;&#123; print VARIABLE &#125;&apos;  [filename]</span><br><span class="line"># 10000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  gawk 程序在引用变量值时并未像shell脚本一样使用美元符。</p>
</blockquote>
<p><strong>可以不用加引号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk -v name=<span class="string">"Jerry"</span> <span class="string">'&#123;print name&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> | awk -v name=Jerry <span class="string">'&#123;print name&#125;'</span>    <span class="comment"># 等价   </span></span><br><span class="line"><span class="built_in">echo</span> | awk -v path=<span class="variable">$PATH</span> <span class="string">'&#123;print path&#125;'</span>    <span class="comment"># 如果是环境变量，需要添加$</span></span><br></pre></td></tr></table></figure>
<p>可以将<strong>多个</strong>外部变量传递给awk。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1=<span class="string">"Variable1"</span></span><br><span class="line">var2=<span class="string">"Variable2"</span></span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line"><span class="comment"># Variable1 Variable2</span></span><br></pre></td></tr></table></figure>
<p>在上面的方法中，变量以键值对的形式给出，使用空格分隔（<code>v1=$var1 v2=$var2</code>），作为awk 的命令行参数紧随在<code>BEGIN</code>、<code>{}</code>和<code>END</code>语句块之后。</p>
<p>方法二：用引号括起来直接用，是<code>&quot;&#39;$var&#39;&quot;</code>的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;abc&quot;</span><br><span class="line">awk &apos;BEGIN&#123;print &quot;&apos;$var&apos;&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>方法三：方法二类似，但使用<code>&quot;&#39;&quot;</code>把shell变量包起来，即<code>&quot;&#39;&quot;$var&quot;&#39;&quot;</code></p>
<p>如果变量的<strong>值中包含空格</strong>，为了shell不把空格作为分隔符，则应使用方法二。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;this a test&quot;</span><br><span class="line">awk &apos;BEGIN&#123;print &quot;&apos;&quot;$var&quot;&apos;&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>方法四：export变量，然后在awk中使用<code>ENVIRON[&quot;var&quot;]</code>形式(大写)获取环境变量的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;this a test&quot;; export var;</span><br><span class="line">awk &apos;BEGIN&#123;print ENVIRON[&quot;var&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><a href="https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html" target="_blank" rel="noopener">https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html</a></p>
<p>基本与C语言的操作相同</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">= += -= *= /= %= ^= **=</td>
<td style="text-align:left">赋值</td>
</tr>
<tr>
<td style="text-align:left">?:</td>
<td style="text-align:left">C条件表达式</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">\</td>
<td></td>
<td>逻辑或</td>
</tr>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">逻辑与</td>
</tr>
<tr>
<td style="text-align:left">~ ~!</td>
<td style="text-align:left">匹配正则表达式和不匹配正则表达式</td>
</tr>
<tr>
<td style="text-align:left">&lt; &lt;= &gt; &gt;= != ==</td>
<td style="text-align:left">关系运算符</td>
</tr>
<tr>
<td style="text-align:left">空格</td>
<td style="text-align:left">拼接字符串</td>
</tr>
<tr>
<td style="text-align:left">+ –</td>
<td style="text-align:left">加，减</td>
</tr>
<tr>
<td style="text-align:left">* / %</td>
<td style="text-align:left">乘，除与求余</td>
</tr>
<tr>
<td style="text-align:left">+ – !</td>
<td style="text-align:left">一元加，减和逻辑非</td>
</tr>
<tr>
<td style="text-align:left">^ ***</td>
<td style="text-align:left">求幂</td>
</tr>
<tr>
<td style="text-align:left">++ —</td>
<td style="text-align:left">增加或减少，作为前缀或后缀</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">字段引用</td>
</tr>
<tr>
<td style="text-align:left">in</td>
<td style="text-align:left">字典成员</td>
</tr>
</tbody>
</table>
<p><code>+=</code>, 等于<code>==</code>，不等于<code>!=</code></p>
<p>逻辑与运算符为 <code>&amp;&amp;</code>。逻辑或运算符为 <code>||</code>。逻辑非 <code>!</code> 。</p>
<p>逻辑非将 expr1 的真值取反。如果 expr1 为真，则返回 0。否则返回 1。下面的示例判断字符串是否为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; name = &quot;&quot;; if (! length(name)) print &quot;name is empty string.&quot; &#125;&apos;</span><br></pre></td></tr></table></figure>
<p>三元运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; a = 10; b = 20; (a &gt; b) ? max = a : max = b; print &quot;Max =&quot;, max&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>字符串连接操作符</p>
<p>空格 (space) 操作符可以完成两个字符串的连接操作。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; str1=&quot;Hello, &quot;; str2=&quot;World&quot;; str3 = str1 str2; print str3 &#125;&apos;</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
<p>数组成员操作符</p>
<p>数组成员操作符为 in。该操作符用于访问数组元素 。下面的示例用于此操作符输出数组中所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; arr[0] = 1; arr[1] = 2; arr[2] = 3; for (i in arr) printf &quot;arr[%d] = %d\n&quot;, i, arr[i] &#125;&apos;</span><br><span class="line"></span><br><span class="line">arr[0] = 1</span><br><span class="line">arr[1] = 2</span><br><span class="line">arr[2] = 3</span><br></pre></td></tr></table></figure>
<p>awk中并没有数组对象，其实是字典，因此<code>i</code> 遍历的是arr的key，而不是value</p>
<p>匹配（Match）</p>
<p>匹配运算符为 ~。不匹配操作符为 !~。 它用于搜索包含匹配模式字符串的域。下面的示例中将输出包括 9 的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;$0 ~ 9&apos; marks.txt    # 这种写法只对数字有效，如果是字母，就会失效</span><br><span class="line">[jerry]$ awk &apos;$0 ~ /9/&apos; marks.txt  # 推荐正则写法</span><br></pre></td></tr></table></figure>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><blockquote>
<p>  仅可以在动作中使用</p>
</blockquote>
<p>一定要加<code>{}</code>与其他语言一样的用法，括号内的为同一语句块</p>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">    action-1</span><br><span class="line">    action-1</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    action-n</span><br><span class="line">&#125;</span><br><span class="line">else if (a == 30)</span><br><span class="line">  print &quot;a = 30&quot;;</span><br><span class="line">else</span><br><span class="line">  print &quot;a = 30&quot;;</span><br></pre></td></tr></table></figure>
<p>例子：将每隔几行就拼接在一起输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"cat\nbat\nfun\nfin\nfan\nend"</span> | awk <span class="string">'&#123;str=str $0&#125;;NR %2==0&#123;print str;str=""&#125;'</span></span><br></pre></td></tr></table></figure>
<p>if-else 语句中，if 后的条件会被计算。如果为真，执行第一个 print 语句。否则，执行第二个 print 语句。注意我们可以使用一个逗号将一个长语句截断为多行来书写。</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>一个 while 语句有一个条件和一个执行体。条件为真时执行体中的语句会被重复执行。这个程序使用公式 value=amount(1+rate)yearsvalue=amount(1+rate)years</p>
<p>来演示以特定的利率投资一定量的钱，其数值是如何随着年数增长的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># interest1 - 计算复利</span><br><span class="line">#   输入: 钱数    利率    年数</span><br><span class="line">#   输出: 复利值</span><br><span class="line"></span><br><span class="line">&#123;   i = 1</span><br><span class="line">    while (i &lt;= $3) &#123;</span><br><span class="line">        printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">        i = i + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件是 while 后括弧包围的表达式；循环体是条件后大括号包围的两个表达式。 printf 规格字符串中的 \t 代表制表符； ^ 是指数操作符。从 # 开始到行尾的文本是注释，会被awk忽略，但能帮助程序的读者理解程序做的事情。</p>
<p>你可以为这程序输入三个一组的数字，看看不一样的钱数、利率、以及年数会产生什么。例如，如下事务演示了1000美元，利率为6%与12%，5年的复利分别是如何增长的：:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk -f interest1</span><br><span class="line">1000 .06 5</span><br><span class="line">        1060.00</span><br><span class="line">        1123.60</span><br><span class="line">        1191.02</span><br><span class="line">        1262.48</span><br><span class="line">        1338.23</span><br><span class="line">1000 .12 5</span><br><span class="line">        1120.00</span><br><span class="line">        1254.40</span><br><span class="line">        1404.93</span><br><span class="line">        1573.52</span><br><span class="line">        1762.34</span><br></pre></td></tr></table></figure>
<h4 id="do-while"><a href="#do-while" class="headerlink" title="do -while"></a>do -while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;i = 1; do &#123; print i; ++i &#125; while (i &lt; 6) &#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p> for ，将大多数循环都包含的初始化、测试、以及自增压缩成一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; for (i = 1; i &lt;= $3; ++i)</span><br><span class="line">    printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化 i = 1 只执行一次。接下来，测试条件 i &lt;= $3 ；如果为真，则执行循环体的 printf 语句。循环体执行结束后执行自增 i = i + 1 ，接着由另一次条件测试开始下一个循环迭代。代码更加紧凑，并且由于循环体仅是一条语句，所以不需要大括号来包围它。</p>
<h4 id="跳出循环（break、continue、exit、next）"><a href="#跳出循环（break、continue、exit、next）" class="headerlink" title="跳出循环（break、continue、exit、next）"></a>跳出循环（break、continue、exit、next）</h4><p>break、continue、exit都支持</p>
<p>next </p>
<p>等价于<code>continue</code>,next 停止处理当前记录，并且进入到下一条记录的处理过程。下面的例子中，当模式串匹配成功后程序并不执行任何操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;if ($0 ~/Shyam/) next; print $0&#125;'</span> marks.txt</span><br></pre></td></tr></table></figure>
<p>nextfile</p>
<p>nextfile 停止处理当前文件，从下一个文件第一个记录开始处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; if ($0 ~ /file1:str2/) nextfile; print $0 &#125;'</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><a href="https://man.linuxde.net/awk" target="_blank" rel="noopener"><a href="https://man.linuxde.net/awk" target="_blank" rel="noopener">更多的函数说明</a></a></p>
<h4 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h4><h5 id="match"><a href="#match" class="headerlink" title="match"></a>match</h5><p>返回正则表达式在字符串 str 中第一个最长匹配的位置。如果能够找到，返回非0值；否则，返回0。match()有两个<strong>相关的特殊变量</strong>，分别是<code>RSTART</code>和<code>RLENGTH</code>。变量<code>RSTART</code>包含了匹配内容的起始位置，而变量<code>RLENGTH</code>包含了匹配内容的长度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "One Two Three"</span></span><br><span class="line"><span class="string">    subs = "Two"</span></span><br><span class="line"><span class="string">    ret = match(str, subs)</span></span><br><span class="line"><span class="string">    printf "Substring \"%s\" found at %d location.\n", subs, ret</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Substring "Two" found at 5 location.</span></span><br></pre></td></tr></table></figure>
<h5 id="asort-数组排序"><a href="#asort-数组排序" class="headerlink" title="asort 数组排序"></a>asort 数组排序</h5><p>asort(arr,[, d [,how] ])</p>
<p>asort 函数使用 GAWK 值比较的一般规则排序 arr 中的value，然后用以 1 开始的有序整数替换排序内容的索引。</p>
<p>大写的会排在前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;</span><br><span class="line">    arr[0] = &quot;Three&quot;</span><br><span class="line">    arr[1] = &quot;One&quot;</span><br><span class="line">    arr[2] = &quot;two&quot;</span><br><span class="line"></span><br><span class="line">    print &quot;Array elements before sorting:&quot;</span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asort(arr)</span><br><span class="line"></span><br><span class="line">    print &quot;Array elements after sorting:&quot;</span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h5 id="asorti-数组排序"><a href="#asorti-数组排序" class="headerlink" title="asorti 数组排序"></a>asorti 数组排序</h5><p>asorti(arr,[, d [,how] ])</p>
<p>asorti 函数的行为与 asort 函数的行为很相似，二者的差别在于 aosrt 对数组的value排序，而 asorti 对数组的index排序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    arr["Two"] = 1</span></span><br><span class="line"><span class="string">    arr["One"] = 2</span></span><br><span class="line"><span class="string">    arr["Three"] = 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    asorti(arr)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    print "Array indices after sorting:"</span></span><br><span class="line"><span class="string">    for (i in arr) &#123;</span></span><br><span class="line"><span class="string">        print arr[i]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="sub、gsub-替换"><a href="#sub、gsub-替换" class="headerlink" title="sub、gsub 替换"></a>sub、gsub 替换</h5><p>sub</p>
<p>将正则表达式regex匹配到的第一处内容<strong>替换</strong>成replacment_str。</p>
<p>gsub(regx,sub, string)</p>
<p>gsub 是全局替换( global substitution )的缩写。它将出现的子串（sub）替换为 regx。第三个参数 string 是可选的，<strong>默认值为 $0</strong>，表示在整个输入记录中搜索子串。进行一次替换的有sub(regex,sub,string)函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "Hello, World"</span></span><br><span class="line"><span class="string">    print "String before replacement = " str</span></span><br><span class="line"><span class="string">    gsub("World", "Jerry", str)</span></span><br><span class="line"><span class="string">    print "String after replacement = " str</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="index-判断子串包含"><a href="#index-判断子串包含" class="headerlink" title="index 判断子串包含"></a>index 判断子串包含</h5><p>index(str,sub)</p>
<p>index 函数用于检测字符串 sub 是否是 str 的子串。如果 sub 是 str 的子串，则返回子串 sub 在字符串 str 的开始位置；若不是其子串，则返回 0。str 的字符位置索引从 1 开始计数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "One Two Three"</span></span><br><span class="line"><span class="string">    subs = "Two"</span></span><br><span class="line"><span class="string">    ret = index(str, subs)</span></span><br><span class="line"><span class="string">    printf "Substring \"%s\" found at %d location.\n", subs, ret</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="split-分割字符串"><a href="#split-分割字符串" class="headerlink" title="split 分割字符串"></a>split 分割字符串</h5><p><code>split(str, arr, regex)</code></p>
<p>split 函数使用正则表达式 regex 分割字符串 str。分割后的所有结果存储在数组 arr 中。如果没有指定 regex 则使用 FS 切分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123;</span><br><span class="line">    str = &quot;One,Two,Three,Four&quot;</span><br><span class="line"></span><br><span class="line">    split(str, arr, &quot;,&quot;)</span><br><span class="line"></span><br><span class="line">    print &quot;Array contains following values&quot;</span><br><span class="line"></span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h5 id="substr-字符串截取"><a href="#substr-字符串截取" class="headerlink" title="substr 字符串截取"></a>substr 字符串截取</h5><p><code>substr(str, start, length)</code></p>
<p>substr 函数返回 str 字符串中从第 start 个字符开始长度为 length 的子串。如果没有指定 length 的值，返回 str 从第 start 个字符开始的后缀子串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "Hello, World !!!"</span></span><br><span class="line"><span class="string">    subs = substr(str, 1, 5)</span></span><br><span class="line"><span class="string">    print "Substring = " subs</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Substring = Hello</span></span><br></pre></td></tr></table></figure>
<h5 id="strtonum字符串转数字"><a href="#strtonum字符串转数字" class="headerlink" title="strtonum字符串转数字"></a>strtonum字符串转数字</h5><p>strtonum(str)</p>
<p>strtonum 将字符串 str 转换为数值。 如果字符串以 0 开始，则将其当作八进制数；如果字符串以 0x 或 0X 开始，则将其当作十六进制数；否则，将其当作浮点数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    print "Decimal num = " strtonum("123")</span></span><br><span class="line"><span class="string">    print "Octal num = " strtonum("0123")</span></span><br><span class="line"><span class="string">    print "Hexadecimal num = " strtonum("0x123")</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line">Decimal num = 123</span><br><span class="line">Octal num = 83</span><br><span class="line">Hexadecimal num = 291</span><br></pre></td></tr></table></figure>
<h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><p><code>tolower(str)</code>、<code>toupper(str)</code></p>
<p>将字符串 str 进行大小写字母转换，然后返回。注意，字符串 str 本身不被改变。</p>
<h4 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h4><p>getline：得到行，但是注意，<strong>得到的并不是当前行，而是当前行的下一行</strong>。原因如下：</p>
<p>从整体上来说，应这么理解它的用法：</p>
<ul>
<li><code>getline var</code> 读取一行内容给 <code>var</code>，没有变量时等价于 <code>getline $0</code></li>
<li>当其左右无重定向符 | 或 &lt; 时，getline作用于当前文件，读入当前文件的一行给其后跟的变量  <code>var</code> 或<code>$0</code>（无变量时）；由于<code>awk</code>在处理<code>getline</code>之前已经读入了一行，所以<code>getline</code>得的是下一行（第二行开始）。</li>
<li><p>当其左右有重定向符 | 或 &lt; 时，<code>getline</code>则作用于定向输入文件（用重定向符从另外一个文件中读取内容、管道符号获得UNIX命令的输出）赋值给<code>$0</code> 或<code>getline</code>后面的变量。由于该文件是刚打开，并没有被<code>awk</code>读入一行，那么<code>getline</code>返回的是该文件的第一行，而不是隔行，并赋值。</p>
<blockquote>
<p>  <code>getline</code> 会记住重定向的文件读取到哪一行了，并不会重复执行<code>getline var &lt; file</code>  重复读取文件，而是一次读取一行</p>
</blockquote>
</li>
<li><code>getline</code>执行后会更新<code>NF</code>，<code>NR</code>，<code>FNR</code>等这些内部变量。</li>
</ul>
<p>例子：</p>
<p>比较 <code>getline</code>后有无变量的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 显示奇数</span><br><span class="line">$ seq 10 | awk &apos;&#123;getline var;  print $0&#125;&apos;  # getline var 后，内部变量不变，因此$0仍然是第1行</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line"># 显示偶数</span><br><span class="line">$ seq 10 | awk &apos;&#123;getline;  print $0&#125;&apos;   # getline 等价于 getline $0 ，处理getline之前$0是第一行，因此$0变为第2行</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>同时读取2个文件，不用担心<code>getline &lt; &quot;b.txt&quot;</code>重复读取文件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;&#123;printf &quot;%s &quot;, $0; getline &lt; &quot;b.txt&quot;; print $0&#125;&apos; a.txt </span><br><span class="line"># 记住 getline 等价于 getline $0 ，因此$0变成了 b 文件的内容</span><br><span class="line">1 6</span><br><span class="line">2 7</span><br><span class="line">3 8</span><br><span class="line">4 9</span><br><span class="line">5 10</span><br><span class="line"></span><br><span class="line"># 交替打印</span><br><span class="line">awk &apos;&#123;getline var &lt; &quot;a.txt&quot;;print var;print $0&#125;&apos; b.txt   # var 是文件a的行，$0是文件b的内容</span><br></pre></td></tr></table></figure>
<p>获取命令输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;&quot;date&quot; | getline; close(&quot;date&quot;); print $0&#125;&apos;</span><br><span class="line">Tue May 10 07:50:51 PDT 2016</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，使用管道符号时，<code>getline</code> 中这样是无法获取环境变量<code>FILE</code>的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F&quot;\t&quot; &apos;BEGIN&#123;while(&quot;cat $FILE&quot;|getline c)&#123;dict[c]=1&#125;&#125; ($2 in dict)&#123;print&#125;&apos; file</span><br></pre></td></tr></table></figure>
<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> find_min(num1, num2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2)</span><br><span class="line">    <span class="built_in">return</span> num1</span><br><span class="line">  <span class="built_in">return</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Script execution starts here</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">  main(10, 20) <span class="comment"># 使用自定义函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h3><h4 id="匹配中文"><a href="#匹配中文" class="headerlink" title="匹配中文"></a>匹配中文</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$1 ~/[一-龥]/'  匹配中文</span><br><span class="line">awk '$1 ~/[\u4e00-\u9fa5]/'  这样反而不行，要不unicode转成对应的中文</span><br></pre></td></tr></table></figure>
<h4 id="awk对换行敏感"><a href="#awk对换行敏感" class="headerlink" title="awk对换行敏感"></a>awk对换行敏感</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123;while(&quot;cat company.txt&quot;|getline)&#123;dict[$1]=1&#125;&#125; &#123;if($3 in dict)print NR&#125;&apos; target.txt</span><br></pre></td></tr></table></figure>
<p>company.txt的文件是<code>\r\n</code>结尾时，无法匹配</p>
<h4 id="shell使用awk批量创建变量"><a href="#shell使用awk批量创建变量" class="headerlink" title="shell使用awk批量创建变量"></a>shell使用awk批量创建变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval $(awk &apos;BEGIN&#123;print &quot;v1=&apos;str1&apos;;v2=&apos;str2&apos;&quot;&#125;&apos;)   # 相当于执行了  v1=&apos;str1&apos;;v2=&apos;str2&apos;</span><br><span class="line">echo &quot;v1=$var1&quot;</span><br><span class="line">echo &quot;v2=$var2&quot;</span><br></pre></td></tr></table></figure></the></excerpt>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/09/02/awk/">awk</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">jizx</a></p>
        <p><span>发布时间:</span>2019-09-02, 12:05:24</p>
        <p><span>最后更新:</span>2020-02-24, 23:39:41</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/09/02/awk/" title="awk">https://jizx.top/2019/09/02/awk/</a>
            <span class="copy-path" data-clipboard-text="原文: https://jizx.top/2019/09/02/awk/　　作者: jizx" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/09/04/bash命令提示符个性化/">
                    bash命令提示符个性化
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/08/13/linux-shell编程/">
                    linux shell编程
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#awk英文文档"><span class="toc-text">awk英文文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本组成"><span class="toc-text">基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行流程"><span class="toc-text">运行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出"><span class="toc-text">输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#print输出"><span class="toc-text">print输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#printf高级输出"><span class="toc-text">printf高级输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#转义序列"><span class="toc-text">转义序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#格式说明符"><span class="toc-text">格式说明符%</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#格式说明符-的可选参数"><span class="toc-text">格式说明符% 的可选参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重定向、管道、双向管道"><span class="toc-text">重定向、管道、双向管道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#重定向"><span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#管道"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双向通信通道"><span class="toc-text">双向通信通道</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#保存到不同文件中"><span class="toc-text">保存到不同文件中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用参数"><span class="toc-text">常用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模式-pattern-种类"><span class="toc-text">模式(pattern)种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择、过滤"><span class="toc-text">选择、过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多条命令"><span class="toc-text">多条命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将命令保存在文件中"><span class="toc-text">将命令保存在文件中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#读取命令的输出"><span class="toc-text">读取命令的输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内置变量"><span class="toc-text">内置变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义变量"><span class="toc-text">自定义变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义变量"><span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数值"><span class="toc-text">数值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组变量"><span class="toc-text">数组变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外部变量"><span class="toc-text">外部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作符"><span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制语句"><span class="toc-text">控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if"><span class="toc-text">if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while"><span class="toc-text">while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-while"><span class="toc-text">do -while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for"><span class="toc-text">for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跳出循环（break、continue、exit、next）"><span class="toc-text">跳出循环（break、continue、exit、next）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置函数"><span class="toc-text">内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串相关"><span class="toc-text">字符串相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#match"><span class="toc-text">match</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#asort-数组排序"><span class="toc-text">asort 数组排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#asorti-数组排序"><span class="toc-text">asorti 数组排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sub、gsub-替换"><span class="toc-text">sub、gsub 替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#index-判断子串包含"><span class="toc-text">index 判断子串包含</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#split-分割字符串"><span class="toc-text">split 分割字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#substr-字符串截取"><span class="toc-text">substr 字符串截取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#strtonum字符串转数字"><span class="toc-text">strtonum字符串转数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#大小写转换"><span class="toc-text">大小写转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getline"><span class="toc-text">getline</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义函数"><span class="toc-text">自定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他知识点"><span class="toc-text">其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#匹配中文"><span class="toc-text">匹配中文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk对换行敏感"><span class="toc-text">awk对换行敏感</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shell使用awk批量创建变量"><span class="toc-text">shell使用awk批量创建变量</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-4 i,
        .toc-level-4 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/09/04/bash命令提示符个性化/" title="上一篇: bash命令提示符个性化">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/08/13/linux-shell编程/" title="下一篇: linux shell编程">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/04/attention图解/">attention图解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/04/keras/">keras</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/04/数据分析库/">python数据分析库</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/04/sklearn/">sklearn</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/07/python-多线程/">python 多线程与多进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/01/python-cookbook/">python cookbook</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/28/推荐网站/">推荐网站</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/python技巧/">python技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/开发环境搭建与效率技巧/">开发环境搭建与效率技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/hive/">hive</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/11/linux知识点/">linux知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/10/vim技巧/">vim技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/bash命令提示符个性化/">bash命令提示符个性化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/awk/">awk</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/13/linux-shell编程/">linux shell编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/python小模块/">python小模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/python模块-logging/">python模块-logging</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/04/anaconda与jupyter使用与设置/">anaconda与jupyter的使用和设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/04/linux常用命令/">linux常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/18/photoshop曲线原理与应用/">photoshop曲线原理与应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/18/正则表达式必知必会/">正则表达式必知必会</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/window添加右键用atom打开/">window添加右键用atom打开</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/12/notepad常用插件/">notepad常用插件与设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/chrome截取整个网页/">chrome截取整个网页</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Git教程/">Git教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/python编码问题/">python编码问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/java方法传参问题/">java方法传参问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/17/如何有效批评而不是吵架/">如何有效批评而不是吵架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/17/剑指offer/">剑指offer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/喜欢人的理由为什么说不出来/">喜欢人的理由为什么说不出来</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/全球公认的最健康的一天作息图解/">全球公认的最健康的一天作息图解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/如何提高「钝感力」，从此不再「想太多」/">如何提高「钝感力」，从此不再「想太多」</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/03/java嵌套类/">java嵌套类</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/英语语法——中级：第3章-完成时态/">英语语法——中级：第3章.完成时态</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/英语语法——中级：第2章-名词、定语、状语从句/">英语语法——中级：第2章.名词、定语、状语从句</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/英语语法——中级：第1章-简单句与复合句/">英语语法——中级：第1章.简单句与复合句</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/08/vim/">vim</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2020 jizx
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 6;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>