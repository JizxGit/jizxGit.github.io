<!DOCTYPE html>
<html>
<head hexo-theme="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4"><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="x-dns-prefetch-control" content="on">

  <!-- 页面元数据 -->
  
  <title>linux常用命令 - 玖玖的博客</title>
  
    <meta name="keywords" content="awk,linux,ing,命令">
  

  
    <meta name="description" content=" 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css">
  
  

  

  

  

  

  <!-- import link -->
  

  
  
    <link rel="stylesheet" href="/css/style.css">
  
  
  
  <!-- 脚本懒加载函数 -->
  <script>
  function loadScript(src, cb) {
    var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
    var script = document.createElement('script');
    script.setAttribute('type','text/javascript');
    if (cb) script.onload = cb;
    script.setAttribute('src', src);
    HEAD.appendChild(script);
  }
  //https://github.com/filamentgroup/loadCSS
  !function(c){"use strict";var e=function(e,t,n,r){var o,i=c.document,a=i.createElement("link");if(t)o=t;else{var d=(i.body||i.getElementsByTagName("head")[0]).childNodes;o=d[d.length-1]}var f=i.styleSheets;if(r)for(var l in r)r.hasOwnProperty(l)&&a.setAttribute(l,r[l]);a.rel="stylesheet",a.href=e,a.media="only x",function e(t){if(i.body)return t();setTimeout(function(){e(t)})}(function(){o.parentNode.insertBefore(a,t?o:o.nextSibling)});var s=function(e){for(var t=a.href,n=f.length;n--;)if(f[n].href===t)return e();setTimeout(function(){s(e)})};function u(){a.addEventListener&&a.removeEventListener("load",u),a.media=n||"all"}return a.addEventListener&&a.addEventListener("load",u),(a.onloadcssdefined=s)(u),a};"undefined"!=typeof exports?exports.loadCSS=e:c.loadCSS=e}("undefined"!=typeof global?global:this);
  </script>
  <script id="loadcss"></script>
</head>

<body>
  <header class="l_header auto shadow blur " style='opacity: 0' >
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div class="l_body">
    <div class="l_cover">
  
    
    
        <div class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">玖玖的博客</p>
    
    
      <p class="subtitle">^_^</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              id="v4getting-started">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              id="faqs">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              id="examples">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              id="contributors">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f389.svg'><p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
            <a href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              id="https:githubcomvolantis-xhexo-theme-volantis">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg'><p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>
  
    <div class='safearea'>
      <div class='body-wrapper' id="pjax-container">
        
          <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">true</div> 
  <div id="pjax-pageTitle">linux常用命令</div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path"></div> 
  <div id="pjax-comment-placeholder"></div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover-wrapper')[0].style.display = "none"; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "half") { // 半屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'half'); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "full") { // 全屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'full'); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover-wrapper')[0].style.display = ""; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 
 

        
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        linux常用命令
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="">
    <p>请设置文章作者</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <a class='notlink'>
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <a class="category-link" href="/categories/linux/">linux</a>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Aug 4, 2019</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="linux常用命令" data-path="/2019/08/04/linux常用命令/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <excerpt in="" index="" |="" 首页摘要=""> 

<p>处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）</p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">



<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><code>ps -f</code>命令也能够表现子shell的嵌套关系</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；</span><br><span class="line">-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；</span><br><span class="line"></span><br><span class="line">date [选项]... [+格式]</span><br><span class="line">　或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">Display the current time in the given FORMAT, or set the system date.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line">  -d, --date=STRING         显示由STRING 描述指定的时间, 不是默认的&apos;now&apos;</span><br><span class="line">  -f, --file=DATEFILE       like --date once for each line of DATEFILE</span><br><span class="line">  -I[TIMESPEC], --iso-8601[=TIMESPEC]  使用ISO 8601格式显示 date/time </span><br><span class="line">                            TIMESPEC可以设置为&apos;date&apos;, &apos;hours&apos;, &apos;minutes&apos;, &apos;seconds&apos;, &apos;ns&apos;  </span><br><span class="line">                            来指定显示的精度，默认是date</span><br><span class="line">  -r, --reference=文件	   显示指定文件的最后修改时间</span><br><span class="line">  -R, --rfc-2822             以RFC 2822格式输出日期和时间</span><br><span class="line">                            例如：2006年8月7日，星期一 12:34:56 -0600</span><br><span class="line">      --rfc-3339=TIMESPEC   output date and time in RFC 3339 format.</span><br><span class="line">                            TIMESPEC=&apos;date&apos;, &apos;seconds&apos;, or &apos;ns&apos; for</span><br><span class="line">                            date and time to the indicated precision.</span><br><span class="line">                            Date and time components are separated by</span><br><span class="line">                            a single space: 2006-08-07 12:34:56-06:00</span><br><span class="line">  -s, --set=STRING          用描述时间的字符串 STRING 设置时间</span><br><span class="line">  -u, --utc, --universal    显示或设置 Coordinated Universal Time</span><br><span class="line">      --help		显示此帮助信息并退出</span><br><span class="line">      --version		显示版本信息并退出</span><br></pre></td></tr></table></figure>
<h4 id="格式化参数"><a href="#格式化参数" class="headerlink" title="格式化参数"></a>格式化参数</h4><p>给定的格式FORMAT 控制着输出，解释序列如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  %%	一个%</span><br><span class="line">  %a	当前locale 的星期名缩写(例如： 日，代表星期日)</span><br><span class="line">  %A	当前locale 的星期名全称 (如：星期日)</span><br><span class="line">  %b	当前locale 的月名缩写 (如：一，代表一月)</span><br><span class="line">  %B	当前locale 的月名全称 (如：一月)</span><br><span class="line">  %c	当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)</span><br><span class="line">  %C	世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)</span><br><span class="line">  %d	按月计的日期(例如：01)</span><br><span class="line">  %D	按月计的日期；等于%m/%d/%y</span><br><span class="line">  %e	按月计的日期，添加空格，等于%_d</span><br><span class="line">  %F	完整日期格式，等价于 %Y-%m-%d</span><br><span class="line">  %g	ISO-8601 格式年份的最后两位 (参见%G)</span><br><span class="line">  %G	ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用</span><br><span class="line">  %h	等于%b</span><br><span class="line">  %H	小时(00-23)</span><br><span class="line">  %I	小时(00-12)</span><br><span class="line">  %j	按年计的日期(001-366)</span><br><span class="line">  %k   hour, space padded ( 0..23); same as %_H</span><br><span class="line">  %l   hour, space padded ( 1..12); same as %_I</span><br><span class="line">  %m   month (01..12)</span><br><span class="line">  %M   minute (00..59)</span><br><span class="line">  %n	换行</span><br><span class="line">  %N	纳秒(000000000-999999999)</span><br><span class="line">  %p	当前locale 下的&quot;上午&quot;或者&quot;下午&quot;，未知时输出为空</span><br><span class="line">  %P	与%p 类似，但是输出小写字母</span><br><span class="line">  %r	当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)</span><br><span class="line">  %R	24 小时时间的时和分，等价于 %H:%M</span><br><span class="line">  %s	自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</span><br><span class="line">  %S	秒(00-60)</span><br><span class="line">  %t	输出制表符 Tab</span><br><span class="line">  %T	时间，等于%H:%M:%S</span><br><span class="line">  %u	星期，1 代表星期一</span><br><span class="line">  %U	一年中的第几周，以周日为每星期第一天(00-53)</span><br><span class="line">  %V	ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)</span><br><span class="line">  %w	一星期中的第几日(0-6)，0 代表周一</span><br><span class="line">  %W	一年中的第几周，以周一为每星期第一天(00-53)</span><br><span class="line">  %x	当前locale 下的日期描述 (如：12/31/99)</span><br><span class="line">  %X	当前locale 下的时间描述 (如：23:13:48)</span><br><span class="line">  %y	年份最后两位数位 (00-99)</span><br><span class="line">  %Y	年份</span><br><span class="line">  %z +hhmm		数字时区(例如，-0400)</span><br><span class="line">  %:z +hh:mm		数字时区(例如，-04:00)</span><br><span class="line">  %::z +hh:mm:ss	数字时区(例如，-04:00:00)</span><br><span class="line">  %:::z			数字时区带有必要的精度 (例如，-04，+05:30)</span><br><span class="line">  %Z			按字母表排序的时区缩写 (例如，EDT)</span><br><span class="line"></span><br><span class="line">默认情况下，日期的数字区域以0填充。</span><br><span class="line">%后面可以加 下面这些标记：</span><br><span class="line">  -  (hyphen) do not pad the field</span><br><span class="line">  _  (underscore) pad with spaces</span><br><span class="line">  0  (zero) pad with zeros</span><br><span class="line">  ^  use upper case if possible</span><br><span class="line">  #  use opposite case if possible</span><br><span class="line"></span><br><span class="line">在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。</span><br><span class="line">作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的</span><br><span class="line">表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。</span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line">Convert seconds since the epoch (1970-01-01 UTC) to a date</span><br><span class="line">  $ date --date=&apos;@2147483647&apos;</span><br><span class="line"></span><br><span class="line">Show the time on the west coast of the US (use tzselect(1) to find TZ)</span><br><span class="line">  $ TZ=&apos;America/Los_Angeles&apos; date</span><br><span class="line"></span><br><span class="line">Show the local time for 9AM next Friday on the west coast of the US</span><br><span class="line">  $ date --date=&apos;TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri&apos;</span><br></pre></td></tr></table></figure>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +&quot;%Y-%m-%d&quot;</span><br></pre></td></tr></table></figure>
<h4 id="时间游走"><a href="#时间游走" class="headerlink" title="时间游走"></a>时间游走</h4><p>1.加减操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">date +%Y%m%d                   //显示前天年月日</span><br><span class="line">date -d &quot;+1 day&quot; +%Y%m%d       //显示前一天的日期</span><br><span class="line">date -d &quot;-1 day&quot; +%Y%m%d       //显示后一天的日期</span><br><span class="line">date -d &quot;-1 month&quot; +%Y%m%d     //显示上一月的日期</span><br><span class="line">date -d &quot;+1 month&quot; +%Y%m%d     //显示下一月的日期</span><br><span class="line">date -d &quot;-1 year&quot; +%Y%m%d      //显示前一年的日期</span><br><span class="line">date -d &quot;+1 year&quot; +%Y%m%d      //显示下一年的日期</span><br></pre></td></tr></table></figure>
<p>2.文字版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;1 day ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;               # 一天前</span><br><span class="line">date -d &quot;1 day&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;                   # 一天后</span><br><span class="line">date -d &quot;2009-12-12  1 year ago&quot; +&quot;%Y/%m/%d %H:%M.%S&quot;  # 指定时间的一年前</span><br><span class="line">date -d &quot;2009-12-12  1 year&quot; +&quot;%Y/%m/%d %H:%M.%S&quot;      # 指定时间的一年后</span><br></pre></td></tr></table></figure>
<p>设置时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date -s                        //设置当前时间，只有root权限才能设置，其他只能查看</span><br><span class="line">date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01               //设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2012-05-23&quot;  //这样可以设置全部时间</span><br></pre></td></tr></table></figure>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p><code>-e</code>：输出转义字符</p>
<p><code>-n</code>：不换行输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RCol='\e[0m'    # Text Reset</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds</span></span><br><span class="line">Bla='\e[0;30m';     BBla='\e[1;30m';    UBla='\e[4;30m';    IBla='\e[0;90m';    BIBla='\e[1;90m';   On_Bla='\e[40m';    On_IBla='\e[0;100m';</span><br><span class="line">Red='\e[0;31m';     BRed='\e[1;31m';    URed='\e[4;31m';    IRed='\e[0;91m';    BIRed='\e[1;91m';   On_Red='\e[41m';    On_IRed='\e[0;101m';</span><br><span class="line">Gre='\e[0;32m';     BGre='\e[1;32m';    UGre='\e[4;32m';    IGre='\e[0;92m';    BIGre='\e[1;92m';   On_Gre='\e[42m';    On_IGre='\e[0;102m';</span><br><span class="line">Yel='\e[0;33m';     BYel='\e[1;33m';    UYel='\e[4;33m';    IYel='\e[0;93m';    BIYel='\e[1;93m';   On_Yel='\e[43m';    On_IYel='\e[0;103m';</span><br><span class="line">Blu='\e[0;34m';     BBlu='\e[1;34m';    UBlu='\e[4;34m';    IBlu='\e[0;94m';    BIBlu='\e[1;94m';   On_Blu='\e[44m';    On_IBlu='\e[0;104m';</span><br><span class="line">Pur='\e[0;35m';     BPur='\e[1;35m';    UPur='\e[4;35m';    IPur='\e[0;95m';    BIPur='\e[1;95m';   On_Pur='\e[45m';    On_IPur='\e[0;105m';</span><br><span class="line">Cya='\e[0;36m';     BCya='\e[1;36m';    UCya='\e[4;36m';    ICya='\e[0;96m';    BICya='\e[1;96m';   On_Cya='\e[46m';    On_ICya='\e[0;106m';</span><br><span class="line">Whi='\e[0;37m';     BWhi='\e[1;37m';    UWhi='\e[4;37m';    IWhi='\e[0;97m';    BIWhi='\e[1;97m';   On_Whi='\e[47m';    On_IWhi='\e[0;107m';</span><br></pre></td></tr></table></figure>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat -A test   显示隐藏字符如^A,^B</span><br><span class="line">cat -n test   所有的行加上行号</span><br><span class="line">cat -b test  【有文本的行】 加上行号，【空白行】不算</span><br><span class="line">cat -T test   以^I显示制表符</span><br></pre></td></tr></table></figure>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 2 -f log_file</span><br></pre></td></tr></table></figure>
<p><code>-f</code> 参数是 tail 命令的一个突出特性。它允许你在其他进程使用该文件时查看文件的内容。tail命令会保持活动状态，并不断显示添加到文件中的内容。这是实时监测系统日志的绝妙方式。</p>
<h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>uniq命令用于报告或忽略文件中的重复行，<strong>查重复行的时候，只会检查相邻的行</strong>，因此一般与<a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort</a>命令结合使用，让重复的排在一起。比如下面：<code>aa</code> 统计结果是出现了 2 次，后面又有出现 1 次的 <code>aa</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 文本</span><br><span class="line">aa</span><br><span class="line">aa</span><br><span class="line">c</span><br><span class="line">aa</span><br><span class="line"></span><br><span class="line"># uniq 后</span><br><span class="line">uniq -c </span><br><span class="line">2 aa</span><br><span class="line">1 c</span><br><span class="line">1 aa</span><br></pre></td></tr></table></figure>
<p>常用参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：			在每列旁边显示该行重复出现的次数；</span><br><span class="line">-u或——unique：		仅显示出一次的行列；</span><br><span class="line">-d或--repeated：		仅输出重复出现的行列，且重复的只输出一行；</span><br><span class="line">-D, --all-repeated   仅输出重复的行，有几行输出几行  </span><br><span class="line">-i, --ignore-case    不区分大小写  </span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;   指定要比较的前 n 个字符，忽略后面的内容</span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;         忽略前n列（空格分割），-f 1 忽略第一列</span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;   忽略前n个字符 -s 4 忽略前 4 个字符</span><br><span class="line">-z 忽略换行(不知道有什么用)</span><br></pre></td></tr></table></figure>
<p>提供的测试文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this is a test  </span><br><span class="line">this is a test  </span><br><span class="line">this is a test  </span><br><span class="line">i am tank  </span><br><span class="line">i love tank  </span><br><span class="line">i love tank  </span><br><span class="line">this is a test  </span><br><span class="line">whom have a try  </span><br><span class="line">WhoM have a try </span><br><span class="line">WhoM have a try1</span><br><span class="line">you  have a try  </span><br><span class="line">i want to abroad  </span><br><span class="line">those are good men  </span><br><span class="line">we are good men</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="http://blog.51yip.com/shell/1022.html" target="_blank" rel="noopener">http://blog.51yip.com/shell/1022.html</a></p>
<h4 id="两个文件的交并集"><a href="#两个文件的交并集" class="headerlink" title="两个文件的交并集"></a>两个文件的交并集</h4><p>如果你知道怎么用<code>sort/uniq</code>来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已经被uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat a b | sort | uniq &gt; c   # c is a union b 并集</span><br><span class="line">cat a b | sort | uniq -d &gt; c   # c is a intersect b 交集</span><br><span class="line">cat a b b | sort | uniq -u &gt; c   # c is set difference a - b 差集</span><br></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h4><table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th></th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-b</td>
<td>–ignore-leading-blanks</td>
<td>排序时忽略起始的空白，空格数量不固定时，该选项几乎是必须要使用的。”-n”选项隐含该选项。</td>
</tr>
<tr>
<td style="text-align:left">-c</td>
<td>–check</td>
<td>仅检查输入数据是不是已排序；未排序的话，会输出诊断信息，提示从哪一行开始乱序。</td>
</tr>
<tr>
<td style="text-align:left">-t</td>
<td>–field-separator=SEP</td>
<td>指定分隔符，如果是<code>\t</code>，需要这样<code>sort -t$&#39;\t&#39; file</code>。<strong>默认的分隔符为空白字符和非空白字符之间的空字符</strong>，<strong>并非网上众多文章所说的空格或制表符</strong>(By default, fields are separated by the empty string between a non-blank character and a blank character)。” foo bar”被分割为：`</td>
<td>foo</td>
<td>bar<code>（</code></td>
<td>`视为分割符）</td>
</tr>
<tr>
<td style="text-align:left">-u</td>
<td>–unique</td>
<td>在输出行中去除重复行，只识别用<code>-k</code>设定的域，发现都相同的才会删除，只要其中有一级不同都不会轻易删除的。</td>
</tr>
<tr>
<td style="text-align:left">-n</td>
<td>–numeric-sort</td>
<td>指定-n使用数值比较，默认是字符串比较，<strong>一遇到不可识别字符就会立即结束该字段的排序行为</strong>，<strong>无法跨域使用</strong>。”n”选项隐含”b”选项。</td>
</tr>
<tr>
<td style="text-align:left">-g</td>
<td>–general-number-sort</td>
<td>按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学 计数法表示的值）</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td>–reverse</td>
<td>默认从小到大，指定后改为从大到小排序</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td>–ignore-case</td>
<td>忽略大小写，未指定情况下，会将<strong>大写字母排在前面</strong>；在和”-u”选项一起使用时，如果排序字段的比较结果相等，则丢弃小写字母行。</td>
</tr>
<tr>
<td style="text-align:left">-o</td>
<td>–output=file</td>
<td>排序结果输出到指定文件，对于<strong>保存到原文件很有用</strong>，不然是可以用重定向的</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td>–merge</td>
<td>对给定的多个已排序文件进行合并。在合并过程中不做任何排序动作。</td>
</tr>
<tr>
<td style="text-align:left">-k</td>
<td>–key=POS1[,POS2]</td>
<td>指定排序的列，排序从POS1位置开始；如果指定了POS2的话， 到POS2位置结 束</td>
</tr>
<tr>
<td style="text-align:left">-s</td>
<td>–stable</td>
<td>禁用”最终排序”。<strong>推荐大文件使用</strong>，能确认要排序的列后，不启用可以提高性能</td>
</tr>
<tr>
<td style="text-align:left">-z</td>
<td>–zero-terminated</td>
<td>NULL字符作为行尾，而不是用换行符</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>–debug</td>
<td>查看排序的过程和排序时所使用的列。注意，该选项只有CentOS 7上的sort才有。</td>
</tr>
</tbody>
</table>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p><strong>私有选项</strong>：紧跟在字段后的选项(如”-k3n”的”n”和”-k2r”的”r”)称为私有选项，使用短横线写在字段外的选项(如”-n”、”-r”)为全局选项。<strong>当没有为字段分配私有选项时，该排序字段将继承全局选项。</strong>当然，只有像”-n”、”-r”这样的排序性的选项才能继承和分配给字段，”-t”这样的选项则无法分配。</p>
<p>除了”b”选项外，其余选项无论是<strong>指定在POS1还是POS2中都是等价的</strong>，对于”b”选项，指定在POS1则作用于POS1，指定在POS2则作用于POS2。如果继承了全局选项”-b”，则作用于POS1和POS2。</p>
<blockquote>
<p>  因此，”-n -k3 -k4”、”-n -k3n -k4”和”-k3n -k4n”是等价的，”-r -k3n -k4”和”-k3nr -k4r”是等价的</p>
</blockquote>
<p><strong>排序规则</strong>：sort命令默认按照字符集的排序规则进行排序，可以指定”-d”选项按照字典顺序排序，指定”-n”按照数值排序，指定”-M”按照字符格式的月份规则排序，指定”-h”按照文件容量大小规则排序。</p>
<p><strong>分隔符</strong> ：sort使用<code>-t</code>选项指定的分隔符对每行进行分割，得到多个字段，<strong>分隔符不作为字段的内容，跨域时也没有，注意<code>-n</code>无法跨域，会造成分隔符在其中的错觉</strong>。默认的分隔符为空白字符和非空白字符之间的空字符，并非网上众多文章所说的空格或制表符(原文：By default, fields are separated by the empty string between a non-blank character and a blank character.)。</p>
<p>“ foo bar”默认将分隔为两个字段” foo”和” bar”，空格都保留着，可以视为”| foo| bar”，<code>|</code>为分割符。而使用空格作为分隔符时将分隔为三个字段：第一个字段为空，第二个字段和第三个字段为”foo”和”bar”。使用下面三个sort语句可以验证默认的分隔符并非空格。</p>
<blockquote>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">   $ <span class="built_in">echo</span> -e <span class="string">" 234 bar\n 323 aar"</span> | sort  -k2     <span class="comment"># 视为 2 列，对（aar,bar）排序</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    323 aar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    234 bar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   $ <span class="built_in">echo</span> -e <span class="string">" 234 bar\n 323 aar"</span> | sort  -t<span class="string">' '</span> -k2 <span class="comment"># 视为 3 列，对 (234,323)排序</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    234 bar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    323 aar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   $ <span class="built_in">echo</span> -e <span class="string">" 234 bar\n 323 aar"</span> | sort -b -t<span class="string">' '</span> -k1 <span class="comment"># 视为 2 列，因为全局选项-b 去除了开头的空格</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    123 aar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    234 bar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   $ <span class="built_in">echo</span> -e <span class="string">" 234  bar\n 323 aar"</span> | sort -t<span class="string">' '</span> -bk3  <span class="comment"># 视为 3 列，对（aar, bar）排序，私有选项忽略 bar 前的空格</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    323 aar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    234  bar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>分割后字段</strong>：分割字段后，<strong>分隔符不在排序目标中，跨域时也不包括（<code>-n</code>无法跨域，会造成分隔符在其中的错觉）</strong>，分割后两个字段A和B是紧靠在一起的。当排序的目标字段包含了B字段，那么sort会从字段左对齐处开始依次对字符排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># cat sort.txt</span></span><br><span class="line"><span class="number">11</span>:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"><span class="number">12</span>:<span class="number">1</span>:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>:<span class="number">0</span></span><br><span class="line">[root@xuexi ~]<span class="comment"># sort -t:  sort.txt</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>:<span class="number">0</span></span><br><span class="line"><span class="number">11</span>:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"><span class="number">12</span>:<span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上面排序例子中，为什么”1:1:2”的1会在11和12中间，而”1:1:0”中的1却在11的前面？实际上，真正排序的时候，sort看到的内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1112</span><br><span class="line">112</span><br><span class="line">1211</span><br><span class="line">110</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：info sort 文档中说跨域时分隔符会保留感觉是错的。通过下面的例子进行测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat t</span></span><br><span class="line">a ae</span><br><span class="line">aa da</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sort -t<span class="string">" "</span> -k1,2 t   <span class="comment"># d &gt; e</span></span></span><br><span class="line">aa da</span><br><span class="line">a ae</span><br></pre></td></tr></table></figure>
<p><strong>最后排序</strong>：默认情况下，在命令行中指定的排序行为结束后，sort还会做最后一次排序，这最后一次排序是对整行按照完全默认规则进行排序的，也就是按字符集、升序排序。</p>
<p>考虑这样一种情况：两行在<strong>所有key的排序结果</strong>上都完全相同，应该如何决定这两行的先后顺序？</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# echo -e &quot;b 100 200\na 100 300&quot; | sort -t &apos; &apos; -k2n</span><br><span class="line">a 100 300</span><br><span class="line">b 100 200</span><br></pre></td></tr></table></figure>
<p>第一行为”b 100 200”，第二行为”a 100 300”。由于第2字段都是100，所以这两行在该key上的数值排序的结果相同，<strong>于是sort采取最后的手段，完全按照默认规则(即按字符集排序规则升序排序)对整行进行一次排序，这次排序称为”最后的排序”</strong>(info sort中称为last-resort comparison)。由于最后的排序过程中，第一个字符a&lt;b，所以最终结果将是第二行”a 100 300”在第一行”b 100 200”的前面。</p>
<p><strong>禁止”最后的排序”后，对那些排序key相同的行，将保留被读取时相对顺序。</strong>即，先读取的排在前面。</p>
<p>如果上面的例子中，第二字段不采用数值排序，而是默认排序规则排序呢？如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# echo -e &quot;b 100 200\na 100 300&quot; | sort -t &apos; &apos; -k2</span><br><span class="line">b 100 200</span><br><span class="line">a 100 300</span><br></pre></td></tr></table></figure>
<p>由于默认的排序规则是按照字符集排序规则进行排序，它能识别所有的字符，所以<code>-k2</code>等价于<code>-k2,3</code>，对整个key进行排序，由于第三字段的2小于3，所以结果中第一行排在第二行的前面。即使如此，sort还是进行了”最后的排序”，只不过”最后的排序”不影响排序结果。</p>
<p>如果未指定任何排序选项，其本身就是完全默认的，因此没必要再做最后的排序，所以将不会进行”最后的排序”。如果指定的是”-r”选项，由于”-r”是对最终结果进行反转排序，因此会影响这次的”最后的排序”的结果。</p>
<h4 id="排序对象"><a href="#排序对象" class="headerlink" title="排序对象"></a>排序对象</h4><p><strong>使用”-k”选项指定排序的key。不指定排序key时，整行将成为排序key，即对整行进行排序。</strong></p>
<ul>
<li>key由字段组成，格式为<code>POS1,[POS2]</code>，表示每行排序的起始和终止位置。也就是说，key才是排序的对象。</li>
<li>POS的格式为<code>F[.C][OPTS]</code>，其中F表示字段的序号，C表示该字段中字符的序号。字段和字符的位置都从1开始计算。如果POS2的字符位置指定为0，则表示POS2字段中的最后一个字符。如果POS1中省略<code>.C</code>，则默认值为1(字段的起始字符)，如果POS2中省略<code>.C</code>，默认值为0(字段的终止字符)。使用”-b”选项忽略前导空白字符时，C从第一个非空白字符开始计算。如果F或C超出了有效范围，则该key为空，例如一行只有3个字段，却指定了”-k4”，或者第2字段只有3个字符，却指定了”-k2.5”。</li>
<li>如果<strong>省略POS2，则key将自动扩展到行尾</strong>，即等价于”POS1,line_end”。如果不省略POS2，则该key可能会跨越多个字段。无论那种情况，跨越多个字段时，key中都不会保留字段间的分隔符。</li>
<li>OPTS指定的是该key的选项，包括但不限于<code>bfnrhM</code>，它们的作用和全局选项”-b”、”-f”、”-n”、”-r”、”-h”、”-M”相同。默认情况下，如果key中没有指定任何OPTS，则该<strong>key会继承全局选项</strong>。当key中单独指定了选项时，这些选项是该key的私有排序选项，将覆盖全局选项。除了”b”选项外，其余选项无论是指定在POS1还是POS2中都是等价的，对于”b”选项，指定在POS1则作用于POS1，指定在POS2则作用于POS2。如果继承了全局选项”-b”，则作用于POS1和POS2。<strong><code>-n</code>选项无法跨域</strong>。</li>
<li>字段前数量不固定的前导空白字符，将使得字段混乱，因此<strong>强烈建议总是忽略前导空白字符</strong>。数值排序时(即”n”选项)隐含”b”选项。</li>
<li>可以使用多个”-k”选项指定多个key，排序时将按照key的顺序进行排序。第一个key通常称为主排序key(primary key)。第二个key将在第一个key排序的基础上排序，同理，第三个key将在第二个key的排序基础上进行排序。</li>
</ul>
<p>以下是几个例子：例子中出现了选项”n”的，描述暂不严谨，但目前只能如此描述，在稍后的(4)中解释。</p>
<ul>
<li><p><code>-k 2</code>： 因为没有指定POS2，所以key扩展到了行尾。因此该key从第2字段第一个字符开始，到行尾结束。</p>
</li>
<li><p><code>-k 2,3</code> ：该key从第2字段第一个字符开始到第3字段最后一个字符结束。</p>
</li>
<li><p><code>-k 2,2</code>： 该key仅拥有第2字段。</p>
</li>
<li><p><code>-k 2,3n</code>和<code>-k 2n,3</code>和<code>-k 2n,3n</code>：这三者等价，因为除了”b”选项，OPTS指定在POS1或POS2的结果是一样的。</p>
</li>
<li><p><code>-k 2,3b</code>和<code>-k 2b,3</code>和<code>-k 2b,3b</code>：这三者互不等价。</p>
</li>
<li><p><code>-k 2n</code>： 该key从第2字段开始直到行尾，都按数值排序。</p>
</li>
<li><p><code>-k 2.2b,3.2n</code>： 该key从第2字段的第2个非空白字符开始，到第3字段第2字符(可能包含空白字符)结束，且该key按照数值排序。其实此处的b选项是多余的，因为n隐含了b选项。</p>
</li>
<li><p><code>-k 5b,5 -k 3,3n</code>： 定义了两个排序key，主排序key为第5字段不包含空白字符的部分，副key为第三个字段。主key按照默认规则排序，副key按照数值排序。副key在主key排序后的基础上再排序。</p>
</li>
<li><p><code>-k 5,5n -k 3b,6b</code>： 主key为第5字段，按照数值排序，副key从第3字段到第六字段，忽略前导空白字符，但是按照默认规则排序。副key在主key排序后的基础上再排序。</p>
</li>
</ul>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul>
<li>任何时候想对单个字段或单个字符排序时，都建议写出POS2，且POS2=POS1，这样能严格排序key的范围只为那个字段或字符。例如，使用<code>-k2,2</code>取代<code>-k2</code>。</li>
<li>想对多个字段或字符排序时，建议使用多个”-k”选项指定多个key，并按需求为每个key分配私有选项。之所以要如此，是防止无意中忽视了扩展到行尾或者范围。例如，想对第2列、第3列按数值排序，应该指定<code>-k2n -k3n</code>，而不应该写成<code>-k2,3n</code>。</li>
<li>应该总是使用<code>-b</code>选项去掉前导空白字符面，防止字段分割时混乱。<code>-n</code>隐含了<code>-b</code>，所以对数值排序时，可以省略<code>-b</code>。</li>
<li>对于大文件，建议写出满足需求的所有排序命令，然后使用<code>-s</code>关闭”最后的排序”。因为”最后的排序”对每个整行进行排序，性能非常低。</li>
</ul>
<h4 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h4><p>sort按照某列排序，一样的话再按某一列排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort  -k2,2 -k5,5 wide_table |grep <span class="string">"DD4486F320A7F0C112E2757C26609769"</span></span><br></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ol>
<li><p>从公司英文名称的第二个字母开始进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 1.2 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
<p> 使用了<code>-k 1.2</code>，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。</p>
</li>
<li><p>按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -n -t &apos; &apos; -k 3r -k 2 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
<p>在-k 3后面偷偷加上了一个小写字母r。<strong>r和-r选项的作用是一样的，就是表示逆序，不过只对当前域有效</strong>，表示第三个域（员工平均工资）是按照降序排序。此处你还可以加上n，就表示对这个域进行排序时，要按照数值大小进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 3nr -k 2n facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
<p>我们去掉了最前面的-n选项，而是将它加入到了每一个-k选项中了。</p>
</li>
<li><p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 1.2,1.2 -k 3nr facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。</p>
</blockquote>
</li>
<li><p>最诡异的排序（跨域是不行的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -n -k 2.2,3.1 facebook.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure>
<p>以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。</p>
<p>第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。</p>
<p>又因为sort认为0小于00小于000小于0000….</p>
<p>因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢？（你可以自己做实验思考一下。）</p>
<p>答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了。</p>
</li>
</ol>
<p><a href="http://blog.chinaunix.net/uid-10540984-id-313479.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-10540984-id-313479.html</a></p>
<p><a href="https://www.cnblogs.com/f-ck-need-u/p/7442886.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7442886.html</a></p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]</span><br></pre></td></tr></table></figure>
<p>任何位于表达式（expression）之前的字符串都将被视为欲查找的目录名。</p>
<p>默认路径为当前目录；默认表达式为<code>-print</code><br>表达式(expression)可能由下列成份组成：操作符、选项、测试表达式以及动作：</p>
<p>find会对每个文件评估从左向右的表达式，直到结果明确为真 或 表达式全部执行结束。</p>
<p>-H，-L和-P选项控制符号链接的处理。后面的命令行参数被视为要检查的文件或目录的名称，直到开始的第一个参数使用’ - ‘或参数’（’或’！’。该参数和任何后续参数被视为描述要搜索内容的表达式。</p>
<p>五个’真正的’选项-H，-L，-P， -D和-O必须出现在第一个路径名之前</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">操作符 (优先级递减；未做任何指定时默认使用 -and):</span><br><span class="line">      ( EXPR )  </span><br><span class="line">      ! EXPR   </span><br><span class="line">      -not EXPR  </span><br><span class="line">      EXPR1 -a EXPR2</span><br><span class="line">      EXPR1 -and EXPR2</span><br><span class="line">      EXPR1 -o EXPR2</span><br><span class="line">      EXPR1 -or EXPR2</span><br><span class="line">      EXPR1 , EXPR2</span><br><span class="line"></span><br><span class="line">位置选项 (总是真): </span><br><span class="line">      -daystart <span class="comment"># 从本日开始计算时间；TODO</span></span><br><span class="line">      -follow  废弃; 使用-L代替, 排除符号连接；</span><br><span class="line">      -regextype 普通选项 (总是真，在其它表达式前指定):</span><br><span class="line">      -depth  <span class="comment"># 从指定目录下最深层的子目录开始查找，不像默认的一层一层目录往下找，如下：</span></span><br><span class="line">          <span class="comment"># ./logs/hadoop.kylin.libdfs.log</span></span><br><span class="line">	      <span class="comment"># ./logs</span></span><br><span class="line">      -maxdepth LEVELS  <span class="comment"># 设置最大目录层级;</span></span><br><span class="line">      -mindepth LEVELS  <span class="comment"># 搜索深度距离当前目录至少2个子目录的所有文件</span></span><br><span class="line">      -mount   <span class="comment"># 此参数的效果和指定“-xdev”相同；</span></span><br><span class="line">      -xdev    <span class="comment"># Don’t descend directories on other filesystems.TODO</span></span><br><span class="line">      -ignore_readdir_race</span><br><span class="line">      -noignore_readdir_race</span><br><span class="line">      --version </span><br><span class="line">      --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">比较测试 (N 可以是 +N 或 -N 或 N): </span><br><span class="line">       +N     <span class="keyword">for</span> greater than N,</span><br><span class="line">       -N     <span class="keyword">for</span> less than N,</span><br><span class="line">        N     <span class="keyword">for</span> exactly N.</span><br><span class="line">       </span><br><span class="line">      -amin N   <span class="comment"># 查找在指定时间曾被存取过的文件或目录，单位以分钟计算；</span></span><br><span class="line">      -mmin N   <span class="comment"># 查找在指定时间曾被更改过的文件或目录，单位以分钟计算；</span></span><br><span class="line">      -cmin N   <span class="comment"># 查找在指定时间之时被更改过的文件或目录,单位以分钟计算；</span></span><br><span class="line">      -atime N  <span class="comment"># 查找在指定时间曾被存取过的文件或目录，单位以24小时计算；</span></span><br><span class="line">      -mtime N  <span class="comment"># 查找在指定时间曾被更改过的文件或目录，单位以24小时计算;</span></span><br><span class="line">      -ctime N  <span class="comment"># 查找在指定时间之时被更改的文件或目录，单位以24小时计算；</span></span><br><span class="line">      -cnewer 文件  <span class="comment"># 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</span></span><br><span class="line">      -anewer 文件 <span class="comment"># 查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；</span></span><br><span class="line">      -empty </span><br><span class="line">      -<span class="literal">true</span>            <span class="comment"># 将find指令的回传值皆设为True;</span></span><br><span class="line">      -<span class="literal">false</span>            <span class="comment"># 将find指令的回传值皆设为False；</span></span><br><span class="line">      -fstype 类型      <span class="comment"># 只寻找该文件系统类型下的文件或目录；</span></span><br><span class="line">      -gid N            <span class="comment"># 查找符合指定之群组识别码的文件或目录；</span></span><br><span class="line">      -group 名称       <span class="comment"># 查找符合指定之群组名称的文件或目录；</span></span><br><span class="line">      -uid N           <span class="comment"># 查找符合用户uid的文件或目录</span></span><br><span class="line">      -user NAME       <span class="comment"># 查找符和指定的拥有者名称的文件或目录</span></span><br><span class="line">      <span class="comment"># 匹配模式使用的是shell的通配符（除了regex）</span></span><br><span class="line">      -name 匹配模式      <span class="comment"># *.py  最好配合*使用，精确指定可能得不到想要的结果</span></span><br><span class="line">      -regex 匹配模式     <span class="comment"># 需要较多的转义，请看后面的例子</span></span><br><span class="line">      -path 匹配模式      <span class="comment"># 与name很像，必须配合*使用，指定字符串作为寻找目录的范本样式，只要目录中包含匹配的模式，就输出</span></span><br><span class="line">      -perm [+-]访问模式  <span class="comment"># 查找符合指定的权限数值的文件或目录;</span></span><br><span class="line">      -lname 匹配模式     <span class="comment"># 查找是符号链接的文件，并且其内容匹配模式</span></span><br><span class="line">      -newer 文件或目录    <span class="comment"># 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录;</span></span><br><span class="line">      <span class="comment"># 忽略字符大小写的差别</span></span><br><span class="line">      -iname 匹配模式 -ipath 匹配模式 -iregex 匹配模式   -ilname 匹配模式</span><br><span class="line">      </span><br><span class="line">      -links N           <span class="comment"># 查找符合指定的硬连接数目的文件或目录；</span></span><br><span class="line">      -inum N            <span class="comment"># 查找符合指定的inode编号的文件或目录；</span></span><br><span class="line">      </span><br><span class="line">      -nouser -nogroup   <span class="comment"># 找出不属于本地主机[用户识别码/群组识别码]的文件或目录;</span></span><br><span class="line">      -noleaf            <span class="comment"># 不去考虑目录至少需拥有两个硬连接存在；</span></span><br><span class="line">      <span class="comment"># 可读写执行</span></span><br><span class="line">      -readable -writable -executable</span><br><span class="line">      </span><br><span class="line">      -wholename PATTERN  <span class="comment"># TODO</span></span><br><span class="line">      -size N[bcwkMG] <span class="comment"># 查找符合指定的文件大小的文件;</span></span><br><span class="line"></span><br><span class="line">      -<span class="built_in">type</span> [bcdpflsD] <span class="comment"># 只寻找符合指定的文件类型的文件；</span></span><br><span class="line">      -used N    <span class="comment"># 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算;</span></span><br><span class="line">     </span><br><span class="line">      -xtype [bcdpfls] <span class="comment"># 和指定“-type”参数类似，差别在于它针对符号连接检查。</span></span><br><span class="line"></span><br><span class="line">动作: -delete </span><br><span class="line">      -<span class="built_in">print</span>   <span class="comment"># 若回传值为Ture，就将符合的文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串;</span></span><br><span class="line">      -print0  <span class="comment"># 回传值为Ture，就将符合的文件或目录名称列出到标准输出。格式为全部的名称皆在同一行;</span></span><br><span class="line">      -<span class="built_in">printf</span> FORMAT <span class="comment"># 回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定;</span></span><br><span class="line">      -fprintf FILE FORMAT  <span class="comment"># 此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；</span></span><br><span class="line">      -fprint0 FILE         <span class="comment"># 指定“-print0”参数类似，但会把结果保存成指定的列表文件；</span></span><br><span class="line">      -fprint FILE          <span class="comment"># 和指定“-print”参数类似，但会把结果保存成指定的列表文件；</span></span><br><span class="line">      -ls 					<span class="comment"># 对符合条件的文件或目录执行ll命令，显示详细信息</span></span><br><span class="line">      -fls FILE             <span class="comment"># 和指定“-ls”参数类似，但会把结果保存为指定的列表文件；</span></span><br><span class="line">      -prune                <span class="comment"># 不打印符合条的文件或目录</span></span><br><span class="line">      -quit</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 执行的命令不支持你自定义的alias</span></span><br><span class="line">      -<span class="built_in">exec</span> COMMAND &#123;&#125; \;       <span class="comment"># find指令的回传值为True，就执行该指令;</span></span><br><span class="line">      -ok COMMAND &#123;&#125; \;         <span class="comment"># 与-exec相似，但是会给出提示，是否执行相应的操作。</span></span><br><span class="line">      -<span class="built_in">exec</span> COMMAND &#123;&#125; + -ok COMMAND ; <span class="comment"># &#123;&#125;是一个占位符，用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名</span></span><br><span class="line">      -execdir COMMAND ; </span><br><span class="line">      -execdir COMMAND &#123;&#125; + -okdir COMMAND ;</span><br></pre></td></tr></table></figure>
<p>在<code>/home</code>目录下查找以.txt结尾的文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>
<p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br></pre></td></tr></table></figure>
<p>匹配文件路径或者文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure>
<p>name与path的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ find . -ipath &quot;*match*&quot;</span><br><span class="line">./bin/match</span><br><span class="line">./bin/match/match.py</span><br><span class="line">./data/match_result.txt</span><br><span class="line">./data/match</span><br><span class="line">./data/match/20190910   # 这一行的差别</span><br><span class="line">./data/match/20190910/match_result_20190910.txt</span><br><span class="line">./data/match_result_20190910.txt</span><br><span class="line"></span><br><span class="line">$ find . -iname &quot;*match*&quot;</span><br><span class="line">./bin/match</span><br><span class="line">./bin/match/match.py</span><br><span class="line">./data/match_result.txt</span><br><span class="line">./data/match</span><br><span class="line">./data/match/20190910/match_result_20190910.txt</span><br><span class="line">./data/match_result_20190910.txt</span><br></pre></td></tr></table></figure>
<p>基于正则表达式匹配文件路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>
<p><strong>否定参数</strong></p>
<p>找出/home下不是以.txt结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>
<p>类型参数列表：</p>
<ul>
<li><strong>f</strong> 普通文件</li>
<li><strong>l</strong> 符号连接</li>
<li><strong>d</strong> 目录</li>
<li><strong>c</strong> 字符设备</li>
<li><strong>b</strong> 块设备</li>
<li><strong>s</strong> 套接字</li>
<li><strong>p</strong> Fifo</li>
</ul>
<p>UNIX/Linux文件系统每个文件都有三种时间戳：</p>
<ul>
<li><strong>访问时间</strong>（-atime/天，-amin/分钟）：用户最近一次访问时间。</li>
<li><strong>修改时间</strong>（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</li>
<li><strong>变化时间</strong>（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</li>
</ul>
<p>搜索最近七天内被访问过的所有文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime -7</span><br></pre></td></tr></table></figure>
<p>搜索恰好在七天前被访问过的所有文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime 7</span><br></pre></td></tr></table></figure>
<p>搜索超过七天内被访问过的所有文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime +7</span><br></pre></td></tr></table></figure>
<p>搜索访问时间超过10分钟的所有文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -amin +10</span><br></pre></td></tr></table></figure>
<p>找出比<a href="http://man.linuxde.net/file" target="_blank" rel="noopener">file</a>.log修改时间更长的所有文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -newer file.log</span><br></pre></td></tr></table></figure>
<p><strong>根据文件大小进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size 文件大小单元</span><br></pre></td></tr></table></figure>
<p>文件大小单元：</p>
<ul>
<li><strong>b</strong> —— 块（512字节）</li>
<li><strong>c</strong> —— 字节</li>
<li><strong>w</strong> —— 字（2字节）</li>
<li><strong>k</strong> —— 千字节</li>
<li><strong>M</strong> —— 兆字节</li>
<li><strong>G</strong> —— 吉字节</li>
</ul>
<p>搜索大于10KB的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +10k</span><br></pre></td></tr></table></figure>
<p>搜索小于10KB的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size -10k</span><br></pre></td></tr></table></figure>
<p>搜索等于10KB的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size 10k</span><br></pre></td></tr></table></figure>
<p><strong>删除匹配文件</strong></p>
<p>删除当前目录下所有.txt文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -delete</span><br></pre></td></tr></table></figure>
<p><strong>根据文件权限/所有权进行匹配</strong></p>
<p>当前目录下搜索出权限为777的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -perm 777</span><br></pre></td></tr></table></figure>
<p>找出当前目录下权限不是644的<a href="http://man.linuxde.net/php" target="_blank" rel="noopener">php</a>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.php&quot; ! -perm 644</span><br></pre></td></tr></table></figure>
<p>找出当前目录用户tom拥有的所有文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -user tom</span><br></pre></td></tr></table></figure>
<p>找出当前目录用户组sunk拥有的所有文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -group sunk</span><br></pre></td></tr></table></figure>
<p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>
<p>要列出所有长度为零的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -empty</span><br></pre></td></tr></table></figure>
<p><strong>执行命令相关</strong></p>
<p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; all.txt</span><br></pre></td></tr></table></figure>
<p>将30天前的.log文件移动到old目录中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br></pre></td></tr></table></figure>
<p>单行命令中-exec参数中无法使用多个命令，可以将多条命令保存在shell文件中，在-exec执行该文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./text.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。例如： <code>grep -i &#39;hello world&#39; menu.h main.c</code></p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep pattern filename  <span class="comment"># 默认支持正则</span></span><br><span class="line">grep -e pattern1 -e pattern2 filename</span><br></pre></td></tr></table></figure>
<p>默认情况下，grep命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。</p>
<p>需要注意的是：限定连续字符范围 的<code>{}</code>符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 <code>\{</code> 与<code>\}</code> 来让它失去特殊意义才行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">grep --color=auto <span class="string">" 在输出行中着重标记出匹配到的模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-a # 将 binary 文件以 text 文件的方式搜寻数据</span></span><br><span class="line"><span class="string">-e # 指定字符串做为查找文件内容的样式（非正则）。如果要指定多个匹配模式，可用-e参数来指定每个模式,grep -e t -e f file 输出了含有字符t或字符f的所有行。</span></span><br><span class="line"><span class="string">-E # 将字符串为延伸的正则表达式来使用</span></span><br><span class="line"><span class="string">-o # 只输出匹配到的文本，如果在同一行中，会分开显示</span></span><br><span class="line"><span class="string">-v # 打印出不匹配match_pattern的所有行</span></span><br><span class="line"><span class="string">-c # 统计匹配行的数量，并不是匹配的次数。匹配次数需要与-o配合，请看后面的例子</span></span><br><span class="line"><span class="string">-n # 打印出匹配字符串所在行的行号,以及该行的内容，如果涉及多个文件，该选项也会随输出结果打印出文件名</span></span><br><span class="line"><span class="string">-i # 忽略模式中的大小写</span></span><br><span class="line"><span class="string">-l # 多文件处理时，可以列出匹配模式所在的文件</span></span><br><span class="line"><span class="string">-L # 与-l相反，它会返回一个不匹配的文件列表</span></span><br><span class="line"><span class="string">-q # 静默模式（主要用于脚本中，，在命令行中没什么用），只判断是否匹配成功,不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。0表示匹配成功，非0表示匹配失败。</span></span><br><span class="line"><span class="string">-r # 递归搜索当前目录和子目录</span></span><br><span class="line"><span class="string">-w # 匹配整个英文单词，对中文不管用</span></span><br><span class="line"><span class="string">-x # 匹配整行，比较两个文件不同行时使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-f # 从文件中读取匹配模式，一行一个模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 显示前后几行</span></span><br><span class="line"><span class="string">-A # after，显示匹配到的行以及之后的 n 行</span></span><br><span class="line"><span class="string">-B # before，显示匹配到的行以及之前的 n 行</span></span><br><span class="line"><span class="string">-C # Center，显示匹配到的行以及前后的 n </span></span><br><span class="line"><span class="string"># 如果匹配到多行，为了区分匹配到的字符串，用"</span>--<span class="string">"进行区分，比如：</span></span><br><span class="line"><span class="string">echo -e "</span>a\nb\nc\na\nb\nc<span class="string">" | grep a -A 1</span></span><br><span class="line"><span class="string"># a		匹配到第1次</span></span><br><span class="line"><span class="string"># b</span></span><br><span class="line"><span class="string"># --</span></span><br><span class="line"><span class="string"># a		匹配到第2次</span></span><br><span class="line"><span class="string"># c</span></span><br></pre></td></tr></table></figure>
<p>统计匹配项的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">正则表达式选择与解释:</span><br><span class="line">  -E, --extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)</span><br><span class="line">  -F, --fixed-strings       PATTERN 是一组由断行符分隔的定长字符串。</span><br><span class="line">  -G, --basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)</span><br><span class="line">  -P, --perl-regexp         PATTERN 是一个 Perl 正则表达式</span><br><span class="line">  -e, --regexp=PATTERN      用 PATTERN 来进行匹配操作</span><br><span class="line">  -f, --file=FILE           从 FILE 中取得 PATTERN</span><br><span class="line">  -i, --ignore-case         忽略大小写</span><br><span class="line">  -w, --word-regexp         强制 PATTERN 仅完全匹配字词</span><br><span class="line">  -x, --line-regexp         强制 PATTERN 仅完全匹配一行</span><br><span class="line">  -z, --null-data           一个 0 字节的数据行，但不是空行</span><br><span class="line"></span><br><span class="line">杂项:</span><br><span class="line">  -s, --no-messages         不显示错误信息</span><br><span class="line">  -v, --invert-match        选中不匹配的行</span><br><span class="line">  -V, --version             显示版本信息并退出</span><br><span class="line">      --help                显示此帮助并退出</span><br><span class="line">      --mmap                忽略向后兼容性</span><br><span class="line"></span><br><span class="line">输出控制:</span><br><span class="line">  -m, --max-count=NUM       NUM 次匹配后停止</span><br><span class="line">  -b, --byte-offset         输出行的同时打印字节偏移</span><br><span class="line">  -n, --line-number         输出行的同时打印行号</span><br><span class="line">      --line-buffered       每行输出清空</span><br><span class="line">  -H, --with-filename       为每一匹配项打印文件名</span><br><span class="line">  -h, --no-filename         输出时不显示文件名前缀</span><br><span class="line">      --label=LABEL         标准输入将LABEL 打印为文件名</span><br><span class="line">  -o, --only-matching       只显示一行中匹配PATTERN 的部分</span><br><span class="line">  -q, --quiet, --silent     不显示所有输出</span><br><span class="line">      --binary-files=TYPE   假定二进制文件的TYPE 类型；</span><br><span class="line">                            TYPE 可以是`binary&apos;, `text&apos;, 或`without-match&apos;</span><br><span class="line">  -a, --text                等同于 --binary-files=text</span><br><span class="line">  -I                        等同于 --binary-files=without-match</span><br><span class="line">  -d, --directories=ACTION  操作目录的方式；</span><br><span class="line">                            ACTION 可以是`read&apos;, `recurse&apos;,或`skip&apos;</span><br><span class="line">  -D, --devices=ACTION      操作设备、先入先出队列、套接字的方式；</span><br><span class="line">                            ACTION 可以是`read&apos;或`skip&apos;</span><br><span class="line">  -r, --recursive       等同于 --directories=recurse</span><br><span class="line">  -R --dereference-recursive  likewise, but follow all symlinks</span><br><span class="line">      --include=FILE_PATTERN  只查找匹配FILE_PATTERN 的文件</span><br><span class="line">      --exclude=FILE_PATTERN  跳过匹配FILE_PATTERN 的文件和目录</span><br><span class="line">      --exclude-from=FILE   跳过所有除FILE 以外的文件</span><br><span class="line">      --exclude-dir=PATTERN  跳过所有匹配PATTERN 的目录。</span><br><span class="line">  -L, --files-without-match  只打印不匹配FILEs 的文件名</span><br><span class="line">  -l, --files-with-matches  只打印匹配FILES 的文件名</span><br><span class="line">  -c, --count               只打印每个FILE 中的匹配行数目</span><br><span class="line">  -T, --initial-tab         行首tabs 分隔（如有必要）</span><br><span class="line">  -Z, --null                在FILE 文件最后打印空字符</span><br><span class="line"></span><br><span class="line">文件控制:</span><br><span class="line">  -B, --before-context=NUM  打印以文本起始的NUM 行</span><br><span class="line">  -A, --after-context=NUM   打印以文本结尾的NUM 行</span><br><span class="line">  -C, --context=NUM         打印输出文本NUM 行</span><br><span class="line">  -NUM                      等同于 --context=NUM</span><br><span class="line">      --color[=WHEN],</span><br><span class="line">      --colour[=WHEN]       使用标志高亮匹配字串；</span><br><span class="line">                            WHEN 可以是`always&apos;, `never&apos;或`auto&apos;</span><br><span class="line">  -U, --binary              不要清除行尾的CR 字符(MSDOS 模式)</span><br><span class="line">  -u, --unix-byte-offsets   当CR 字符不存在，报告字节偏移(MSDOS 模式)</span><br></pre></td></tr></table></figure>
<h4 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h4><p>egrep命令是grep的一个衍生，支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更 多的可以用来指定匹配模式的字符，增加了额外的正则表达式元字符集。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">"[a-z]+"</span> filename</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">egrep <span class="string">"[a-z]+"</span> filename</span><br></pre></td></tr></table></figure>
<h4 id="不使用正则表达式"><a href="#不使用正则表达式" class="headerlink" title="不使用正则表达式"></a>不使用正则表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -F &apos;str&apos;</span><br><span class="line">fgrep &apos;str&apos;</span><br></pre></td></tr></table></figure>
<p><code>fgrep</code> 查询速度比<code>grep</code>命令快，但是不够灵活：它<strong>只能找固定的文本，而不是正则表达式。</strong></p>
<p>如果你想在一个文件或者输出中找到包含星号字符的行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fgrep  <span class="string">'*'</span> /etc/profile</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">grep -F <span class="string">'*'</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>fgrep则是另外一个版本，支持将匹配模式 指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后 在fgrep命令中用其在一个大型文件中搜索字符串了。</p>
<h4 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h4><h5 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h5><p>命令会打印出匹配任意一种模式的行，每个匹配对应一行输出。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a line of text | grep -o -e <span class="string">"this"</span> -e <span class="string">"line"</span> this</span><br></pre></td></tr></table></figure>
<h5 id="从文件中读取匹配模式"><a href="#从文件中读取匹配模式" class="headerlink" title="从文件中读取匹配模式"></a>从文件中读取匹配模式</h5><p>可以将多个模式定义在文件中。选项<code>-f</code>可以读取文件并使用其中的模式（一个模式一行，记得最后留一行空白行，不然最后一种模式匹配不到，很诡异）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat pat_file</span><br><span class="line"><span class="comment"># ^h.*</span></span><br><span class="line"><span class="comment"># co+l</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> hello \n this is cool | grep -f pat_file </span><br><span class="line"><span class="comment"># hello </span></span><br><span class="line"><span class="comment"># this is cool</span></span><br></pre></td></tr></table></figure>
<h5 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h5><p>grep 本身并不支持，所以需要通过管道符号或者与 find 组合使用</p>
<h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><h5 id="检索文件内容"><a href="#检索文件内容" class="headerlink" title="检索文件内容"></a>检索文件内容</h5><p>递归搜索目录中的文件内容（不是文件名）<code>-</code>，<strong>注意</strong>：支持相对路径、绝对路径，但<strong>不支持<code>~/work/</code>这样的路径</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;查找内容&quot;  目录  -r -n  --include=*.&#123;py,sh&#125; --exclude=*.&#123;log,txt&#125;  --exclude-dir=&#123;log,tmp,config&#125; --exclude-from BLACK_LIST</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>--include</code> 指定搜索的文件类型或者某个文件，比如<code>*.sh</code>，<code>*.py</code>，可以使用GLOB写法，如<code>*.{py,sh}</code></p>
</li>
<li><p><code>--exclude</code> 指定不想搜索的文件类型或者某个文件，比如<code>*.txt</code>，<code>bigdata.txt</code> ,可以使用GLOB写法，如<code>*.{txt,log}</code></p>
</li>
<li><p><code>--exclude-dir</code>可以排除不想搜索的目录，多个目录时请用<code>{a,b,c}</code></p>
</li>
<li><p><code>--exclude-from BLACK_LIST</code>从黑名单文件中读取要排除文件列表</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"TODO"</span> ./ -r -n  --include=*.&#123;sh,py&#125;  --exclude-dir=&#123;tmp,logs&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./src/test.c:16:TODO 添加注释;</span></span><br></pre></td></tr></table></figure>
<p>等价于<code>find . -type f | xargs grep &quot;test_function()&quot;</code></p>
<h5 id="0值字节后缀的-xargs"><a href="#0值字节后缀的-xargs" class="headerlink" title="0值字节后缀的 xargs"></a>0值字节后缀的 xargs</h5><p>xargs命令可以为其他命令提供命令行参数列表。</p>
<p>当文件名作为命令行参数时，建议用0值字节作为文件名终结符，而非空格。因为一些文件名中会包含空格字符，一旦它被误解为终结符， 那么单个文件名就会被视为两个（例如，New file.txt被解析成New和file.txt两个文件名）。</p>
<p>这个问题可以利用0值字节后缀来避免。</p>
<p>grep和find命令可以生成带有0值字节后缀的输出，然后传递 给 xargs，让它产生文件名列表。为了指明输入中的文件名是以0值字节作为终结，需 要在xargs中使用选项-0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试文件：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; file1  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"cool"</span> &gt; file2 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出包含有 test 内容的文件名，并以0值字节作为终结符，然后传递给 xargs，让它生成文件名参数列表，之后传递（不用管道符号）给 rm 命令，删除这些文件</span></span><br><span class="line">grep <span class="string">"test"</span> file* -lZ | xargs -0 rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-l告诉grep只输出有匹配出现的文件名。选项-Z使得grep使用0值字节（\0）作为文 件名的终结符。这两个选项通常都是配合使用的。xargs的-0选项会使用0值字节作为输入的分隔符</span></span><br></pre></td></tr></table></figure>
<h5 id="比较两个文件相同内容与不同内容"><a href="#比较两个文件相同内容与不同内容" class="headerlink" title="比较两个文件相同内容与不同内容"></a>比较两个文件相同内容与不同内容</h5><p>输出file2中不含file1的内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -Ff  file1 file2   <span class="comment"># 输出公共的行</span></span><br><span class="line">grep -vFf  file1 file2   <span class="comment"># 输出不在 file1 的行</span></span><br><span class="line">grep -xvFf file1.txt file2.txt &gt; result.tx</span><br></pre></td></tr></table></figure>
<p> <code>-x, --line-regexp</code>    强制 PATTERN 仅完全匹配一行</p>
<h5 id="查找满足条件的文件是否匹配到文字"><a href="#查找满足条件的文件是否匹配到文字" class="headerlink" title="查找满足条件的文件是否匹配到文字"></a>查找满足条件的文件是否匹配到文字</h5><p>查找包含”hello world”的文件清单，并从这些清单中查找出满足”mailx”的匹配情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方法1：直接利用管道</span></span><br><span class="line">grep -i "hello world" -rl /home/tyrone | xargs grep -i "mailx"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出结果</span></span><br><span class="line">/home/tyrone/test1.txt:mailx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方法2：使用find，适合于需要灵活判断条件的场景。例如查找指定路径下，同时匹配多个模式的txt文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意：本例中“mailx”后面的命令必须加上反引号 ` ，否则会被当作要查询的文件名。</span></span><br><span class="line">grep -i "mailx" `find /home/tyrone -type f -name "*.txt" -exec grep -l "hello world"  &#123;&#125; \;`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出结果</span></span><br><span class="line">/home/tyrone/test1.txt:mailx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方法3:同2</span></span><br><span class="line">find /home/tyrone -name "*.txt" -exec grep -l "hello world" &#123;&#125; \; | xargs grep -i "mailx"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出结果</span></span><br><span class="line">/home/tyrone/test1.txt:mailx</span><br></pre></td></tr></table></figure>
<h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>tr是translate（转换）的简写，基本功能是将字符从一个字符集合映射到另一个集合中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr set1 set2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  注意： <code>tr</code>只能通过<code>stdin</code> 接收输入，无法通过命令行参数接收 ，如<code>tr -s &#39;&#39; file</code>，只能转为 <code>stdin</code> 形式，<code>tr -s &#39; &#39;&lt; file.txt</code></p>
</blockquote>
<p>如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1 相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;HELLO WHO IS THIS&quot; | tr &apos;A-Z&apos; &apos;a-z&apos;</span><br></pre></td></tr></table></figure>
<p>字符集合（字符组）可以使用“起始字符—终止字符”，如果不是有效的连续字符序列， 那么它就会被视为<code>起始字符</code>、<code>—</code>、<code>终止字符</code>这3个元素的集合。也可以使用像<code>\t</code>、<code>\n</code> 这种特殊字符或其他ASCII字符。可以按照需要追加字符或<strong>字符类</strong>来构造自己的字符组。</p>
<table>
<thead>
<tr>
<th>字符类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alnum</td>
<td>字母和数字</td>
</tr>
<tr>
<td>alpha</td>
<td>字母</td>
</tr>
<tr>
<td>cntrl</td>
<td>控制（非打印）字符</td>
</tr>
<tr>
<td>digit</td>
<td>数字</td>
</tr>
<tr>
<td>graph</td>
<td>图形字符</td>
</tr>
<tr>
<td>lower</td>
<td>小写字母</td>
</tr>
<tr>
<td>print</td>
<td>可打印字符</td>
</tr>
<tr>
<td>punct</td>
<td>标点符号</td>
</tr>
<tr>
<td>space</td>
<td>空白字符</td>
</tr>
<tr>
<td>upper</td>
<td>大写字母</td>
</tr>
<tr>
<td>xdigit</td>
<td>十六进制字符</td>
</tr>
</tbody>
</table>
<p>字符类的使用方法<code>tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code></p>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tr [options] set1  [set2]</span><br><span class="line">-d     # 删除(delete)set1 中的字符</span><br><span class="line">-c     # tr会将不在set1中的字符转换成set2中的字符,set2只能是一个字符</span><br><span class="line">-d -c  # 只保留set1的字符，不需要set2</span><br><span class="line">-s     # 删除重复字符，只留下一个</span><br></pre></td></tr></table></figure>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>tr命令可以用来加密。ROT13是一个著名的加密算法。在ROT13算法中，字符会被移动13 个位置，因此文本加密和解密都使用同一个函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"tr came, tr saw, tr conquered."</span> | tr <span class="string">'a-zA-Z'</span> <span class="string">'n-za-mN-ZA-M'</span></span><br></pre></td></tr></table></figure>
<p>将制表符转换成单个空格：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr <span class="string">'\t'</span> <span class="string">' '</span> &lt; file.txt</span><br></pre></td></tr></table></figure>
<p> 删除字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello 123 world 456&quot; | tr -d &apos;0-9&apos; </span><br><span class="line"># Hello world</span><br></pre></td></tr></table></figure>
<p>只保留set1 的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hello 1 char 2 next 4 | tr -d -c &apos;0-9 \n&apos;</span><br><span class="line"># 124</span><br></pre></td></tr></table></figure>
<p>压缩空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;GNU  is   not     UNIX.     Recursive       GNU is not UNIX. Recursive right ?&quot; | tr -s &apos; &apos;</span><br></pre></td></tr></table></figure>
<h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、 CSV文件或是由空格分隔的文件。</p>
<blockquote>
<p>  如果空格的长度不一致，需要使结合<code>tr</code>命令，进行字符串转换</p>
</blockquote>
<p>每列被称为一个<strong>字段</strong>，默认分隔符是制表符<code>\t</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-d&quot;\t&quot;    # 指定分割符为&quot;\t&quot;，默认就是制表符，因此可以不写</span><br><span class="line">-f2,3     # 显示2,3列的内容,f2可以不用空格分开</span><br><span class="line">-f2-4     # 显示第2到4列(field)的内容，2-5 的用法看后面表格说明</span><br><span class="line">-c2-5     # 显示第2到5个字符(character)，注意不能与-d 组合</span><br><span class="line">-b2-5     # 显示第2到5个字节(byte)，注意不能与-d 组合</span><br><span class="line">--complement # 与-f 组合使用，显示f没有指定的列，就是取反</span><br><span class="line">--output-delimiter    指定输出时的列分隔符</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cut range_fields.txt -c1-3,6-9 --output-delimiter <span class="string">","</span> </span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选取方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>N-</td>
<td>从第N个字节、字符或字段开始到行尾</td>
</tr>
<tr>
<td>N-M</td>
<td>从第N个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</td>
</tr>
<tr>
<td>-M</td>
<td>从第1个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut -c -2 range_fields.txt    <span class="comment"># 打印前2个字符</span></span><br><span class="line">cut -c2-5 range_fields.txt    <span class="comment"># 打印第2个到第5个字符</span></span><br></pre></td></tr></table></figure>
<h3 id="文件分割-split"><a href="#文件分割-split" class="headerlink" title="文件分割 split"></a>文件分割 split</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split  [options] filename prefix.</span><br></pre></td></tr></table></figure>
<p>将文件分割成固定大小（bytes）或者固定行数的小文件，原文件不动，小文件为<code>prefix.aa prefix.ab</code>等形式，前缀后面最好要有<code>.</code>，如<code>file.</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d    使用数字后缀，file.01 file.02，默认为字符后缀</span><br><span class="line">-l    指定每个输出文件多少行内容，最后一个文件可能会小于n</span><br><span class="line">-b, --bytes=SIZE  指定每个输出文件的大小，如-b100K,大小可以是 KB、MB，GB</span><br><span class="line">-C，--line-bytes=SIZE  TODO</span><br><span class="line">-a    指定后缀长度，默认是2，不指定时程序会自适应</span><br><span class="line">--verbose  显示创建文件的信息</span><br></pre></td></tr></table></figure>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed是stream editor（流编辑器）的缩写。它最常见的用法是进行文本替换。<strong>默认不修改原文件，只显示修改后的结果。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br><span class="line"></span><br><span class="line">-e &apos;script1;script2&apos;</span><br><span class="line">-f script_file # 从文本中读取大量指令，一行一个，以换行结束</span><br><span class="line">-i # 保存到原文件</span><br><span class="line">-n或--quiet或--silent # 仅显示script处理后的结果。</span><br></pre></td></tr></table></figure>
<p>要是我们想就地（in place）修改文件内容，可以使用选项<code>-i</code>保存到原文件中。值得<strong>推荐的做法</strong>是</p>
<ul>
<li><p>先使用不带<code>-i</code>选项的<code>sed</code>命令，以确保正则表达式没有问题，如果结果符合要求，再加入-i选项将更改写入文件。</p>
</li>
<li><p>也可以使用<code>sed -i.bak &#39;s/abc/def/&#39; file</code>，这时的sed不仅替换文件内容，还会创建一个名为<code>file.bak</code>的文件，其中包含着原始文件内容的副本。</p>
</li>
</ul>
<h4 id="替换s"><a href="#替换s" class="headerlink" title="替换s"></a>替换<code>s</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s/old/new/          # 替换每行第1个匹配到的字符串</span><br><span class="line">s/old/new/2         # 替换每行第2个匹配到的字符串</span><br><span class="line">s/old/new/g         # 替换全部</span><br><span class="line">s/old/new/2g        # 只替换第2次及之后匹配到的字符串</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/2g'</span> </span><br><span class="line"><span class="comment"># thisTHISTHISTHIS</span></span><br></pre></td></tr></table></figure>
<h5 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s/pattern/replacement/flags</span><br></pre></td></tr></table></figure>
<p>有4种可用的替换标记： </p>
<ul>
<li>数字，表明新文本只替换每行第几处模式匹配的地方； </li>
<li>g，表明新文本将会替换所有匹配的文本； </li>
<li>p，表明原先行的内容要打印出来；</li>
<li>w file，将匹配到的行替换的结果写到指定的file中。</li>
</ul>
<p>p替换标记会打印与替换命令中指定的模式匹配的行替换后的结果。这通常会和sed的-n选项一起使用。-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是 只输出被替换命令修改过的行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat data5.txt </span><br><span class="line">This is a <span class="built_in">test</span> line.</span><br><span class="line">This is a different line.</span><br><span class="line"></span><br><span class="line">$ sed -n <span class="string">'s/test/trial/p'</span> data5.txt </span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure>
<p>w替换标记会产生与 p 模式同样的输出，不过会将输出保存到指定文件中。</p>
<h5 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h5><p><code>sed</code>命令会将<code>s</code>之后的字符视为命令分隔符。这允许我们更改默认的分隔符<code>/</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s:text:replace:g&apos; </span><br><span class="line">sed &apos;s|text|replace|g&apos;</span><br></pre></td></tr></table></figure>
<p>如果作为分隔符的字符出现在模式中，必须使用<code>\</code>对其进行转义</p>
<h5 id="指定行"><a href="#指定行" class="headerlink" title="指定行"></a>指定行</h5><p>方式1（数字）：</p>
<p>在<code>s</code>前添加行编辑即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2s/dog/cat/'</span> data1.txt   <span class="comment"># 只修改地址指定的第2行的文本</span></span><br><span class="line">sed <span class="string">'2,3s/dog/cat/'</span> data1.txt <span class="comment"># 只修改地址指定的第2，3行的文本</span></span><br><span class="line">sed <span class="string">'2,$s/dog/cat/'</span> data1.txt <span class="comment"># 修改从某行开始的所有行</span></span><br></pre></td></tr></table></figure>
<p>方式2（正则）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/pattern/s/bash/csh/'</span> /etc/passwd  <span class="comment"># 使用 pattern 正则表达式过滤</span></span><br></pre></td></tr></table></figure>
<p><strong>已匹配字符串标记（<code>&amp;</code>）</strong></p>
<p>在sed中，我们可以用&amp;指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹 配的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo this is an example | sed &apos;s/\w+/[&amp;]/g&apos;</span><br><span class="line"># [this] [is] [an] [example]</span><br></pre></td></tr></table></figure>
<p><strong>子串匹配标记（\num）</strong></p>
<p> 匹配正则中的子表达式，第1 个是<code>\1</code>，第 2 个是<code>\2</code>，以此类推</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo this is digit 7 in a number | sed &apos;s/digit \([0-9]\)/\1/&apos; </span><br><span class="line"># this is 7 in a number</span><br></pre></td></tr></table></figure>
<p><strong>多表达式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'expression; expression'</span></span><br><span class="line">sed <span class="string">'expression'</span> | sed <span class="string">'expression'</span></span><br><span class="line">sed -e <span class="string">'expression'</span> -e <span class="string">'expression'</span></span><br><span class="line">sed -e <span class="string">'expression; expression'</span></span><br><span class="line">sed -e <span class="string">'</span></span><br><span class="line"><span class="string">&gt; s/brown/green/</span></span><br><span class="line"><span class="string">&gt; s/fox/elephant/</span></span><br><span class="line"><span class="string">&gt; s/dog/cat/'</span> data1.txt</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo abc | sed &apos;s/a/A/;s/c/C/&apos;</span><br><span class="line">echo abc | sed &apos;s/a/A/&apos; | sed &apos;s/c/C/&apos;</span><br><span class="line">echo abc | sed -e &apos;s/a/A/&apos; -e &apos;s/c/C/&apos;</span><br><span class="line">echo abc | sed -e &apos;s/a/A/; s/c/C/&apos;</span><br><span class="line"># AbC</span><br></pre></td></tr></table></figure>
<p><strong>单引号与双引号的区别</strong></p>
<p>sed表达式<strong>通常用单引号来引用</strong>。如果想在sed表达式中使用变量，双引号就能派上用场了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text=hello </span><br><span class="line">echo hello world | sed &quot;s/$text/HELLO/&quot; </span><br><span class="line"># HELLO world</span><br></pre></td></tr></table></figure>
<h4 id="多命令"><a href="#多命令" class="headerlink" title="多命令"></a>多命令</h4><p>如果需要在匹配到的行上执行多条命令，可以用<code>{}</code>将多条命令组合在一起，同时指定过滤的行号，或者匹配模式。</p>
<p>多条命令之间用<code>;</code>分割，或者分成多行书写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行内多个命令</span></span><br><span class="line">sed -n <span class="string">'/root/&#123;s/bash/blueshell/;p;q&#125;'</span> /etc/passwd </span><br><span class="line"></span><br><span class="line"><span class="comment"># 分成多行执行多个命令</span></span><br><span class="line">sed <span class="string">'3,$&#123;</span></span><br><span class="line"><span class="string">&gt; s/brown/green/</span></span><br><span class="line"><span class="string">&gt; s/lazy/active/</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data1.txt</span><br></pre></td></tr></table></figure>
<h4 id="插入a与i"><a href="#插入a与i" class="headerlink" title="插入a与i"></a>插入<code>a</code>与<code>i</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'[address]command\</span></span><br><span class="line"><span class="string">new line'</span></span><br></pre></td></tr></table></figure>
<p>插入（insert）命令（i）会在指定行前插入文本，（插入的文本要带有换行，否则就直接插入在指定行的头部）</p>
<p>附加（append）命令（a）会在指定行后添加文本，（如果文本没换行，会与下一行在同一行）</p>
<p>可以指定一个行地址，匹配一个数字行号或文本模式</p>
<blockquote>
<p>  这两条命令的费解之处在于它们的格式。它们不能在一行内使用。你必须先输入<code>i</code>或者<code>a</code>，然后使用<code>\</code>进行换行，接着输入要插入或者附加的内容。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本中的写法</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'1i\   # 在第一行前插入</span></span><br><span class="line"><span class="string">Test Line 1\     # 换行，否则两行文本会在一同一行</span></span><br><span class="line"><span class="string">'</span> </span><br><span class="line">Test Line 1 </span><br><span class="line">Test Line 2</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'/Line/a\   # 在包含Line的一行添加</span></span><br><span class="line"><span class="string">Test Line 1\</span></span><br><span class="line"><span class="string">'</span> </span><br><span class="line"></span><br><span class="line">Test Line 2 </span><br><span class="line">Test Line 1</span><br></pre></td></tr></table></figure>
<h5 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h5><p>插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后 一行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1i\</span></span><br><span class="line"><span class="string">&gt; This is one line of new text.\</span></span><br><span class="line"><span class="string">&gt; This is another line of new text.'</span> data6.txt </span><br><span class="line"></span><br><span class="line">This is one line of new text.</span><br><span class="line">This is another line of new text.</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>
<h4 id="删除行-d"><a href="#删除行-d" class="headerlink" title="删除行 d"></a>删除行 <code>d</code></h4><p>删除命令<code>d</code>名副其实，它会删除匹配指定寻址模式的所有行。</p>
<p>支持指定行<code>sed &#39;2,3d&#39; data6.txt</code></p>
<p>通过特定行区间指定：<code>sed &#39;2,3d&#39; data6.txt</code></p>
<p>模式匹配特性也适用于删除命令<code>sed &#39;/number 1/d&#39; data6.txt</code></p>
<p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。</p>
<ul>
<li>sed编辑器会删除两个指定行之间 的所有行（包括指定的行）。<strong>如果没有找到停止模式，所以就将数据流中的剩余行全部删除了。</strong></li>
<li>你指定的第1个模式 会“打开”行删除功能，第2个模式会“关闭”行删除功能。之后<strong>再遇到第1个模式会再打开删除功能</strong>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat data7.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is line number 1 again.   <span class="comment"># 再次触发删除功能</span></span><br><span class="line">This is text you want to keep. </span><br><span class="line">This is the last line <span class="keyword">in</span> the file. </span><br><span class="line"></span><br><span class="line">$ sed <span class="string">'/1/,/3/d'</span> data7.txt </span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>
<h4 id="字符转换y"><a href="#字符转换y" class="headerlink" title="字符转换y"></a>字符转换<code>y</code></h4><p>转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]y/inchars/outchars/</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'y/123/789/'</span> data8.txt </span><br><span class="line">This is line number 7.</span><br><span class="line">This is line number 8.</span><br><span class="line">This is line number 9.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is line number 7 again.</span><br><span class="line">This is yet another line.</span><br><span class="line">This is the last line <span class="keyword">in</span> the file.</span><br></pre></td></tr></table></figure>
<p>转换命令会对inchars和outchars值进行一对一的映射。</p>
<p>如果inchars和outchars的长度不同，则sed编辑器会产生一 条错误消息。</p>
<p>转换命令是一个全局命令，你无法限定只转换在特定地方出现的字符。</p>
<h4 id="打印命令"><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h4><ol>
<li>p命令用来打印文本行； </li>
<li>等号（=）命令用来打印行号； </li>
<li>l（小写的L）命令用来列出行。</li>
</ol>
<h5 id="p-命令"><a href="#p-命令" class="headerlink" title="p 命令"></a>p 命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is a test"</span> | sed <span class="string">'p'</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>它所做的就是打印已有的数据文本</p>
<p>最常见的用法是与<code>-n</code>配合打印包含匹配文本模式的行。用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line"></span><br><span class="line">$ $ sed -n &apos;/number 3/p&apos; data6.txt </span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure>
<p>修改前后对比</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'/3/&#123;</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; s/line/test/p</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data6.txt </span><br><span class="line">This is line number 3. </span><br><span class="line">This is <span class="built_in">test</span> number 3. $</span><br></pre></td></tr></table></figure>
<h5 id="等号"><a href="#等号" class="headerlink" title="=等号"></a><code>=</code>等号</h5><p>等号命令会打印行在<strong>数据流中的当前行号</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;=&apos; data1.txt </span><br><span class="line">1 </span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">2 </span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'/number 4/&#123;</span></span><br><span class="line"><span class="string">&gt; =</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data6.txt 4 </span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>
<h5 id="显示特殊字符l"><a href="#显示特殊字符l" class="headerlink" title="显示特殊字符l"></a>显示特殊字符<code>l</code></h5><p>命令（<code>l</code>）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印 字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\t，来代表制表符。</p>
<p>制表符的位置使用\t来显示。行尾的美元符表示换行符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat data10.txt </span><br><span class="line">This line contains an escape	character.</span><br><span class="line"></span><br><span class="line">$ sed -n <span class="string">'l'</span> data10.txt </span><br><span class="line">This line contains an escape\tcharacter. \a</span><br></pre></td></tr></table></figure>
<h4 id="保存命令w"><a href="#保存命令w" class="headerlink" title="保存命令w"></a>保存命令<code>w</code></h4><p>w命令用来向文件写入行。该命令的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]w filename</span><br></pre></td></tr></table></figure>
<p><code>filename</code>可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文 件的写权限。</p>
<p>地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat data11.txt </span><br><span class="line">Blum, R Browncoat </span><br><span class="line">McGuiness, A Alliance</span><br><span class="line">Bresnahan, C Browncoat </span><br><span class="line">Harken, C Alliance </span><br><span class="line"> </span><br><span class="line">$ sed -n <span class="string">'/Browncoat/w Browncoats.txt'</span> data11.txt </span><br><span class="line"></span><br><span class="line">$ cat Browncoats.txt </span><br><span class="line">Blum, R Browncoat </span><br><span class="line">Bresnahan, C Browncoat</span><br></pre></td></tr></table></figure>
<h4 id="读取命令"><a href="#读取命令" class="headerlink" title="读取命令"></a>读取命令</h4><p>读取（read）命令（r）允许你将另一个文件中的数据插入到数据流中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]r filename</span><br></pre></td></tr></table></figure>
<p>地址区间<strong>只能指定单独一个行号或文本模式地址</strong>。sed编辑器会将文件中的<strong>所有文本行</strong>插入到指定地址后。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat data12.txt </span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line. </span><br><span class="line"></span><br><span class="line">$ sed <span class="string">'3r data12.txt'</span> data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line. </span><br><span class="line">This is line number 4.</span><br><span class="line"></span><br><span class="line">$ sed <span class="string">'/number 2/r data12.txt'</span> data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure>
<p>另一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat notice.std </span><br><span class="line">Would the following people:</span><br><span class="line">LIST </span><br><span class="line">please report to the ship<span class="string">'s captain. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ sed '</span>/LIST/&#123;</span><br><span class="line">&gt; r data11.txt</span><br><span class="line">&gt; d</span><br><span class="line">&gt; &#125;<span class="string">' notice.std </span></span><br><span class="line"><span class="string">Would the following people:</span></span><br><span class="line"><span class="string">Blum, R Browncoat </span></span><br><span class="line"><span class="string">McGuiness, A Alliance </span></span><br><span class="line"><span class="string">Bresnahan, C Browncoat </span></span><br><span class="line"><span class="string">Harken, C Alliance </span></span><br><span class="line"><span class="string">please report to the ship'</span>s captain. $</span><br><span class="line"></span><br><span class="line">现在占位文本已经被替换成了数据文件中的名单。</span><br></pre></td></tr></table></figure>
<h3 id="Join-字段合并"><a href="#Join-字段合并" class="headerlink" title="Join 字段合并"></a>Join 字段合并</h3><p>根据指定的字段 拼接两个文件。前提是2个文件中指定的拼接字段是排序过的。</p>
<p>拼接字典默认是第一列，可以通过以下方式修改：</p>
<ul>
<li><p><code>-12</code>表示第一个文件使用第2个字段进行拼接。</p>
</li>
<li><p><code>-22</code>表示第二个文件使用第2个字段进行拼接。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat a</span><br><span class="line">aaa 111</span><br><span class="line">bbb 222</span><br><span class="line"></span><br><span class="line">cat b</span><br><span class="line">555 aaa</span><br><span class="line">666 bbb</span><br><span class="line">777 ccc</span><br><span class="line"></span><br><span class="line">join -1  -2  a b</span><br></pre></td></tr></table></figure>
<h3 id="文本编码转换-iconv"><a href="#文本编码转换-iconv" class="headerlink" title="文本编码转换 iconv"></a>文本编码转换 iconv</h3><p>对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv 命令（这个命令支持更高级的Unicode编码）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f ISO-8859-1 -t UTF-8  file</span><br></pre></td></tr></table></figure>
<h3 id="临时文件-mktemp"><a href="#临时文件-mktemp" class="headerlink" title="临时文件 mktemp"></a>临时文件 mktemp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp [-qu][文件名参数]</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong>：</p>
<ul>
<li><code>-d</code>     创建临时目录</li>
<li><code>-q</code> 　执行时若发生错误，不会显示任何信息。</li>
<li><code>-u</code> 　暂存文件会在mktemp结束前先行删除，不推荐使用</li>
<li>[文件名参数] 　文件名参数必须是以”自订名称.XXXXXX”的格式，XXX 会被替换为随机字符串。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mktemp jizx.XXX</span><br><span class="line"><span class="meta">#</span><span class="bash"> jizx.ztI</span></span><br></pre></td></tr></table></figure>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>默认情况下，mount命令会输出当前系统上挂载的 设备列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -t type device directory      # 格式说明</span><br><span class="line">mount -t vfat /dev/sdb1 /media/disk</span><br></pre></td></tr></table></figure>
<p><code>umount [directory | device ]</code>，<code>umount</code>命令支持通过设备文件或者挂载点来指定要卸载的设备。</p>
<p>在卸载设备时，系统<strong>提示设备繁忙，无法卸载设</strong>备，可用<code>lsof</code>命令获得使用它的进程信息，在应用中停止使用该设备或停止该进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof /path/to/device/node</span><br><span class="line">lsof /path/to/mount/point</span><br></pre></td></tr></table></figure>
<h3 id="df与-du-TODO"><a href="#df与-du-TODO" class="headerlink" title="df与 du TODO"></a>df与 du TODO</h3><p>df命令很容易发现哪个磁盘的存储空间快没了</p>
<p>du TODO</p>
<p>du命令可以显示某个特定目录（默认情况下是当前目录）的 磁盘使用情况。</p>
<h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><p>压缩命令 linux 命令行与 shell 脚本编程大全 4.33 </p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p><code>file</code> 查看文件类型</p>
<h3 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h3><p>以指定增量从首数开始打印数字到尾数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seq [选项]... 尾数</span><br><span class="line">seq [选项]... 首数 尾数</span><br><span class="line">seq [选项]... 首数 增量 尾数</span><br><span class="line">-f, --format=格式 使用 <span class="built_in">printf</span> 样式的浮点格式</span><br><span class="line">-s, --separator=字符串使用指定字符串分隔数字(默认使用：\n)</span><br><span class="line">-w, --equal-width 在列前添加0，使得宽度相同</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ seq 5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">$ seq 5 8</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">$ seq 5 2 10</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ seq 5 -1 1      <span class="comment"># -1 逆序时-1必须存在</span></span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="xarg"><a href="#xarg" class="headerlink" title="xarg"></a>xarg</h3><p>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p>
<p>它能够捕获一个命令的输出，然后传递给另外一个命令。</p>
<p>args 一般是和管道一起使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">somecommand |xargs  -item  command</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-d delim  # 指定分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</span><br><span class="line">-i 或者-I  # 配合占位符使用，将参数替换到命令的占位符上，对每一个参数，命令都会被执行一次。</span><br><span class="line">					# 个人理解：因为 xargs 默认将参数放在其他命令的最后，但是像 cp 这种需要在中间的位置时，就可以用-I选项，具体看后面的例子。</span><br><span class="line">-t # 打印 xargs 后面那个命令拼上参数后的完整形式，然后再执行，用于debug</span><br><span class="line">-s # num 指定 xargs 后面那个命令的最大命令行字符数。</span><br><span class="line">-0 # 将 \0 作为定界符。</span><br><span class="line">-p # 当每次执行一个argument的时候询问一次用户。</span><br><span class="line">-L num  # 从标准输入一次读取 num 行送给 command 命令。</span><br><span class="line">-n num  # 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</span><br></pre></td></tr></table></figure>
<p>参数的功能分类：</p>
<ul>
<li><p>如何分割（xargs、xargs -d、xargs -0）</p>
</li>
<li><p>分割后如何划批（xargs -n、xargs -L）</p>
</li>
<li>参数如何传递（xargs -i）。</li>
<li>另外xargs还提供询问交互式处理（-p选项）和预先打印一遍命令的执行情况（-t选项），传递终止符（-E选项）</li>
</ul>
<h4 id="实验文件准备"><a href="#实验文件准备" class="headerlink" title="实验文件准备"></a>实验文件准备</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line"><span class="built_in">cd</span> tmp</span><br><span class="line">rm -fr *</span><br><span class="line">mkdir a b c d <span class="built_in">test</span> logdir shdir</span><br><span class="line">touch <span class="string">"one space.log"</span></span><br><span class="line">touch logdir/&#123;1..10&#125;.<span class="built_in">log</span></span><br><span class="line">touch shdir/&#123;1..5&#125;.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the second sh the second line"</span> &gt; shdir/2.sh </span><br><span class="line">cat &lt;&lt;eof&gt;shdir/1.sh  </span><br><span class="line">&gt; the first sh</span><br><span class="line">&gt; the second line</span><br><span class="line">&gt; eof</span><br></pre></td></tr></table></figure>
<h4 id="流程讲解"><a href="#流程讲解" class="headerlink" title="流程讲解"></a>流程讲解</h4><p><strong>先分割，再分批，然后传递到参数位</strong></p>
<h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>管道传递过来的<code>stdin</code>经过<code>xargs</code>处理后的：<strong>将所有空格(多个空格)、制表符和分行符都替换为(一个)空格并压缩到一行上显示，这一整行将作为一个整体，这个整体的所有空格属性继承xargs处理前的符号属性</strong>.</p>
<blockquote>
<p>  如果想要保存制表符、空格等特殊符号，需要将它们用单引号或双引号包围起来，<strong>但是被xargs处理后，一行的整体中单双引号（和反斜线）都会被去掉。</strong></p>
</blockquote>
<h5 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h5><p><strong>文本意义上的符号和标记意义上的符号</strong></p>
<p>在解释xargs和它的各种选项之前，先介绍一个贯穿xargs命令的符号分类：文本意义上的空格、制表符、反斜线、引号和非文本意义上的符号。我觉得<strong>理解它们是理解xargs分割和分批原理的关键。</strong></p>
<ul>
<li><p><strong>文本意义</strong>上的空格、制表符、反斜线、引号：未经处理就已经存在的符号，例如文本的内容中出现这些符号以及在文件名上出现了这些符号都是文本意义上的。</p>
</li>
<li><p>与之相对的是<strong>非文本意义</strong>的符号，由于在网上没找到类似的文章和解释，所以我个人称之为标记意义上的符号：处理后出现的符号，例如<code>ls</code>命令的结果中每个文件之间的制表符，它原本是不存在的，只是<code>ls</code>命令处理后的显示方式。还包括<strong>每个命令结果的最后的换行符，文件内容的最后一行结尾的换行符</strong>。</p>
</li>
</ul>
<p>两种分批可能：</p>
<ul>
<li>指定<code>-n</code>时按空格分段，然后划批，不管是文本意义的空格还是标记意义的空格，只要是空格都是<code>-n</code>的操作对象</li>
<li>指定<code>-L</code>或者<code>-i</code>时按段划批，文本意义的符号不被处理，比如<code>one space.txt</code>这个文件不会被分割。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls | xargs -n 2</span><br><span class="line">ls | xargs -L 2</span><br><span class="line">ls | xargs -i -p echo &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果在一个xargs中使用了多个分批选项，则它们之间必然会冲突，它们的规则是<strong>写在后面的生效，前面的分批选项被忽略</strong>。</p>
<p><strong>-d 整体执行的过程</strong>：</p>
<ol>
<li><p>替换：将所有标记符号替换为<code>\n</code>，完成后所有符号(空格、制表符、换行符)都是文本符号</p>
</li>
<li><p>分段：根据分隔符进行分段、并用空格分开每段。由于分段前所有符号都是文本符号，因此分段后的文本中可能包含空格、制表符、换行符。也就是说除了-d 导致的分段空格，其余的所有符号都是分段中的一部分</p>
</li>
<li>输出：最后根据<code>-n</code>、<code>-L</code>、<code>-i</code>指定的分批选项来输出。</li>
</ol>
<p><strong><code>-0</code>等价于<code>-d&quot;\0&quot;</code></strong>，<strong>-0可以处理接收的stdin中的null字符（\0）。如果不使用 -0选项或- -null选项，检测到\0后会给出警告提醒，并只向命令传递非\0段。</strong></p>
<h5 id="分批行为"><a href="#分批行为" class="headerlink" title="分批行为"></a>分批行为</h5><p>分批用于指定每次传递多少个分段。有三种分批选项：-n，-L和-i。</p>
<p>-n 默认以空格分段划分，与-d、-0一起时，按指定的分隔符分段划分</p>
<p>-L 永远是按段划分的</p>
<p>-i  如果不使用-i，则默认是将分割后处理后的结果整体传递到命令的最尾部。但是有时候需要传递到多个位置，不使用-i就不知道传递到哪个位置了。例如重命名备份的时候在每个传递过来的文件名加上后缀.bak，这需要两个参数位。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls logdir/ | xargs -i mv ./logdir/&#123;&#125; ./logdir/&#123;&#125;.bak   # 将分段传递到多个参数位</span><br></pre></td></tr></table></figure>
<h5 id="分批的典型应用"><a href="#分批的典型应用" class="headerlink" title="分批的典型应用"></a>分批的典型应用</h5><p>分批选项有时特别有用，例如脚本规定每次只能传输三个参数。有时候rm -rf的文件数量特别多的时候会提示参数列表太长而导致失败，这时就可以分批来按批删除。</p>
<p>假设目前在/tmp/longshuai/下有29W个.log文件，如果直接删除将会提示参数列表过长。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | xargs -n 10000  rm -rf</span><br></pre></td></tr></table></figure>
<h5 id="终止行为之-：xargs-E"><a href="#终止行为之-：xargs-E" class="headerlink" title="终止行为之 ：xargs -E"></a>终止行为之 ：xargs -E</h5><ul>
<li><code>-E</code>会将结果空格、制表符、分行符替换为空格并压缩到一行上显示。据我测试，-E似乎只能和独立的xargs使用，和-0、-d配合使用时都会失效。</li>
<li><code>-E</code>优先于<code>-n</code>、<code>-L</code>和<code>-i</code>执行。如果是分批选项先执行，则下面的第二个结果将压缩在一行上。</li>
<li>指定的终止符必须是完整的，例如想在遇到“xyz.txt”的符号终止时，只能指定完整的xyz.txt符号，不能指定.txt或者txt这样的符号。<ul>
<li>分两种情况：如果没指定分批选项或者指定的分批选项是-n或者-L时，则段是以空格为分割符，两个空格之间的段都是完整的。</li>
<li>如果指定的分批选项是-i，则以段为分割符。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">a  b  c  d  logdir   one space.log  shdir  sh.txt  <span class="built_in">test</span>  vmware-root  x.txt</span><br><span class="line"></span><br><span class="line">ls | xargs -E one     <span class="comment">#不指定分批选项</span></span><br><span class="line">a b c d logdir</span><br><span class="line"></span><br><span class="line">ls | xargs -n 2 -E one      <span class="comment">#指定-n，one后面的所有的都终止传递</span></span><br><span class="line">a b</span><br><span class="line">c d</span><br><span class="line">logdir</span><br><span class="line"></span><br><span class="line">ls | xargs -L 2 -E<span class="string">"one"</span>      <span class="comment">#同-n 选项</span></span><br><span class="line">a b</span><br><span class="line">c d</span><br><span class="line">logdir</span><br><span class="line"></span><br><span class="line">ls | xargs -i -E<span class="string">"one space.log"</span> <span class="built_in">echo</span> &#123;&#125;   <span class="comment">#和-i配合使用时指定完整的段才可以</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">logdir</span><br><span class="line"></span><br><span class="line">ls | xargs -i -E<span class="string">"one"</span>  -p <span class="built_in">echo</span> &#123;&#125;         <span class="comment">#非完整段终止失效</span></span><br><span class="line"><span class="built_in">echo</span> a ?...</span><br><span class="line"><span class="built_in">echo</span> b ?...</span><br><span class="line"><span class="built_in">echo</span> c ?...</span><br><span class="line"><span class="built_in">echo</span> d ?...</span><br><span class="line"><span class="built_in">echo</span> logdir ?...</span><br><span class="line"><span class="built_in">echo</span> one space.log ?...</span><br><span class="line"><span class="built_in">echo</span> shdir ?...</span><br><span class="line"><span class="built_in">echo</span> sh.txt ?...</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">test</span> ?...</span><br><span class="line"><span class="built_in">echo</span> vmware-root ?...</span><br><span class="line"><span class="built_in">echo</span> x.txt ?...</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>分割行为</th>
<th>标记符号处理方式</th>
<th>分段方法</th>
<th>分批方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>xargs</td>
<td>空格、制表符、分行符替换为空格，引号和反斜线删除。处理完后只有空格。如果空格、制表符和分行符使用引号包围则可以保留</td>
<td>结果继承处理前的符号性质（文本符号还是标记符号）</td>
<td><code>-n</code>以分段结果中的每个空格分段，进而分批。不管是文本还是标记意义的空格.<br><code>-L -i</code>以标记意义上的空格分段，进而分批</td>
</tr>
<tr>
<td>xargs -d</td>
<td>不处理文本符号，所有标记符号替换为换行符<code>\n</code>，将<code>-d</code>指定的分割符替换为标记意义的空格。结果中除了最后的空行和<code>-d</code>指定的分割符位的分段空格，<strong>其余全是文本意义上的符号</strong></td>
<td>按照-d指定的符号进行分段，每个段中可包含文本意义上的空格、制表符、换行符。</td>
<td>以标记意义上的符号（即最后的空行和-d指定分隔符位的空格）分段，进而分批。分段结果中保留所有段中的符号，包括制表符和分行符。</td>
</tr>
<tr>
<td>xargs -0</td>
<td>不处理文本意义上的符号，将非<code>\0</code>的标记意义上的符号替换为<code>\n</code>，将<code>\0</code>替换为空格。</td>
<td>以替换<code>\0</code>位的空格分段，每个段中可能包含文本意义上的空格、制表符、换行符。</td>
<td>检测到<code>\0</code>时，以标记意义上的符号（即最后的空行和<code>\0</code>位的空格）分段，进而分批。分段结果中保留所有段中的符号，包括制表符和分行符。未检测到<code>\0</code>时，整个结果作为不可分割整体，使用分批选项是无意义的</td>
</tr>
</tbody>
</table>
<h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>只要能分批的选项，都可以使用”-P”，包括”-n”、”-L”和”-i”。</p>
<p>使用xargs的分批行为，除了可以解决一些问题，还可以一次性将多个分批交给不同进程去处理，这些进程可以使用多个cpu执行，效率可谓大幅提高。</p>
<p>“-P N”选项可以指定并行处理的进程数量为N。不指定”-P”时，默认为1个处理进程，也就是串行执行。指定为0时，将尽可能多地开启进程数量。</p>
<h4 id="xargs与文件名"><a href="#xargs与文件名" class="headerlink" title="xargs与文件名"></a>xargs与文件名</h4><p>由于<code>xargs</code>默认将空格作为分隔符，所以不太适合处理文件名，因为文件名可能包含空格。</p>
<p><code>find</code>命令有一个特别的参数<code>-print0</code>，指定输出的文件列表以<code>null</code>分隔。然后，<code>xargs</code>命令的<code>-0</code>参数表示用<code>null</code>当作分隔符。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ find /path -<span class="built_in">type</span> f -print0 | xargs -0 rm</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="xargs与复杂命令"><a href="#xargs与复杂命令" class="headerlink" title="xargs与复杂命令"></a>xargs与复杂命令</h4><p>如果<code>xargs</code>要将命令行参数传给多个命令，可以使用<code>-I</code>参数，并配合<code>sh -c</code> 执行命令</p>
<p><code>-I</code>指定每一项命令行参数的替代字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat foo.txt</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"></span><br><span class="line">$ cat foo.txt | xargs -I file sh -c <span class="string">'echo file; mkdir file'</span></span><br><span class="line">one </span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"></span><br><span class="line">$ ls </span><br><span class="line">one two three</span><br></pre></td></tr></table></figure>
<p>我们希望对每一项命令行参数，执行两个命令（<code>echo</code>和<code>mkdir</code>），使用<code>-I file</code>表示<code>file</code>是命令行参数的替代字符串。执行命令时，具体的参数会替代掉<code>echo file; mkdir file</code>里面的两个<code>file</code>。</p>
<h4 id="xargs与重定向"><a href="#xargs与重定向" class="headerlink" title="xargs与重定向"></a>xargs与重定向</h4><p>如果脚本中包含重定向的命令，那么整个命令必须用双引号扩起来，如果双引号里面有<code>$</code>需要用<code>\</code>来转义，就比如下面的<code>$5</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq 5 10 |xargs -i sh -c <span class="string">"awk -F\$'\t' '\$5==&#123;&#125;' file &gt; file_part_&#123;&#125;"</span></span><br></pre></td></tr></table></figure>
<p>不过awk本身支持将不同的内容保存到不同的文件中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'NR!=1&#123;print $4,$5 &gt; $6&#125;'</span> netstat.txt</span><br></pre></td></tr></table></figure>
<h4 id="xargs的限制"><a href="#xargs的限制" class="headerlink" title="xargs的限制"></a>xargs的限制</h4><p>其实是xargs的限制和缺点，但因为通过”-i”选项方便演示，所以此处使用”-i”选项。注意，不是”-i”选项的缺陷。</p>
<p>由于xargs -i传递数据时是在shell执行xargs命令的时候，根据<a href="http://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">shell解析命令行的流程</a> ，xargs后的命令如果有依赖于待传递数据的表达式，则无法正确执行。</p>
<p>第一：无法通过xargs传递数值做正确的算术扩展：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1  | xargs  -I &quot;x&quot; echo $((2*x))</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>第二：无法将数据传递到命令替换中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo /etc/fstab | xargs -i `cat &#123;&#125;`     </span><br><span class="line">cat: &#123;&#125;: No such file or directory</span><br></pre></td></tr></table></figure>
<p>参考下图的shell命令行解析过程。</p>
<p><img src="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" class="lazyload" data-srcset="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" class="lazyload" data-srcset="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>这时要通过xargs正确实现目标，只能改变方法或寻找一些小技巧，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# echo 1  | xargs -i expr 2 \* &#123;&#125;    # 感谢楼下评论者提供的expr思路</span><br><span class="line">2</span><br><span class="line">[root@xuexi ~]# echo /etc/fstab | xargs -i cat $(echo &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>第三：xargs无法处理bash内置命令。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# echo /etc  | xargs -i cd &#123;&#125;</span><br><span class="line">xargs: cd: No such file or directory</span><br></pre></td></tr></table></figure>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>复制所有图片文件到 <code>/data/images</code> 目录下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls 出来的每一行文件名，都会通过 xargs 传递给 cp 命令</span></span><br></pre></td></tr></table></figure>
<p>统计一个源代码目录中所有 php 文件的行数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l</span><br></pre></td></tr></table></figure>
<h5 id="删除带空格的文件"><a href="#删除带空格的文件" class="headerlink" title="删除带空格的文件"></a>删除带空格的文件</h5><p>删除带空格的文件名，思路是让找到的“one space.log”成为一个段，而不是两个段。我给出了常见的两种。</p>
<p>方法一：通过常用的find的-print0选项使用\0来分隔而不是\n分隔，再通过xargs -0来配对保证one space.log的整体性。因为-print0后one space.log的前后各有一个\0，但是文件名中间没有。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi tmp]# find -name &quot;* *.log&quot; -print0 | xargs -0 rm -rf</span><br></pre></td></tr></table></figure>
<p>当然，能使用-0肯定也能使用-d了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi tmp]# find -name &quot;* *.log&quot; -print0 | xargs -d &quot;x&quot; rm -rf     #随意指定非文件名中的字符都行，不一定非要\0</span><br></pre></td></tr></table></figure>
<p>方法二：不在find上处理，在xargs上处理，只要通过配合-i选项，就能宣告它的整体性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi tmp]# find -name &quot;* *.log&quot; | xargs -i rm -rf &quot;&#123;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>相较而言，方法一使用的更广泛更为人所知，但是方法二更具有通用性，对于非find如ls命令也可以进行处理。</p>
<p>还可以使用tr将find的换行符换成其他符号再xargs分割配对也行。</p>
<p>除了find -print0可以输出\0字符，Linux中还有其他几个命令配合参数也可以实现：<strong>locate -0</strong>,<strong>grep -z</strong>或<strong>grep -Z</strong>,<strong>sort -z等</strong>。</p>
<p>其他小例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat test.txt | xargs -n3</span></span><br><span class="line"></span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"nameXnameXnameXname"</span> | xargs -dX</span></span><br><span class="line"></span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.cnblogs.com/f-ck-need-u/p/5925923.html#auto_id_4" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/5925923.html#auto_id_4</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html</a></p>
<h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p><strong>tee命令</strong>可以把数据重定向到<strong>给定文件</strong>和<strong>屏幕</strong>上，相当于分流了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a：向文件中重定向时使用追加模式；</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/04/linux常用命令/./tee.gif" class="lazyload" data-srcset="./tee.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tee"></p>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>TODO scp 的完整命令</p>
<p><strong>scp免密码</strong></p>
<ol>
<li>在A中执行命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>这会在 ~/.ssh 目录下生成两个文件：id_rsa 和 id_rsa.pub</p>
<ol>
<li>拷贝A的id_rsa.pub到B：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.ssh/id_rsa.pub yliu@192.168.200.1:/home/yliu</span><br></pre></td></tr></table></figure>
<ol>
<li>登录B，并把id_rsa.pub输入到B的authorized_keys文件中：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/yliu/id_rsa.pub &gt;&gt; /home/yliu/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<ol>
<li>最后一步：如果是第一次生成authorized_keys，需要授权：chmod 600 authorized_keys</li>
</ol>
<p>大功告成！此时在复制文件就无需输入密码了。而且，<strong>在A中ssh登录B也无需密码</strong>了。</p>
<p>反之亦然，在B中设置A的免密码登录完全一样，在此不做赘述。</p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="一行内指令"><a href="#一行内指令" class="headerlink" title="一行内指令"></a>一行内指令</h3><p>一行内指定依次运行的一系列指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls</span><br></pre></td></tr></table></figure>
<h3 id="命令行中输入tab"><a href="#命令行中输入tab" class="headerlink" title="命令行中输入tab"></a>命令行中输入tab</h3><p>我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在<code>sort -t</code>选项后输入<code>字符），你可以先按`Ctrl-V`，然后再按Tab键，就可以输入</code>字符了。当然，你也可以使用<code>$&#39;\t&#39;</code>。</p>
<p>EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。</p>
<p>参考：<a href="https://awk.readthedocs.io/en/latest/chapter-one.html" target="_blank" rel="noopener">https://awk.readthedocs.io/en/latest/chapter-one.html</a></p>
</the></excerpt>
  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://jizx.vip/2019/08/04/linux常用命令/>https://jizx.vip/2019/08/04/linux常用命令/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-07-14T09:31:58+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Jul 14, 2020</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/awk/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>awk</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/linux/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>linux</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/ing/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>ing</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/命令/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>命令</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://jizx.vip/2019/08/04/linux常用命令/&title=linux常用命令 - 玖玖的博客&summary= 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://jizx.vip/2019/08/04/linux常用命令/&title=linux常用命令 - 玖玖的博客&summary= 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://jizx.vip/2019/08/04/linux常用命令/&title=linux常用命令 - 玖玖的博客&summary= 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2019/08/04/anaconda与jupyter使用与设置/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>anaconda与jupyter的使用和设置</p>
          <p class='content'> 

jupyter 使用介绍、与 anaconda 的虚拟环境结合 、右键打开配置





anaconda安装
清华镜像站下载 或者清华镜像站anaconda首页 或者anaconda官网...</p>
        </a>
      
      
        <a class='next' href='/2018/12/18/photoshop曲线原理与应用/'>
          <p class='title'>photoshop曲线原理与应用<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'> 

转载poco：photoshop曲线原理与应用，https://www.jb51.net/photoshop/532386.html




关键句：可以看到S型曲线中间部分，输入和输出值...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间"><span class="toc-text">时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#date"><span class="toc-text">date</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#格式化参数"><span class="toc-text">格式化参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#格式化"><span class="toc-text">格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间游走"><span class="toc-text">时间游走</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文本处理"><span class="toc-text">文本处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#echo"><span class="toc-text">echo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cat"><span class="toc-text">cat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tail"><span class="toc-text">tail</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniq"><span class="toc-text">uniq</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两个文件的交并集"><span class="toc-text">两个文件的交并集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-text">sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局选项"><span class="toc-text">全局选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#知识点"><span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#排序对象"><span class="toc-text">排序对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#建议"><span class="toc-text">建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多列排序"><span class="toc-text">多列排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-text">grep</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用参数"><span class="toc-text">常用参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展用法"><span class="toc-text">扩展用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不使用正则表达式"><span class="toc-text">不使用正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多模式匹配"><span class="toc-text">多模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#逻辑或"><span class="toc-text">逻辑或</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#从文件中读取匹配模式"><span class="toc-text">从文件中读取匹配模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#逻辑与"><span class="toc-text">逻辑与</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用功能"><span class="toc-text">常用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#检索文件内容"><span class="toc-text">检索文件内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0值字节后缀的-xargs"><span class="toc-text">0值字节后缀的 xargs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#比较两个文件相同内容与不同内容"><span class="toc-text">比较两个文件相同内容与不同内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#查找满足条件的文件是否匹配到文字"><span class="toc-text">查找满足条件的文件是否匹配到文字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tr"><span class="toc-text">tr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他参数"><span class="toc-text">其他参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cut"><span class="toc-text">cut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件分割-split"><span class="toc-text">文件分割 split</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sed"><span class="toc-text">sed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#替换s"><span class="toc-text">替换s</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#替换标记"><span class="toc-text">替换标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分隔符"><span class="toc-text">分隔符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#指定行"><span class="toc-text">指定行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多命令"><span class="toc-text">多命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入a与i"><span class="toc-text">插入a与i</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#插入多行"><span class="toc-text">插入多行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除行-d"><span class="toc-text">删除行 d</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符转换y"><span class="toc-text">字符转换y</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打印命令"><span class="toc-text">打印命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#p-命令"><span class="toc-text">p 命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#等号"><span class="toc-text">=等号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#显示特殊字符l"><span class="toc-text">显示特殊字符l</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#保存命令w"><span class="toc-text">保存命令w</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取命令"><span class="toc-text">读取命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-字段合并"><span class="toc-text">Join 字段合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本编码转换-iconv"><span class="toc-text">文本编码转换 iconv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临时文件-mktemp"><span class="toc-text">临时文件 mktemp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁盘"><span class="toc-text">磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mount"><span class="toc-text">mount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#df与-du-TODO"><span class="toc-text">df与 du TODO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩命令"><span class="toc-text">压缩命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他命令"><span class="toc-text">其他命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#seq"><span class="toc-text">seq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xarg"><span class="toc-text">xarg</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实验文件准备"><span class="toc-text">实验文件准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流程讲解"><span class="toc-text">流程讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#预处理"><span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分割"><span class="toc-text">分割</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分批行为"><span class="toc-text">分批行为</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分批的典型应用"><span class="toc-text">分批的典型应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#终止行为之-：xargs-E"><span class="toc-text">终止行为之 ：xargs -E</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多进程"><span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xargs与文件名"><span class="toc-text">xargs与文件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xargs与复杂命令"><span class="toc-text">xargs与复杂命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xargs与重定向"><span class="toc-text">xargs与重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xargs的限制"><span class="toc-text">xargs的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子-2"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#删除带空格的文件"><span class="toc-text">删除带空格的文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tee"><span class="toc-text">tee</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scp"><span class="toc-text">scp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他知识点"><span class="toc-text">其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一行内指令"><span class="toc-text">一行内指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行中输入tab"><span class="toc-text">命令行中输入tab</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>



      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <!-- required -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  










  
  <script src="/js/valine.js"></script>

<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = $.trim($('#pjax-comment-placeholder').text()) || "快来评论吧~";

    let path = $.trim($('#pjax-comment-path').text());
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>







  <script src="/js/app.js"></script>



  
    <script src="/js/search.js"></script>
  


<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );
(function ($) {
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
})(jQuery);

</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://jizx.vip' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://jizx.vip' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://jizx.vip' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>



<!-- more -->


    
      

<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>
<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
