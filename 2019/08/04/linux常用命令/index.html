<!DOCTYPE html>
<html>
<head hexo-theme="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4"><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="x-dns-prefetch-control" content="on">

  <!-- 页面元数据 -->
  
  <title>linux常用命令 - 玖玖的博客</title>
  
    <meta name="keywords" content="linux,awk,ing,命令">
  

  
    <meta name="description" content=" 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">
  

  

  

  

  

  <!-- import link -->
  

  
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">
    
  
  
    <link rel="stylesheet" href="/css/style.css">
  
  
  
  <!-- 脚本懒加载函数 -->
  <script>
  function loadScript(src, cb) {
    var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
    var script = document.createElement('script');
    script.setAttribute('type','text/javascript');
    if (cb) script.onload = cb;
    script.setAttribute('src', src);
    HEAD.appendChild(script);
  }
  //https://github.com/filamentgroup/loadCSS
  !function(c){"use strict";var e=function(e,t,n,r){var o,i=c.document,a=i.createElement("link");if(t)o=t;else{var d=(i.body||i.getElementsByTagName("head")[0]).childNodes;o=d[d.length-1]}var f=i.styleSheets;if(r)for(var l in r)r.hasOwnProperty(l)&&a.setAttribute(l,r[l]);a.rel="stylesheet",a.href=e,a.media="only x",function e(t){if(i.body)return t();setTimeout(function(){e(t)})}(function(){o.parentNode.insertBefore(a,t?o:o.nextSibling)});var s=function(e){for(var t=a.href,n=f.length;n--;)if(f[n].href===t)return e();setTimeout(function(){s(e)})};function u(){a.addEventListener&&a.removeEventListener("load",u),a.media=n||"all"}return a.addEventListener&&a.addEventListener("load",u),(a.onloadcssdefined=s)(u),a};"undefined"!=typeof exports?exports.loadCSS=e:c.loadCSS=e}("undefined"!=typeof global?global:this);
  </script>
  <script id="loadcss"></script>
</head>

<body>
  <header class="l_header auto shadow blur " style='opacity: 0' >
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div class="l_body">
    <div class="l_cover">
  
    
    
        <div class='cover-wrapper post search' style="display: none;">
          
            <div class='cover-backstretch'></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">玖玖</p>
    
    
      <p class="subtitle">^_^</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="Search..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              id="v4getting-started">
              <p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              id="faqs">
              <p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              id="examples">
              <p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              id="contributors">
              <p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <p>博客</p>
            </a>
          
            <a href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              id="https:githubcomvolantis-xhexo-theme-volantis">
              <p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>
  
    <div class='safearea'>
      <div class='body-wrapper' id="pjax-container">
        
          <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">true</div> 
  <div id="pjax-pageTitle">linux常用命令</div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path"></div> 
  <div id="pjax-comment-placeholder"></div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("half" == "none") { // 移除封面 
    document.getElementsByClassName('cover-wrapper')[0].style.display = "none"; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("half" == "half") { // 半屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'half'); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("half" == "full") { // 全屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'full'); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover-wrapper')[0].style.display = ""; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 
 

        
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        linux常用命令
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="">
    <p>玖玖</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <a class='notlink'>
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <a class="category-link" href="/categories/linux/">linux</a>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Aug 4, 2019</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="linux常用命令" data-path="/2019/08/04/linux常用命令/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>19.7k words</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>80 min</p>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <excerpt in="" index="" |="" 首页摘要=""> 

<p>处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）</p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">



<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><code>ps -f</code>命令也能够表现子shell的嵌套关系</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><pre><code>-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；
-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；

date [选项]... [+格式]
　或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]
Display the current time in the given FORMAT, or set the system date.

Mandatory arguments to long options are mandatory for short options too.
  -d, --date=STRING         显示由STRING 描述指定的时间, 不是默认的&#39;now&#39;
  -f, --file=DATEFILE       like --date once for each line of DATEFILE
  -I[TIMESPEC], --iso-8601[=TIMESPEC]  使用ISO 8601格式显示 date/time 
                            TIMESPEC可以设置为&#39;date&#39;, &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, &#39;ns&#39;  
                            来指定显示的精度，默认是date
  -r, --reference=文件       显示指定文件的最后修改时间
  -R, --rfc-2822             以RFC 2822格式输出日期和时间
                            例如：2006年8月7日，星期一 12:34:56 -0600
      --rfc-3339=TIMESPEC   output date and time in RFC 3339 format.
                            TIMESPEC=&#39;date&#39;, &#39;seconds&#39;, or &#39;ns&#39; for
                            date and time to the indicated precision.
                            Date and time components are separated by
                            a single space: 2006-08-07 12:34:56-06:00
  -s, --set=STRING          用描述时间的字符串 STRING 设置时间
  -u, --utc, --universal    显示或设置 Coordinated Universal Time
      --help        显示此帮助信息并退出
      --version        显示版本信息并退出
</code></pre><h4 id="格式化参数"><a href="#格式化参数" class="headerlink" title="格式化参数"></a>格式化参数</h4><p>给定的格式FORMAT 控制着输出，解释序列如下：</p>
<pre><code>  %%    一个%
  %a    当前locale 的星期名缩写(例如： 日，代表星期日)
  %A    当前locale 的星期名全称 (如：星期日)
  %b    当前locale 的月名缩写 (如：一，代表一月)
  %B    当前locale 的月名全称 (如：一月)
  %c    当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)
  %C    世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)
  %d    按月计的日期(例如：01)
  %D    按月计的日期；等于%m/%d/%y
  %e    按月计的日期，添加空格，等于%_d
  %F    完整日期格式，等价于 %Y-%m-%d
  %g    ISO-8601 格式年份的最后两位 (参见%G)
  %G    ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用
  %h    等于%b
  %H    小时(00-23)
  %I    小时(00-12)
  %j    按年计的日期(001-366)
  %k   hour, space padded ( 0..23); same as %_H
  %l   hour, space padded ( 1..12); same as %_I
  %m   month (01..12)
  %M   minute (00..59)
  %n    换行
  %N    纳秒(000000000-999999999)
  %p    当前locale 下的&quot;上午&quot;或者&quot;下午&quot;，未知时输出为空
  %P    与%p 类似，但是输出小写字母
  %r    当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)
  %R    24 小时时间的时和分，等价于 %H:%M
  %s    自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数
  %S    秒(00-60)
  %t    输出制表符 Tab
  %T    时间，等于%H:%M:%S
  %u    星期，1 代表星期一
  %U    一年中的第几周，以周日为每星期第一天(00-53)
  %V    ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)
  %w    一星期中的第几日(0-6)，0 代表周一
  %W    一年中的第几周，以周一为每星期第一天(00-53)
  %x    当前locale 下的日期描述 (如：12/31/99)
  %X    当前locale 下的时间描述 (如：23:13:48)
  %y    年份最后两位数位 (00-99)
  %Y    年份
  %z +hhmm        数字时区(例如，-0400)
  %:z +hh:mm        数字时区(例如，-04:00)
  %::z +hh:mm:ss    数字时区(例如，-04:00:00)
  %:::z            数字时区带有必要的精度 (例如，-04，+05:30)
  %Z            按字母表排序的时区缩写 (例如，EDT)

默认情况下，日期的数字区域以0填充。
%后面可以加 下面这些标记：
  -  (hyphen) do not pad the field
  _  (underscore) pad with spaces
  0  (zero) pad with zeros
  ^  use upper case if possible
  #  use opposite case if possible

在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。
作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的
表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。

例子:
Convert seconds since the epoch (1970-01-01 UTC) to a date
  $ date --date=&#39;@2147483647&#39;

Show the time on the west coast of the US (use tzselect(1) to find TZ)
  $ TZ=&#39;America/Los_Angeles&#39; date

Show the local time for 9AM next Friday on the west coast of the US
  $ date --date=&#39;TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri&#39;
</code></pre><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><pre><code>date +&quot;%Y-%m-%d&quot;
</code></pre><h4 id="时间游走"><a href="#时间游走" class="headerlink" title="时间游走"></a>时间游走</h4><p>1.加减操作</p>
<pre><code>date +%Y%m%d                   //显示前天年月日
date -d &quot;+1 day&quot; +%Y%m%d       //显示前一天的日期
date -d &quot;-1 day&quot; +%Y%m%d       //显示后一天的日期
date -d &quot;-1 month&quot; +%Y%m%d     //显示上一月的日期
date -d &quot;+1 month&quot; +%Y%m%d     //显示下一月的日期
date -d &quot;-1 year&quot; +%Y%m%d      //显示前一年的日期
date -d &quot;+1 year&quot; +%Y%m%d      //显示下一年的日期
</code></pre><p>2.文字版本</p>
<pre><code>date -d &quot;1 day ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;               # 一天前
date -d &quot;1 day&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;                   # 一天后
date -d &quot;2009-12-12  1 year ago&quot; +&quot;%Y/%m/%d %H:%M.%S&quot;  # 指定时间的一年前
date -d &quot;2009-12-12  1 year&quot; +&quot;%Y/%m/%d %H:%M.%S&quot;      # 指定时间的一年后
</code></pre><p>设置时间</p>
<pre><code>date -s                        //设置当前时间，只有root权限才能设置，其他只能查看
date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00
date -s 01:01:01               //设置具体时间，不会对日期做更改
date -s &quot;01:01:01 2012-05-23&quot;  //这样可以设置全部时间
</code></pre><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p><code>-e</code>：输出转义字符</p>
<p><code>-n</code>：不换行输出</p>
<pre><code class="shell">RCol=&#39;\e[0m&#39;    # Text Reset

# Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds
Bla=&#39;\e[0;30m&#39;;     BBla=&#39;\e[1;30m&#39;;    UBla=&#39;\e[4;30m&#39;;    IBla=&#39;\e[0;90m&#39;;    BIBla=&#39;\e[1;90m&#39;;   On_Bla=&#39;\e[40m&#39;;    On_IBla=&#39;\e[0;100m&#39;;
Red=&#39;\e[0;31m&#39;;     BRed=&#39;\e[1;31m&#39;;    URed=&#39;\e[4;31m&#39;;    IRed=&#39;\e[0;91m&#39;;    BIRed=&#39;\e[1;91m&#39;;   On_Red=&#39;\e[41m&#39;;    On_IRed=&#39;\e[0;101m&#39;;
Gre=&#39;\e[0;32m&#39;;     BGre=&#39;\e[1;32m&#39;;    UGre=&#39;\e[4;32m&#39;;    IGre=&#39;\e[0;92m&#39;;    BIGre=&#39;\e[1;92m&#39;;   On_Gre=&#39;\e[42m&#39;;    On_IGre=&#39;\e[0;102m&#39;;
Yel=&#39;\e[0;33m&#39;;     BYel=&#39;\e[1;33m&#39;;    UYel=&#39;\e[4;33m&#39;;    IYel=&#39;\e[0;93m&#39;;    BIYel=&#39;\e[1;93m&#39;;   On_Yel=&#39;\e[43m&#39;;    On_IYel=&#39;\e[0;103m&#39;;
Blu=&#39;\e[0;34m&#39;;     BBlu=&#39;\e[1;34m&#39;;    UBlu=&#39;\e[4;34m&#39;;    IBlu=&#39;\e[0;94m&#39;;    BIBlu=&#39;\e[1;94m&#39;;   On_Blu=&#39;\e[44m&#39;;    On_IBlu=&#39;\e[0;104m&#39;;
Pur=&#39;\e[0;35m&#39;;     BPur=&#39;\e[1;35m&#39;;    UPur=&#39;\e[4;35m&#39;;    IPur=&#39;\e[0;95m&#39;;    BIPur=&#39;\e[1;95m&#39;;   On_Pur=&#39;\e[45m&#39;;    On_IPur=&#39;\e[0;105m&#39;;
Cya=&#39;\e[0;36m&#39;;     BCya=&#39;\e[1;36m&#39;;    UCya=&#39;\e[4;36m&#39;;    ICya=&#39;\e[0;96m&#39;;    BICya=&#39;\e[1;96m&#39;;   On_Cya=&#39;\e[46m&#39;;    On_ICya=&#39;\e[0;106m&#39;;
Whi=&#39;\e[0;37m&#39;;     BWhi=&#39;\e[1;37m&#39;;    UWhi=&#39;\e[4;37m&#39;;    IWhi=&#39;\e[0;97m&#39;;    BIWhi=&#39;\e[1;97m&#39;;   On_Whi=&#39;\e[47m&#39;;    On_IWhi=&#39;\e[0;107m&#39;;
</code></pre>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><pre><code>cat -A test   显示隐藏字符如^A,^B
cat -n test   所有的行加上行号
cat -b test  【有文本的行】 加上行号，【空白行】不算
cat -T test   以^I显示制表符
</code></pre><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><pre><code>tail -n 2 -f log_file
</code></pre><p><code>-f</code> 参数是 tail 命令的一个突出特性。它允许你在其他进程使用该文件时查看文件的内容。tail命令会保持活动状态，并不断显示添加到文件中的内容。这是实时监测系统日志的绝妙方式。</p>
<h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>uniq命令用于报告或忽略文件中的重复行，<strong>查重复行的时候，只会检查相邻的行</strong>，因此一般与<a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort</a>命令结合使用，让重复的排在一起。比如下面：<code>aa</code> 统计结果是出现了 2 次，后面又有出现 1 次的 <code>aa</code></p>
<pre><code># 文本
aa
aa
c
aa

# uniq 后
uniq -c 
2 aa
1 c
1 aa
</code></pre><p>常用参数：</p>
<pre><code>-c或——count：            在每列旁边显示该行重复出现的次数；
-u或——unique：        仅显示出一次的行列；
-d或--repeated：        仅输出重复出现的行列，且重复的只输出一行；
-D, --all-repeated   仅输出重复的行，有几行输出几行  
-i, --ignore-case    不区分大小写  
-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;   指定要比较的前 n 个字符，忽略后面的内容
-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;         忽略前n列（空格分割），-f 1 忽略第一列
-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;   忽略前n个字符 -s 4 忽略前 4 个字符
-z 忽略换行(不知道有什么用)
</code></pre><p>提供的测试文件</p>
<pre><code>this is a test  
this is a test  
this is a test  
i am tank  
i love tank  
i love tank  
this is a test  
whom have a try  
WhoM have a try 
WhoM have a try1
you  have a try  
i want to abroad  
those are good men  
we are good men  
</code></pre><p>参考：<a href="http://blog.51yip.com/shell/1022.html" target="_blank" rel="noopener">http://blog.51yip.com/shell/1022.html</a></p>
<h4 id="两个文件的交并集"><a href="#两个文件的交并集" class="headerlink" title="两个文件的交并集"></a>两个文件的交并集</h4><p>如果你知道怎么用<code>sort/uniq</code>来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已经被uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小）</p>
<pre><code>cat a b | sort | uniq &gt; c   # c is a union b 并集
cat a b | sort | uniq -d &gt; c   # c is a intersect b 交集
cat a b b | sort | uniq -u &gt; c   # c is set difference a - b 差集
</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h4><table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th></th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-b</td>
<td>–ignore-leading-blanks</td>
<td>排序时忽略起始的空白，空格数量不固定时，该选项几乎是必须要使用的。”-n”选项隐含该选项。</td>
</tr>
<tr>
<td style="text-align:left">-c</td>
<td>–check</td>
<td>仅检查输入数据是不是已排序；未排序的话，会输出诊断信息，提示从哪一行开始乱序。</td>
</tr>
<tr>
<td style="text-align:left">-t</td>
<td>–field-separator=SEP</td>
<td>指定分隔符，如果是<code>\t</code>，需要这样<code>sort -t$&#39;\t&#39; file</code>。<strong>默认的分隔符为空白字符和非空白字符之间的空字符</strong>，<strong>并非网上众多文章所说的空格或制表符</strong>(By default, fields are separated by the empty string between a non-blank character and a blank character)。” foo bar”被分割为：`</td>
<td>foo</td>
<td>bar<code>（</code></td>
<td>`视为分割符）</td>
</tr>
<tr>
<td style="text-align:left">-u</td>
<td>–unique</td>
<td>在输出行中去除重复行，只识别用<code>-k</code>设定的域，发现都相同的才会删除，只要其中有一级不同都不会轻易删除的。</td>
</tr>
<tr>
<td style="text-align:left">-n</td>
<td>–numeric-sort</td>
<td>指定-n使用数值比较，默认是字符串比较，<strong>一遇到不可识别字符就会立即结束该字段的排序行为</strong>，<strong>无法跨域使用</strong>。”n”选项隐含”b”选项。</td>
</tr>
<tr>
<td style="text-align:left">-g</td>
<td>–general-number-sort</td>
<td>按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学 计数法表示的值）</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td>–reverse</td>
<td>默认从小到大，指定后改为从大到小排序</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td>–ignore-case</td>
<td>忽略大小写，未指定情况下，会将<strong>大写字母排在前面</strong>；在和”-u”选项一起使用时，如果排序字段的比较结果相等，则丢弃小写字母行。</td>
</tr>
<tr>
<td style="text-align:left">-o</td>
<td>–output=file</td>
<td>排序结果输出到指定文件，对于<strong>保存到原文件很有用</strong>，不然是可以用重定向的</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td>–merge</td>
<td>对给定的多个已排序文件进行合并。在合并过程中不做任何排序动作。</td>
</tr>
<tr>
<td style="text-align:left">-k</td>
<td>–key=POS1[,POS2]</td>
<td>指定排序的列，排序从POS1位置开始；如果指定了POS2的话， 到POS2位置结 束</td>
</tr>
<tr>
<td style="text-align:left">-s</td>
<td>–stable</td>
<td>禁用”最终排序”。<strong>推荐大文件使用</strong>，能确认要排序的列后，不启用可以提高性能</td>
</tr>
<tr>
<td style="text-align:left">-z</td>
<td>–zero-terminated</td>
<td>NULL字符作为行尾，而不是用换行符</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>–debug</td>
<td>查看排序的过程和排序时所使用的列。注意，该选项只有CentOS 7上的sort才有。</td>
</tr>
</tbody>
</table>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p><strong>私有选项</strong>：紧跟在字段后的选项(如”-k3n”的”n”和”-k2r”的”r”)称为私有选项，使用短横线写在字段外的选项(如”-n”、”-r”)为全局选项。<strong>当没有为字段分配私有选项时，该排序字段将继承全局选项。</strong>当然，只有像”-n”、”-r”这样的排序性的选项才能继承和分配给字段，”-t”这样的选项则无法分配。</p>
<p>除了”b”选项外，其余选项无论是<strong>指定在POS1还是POS2中都是等价的</strong>，对于”b”选项，指定在POS1则作用于POS1，指定在POS2则作用于POS2。如果继承了全局选项”-b”，则作用于POS1和POS2。</p>
<blockquote>
<p>  因此，”-n -k3 -k4”、”-n -k3n -k4”和”-k3n -k4n”是等价的，”-r -k3n -k4”和”-k3nr -k4r”是等价的</p>
</blockquote>
<p><strong>排序规则</strong>：sort命令默认按照字符集的排序规则进行排序，可以指定”-d”选项按照字典顺序排序，指定”-n”按照数值排序，指定”-M”按照字符格式的月份规则排序，指定”-h”按照文件容量大小规则排序。</p>
<p><strong>分隔符</strong> ：sort使用<code>-t</code>选项指定的分隔符对每行进行分割，得到多个字段，<strong>分隔符不作为字段的内容，跨域时也没有，注意<code>-n</code>无法跨域，会造成分隔符在其中的错觉</strong>。默认的分隔符为空白字符和非空白字符之间的空字符，并非网上众多文章所说的空格或制表符(原文：By default, fields are separated by the empty string between a non-blank character and a blank character.)。</p>
<p>“ foo bar”默认将分隔为两个字段” foo”和” bar”，空格都保留着，可以视为”| foo| bar”，<code>|</code>为分割符。而使用空格作为分隔符时将分隔为三个字段：第一个字段为空，第二个字段和第三个字段为”foo”和”bar”。使用下面三个sort语句可以验证默认的分隔符并非空格。</p>
<blockquote>
<pre><code class="shell">  $ echo -e &quot; 234 bar\n 323 aar&quot; | sort  -k2     # 视为 2 列，对（aar,bar）排序
   323 aar
   234 bar

  $ echo -e &quot; 234 bar\n 323 aar&quot; | sort  -t&#39; &#39; -k2 # 视为 3 列，对 (234,323)排序
   234 bar
   323 aar

  $ echo -e &quot; 234 bar\n 323 aar&quot; | sort -b -t&#39; &#39; -k1 # 视为 2 列，因为全局选项-b 去除了开头的空格
   123 aar
   234 bar

  $ echo -e &quot; 234  bar\n 323 aar&quot; | sort -t&#39; &#39; -bk3  # 视为 3 列，对（aar, bar）排序，私有选项忽略 bar 前的空格
   323 aar
   234  bar
</code></pre>
</blockquote>
<p><strong>分割后字段</strong>：分割字段后，<strong>分隔符不在排序目标中，跨域时也不包括（<code>-n</code>无法跨域，会造成分隔符在其中的错觉）</strong>，分割后两个字段A和B是紧靠在一起的。当排序的目标字段包含了B字段，那么sort会从字段左对齐处开始依次对字符排序。</p>
<pre><code class="python">[root@xuexi ~]# cat sort.txt
11:1:2
1:1:2
12:1:1
1:1:0
[root@xuexi ~]# sort -t:  sort.txt
1:1:0
11:1:2
1:1:2
12:1:1
</code></pre>
<p>上面排序例子中，为什么”1:1:2”的1会在11和12中间，而”1:1:0”中的1却在11的前面？实际上，真正排序的时候，sort看到的内容是这样的：</p>
<pre><code>1112
112
1211
110
</code></pre><p><strong>注意</strong>：info sort 文档中说跨域时分隔符会保留感觉是错的。通过下面的例子进行测试</p>
<pre><code class="shell">$ cat t
a ae
aa da

$ sort -t&quot; &quot; -k1,2 t   # d &gt; e
aa da
a ae
</code></pre>
<p><strong>最后排序</strong>：默认情况下，在命令行中指定的排序行为结束后，sort还会做最后一次排序，这最后一次排序是对整行按照完全默认规则进行排序的，也就是按字符集、升序排序。</p>
<p>考虑这样一种情况：两行在<strong>所有key的排序结果</strong>上都完全相同，应该如何决定这两行的先后顺序？</p>
<p>例如：</p>
<pre><code>[root@xuexi ~]# echo -e &quot;b 100 200\na 100 300&quot; | sort -t &#39; &#39; -k2n
a 100 300
b 100 200
</code></pre><p>第一行为”b 100 200”，第二行为”a 100 300”。由于第2字段都是100，所以这两行在该key上的数值排序的结果相同，<strong>于是sort采取最后的手段，完全按照默认规则(即按字符集排序规则升序排序)对整行进行一次排序，这次排序称为”最后的排序”</strong>(info sort中称为last-resort comparison)。由于最后的排序过程中，第一个字符a&lt;b，所以最终结果将是第二行”a 100 300”在第一行”b 100 200”的前面。</p>
<p><strong>禁止”最后的排序”后，对那些排序key相同的行，将保留被读取时相对顺序。</strong>即，先读取的排在前面。</p>
<p>如果上面的例子中，第二字段不采用数值排序，而是默认排序规则排序呢？如下：</p>
<pre><code>[root@xuexi ~]# echo -e &quot;b 100 200\na 100 300&quot; | sort -t &#39; &#39; -k2
b 100 200
a 100 300
</code></pre><p>由于默认的排序规则是按照字符集排序规则进行排序，它能识别所有的字符，所以<code>-k2</code>等价于<code>-k2,3</code>，对整个key进行排序，由于第三字段的2小于3，所以结果中第一行排在第二行的前面。即使如此，sort还是进行了”最后的排序”，只不过”最后的排序”不影响排序结果。</p>
<p>如果未指定任何排序选项，其本身就是完全默认的，因此没必要再做最后的排序，所以将不会进行”最后的排序”。如果指定的是”-r”选项，由于”-r”是对最终结果进行反转排序，因此会影响这次的”最后的排序”的结果。</p>
<h4 id="排序对象"><a href="#排序对象" class="headerlink" title="排序对象"></a>排序对象</h4><p><strong>使用”-k”选项指定排序的key。不指定排序key时，整行将成为排序key，即对整行进行排序。</strong></p>
<ul>
<li>key由字段组成，格式为<code>POS1,[POS2]</code>，表示每行排序的起始和终止位置。也就是说，key才是排序的对象。</li>
<li>POS的格式为<code>F[.C][OPTS]</code>，其中F表示字段的序号，C表示该字段中字符的序号。字段和字符的位置都从1开始计算。如果POS2的字符位置指定为0，则表示POS2字段中的最后一个字符。如果POS1中省略<code>.C</code>，则默认值为1(字段的起始字符)，如果POS2中省略<code>.C</code>，默认值为0(字段的终止字符)。使用”-b”选项忽略前导空白字符时，C从第一个非空白字符开始计算。如果F或C超出了有效范围，则该key为空，例如一行只有3个字段，却指定了”-k4”，或者第2字段只有3个字符，却指定了”-k2.5”。</li>
<li>如果<strong>省略POS2，则key将自动扩展到行尾</strong>，即等价于”POS1,line_end”。如果不省略POS2，则该key可能会跨越多个字段。无论那种情况，跨越多个字段时，key中都不会保留字段间的分隔符。</li>
<li>OPTS指定的是该key的选项，包括但不限于<code>bfnrhM</code>，它们的作用和全局选项”-b”、”-f”、”-n”、”-r”、”-h”、”-M”相同。默认情况下，如果key中没有指定任何OPTS，则该<strong>key会继承全局选项</strong>。当key中单独指定了选项时，这些选项是该key的私有排序选项，将覆盖全局选项。除了”b”选项外，其余选项无论是指定在POS1还是POS2中都是等价的，对于”b”选项，指定在POS1则作用于POS1，指定在POS2则作用于POS2。如果继承了全局选项”-b”，则作用于POS1和POS2。<strong><code>-n</code>选项无法跨域</strong>。</li>
<li>字段前数量不固定的前导空白字符，将使得字段混乱，因此<strong>强烈建议总是忽略前导空白字符</strong>。数值排序时(即”n”选项)隐含”b”选项。</li>
<li>可以使用多个”-k”选项指定多个key，排序时将按照key的顺序进行排序。第一个key通常称为主排序key(primary key)。第二个key将在第一个key排序的基础上排序，同理，第三个key将在第二个key的排序基础上进行排序。</li>
</ul>
<p>以下是几个例子：例子中出现了选项”n”的，描述暂不严谨，但目前只能如此描述，在稍后的(4)中解释。</p>
<ul>
<li><p><code>-k 2</code>： 因为没有指定POS2，所以key扩展到了行尾。因此该key从第2字段第一个字符开始，到行尾结束。</p>
</li>
<li><p><code>-k 2,3</code> ：该key从第2字段第一个字符开始到第3字段最后一个字符结束。</p>
</li>
<li><p><code>-k 2,2</code>： 该key仅拥有第2字段。</p>
</li>
<li><p><code>-k 2,3n</code>和<code>-k 2n,3</code>和<code>-k 2n,3n</code>：这三者等价，因为除了”b”选项，OPTS指定在POS1或POS2的结果是一样的。</p>
</li>
<li><p><code>-k 2,3b</code>和<code>-k 2b,3</code>和<code>-k 2b,3b</code>：这三者互不等价。</p>
</li>
<li><p><code>-k 2n</code>： 该key从第2字段开始直到行尾，都按数值排序。</p>
</li>
<li><p><code>-k 2.2b,3.2n</code>： 该key从第2字段的第2个非空白字符开始，到第3字段第2字符(可能包含空白字符)结束，且该key按照数值排序。其实此处的b选项是多余的，因为n隐含了b选项。</p>
</li>
<li><p><code>-k 5b,5 -k 3,3n</code>： 定义了两个排序key，主排序key为第5字段不包含空白字符的部分，副key为第三个字段。主key按照默认规则排序，副key按照数值排序。副key在主key排序后的基础上再排序。</p>
</li>
<li><p><code>-k 5,5n -k 3b,6b</code>： 主key为第5字段，按照数值排序，副key从第3字段到第六字段，忽略前导空白字符，但是按照默认规则排序。副key在主key排序后的基础上再排序。</p>
</li>
</ul>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul>
<li>任何时候想对单个字段或单个字符排序时，都建议写出POS2，且POS2=POS1，这样能严格排序key的范围只为那个字段或字符。例如，使用<code>-k2,2</code>取代<code>-k2</code>。</li>
<li>想对多个字段或字符排序时，建议使用多个”-k”选项指定多个key，并按需求为每个key分配私有选项。之所以要如此，是防止无意中忽视了扩展到行尾或者范围。例如，想对第2列、第3列按数值排序，应该指定<code>-k2n -k3n</code>，而不应该写成<code>-k2,3n</code>。</li>
<li>应该总是使用<code>-b</code>选项去掉前导空白字符面，防止字段分割时混乱。<code>-n</code>隐含了<code>-b</code>，所以对数值排序时，可以省略<code>-b</code>。</li>
<li>对于大文件，建议写出满足需求的所有排序命令，然后使用<code>-s</code>关闭”最后的排序”。因为”最后的排序”对每个整行进行排序，性能非常低。</li>
</ul>
<h4 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h4><p>sort按照某列排序，一样的话再按某一列排序</p>
<pre><code class="bash">sort  -k2,2 -k5,5 wide_table |grep &quot;DD4486F320A7F0C112E2757C26609769&quot;
</code></pre>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ol>
<li><p>从公司英文名称的第二个字母开始进行排序：</p>
<pre><code>  $ sort -t &#39; &#39; -k 1.2 facebook.txt
  baidu 100 5000
  sohu 100 4500
  google 110 5000
  guge 50 3000
</code></pre><p> 使用了<code>-k 1.2</code>，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。</p>
</li>
<li><p>按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序</p>
<pre><code>$ sort -n -t &#39; &#39; -k 3r -k 2 facebook.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000
</code></pre><p>在-k 3后面偷偷加上了一个小写字母r。<strong>r和-r选项的作用是一样的，就是表示逆序，不过只对当前域有效</strong>，表示第三个域（员工平均工资）是按照降序排序。此处你还可以加上n，就表示对这个域进行排序时，要按照数值大小进行排序</p>
<pre><code>$ sort -t &#39; &#39; -k 3nr -k 2n facebook.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000
</code></pre><p>我们去掉了最前面的-n选项，而是将它加入到了每一个-k选项中了。</p>
</li>
<li><p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序</p>
<pre><code>$ sort -t &#39; &#39; -k 1.2,1.2 -k 3nr facebook.txt
baidu 100 5000
google 110 5000
sohu 100 4500
guge 50 3000
</code></pre><blockquote>
<p>  我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。</p>
</blockquote>
</li>
<li><p>最诡异的排序（跨域是不行的）</p>
<pre><code>$ sort -n -k 2.2,3.1 facebook.txt
guge 50 3000
baidu 100 5000
sohu 100 4500
google 110 5000
</code></pre><p>以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。</p>
<p>第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。</p>
<p>又因为sort认为0小于00小于000小于0000….</p>
<p>因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢？（你可以自己做实验思考一下。）</p>
<p>答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了。</p>
</li>
</ol>
<p><a href="http://blog.chinaunix.net/uid-10540984-id-313479.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-10540984-id-313479.html</a></p>
<p><a href="https://www.cnblogs.com/f-ck-need-u/p/7442886.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7442886.html</a></p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><pre><code>find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]
</code></pre><p>任何位于表达式（expression）之前的字符串都将被视为欲查找的目录名。</p>
<p>默认路径为当前目录；默认表达式为<code>-print</code><br>表达式(expression)可能由下列成份组成：操作符、选项、测试表达式以及动作：</p>
<p>find会对每个文件评估从左向右的表达式，直到结果明确为真 或 表达式全部执行结束。</p>
<p>-H，-L和-P选项控制符号链接的处理。后面的命令行参数被视为要检查的文件或目录的名称，直到开始的第一个参数使用’ - ‘或参数’（’或’！’。该参数和任何后续参数被视为描述要搜索内容的表达式。</p>
<p>五个’真正的’选项-H，-L，-P， -D和-O必须出现在第一个路径名之前</p>
<pre><code class="bash">操作符 (优先级递减；未做任何指定时默认使用 -and):
      ( EXPR )  
      ! EXPR   
      -not EXPR  
      EXPR1 -a EXPR2
      EXPR1 -and EXPR2
      EXPR1 -o EXPR2
      EXPR1 -or EXPR2
      EXPR1 , EXPR2

位置选项 (总是真): 
      -daystart # 从本日开始计算时间；TODO
      -follow  废弃; 使用-L代替, 排除符号连接；
      -regextype 普通选项 (总是真，在其它表达式前指定):
      -depth  # 从指定目录下最深层的子目录开始查找，不像默认的一层一层目录往下找，如下：
          # ./logs/hadoop.kylin.libdfs.log
          # ./logs
      -maxdepth LEVELS  # 设置最大目录层级;
      -mindepth LEVELS  # 搜索深度距离当前目录至少2个子目录的所有文件
      -mount   # 此参数的效果和指定“-xdev”相同；
      -xdev    # Don’t descend directories on other filesystems.TODO
      -ignore_readdir_race
      -noignore_readdir_race
      --version 
      --help

比较测试 (N 可以是 +N 或 -N 或 N): 
       +N     for greater than N,
       -N     for less than N,
        N     for exactly N.

      -amin N   # 查找在指定时间曾被存取过的文件或目录，单位以分钟计算；
      -mmin N   # 查找在指定时间曾被更改过的文件或目录，单位以分钟计算；
      -cmin N   # 查找在指定时间之时被更改过的文件或目录,单位以分钟计算；
      -atime N  # 查找在指定时间曾被存取过的文件或目录，单位以24小时计算；
      -mtime N  # 查找在指定时间曾被更改过的文件或目录，单位以24小时计算;
      -ctime N  # 查找在指定时间之时被更改的文件或目录，单位以24小时计算；
      -cnewer 文件  # 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
      -anewer 文件 # 查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；
      -empty 
      -true            # 将find指令的回传值皆设为True;
      -false            # 将find指令的回传值皆设为False；
      -fstype 类型      # 只寻找该文件系统类型下的文件或目录；
      -gid N            # 查找符合指定之群组识别码的文件或目录；
      -group 名称       # 查找符合指定之群组名称的文件或目录；
      -uid N           # 查找符合用户uid的文件或目录
      -user NAME       # 查找符和指定的拥有者名称的文件或目录
      # 匹配模式使用的是shell的通配符（除了regex）
      -name 匹配模式      # *.py  最好配合*使用，精确指定可能得不到想要的结果
      -regex 匹配模式     # 需要较多的转义，请看后面的例子
      -path 匹配模式      # 与name很像，必须配合*使用，指定字符串作为寻找目录的范本样式，只要目录中包含匹配的模式，就输出
      -perm [+-]访问模式  # 查找符合指定的权限数值的文件或目录;
      -lname 匹配模式     # 查找是符号链接的文件，并且其内容匹配模式
      -newer 文件或目录    # 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录;
      # 忽略字符大小写的差别
      -iname 匹配模式 -ipath 匹配模式 -iregex 匹配模式   -ilname 匹配模式

      -links N           # 查找符合指定的硬连接数目的文件或目录；
      -inum N            # 查找符合指定的inode编号的文件或目录；

      -nouser -nogroup   # 找出不属于本地主机[用户识别码/群组识别码]的文件或目录;
      -noleaf            # 不去考虑目录至少需拥有两个硬连接存在；
      # 可读写执行
      -readable -writable -executable

      -wholename PATTERN  # TODO
      -size N[bcwkMG] # 查找符合指定的文件大小的文件;

      -type [bcdpflsD] # 只寻找符合指定的文件类型的文件；
      -used N    # 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算;

      -xtype [bcdpfls] # 和指定“-type”参数类似，差别在于它针对符号连接检查。

动作: -delete 
      -print   # 若回传值为Ture，就将符合的文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串;
      -print0  # 回传值为Ture，就将符合的文件或目录名称列出到标准输出。格式为全部的名称皆在同一行;
      -printf FORMAT # 回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定;
      -fprintf FILE FORMAT  # 此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；
      -fprint0 FILE         # 指定“-print0”参数类似，但会把结果保存成指定的列表文件；
      -fprint FILE          # 和指定“-print”参数类似，但会把结果保存成指定的列表文件；
      -ls                     # 对符合条件的文件或目录执行ll命令，显示详细信息
      -fls FILE             # 和指定“-ls”参数类似，但会把结果保存为指定的列表文件；
      -prune                # 不打印符合条的文件或目录
      -quit

      # 执行的命令不支持你自定义的alias
      -exec COMMAND {} \;       # find指令的回传值为True，就执行该指令;
      -ok COMMAND {} \;         # 与-exec相似，但是会给出提示，是否执行相应的操作。
      -exec COMMAND {} + -ok COMMAND ; # {}是一个占位符，用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名
      -execdir COMMAND ; 
      -execdir COMMAND {} + -okdir COMMAND ;
</code></pre>
<p>在<code>/home</code>目录下查找以.txt结尾的文件名</p>
<pre><code>find /home -name &quot;*.txt&quot;
</code></pre><p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p>
<pre><code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;
</code></pre><p>匹配文件路径或者文件</p>
<pre><code>find /usr/ -path &quot;*local*&quot;
</code></pre><p>name与path的区别</p>
<pre><code>$ find . -ipath &quot;*match*&quot;
./bin/match
./bin/match/match.py
./data/match_result.txt
./data/match
./data/match/20190910   # 这一行的差别
./data/match/20190910/match_result_20190910.txt
./data/match_result_20190910.txt

$ find . -iname &quot;*match*&quot;
./bin/match
./bin/match/match.py
./data/match_result.txt
./data/match
./data/match/20190910/match_result_20190910.txt
./data/match_result_20190910.txt
</code></pre><p>基于正则表达式匹配文件路径</p>
<pre><code>find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;
</code></pre><p><strong>否定参数</strong></p>
<p>找出/home下不是以.txt结尾的文件</p>
<pre><code>find /home ! -name &quot;*.txt&quot;
</code></pre><p>类型参数列表：</p>
<ul>
<li><strong>f</strong> 普通文件</li>
<li><strong>l</strong> 符号连接</li>
<li><strong>d</strong> 目录</li>
<li><strong>c</strong> 字符设备</li>
<li><strong>b</strong> 块设备</li>
<li><strong>s</strong> 套接字</li>
<li><strong>p</strong> Fifo</li>
</ul>
<p>UNIX/Linux文件系统每个文件都有三种时间戳：</p>
<ul>
<li><strong>访问时间</strong>（-atime/天，-amin/分钟）：用户最近一次访问时间。</li>
<li><strong>修改时间</strong>（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</li>
<li><strong>变化时间</strong>（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</li>
</ul>
<p>搜索最近七天内被访问过的所有文件</p>
<pre><code>find . -type f -atime -7
</code></pre><p>搜索恰好在七天前被访问过的所有文件</p>
<pre><code>find . -type f -atime 7
</code></pre><p>搜索超过七天内被访问过的所有文件</p>
<pre><code>find . -type f -atime +7
</code></pre><p>搜索访问时间超过10分钟的所有文件</p>
<pre><code>find . -type f -amin +10
</code></pre><p>找出比<a href="http://man.linuxde.net/file" target="_blank" rel="noopener">file</a>.log修改时间更长的所有文件</p>
<pre><code>find . -type f -newer file.log
</code></pre><p><strong>根据文件大小进行匹配</strong></p>
<pre><code>find . -type f -size 文件大小单元
</code></pre><p>文件大小单元：</p>
<ul>
<li><strong>b</strong> —— 块（512字节）</li>
<li><strong>c</strong> —— 字节</li>
<li><strong>w</strong> —— 字（2字节）</li>
<li><strong>k</strong> —— 千字节</li>
<li><strong>M</strong> —— 兆字节</li>
<li><strong>G</strong> —— 吉字节</li>
</ul>
<p>搜索大于10KB的文件</p>
<pre><code>find . -type f -size +10k
</code></pre><p>搜索小于10KB的文件</p>
<pre><code>find . -type f -size -10k
</code></pre><p>搜索等于10KB的文件</p>
<pre><code>find . -type f -size 10k
</code></pre><p><strong>删除匹配文件</strong></p>
<p>删除当前目录下所有.txt文件</p>
<pre><code>find . -type f -name &quot;*.txt&quot; -delete
</code></pre><p><strong>根据文件权限/所有权进行匹配</strong></p>
<p>当前目录下搜索出权限为777的文件</p>
<pre><code>find . -type f -perm 777
</code></pre><p>找出当前目录下权限不是644的<a href="http://man.linuxde.net/php" target="_blank" rel="noopener">php</a>文件</p>
<pre><code>find . -type f -name &quot;*.php&quot; ! -perm 644
</code></pre><p>找出当前目录用户tom拥有的所有文件</p>
<pre><code>find . -type f -user tom
</code></pre><p>找出当前目录用户组sunk拥有的所有文件</p>
<pre><code>find . -type f -group sunk
</code></pre><p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p>
<pre><code>find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print
</code></pre><p>要列出所有长度为零的文件</p>
<pre><code>find . -empty
</code></pre><p><strong>执行命令相关</strong></p>
<p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p>
<pre><code>find . -type f -name &quot;*.txt&quot; -exec cat {} \;&gt; all.txt
</code></pre><p>将30天前的.log文件移动到old目录中</p>
<pre><code>find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp {} old \;
</code></pre><p>单行命令中-exec参数中无法使用多个命令，可以将多条命令保存在shell文件中，在-exec执行该文件</p>
<pre><code>-exec ./text.sh {} \;
</code></pre><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。例如： <code>grep -i &#39;hello world&#39; menu.h main.c</code></p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><pre><code class="bash">grep pattern filename  # 默认支持正则
grep -e pattern1 -e pattern2 filename
</code></pre>
<p>默认情况下，grep命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。</p>
<p>需要注意的是：限定连续字符范围 的<code>{}</code>符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 <code>\{</code> 与<code>\}</code> 来让它失去特殊意义才行。</p>
<pre><code class="bash">grep --color=auto &quot; 在输出行中着重标记出匹配到的模式

-a # 将 binary 文件以 text 文件的方式搜寻数据
-e # 指定字符串做为查找文件内容的样式（非正则）。如果要指定多个匹配模式，可用-e参数来指定每个模式,grep -e t -e f file 输出了含有字符t或字符f的所有行。
-E # 将字符串为延伸的正则表达式来使用
-o # 只输出匹配到的文本，如果在同一行中，会分开显示
-v # 打印出不匹配match_pattern的所有行
-c # 统计匹配行的数量，并不是匹配的次数。匹配次数需要与-o配合，请看后面的例子
-n # 打印出匹配字符串所在行的行号,以及该行的内容，如果涉及多个文件，该选项也会随输出结果打印出文件名
-i # 忽略模式中的大小写
-l # 多文件处理时，可以列出匹配模式所在的文件
-L # 与-l相反，它会返回一个不匹配的文件列表
-q # 静默模式（主要用于脚本中，，在命令行中没什么用），只判断是否匹配成功,不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。0表示匹配成功，非0表示匹配失败。
-r # 递归搜索当前目录和子目录
-w # 匹配整个英文单词，对中文不管用
-x # 匹配整行，比较两个文件不同行时使用

-f # 从文件中读取匹配模式，一行一个模式

# 显示前后几行
-A # after，显示匹配到的行以及之后的 n 行
-B # before，显示匹配到的行以及之前的 n 行
-C # Center，显示匹配到的行以及前后的 n 
# 如果匹配到多行，为了区分匹配到的字符串，用&quot;--&quot;进行区分，比如：
echo -e &quot;a\nb\nc\na\nb\nc&quot; | grep a -A 1
# a        匹配到第1次
# b
# --
# a        匹配到第2次
# c
</code></pre>
<p>统计匹配项的数量</p>
<pre><code>echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l
</code></pre><pre><code>正则表达式选择与解释:
  -E, --extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)
  -F, --fixed-strings       PATTERN 是一组由断行符分隔的定长字符串。
  -G, --basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)
  -P, --perl-regexp         PATTERN 是一个 Perl 正则表达式
  -e, --regexp=PATTERN      用 PATTERN 来进行匹配操作
  -f, --file=FILE           从 FILE 中取得 PATTERN
  -i, --ignore-case         忽略大小写
  -w, --word-regexp         强制 PATTERN 仅完全匹配字词
  -x, --line-regexp         强制 PATTERN 仅完全匹配一行
  -z, --null-data           一个 0 字节的数据行，但不是空行

杂项:
  -s, --no-messages         不显示错误信息
  -v, --invert-match        选中不匹配的行
  -V, --version             显示版本信息并退出
      --help                显示此帮助并退出
      --mmap                忽略向后兼容性

输出控制:
  -m, --max-count=NUM       NUM 次匹配后停止
  -b, --byte-offset         输出行的同时打印字节偏移
  -n, --line-number         输出行的同时打印行号
      --line-buffered       每行输出清空
  -H, --with-filename       为每一匹配项打印文件名
  -h, --no-filename         输出时不显示文件名前缀
      --label=LABEL         标准输入将LABEL 打印为文件名
  -o, --only-matching       只显示一行中匹配PATTERN 的部分
  -q, --quiet, --silent     不显示所有输出
      --binary-files=TYPE   假定二进制文件的TYPE 类型；
                            TYPE 可以是`binary&#39;, `text&#39;, 或`without-match&#39;
  -a, --text                等同于 --binary-files=text
  -I                        等同于 --binary-files=without-match
  -d, --directories=ACTION  操作目录的方式；
                            ACTION 可以是`read&#39;, `recurse&#39;,或`skip&#39;
  -D, --devices=ACTION      操作设备、先入先出队列、套接字的方式；
                            ACTION 可以是`read&#39;或`skip&#39;
  -r, --recursive       等同于 --directories=recurse
  -R --dereference-recursive  likewise, but follow all symlinks
      --include=FILE_PATTERN  只查找匹配FILE_PATTERN 的文件
      --exclude=FILE_PATTERN  跳过匹配FILE_PATTERN 的文件和目录
      --exclude-from=FILE   跳过所有除FILE 以外的文件
      --exclude-dir=PATTERN  跳过所有匹配PATTERN 的目录。
  -L, --files-without-match  只打印不匹配FILEs 的文件名
  -l, --files-with-matches  只打印匹配FILES 的文件名
  -c, --count               只打印每个FILE 中的匹配行数目
  -T, --initial-tab         行首tabs 分隔（如有必要）
  -Z, --null                在FILE 文件最后打印空字符

文件控制:
  -B, --before-context=NUM  打印以文本起始的NUM 行
  -A, --after-context=NUM   打印以文本结尾的NUM 行
  -C, --context=NUM         打印输出文本NUM 行
  -NUM                      等同于 --context=NUM
      --color[=WHEN],
      --colour[=WHEN]       使用标志高亮匹配字串；
                            WHEN 可以是`always&#39;, `never&#39;或`auto&#39;
  -U, --binary              不要清除行尾的CR 字符(MSDOS 模式)
  -u, --unix-byte-offsets   当CR 字符不存在，报告字节偏移(MSDOS 模式)
</code></pre><h4 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h4><p>egrep命令是grep的一个衍生，支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更 多的可以用来指定匹配模式的字符，增加了额外的正则表达式元字符集。</p>
<pre><code class="bash">grep -E &quot;[a-z]+&quot; filename
#或
egrep &quot;[a-z]+&quot; filename
</code></pre>
<h4 id="不使用正则表达式"><a href="#不使用正则表达式" class="headerlink" title="不使用正则表达式"></a>不使用正则表达式</h4><pre><code>grep -F &#39;str&#39;
fgrep &#39;str&#39; 
</code></pre><p><code>fgrep</code> 查询速度比<code>grep</code>命令快，但是不够灵活：它<strong>只能找固定的文本，而不是正则表达式。</strong></p>
<p>如果你想在一个文件或者输出中找到包含星号字符的行</p>
<pre><code class="bash">fgrep  &#39;*&#39; /etc/profile
#或
grep -F &#39;*&#39; /etc/profile
</code></pre>
<p>fgrep则是另外一个版本，支持将匹配模式 指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后 在fgrep命令中用其在一个大型文件中搜索字符串了。</p>
<h4 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h4><h5 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h5><p>命令会打印出匹配任意一种模式的行，每个匹配对应一行输出。例如：</p>
<pre><code class="bash">echo this is a line of text | grep -o -e &quot;this&quot; -e &quot;line&quot; this
</code></pre>
<h5 id="从文件中读取匹配模式"><a href="#从文件中读取匹配模式" class="headerlink" title="从文件中读取匹配模式"></a>从文件中读取匹配模式</h5><p>可以将多个模式定义在文件中。选项<code>-f</code>可以读取文件并使用其中的模式（一个模式一行，记得最后留一行空白行，不然最后一种模式匹配不到，很诡异）</p>
<pre><code class="bash">cat pat_file
# ^h.*
# co+l
# 
echo hello \n this is cool | grep -f pat_file 
# hello 
# this is cool
</code></pre>
<h5 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h5><p>grep 本身并不支持，所以需要通过管道符号或者与 find 组合使用</p>
<h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><h5 id="检索文件内容"><a href="#检索文件内容" class="headerlink" title="检索文件内容"></a>检索文件内容</h5><p>递归搜索目录中的文件内容（不是文件名）<code>-</code>，<strong>注意</strong>：支持相对路径、绝对路径，但<strong>不支持<code>~/work/</code>这样的路径</strong>。</p>
<pre><code>grep &quot;查找内容&quot;  目录  -r -n  --include=*.{py,sh} --exclude=*.{log,txt}  --exclude-dir={log,tmp,config} --exclude-from BLACK_LIST 
</code></pre><ul>
<li><p><code>--include</code> 指定搜索的文件类型或者某个文件，比如<code>*.sh</code>，<code>*.py</code>，可以使用GLOB写法，如<code>*.{py,sh}</code></p>
</li>
<li><p><code>--exclude</code> 指定不想搜索的文件类型或者某个文件，比如<code>*.txt</code>，<code>bigdata.txt</code> ,可以使用GLOB写法，如<code>*.{txt,log}</code></p>
</li>
<li><p><code>--exclude-dir</code>可以排除不想搜索的目录，多个目录时请用<code>{a,b,c}</code></p>
</li>
<li><p><code>--exclude-from BLACK_LIST</code>从黑名单文件中读取要排除文件列表</p>
</li>
</ul>
<p>例子：</p>
<pre><code class="bash">grep &quot;TODO&quot; ./ -r -n  --include=*.{sh,py}  --exclude-dir={tmp,logs}

# ./src/test.c:16:TODO 添加注释; 
</code></pre>
<p>等价于<code>find . -type f | xargs grep &quot;test_function()&quot;</code></p>
<h5 id="0值字节后缀的-xargs"><a href="#0值字节后缀的-xargs" class="headerlink" title="0值字节后缀的 xargs"></a>0值字节后缀的 xargs</h5><p>xargs命令可以为其他命令提供命令行参数列表。</p>
<p>当文件名作为命令行参数时，建议用0值字节作为文件名终结符，而非空格。因为一些文件名中会包含空格字符，一旦它被误解为终结符， 那么单个文件名就会被视为两个（例如，New file.txt被解析成New和file.txt两个文件名）。</p>
<p>这个问题可以利用0值字节后缀来避免。</p>
<p>grep和find命令可以生成带有0值字节后缀的输出，然后传递 给 xargs，让它产生文件名列表。为了指明输入中的文件名是以0值字节作为终结，需 要在xargs中使用选项-0。</p>
<pre><code class="bash"># 创建测试文件：
echo &quot;test&quot; &gt; file1  
echo &quot;cool&quot; &gt; file2 
echo &quot;test&quot; &gt; file3

# 找出包含有 test 内容的文件名，并以0值字节作为终结符，然后传递给 xargs，让它生成文件名参数列表，之后传递（不用管道符号）给 rm 命令，删除这些文件
grep &quot;test&quot; file* -lZ | xargs -0 rm

# 选项-l告诉grep只输出有匹配出现的文件名。选项-Z使得grep使用0值字节（\0）作为文 件名的终结符。这两个选项通常都是配合使用的。xargs的-0选项会使用0值字节作为输入的分隔符
</code></pre>
<h5 id="比较两个文件相同内容与不同内容"><a href="#比较两个文件相同内容与不同内容" class="headerlink" title="比较两个文件相同内容与不同内容"></a>比较两个文件相同内容与不同内容</h5><p>输出file2中不含file1的内容</p>
<pre><code class="bash">grep -Ff  file1 file2   # 输出公共的行
grep -vFf  file1 file2   # 输出不在 file1 的行
grep -xvFf file1.txt file2.txt &gt; result.tx
</code></pre>
<p> <code>-x, --line-regexp</code>    强制 PATTERN 仅完全匹配一行</p>
<h5 id="查找满足条件的文件是否匹配到文字"><a href="#查找满足条件的文件是否匹配到文字" class="headerlink" title="查找满足条件的文件是否匹配到文字"></a>查找满足条件的文件是否匹配到文字</h5><p>查找包含”hello world”的文件清单，并从这些清单中查找出满足”mailx”的匹配情况</p>
<pre><code class="shell">#方法1：直接利用管道
grep -i &quot;hello world&quot; -rl /home/tyrone | xargs grep -i &quot;mailx&quot;

#输出结果
/home/tyrone/test1.txt:mailx


#方法2：使用find，适合于需要灵活判断条件的场景。例如查找指定路径下，同时匹配多个模式的txt文件。
#注意：本例中“mailx”后面的命令必须加上反引号 ` ，否则会被当作要查询的文件名。
grep -i &quot;mailx&quot; `find /home/tyrone -type f -name &quot;*.txt&quot; -exec grep -l &quot;hello world&quot;  {} \;`

#输出结果
/home/tyrone/test1.txt:mailx


#方法3:同2
find /home/tyrone -name &quot;*.txt&quot; -exec grep -l &quot;hello world&quot; {} \; | xargs grep -i &quot;mailx&quot;

#输出结果
/home/tyrone/test1.txt:mailx
</code></pre>
<h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>tr是translate（转换）的简写，基本功能是将字符从一个字符集合映射到另一个集合中</p>
<pre><code>tr set1 set2
</code></pre><blockquote>
<p>  注意： <code>tr</code>只能通过<code>stdin</code> 接收输入，无法通过命令行参数接收 ，如<code>tr -s &#39;&#39; file</code>，只能转为 <code>stdin</code> 形式，<code>tr -s &#39; &#39;&lt; file.txt</code></p>
</blockquote>
<p>如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1 相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p>
<pre><code>echo &quot;HELLO WHO IS THIS&quot; | tr &#39;A-Z&#39; &#39;a-z&#39;
</code></pre><p>字符集合（字符组）可以使用“起始字符—终止字符”，如果不是有效的连续字符序列， 那么它就会被视为<code>起始字符</code>、<code>—</code>、<code>终止字符</code>这3个元素的集合。也可以使用像<code>\t</code>、<code>\n</code> 这种特殊字符或其他ASCII字符。可以按照需要追加字符或<strong>字符类</strong>来构造自己的字符组。</p>
<table>
<thead>
<tr>
<th>字符类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alnum</td>
<td>字母和数字</td>
</tr>
<tr>
<td>alpha</td>
<td>字母</td>
</tr>
<tr>
<td>cntrl</td>
<td>控制（非打印）字符</td>
</tr>
<tr>
<td>digit</td>
<td>数字</td>
</tr>
<tr>
<td>graph</td>
<td>图形字符</td>
</tr>
<tr>
<td>lower</td>
<td>小写字母</td>
</tr>
<tr>
<td>print</td>
<td>可打印字符</td>
</tr>
<tr>
<td>punct</td>
<td>标点符号</td>
</tr>
<tr>
<td>space</td>
<td>空白字符</td>
</tr>
<tr>
<td>upper</td>
<td>大写字母</td>
</tr>
<tr>
<td>xdigit</td>
<td>十六进制字符</td>
</tr>
</tbody>
</table>
<p>字符类的使用方法<code>tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code></p>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><pre><code>tr [options] set1  [set2]
-d     # 删除(delete)set1 中的字符
-c     # tr会将不在set1中的字符转换成set2中的字符,set2只能是一个字符
-d -c  # 只保留set1的字符，不需要set2
-s     # 删除重复字符，只留下一个
</code></pre><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>tr命令可以用来加密。ROT13是一个著名的加密算法。在ROT13算法中，字符会被移动13 个位置，因此文本加密和解密都使用同一个函数：</p>
<pre><code class="bash">echo &quot;tr came, tr saw, tr conquered.&quot; | tr &#39;a-zA-Z&#39; &#39;n-za-mN-ZA-M&#39;
</code></pre>
<p>将制表符转换成单个空格：</p>
<pre><code class="bash">tr &#39;\t&#39; &#39; &#39; &lt; file.txt
</code></pre>
<p> 删除字符</p>
<pre><code>echo &quot;Hello 123 world 456&quot; | tr -d &#39;0-9&#39; 
# Hello world
</code></pre><p>只保留set1 的字符</p>
<pre><code>echo hello 1 char 2 next 4 | tr -d -c &#39;0-9 \n&#39;
# 124
</code></pre><p>压缩空格</p>
<pre><code>echo &quot;GNU  is   not     UNIX.     Recursive       GNU is not UNIX. Recursive right ?&quot; | tr -s &#39; &#39;
</code></pre><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、 CSV文件或是由空格分隔的文件。</p>
<blockquote>
<p>  如果空格的长度不一致，需要使结合<code>tr</code>命令，进行字符串转换</p>
</blockquote>
<p>每列被称为一个<strong>字段</strong>，默认分隔符是制表符<code>\t</code></p>
<pre><code>-d&quot;\t&quot;    # 指定分割符为&quot;\t&quot;，默认就是制表符，因此可以不写
-f2,3     # 显示2,3列的内容,f2可以不用空格分开
-f2-4     # 显示第2到4列(field)的内容，2-5 的用法看后面表格说明
-c2-5     # 显示第2到5个字符(character)，注意不能与-d 组合
-b2-5     # 显示第2到5个字节(byte)，注意不能与-d 组合
--complement # 与-f 组合使用，显示f没有指定的列，就是取反
--output-delimiter    指定输出时的列分隔符
</code></pre><pre><code class="bash">cut range_fields.txt -c1-3,6-9 --output-delimiter &quot;,&quot; 
# abc,fghi 
# abc,fghi 
# abc,fghi 
# abc,fghi
</code></pre>
<table>
<thead>
<tr>
<th>选取方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>N-</td>
<td>从第N个字节、字符或字段开始到行尾</td>
</tr>
<tr>
<td>N-M</td>
<td>从第N个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</td>
</tr>
<tr>
<td>-M</td>
<td>从第1个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</td>
</tr>
</tbody>
</table>
<pre><code class="bash">cut -c -2 range_fields.txt    # 打印前2个字符
cut -c2-5 range_fields.txt    # 打印第2个到第5个字符
</code></pre>
<h3 id="文件分割-split"><a href="#文件分割-split" class="headerlink" title="文件分割 split"></a>文件分割 split</h3><pre><code class="shell">split  [options] filename prefix.
</code></pre>
<p>将文件分割成固定大小（bytes）或者固定行数的小文件，原文件不动，小文件为<code>prefix.aa prefix.ab</code>等形式，前缀后面最好要有<code>.</code>，如<code>file.</code></p>
<pre><code>-d    使用数字后缀，file.01 file.02，默认为字符后缀
-l    指定每个输出文件多少行内容，最后一个文件可能会小于n
-b, --bytes=SIZE  指定每个输出文件的大小，如-b100K,大小可以是 KB、MB，GB
-C，--line-bytes=SIZE  TODO
-a    指定后缀长度，默认是2，不指定时程序会自适应
--verbose  显示创建文件的信息
</code></pre><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed是stream editor（流编辑器）的缩写。它最常见的用法是进行文本替换。<strong>默认不修改原文件，只显示修改后的结果。</strong></p>
<pre><code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]

-e &#39;script1;script2&#39;
-f script_file # 从文本中读取大量指令，一行一个，以换行结束
-i # 保存到原文件
-n或--quiet或--silent # 仅显示script处理后的结果。
</code></pre><p>要是我们想就地（in place）修改文件内容，可以使用选项<code>-i</code>保存到原文件中。值得<strong>推荐的做法</strong>是</p>
<ul>
<li><p>先使用不带<code>-i</code>选项的<code>sed</code>命令，以确保正则表达式没有问题，如果结果符合要求，再加入-i选项将更改写入文件。</p>
</li>
<li><p>也可以使用<code>sed -i.bak &#39;s/abc/def/&#39; file</code>，这时的sed不仅替换文件内容，还会创建一个名为<code>file.bak</code>的文件，其中包含着原始文件内容的副本。</p>
</li>
</ul>
<h4 id="替换s"><a href="#替换s" class="headerlink" title="替换s"></a>替换<code>s</code></h4><pre><code>s/old/new/          # 替换每行第1个匹配到的字符串
s/old/new/2         # 替换每行第2个匹配到的字符串
s/old/new/g         # 替换全部
s/old/new/2g        # 只替换第2次及之后匹配到的字符串
</code></pre><pre><code class="bash">echo thisthisthisthis | sed &#39;s/this/THIS/2g&#39; 
# thisTHISTHISTHIS 
</code></pre>
<h5 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h5><pre><code>s/pattern/replacement/flags
</code></pre><p>有4种可用的替换标记： </p>
<ul>
<li>数字，表明新文本只替换每行第几处模式匹配的地方； </li>
<li>g，表明新文本将会替换所有匹配的文本； </li>
<li>p，表明原先行的内容要打印出来；</li>
<li>w file，将匹配到的行替换的结果写到指定的file中。</li>
</ul>
<p>p替换标记会打印与替换命令中指定的模式匹配的行替换后的结果。这通常会和sed的-n选项一起使用。-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是 只输出被替换命令修改过的行。</p>
<pre><code class="bash">$ cat data5.txt 
This is a test line.
This is a different line.

$ sed -n &#39;s/test/trial/p&#39; data5.txt 
This is a trial line.
</code></pre>
<p>w替换标记会产生与 p 模式同样的输出，不过会将输出保存到指定文件中。</p>
<h5 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h5><p><code>sed</code>命令会将<code>s</code>之后的字符视为命令分隔符。这允许我们更改默认的分隔符<code>/</code>：</p>
<pre><code>sed &#39;s:text:replace:g&#39; 
sed &#39;s|text|replace|g&#39;
</code></pre><p>如果作为分隔符的字符出现在模式中，必须使用<code>\</code>对其进行转义</p>
<h5 id="指定行"><a href="#指定行" class="headerlink" title="指定行"></a>指定行</h5><p>方式1（数字）：</p>
<p>在<code>s</code>前添加行编辑即可</p>
<pre><code class="bash">sed &#39;2s/dog/cat/&#39; data1.txt   # 只修改地址指定的第2行的文本
sed &#39;2,3s/dog/cat/&#39; data1.txt # 只修改地址指定的第2，3行的文本
sed &#39;2,$s/dog/cat/&#39; data1.txt # 修改从某行开始的所有行
</code></pre>
<p>方式2（正则）：</p>
<pre><code class="bash">sed &#39;/pattern/s/bash/csh/&#39; /etc/passwd  # 使用 pattern 正则表达式过滤
</code></pre>
<p><strong>已匹配字符串标记（<code>&amp;</code>）</strong></p>
<p>在sed中，我们可以用&amp;指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹 配的内容：</p>
<pre><code>echo this is an example | sed &#39;s/\w+/[&amp;]/g&#39;
# [this] [is] [an] [example]
</code></pre><p><strong>子串匹配标记（\num）</strong></p>
<p> 匹配正则中的子表达式，第1 个是<code>\1</code>，第 2 个是<code>\2</code>，以此类推</p>
<pre><code>echo this is digit 7 in a number | sed &#39;s/digit \([0-9]\)/\1/&#39; 
# this is 7 in a number
</code></pre><p><strong>多表达式</strong></p>
<pre><code class="bash">sed &#39;expression; expression&#39;
sed &#39;expression&#39; | sed &#39;expression&#39;
sed -e &#39;expression&#39; -e &#39;expression&#39;
sed -e &#39;expression; expression&#39;
sed -e &#39;
&gt; s/brown/green/
&gt; s/fox/elephant/
&gt; s/dog/cat/&#39; data1.txt
</code></pre>
<p>例子</p>
<pre><code>echo abc | sed &#39;s/a/A/;s/c/C/&#39;
echo abc | sed &#39;s/a/A/&#39; | sed &#39;s/c/C/&#39;
echo abc | sed -e &#39;s/a/A/&#39; -e &#39;s/c/C/&#39;
echo abc | sed -e &#39;s/a/A/; s/c/C/&#39;
# AbC
</code></pre><p><strong>单引号与双引号的区别</strong></p>
<p>sed表达式<strong>通常用单引号来引用</strong>。如果想在sed表达式中使用变量，双引号就能派上用场了。</p>
<pre><code>text=hello 
echo hello world | sed &quot;s/$text/HELLO/&quot; 
# HELLO world
</code></pre><h4 id="多命令"><a href="#多命令" class="headerlink" title="多命令"></a>多命令</h4><p>如果需要在匹配到的行上执行多条命令，可以用<code>{}</code>将多条命令组合在一起，同时指定过滤的行号，或者匹配模式。</p>
<p>多条命令之间用<code>;</code>分割，或者分成多行书写。</p>
<pre><code class="bash"># 一行内多个命令
sed -n &#39;/root/{s/bash/blueshell/;p;q}&#39; /etc/passwd 

# 分成多行执行多个命令
sed &#39;3,${
&gt; s/brown/green/
&gt; s/lazy/active/
&gt; }&#39; data1.txt
</code></pre>
<h4 id="插入a与i"><a href="#插入a与i" class="headerlink" title="插入a与i"></a>插入<code>a</code>与<code>i</code></h4><pre><code class="bash">sed &#39;[address]command\
new line&#39;
</code></pre>
<p>插入（insert）命令（i）会在指定行前插入文本，（插入的文本要带有换行，否则就直接插入在指定行的头部）</p>
<p>附加（append）命令（a）会在指定行后添加文本，（如果文本没换行，会与下一行在同一行）</p>
<p>可以指定一个行地址，匹配一个数字行号或文本模式</p>
<blockquote>
<p>  这两条命令的费解之处在于它们的格式。它们不能在一行内使用。你必须先输入<code>i</code>或者<code>a</code>，然后使用<code>\</code>进行换行，接着输入要插入或者附加的内容。</p>
</blockquote>
<pre><code class="bash"># 脚本中的写法
$ echo &quot;Test Line 2&quot; | sed &#39;1i\   # 在第一行前插入
Test Line 1\     # 换行，否则两行文本会在一同一行
&#39; 
Test Line 1 
Test Line 2

$ echo &quot;Test Line 2&quot; | sed &#39;/Line/a\   # 在包含Line的一行添加
Test Line 1\
&#39; 

Test Line 2 
Test Line 1
</code></pre>
<h5 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h5><p>插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后 一行。</p>
<pre><code class="bash">sed &#39;1i\
&gt; This is one line of new text.\
&gt; This is another line of new text.&#39; data6.txt 

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
</code></pre>
<h4 id="删除行-d"><a href="#删除行-d" class="headerlink" title="删除行 d"></a>删除行 <code>d</code></h4><p>删除命令<code>d</code>名副其实，它会删除匹配指定寻址模式的所有行。</p>
<p>支持指定行<code>sed &#39;2,3d&#39; data6.txt</code></p>
<p>通过特定行区间指定：<code>sed &#39;2,3d&#39; data6.txt</code></p>
<p>模式匹配特性也适用于删除命令<code>sed &#39;/number 1/d&#39; data6.txt</code></p>
<p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。</p>
<ul>
<li>sed编辑器会删除两个指定行之间 的所有行（包括指定的行）。<strong>如果没有找到停止模式，所以就将数据流中的剩余行全部删除了。</strong></li>
<li>你指定的第1个模式 会“打开”行删除功能，第2个模式会“关闭”行删除功能。之后<strong>再遇到第1个模式会再打开删除功能</strong>。</li>
</ul>
<pre><code class="bash">$ cat data7.txt 
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
This is line number 1 again.   # 再次触发删除功能
This is text you want to keep. 
This is the last line in the file. 

$ sed &#39;/1/,/3/d&#39; data7.txt 
This is line number 4.
</code></pre>
<h4 id="字符转换y"><a href="#字符转换y" class="headerlink" title="字符转换y"></a>字符转换<code>y</code></h4><p>转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。</p>
<pre><code>[address]y/inchars/outchars/
</code></pre><pre><code class="bash">sed &#39;y/123/789/&#39; data8.txt 
This is line number 7.
This is line number 8.
This is line number 9.
This is line number 4.
This is line number 7 again.
This is yet another line.
This is the last line in the file. 
</code></pre>
<p>转换命令会对inchars和outchars值进行一对一的映射。</p>
<p>如果inchars和outchars的长度不同，则sed编辑器会产生一 条错误消息。</p>
<p>转换命令是一个全局命令，你无法限定只转换在特定地方出现的字符。</p>
<h4 id="打印命令"><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h4><ol>
<li>p命令用来打印文本行； </li>
<li>等号（=）命令用来打印行号； </li>
<li>l（小写的L）命令用来列出行。</li>
</ol>
<h5 id="p-命令"><a href="#p-命令" class="headerlink" title="p 命令"></a>p 命令</h5><pre><code class="bash">echo &quot;this is a test&quot; | sed &#39;p&#39;
this is a test
this is a test
</code></pre>
<p>它所做的就是打印已有的数据文本</p>
<p>最常见的用法是与<code>-n</code>配合打印包含匹配文本模式的行。用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。</p>
<pre><code>$ cat data6.txt 
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.

$ $ sed -n &#39;/number 3/p&#39; data6.txt 
This is line number 3.
</code></pre><p>修改前后对比</p>
<pre><code class="bash">$ sed -n &#39;/3/{
&gt; p
&gt; s/line/test/p
&gt; }&#39; data6.txt 
This is line number 3. 
This is test number 3. $
</code></pre>
<h5 id="等号"><a href="#等号" class="headerlink" title="=等号"></a><code>=</code>等号</h5><p>等号命令会打印行在<strong>数据流中的当前行号</strong>。</p>
<pre><code>sed &#39;=&#39; data1.txt 
1 
The quick brown fox jumps over the lazy dog.
2 
The quick brown fox jumps over the lazy dog.
</code></pre><pre><code class="bash">$ sed -n &#39;/number 4/{
&gt; =
&gt; p
&gt; }&#39; data6.txt 4 
This is line number 4. 
</code></pre>
<h5 id="显示特殊字符l"><a href="#显示特殊字符l" class="headerlink" title="显示特殊字符l"></a>显示特殊字符<code>l</code></h5><p>命令（<code>l</code>）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印 字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\t，来代表制表符。</p>
<p>制表符的位置使用\t来显示。行尾的美元符表示换行符。</p>
<pre><code class="bash">$ cat data10.txt 
This line contains an escape    character.

$ sed -n &#39;l&#39; data10.txt 
This line contains an escape\tcharacter. \a
</code></pre>
<h4 id="保存命令w"><a href="#保存命令w" class="headerlink" title="保存命令w"></a>保存命令<code>w</code></h4><p>w命令用来向文件写入行。该命令的格式如下：</p>
<pre><code>[address]w filename
</code></pre><p><code>filename</code>可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文 件的写权限。</p>
<p>地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</p>
<pre><code class="bash">$ cat data11.txt 
Blum, R Browncoat 
McGuiness, A Alliance
Bresnahan, C Browncoat 
Harken, C Alliance 

$ sed -n &#39;/Browncoat/w Browncoats.txt&#39; data11.txt 

$ cat Browncoats.txt 
Blum, R Browncoat 
Bresnahan, C Browncoat
</code></pre>
<h4 id="读取命令"><a href="#读取命令" class="headerlink" title="读取命令"></a>读取命令</h4><p>读取（read）命令（r）允许你将另一个文件中的数据插入到数据流中。</p>
<pre><code>[address]r filename
</code></pre><p>地址区间<strong>只能指定单独一个行号或文本模式地址</strong>。sed编辑器会将文件中的<strong>所有文本行</strong>插入到指定地址后。</p>
<pre><code class="bash">$ cat data12.txt 
This is an added line.
This is the second added line. 

$ sed &#39;3r data12.txt&#39; data6.txt 
This is line number 1.
This is line number 2.
This is line number 3.
This is an added line.
This is the second added line. 
This is line number 4.

$ sed &#39;/number 2/r data12.txt&#39; data6.txt 
This is line number 1.
This is line number 2.
This is an added line.
This is the second added line.
This is line number 3.
This is line number 4.
</code></pre>
<p>另一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。</p>
<pre><code class="bash">$ cat notice.std 
Would the following people:
LIST 
please report to the ship&#39;s captain. 

$ sed &#39;/LIST/{
&gt; r data11.txt
&gt; d
&gt; }&#39; notice.std 
Would the following people:
Blum, R Browncoat 
McGuiness, A Alliance 
Bresnahan, C Browncoat 
Harken, C Alliance 
please report to the ship&#39;s captain. $

现在占位文本已经被替换成了数据文件中的名单。
</code></pre>
<h3 id="Join-字段合并"><a href="#Join-字段合并" class="headerlink" title="Join 字段合并"></a>Join 字段合并</h3><p>根据指定的字段 拼接两个文件。前提是2个文件中指定的拼接字段是排序过的。</p>
<p>拼接字典默认是第一列，可以通过以下方式修改：</p>
<ul>
<li><p><code>-12</code>表示第一个文件使用第2个字段进行拼接。</p>
</li>
<li><p><code>-22</code>表示第二个文件使用第2个字段进行拼接。</p>
</li>
</ul>
<pre><code class="bash">cat a
aaa 111
bbb 222

cat b
555 aaa
666 bbb
777 ccc

join -1  -2  a b
</code></pre>
<h3 id="文本编码转换-iconv"><a href="#文本编码转换-iconv" class="headerlink" title="文本编码转换 iconv"></a>文本编码转换 iconv</h3><p>对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv 命令（这个命令支持更高级的Unicode编码）</p>
<pre><code class="shell">iconv -f ISO-8859-1 -t UTF-8  file 
</code></pre>
<h3 id="临时文件-mktemp"><a href="#临时文件-mktemp" class="headerlink" title="临时文件 mktemp"></a>临时文件 mktemp</h3><pre><code>mktemp [-qu][文件名参数]
</code></pre><p><strong>参数</strong>：</p>
<ul>
<li><code>-d</code>     创建临时目录</li>
<li><code>-q</code> 　执行时若发生错误，不会显示任何信息。</li>
<li><code>-u</code> 　暂存文件会在mktemp结束前先行删除，不推荐使用</li>
<li>[文件名参数] 　文件名参数必须是以”自订名称.XXXXXX”的格式，XXX 会被替换为随机字符串。</li>
</ul>
<pre><code class="shell">mktemp jizx.XXX
# jizx.ztI
</code></pre>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>默认情况下，mount命令会输出当前系统上挂载的 设备列表。</p>
<pre><code>mount -t type device directory      # 格式说明
mount -t vfat /dev/sdb1 /media/disk
</code></pre><p><code>umount [directory | device ]</code>，<code>umount</code>命令支持通过设备文件或者挂载点来指定要卸载的设备。</p>
<p>在卸载设备时，系统<strong>提示设备繁忙，无法卸载设</strong>备，可用<code>lsof</code>命令获得使用它的进程信息，在应用中停止使用该设备或停止该进程。</p>
<pre><code>lsof /path/to/device/node
lsof /path/to/mount/point
</code></pre><h3 id="df与-du-TODO"><a href="#df与-du-TODO" class="headerlink" title="df与 du TODO"></a>df与 du TODO</h3><p>df命令很容易发现哪个磁盘的存储空间快没了</p>
<p>du TODO</p>
<p>du命令可以显示某个特定目录（默认情况下是当前目录）的 磁盘使用情况。</p>
<h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><p>压缩命令 linux 命令行与 shell 脚本编程大全 4.33 </p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p><code>file</code> 查看文件类型</p>
<h3 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h3><p>以指定增量从首数开始打印数字到尾数。</p>
<pre><code class="bash">seq [选项]... 尾数
seq [选项]... 首数 尾数
seq [选项]... 首数 增量 尾数
-f, --format=格式 使用 printf 样式的浮点格式
-s, --separator=字符串使用指定字符串分隔数字(默认使用：\n)
-w, --equal-width 在列前添加0，使得宽度相同
</code></pre>
<p>案例：</p>
<pre><code class="bash">$ seq 5
1
2
3
4
5

$ seq 5 8
5
6
7
8

$ seq 5 2 10
5
7
9


$ seq 5 -1 1      # -1 逆序时-1必须存在
5
4
3
2
1
</code></pre>
<h3 id="xarg"><a href="#xarg" class="headerlink" title="xarg"></a>xarg</h3><p>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p>
<p>它能够捕获一个命令的输出，然后传递给另外一个命令。</p>
<p>args 一般是和管道一起使用。</p>
<pre><code>somecommand |xargs  -item  command
</code></pre><p>选项：</p>
<pre><code>-d delim  # 指定分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。
-i 或者-I  # 配合占位符使用，将参数替换到命令的占位符上，对每一个参数，命令都会被执行一次。
                    # 个人理解：因为 xargs 默认将参数放在其他命令的最后，但是像 cp 这种需要在中间的位置时，就可以用-I选项，具体看后面的例子。
-t # 打印 xargs 后面那个命令拼上参数后的完整形式，然后再执行，用于debug
-s # num 指定 xargs 后面那个命令的最大命令行字符数。
-0 # 将 \0 作为定界符。
-p # 当每次执行一个argument的时候询问一次用户。
-L num  # 从标准输入一次读取 num 行送给 command 命令。
-n num  # 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。
</code></pre><p>参数的功能分类：</p>
<ul>
<li><p>如何分割（xargs、xargs -d、xargs -0）</p>
</li>
<li><p>分割后如何划批（xargs -n、xargs -L）</p>
</li>
<li>参数如何传递（xargs -i）。</li>
<li>另外xargs还提供询问交互式处理（-p选项）和预先打印一遍命令的执行情况（-t选项），传递终止符（-E选项）</li>
</ul>
<h4 id="实验文件准备"><a href="#实验文件准备" class="headerlink" title="实验文件准备"></a>实验文件准备</h4><pre><code class="bash">mkdir tmp
cd tmp
rm -fr *
mkdir a b c d test logdir shdir
touch &quot;one space.log&quot;
touch logdir/{1..10}.log
touch shdir/{1..5}.sh
echo &quot;the second sh the second line&quot; &gt; shdir/2.sh 
cat &lt;&lt;eof&gt;shdir/1.sh  
&gt; the first sh
&gt; the second line
&gt; eof
</code></pre>
<h4 id="流程讲解"><a href="#流程讲解" class="headerlink" title="流程讲解"></a>流程讲解</h4><p><strong>先分割，再分批，然后传递到参数位</strong></p>
<h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>管道传递过来的<code>stdin</code>经过<code>xargs</code>处理后的：<strong>将所有空格(多个空格)、制表符和分行符都替换为(一个)空格并压缩到一行上显示，这一整行将作为一个整体，这个整体的所有空格属性继承xargs处理前的符号属性</strong>.</p>
<blockquote>
<p>  如果想要保存制表符、空格等特殊符号，需要将它们用单引号或双引号包围起来，<strong>但是被xargs处理后，一行的整体中单双引号（和反斜线）都会被去掉。</strong></p>
</blockquote>
<h5 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h5><p><strong>文本意义上的符号和标记意义上的符号</strong></p>
<p>在解释xargs和它的各种选项之前，先介绍一个贯穿xargs命令的符号分类：文本意义上的空格、制表符、反斜线、引号和非文本意义上的符号。我觉得<strong>理解它们是理解xargs分割和分批原理的关键。</strong></p>
<ul>
<li><p><strong>文本意义</strong>上的空格、制表符、反斜线、引号：未经处理就已经存在的符号，例如文本的内容中出现这些符号以及在文件名上出现了这些符号都是文本意义上的。</p>
</li>
<li><p>与之相对的是<strong>非文本意义</strong>的符号，由于在网上没找到类似的文章和解释，所以我个人称之为标记意义上的符号：处理后出现的符号，例如<code>ls</code>命令的结果中每个文件之间的制表符，它原本是不存在的，只是<code>ls</code>命令处理后的显示方式。还包括<strong>每个命令结果的最后的换行符，文件内容的最后一行结尾的换行符</strong>。</p>
</li>
</ul>
<p>两种分批可能：</p>
<ul>
<li>指定<code>-n</code>时按空格分段，然后划批，不管是文本意义的空格还是标记意义的空格，只要是空格都是<code>-n</code>的操作对象</li>
<li>指定<code>-L</code>或者<code>-i</code>时按段划批，文本意义的符号不被处理，比如<code>one space.txt</code>这个文件不会被分割。</li>
</ul>
<pre><code>ls | xargs -n 2
ls | xargs -L 2
ls | xargs -i -p echo {}
</code></pre><p>如果在一个xargs中使用了多个分批选项，则它们之间必然会冲突，它们的规则是<strong>写在后面的生效，前面的分批选项被忽略</strong>。</p>
<p><strong>-d 整体执行的过程</strong>：</p>
<ol>
<li><p>替换：将所有标记符号替换为<code>\n</code>，完成后所有符号(空格、制表符、换行符)都是文本符号</p>
</li>
<li><p>分段：根据分隔符进行分段、并用空格分开每段。由于分段前所有符号都是文本符号，因此分段后的文本中可能包含空格、制表符、换行符。也就是说除了-d 导致的分段空格，其余的所有符号都是分段中的一部分</p>
</li>
<li>输出：最后根据<code>-n</code>、<code>-L</code>、<code>-i</code>指定的分批选项来输出。</li>
</ol>
<p><strong><code>-0</code>等价于<code>-d&quot;\0&quot;</code></strong>，<strong>-0可以处理接收的stdin中的null字符（\0）。如果不使用 -0选项或- -null选项，检测到\0后会给出警告提醒，并只向命令传递非\0段。</strong></p>
<h5 id="分批行为"><a href="#分批行为" class="headerlink" title="分批行为"></a>分批行为</h5><p>分批用于指定每次传递多少个分段。有三种分批选项：-n，-L和-i。</p>
<p>-n 默认以空格分段划分，与-d、-0一起时，按指定的分隔符分段划分</p>
<p>-L 永远是按段划分的</p>
<p>-i  如果不使用-i，则默认是将分割后处理后的结果整体传递到命令的最尾部。但是有时候需要传递到多个位置，不使用-i就不知道传递到哪个位置了。例如重命名备份的时候在每个传递过来的文件名加上后缀.bak，这需要两个参数位。</p>
<pre><code class="shell">ls logdir/ | xargs -i mv ./logdir/{} ./logdir/{}.bak   # 将分段传递到多个参数位
</code></pre>
<h5 id="分批的典型应用"><a href="#分批的典型应用" class="headerlink" title="分批的典型应用"></a>分批的典型应用</h5><p>分批选项有时特别有用，例如脚本规定每次只能传输三个参数。有时候rm -rf的文件数量特别多的时候会提示参数列表太长而导致失败，这时就可以分批来按批删除。</p>
<p>假设目前在/tmp/longshuai/下有29W个.log文件，如果直接删除将会提示参数列表过长。</p>
<pre><code>ls | xargs -n 10000  rm -rf
</code></pre><h5 id="终止行为之-：xargs-E"><a href="#终止行为之-：xargs-E" class="headerlink" title="终止行为之 ：xargs -E"></a>终止行为之 ：xargs -E</h5><ul>
<li><code>-E</code>会将结果空格、制表符、分行符替换为空格并压缩到一行上显示。据我测试，-E似乎只能和独立的xargs使用，和-0、-d配合使用时都会失效。</li>
<li><code>-E</code>优先于<code>-n</code>、<code>-L</code>和<code>-i</code>执行。如果是分批选项先执行，则下面的第二个结果将压缩在一行上。</li>
<li>指定的终止符必须是完整的，例如想在遇到“xyz.txt”的符号终止时，只能指定完整的xyz.txt符号，不能指定.txt或者txt这样的符号。<ul>
<li>分两种情况：如果没指定分批选项或者指定的分批选项是-n或者-L时，则段是以空格为分割符，两个空格之间的段都是完整的。</li>
<li>如果指定的分批选项是-i，则以段为分割符。</li>
</ul>
</li>
</ul>
<pre><code class="bash">ls
a  b  c  d  logdir   one space.log  shdir  sh.txt  test  vmware-root  x.txt

ls | xargs -E one     #不指定分批选项
a b c d logdir

ls | xargs -n 2 -E one      #指定-n，one后面的所有的都终止传递
a b
c d
logdir

ls | xargs -L 2 -E&quot;one&quot;      #同-n 选项
a b
c d
logdir

ls | xargs -i -E&quot;one space.log&quot; echo {}   #和-i配合使用时指定完整的段才可以
a
b
c
d
logdir

ls | xargs -i -E&quot;one&quot;  -p echo {}         #非完整段终止失效
echo a ?...
echo b ?...
echo c ?...
echo d ?...
echo logdir ?...
echo one space.log ?...
echo shdir ?...
echo sh.txt ?...
echo test ?...
echo vmware-root ?...
echo x.txt ?...
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>分割行为</th>
<th>标记符号处理方式</th>
<th>分段方法</th>
<th>分批方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>xargs</td>
<td>空格、制表符、分行符替换为空格，引号和反斜线删除。处理完后只有空格。如果空格、制表符和分行符使用引号包围则可以保留</td>
<td>结果继承处理前的符号性质（文本符号还是标记符号）</td>
<td><code>-n</code>以分段结果中的每个空格分段，进而分批。不管是文本还是标记意义的空格.<br><code>-L -i</code>以标记意义上的空格分段，进而分批</td>
</tr>
<tr>
<td>xargs -d</td>
<td>不处理文本符号，所有标记符号替换为换行符<code>\n</code>，将<code>-d</code>指定的分割符替换为标记意义的空格。结果中除了最后的空行和<code>-d</code>指定的分割符位的分段空格，<strong>其余全是文本意义上的符号</strong></td>
<td>按照-d指定的符号进行分段，每个段中可包含文本意义上的空格、制表符、换行符。</td>
<td>以标记意义上的符号（即最后的空行和-d指定分隔符位的空格）分段，进而分批。分段结果中保留所有段中的符号，包括制表符和分行符。</td>
</tr>
<tr>
<td>xargs -0</td>
<td>不处理文本意义上的符号，将非<code>\0</code>的标记意义上的符号替换为<code>\n</code>，将<code>\0</code>替换为空格。</td>
<td>以替换<code>\0</code>位的空格分段，每个段中可能包含文本意义上的空格、制表符、换行符。</td>
<td>检测到<code>\0</code>时，以标记意义上的符号（即最后的空行和<code>\0</code>位的空格）分段，进而分批。分段结果中保留所有段中的符号，包括制表符和分行符。未检测到<code>\0</code>时，整个结果作为不可分割整体，使用分批选项是无意义的</td>
</tr>
</tbody>
</table>
<h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>只要能分批的选项，都可以使用”-P”，包括”-n”、”-L”和”-i”。</p>
<p>使用xargs的分批行为，除了可以解决一些问题，还可以一次性将多个分批交给不同进程去处理，这些进程可以使用多个cpu执行，效率可谓大幅提高。</p>
<p>“-P N”选项可以指定并行处理的进程数量为N。不指定”-P”时，默认为1个处理进程，也就是串行执行。指定为0时，将尽可能多地开启进程数量。</p>
<h4 id="xargs与文件名"><a href="#xargs与文件名" class="headerlink" title="xargs与文件名"></a>xargs与文件名</h4><p>由于<code>xargs</code>默认将空格作为分隔符，所以不太适合处理文件名，因为文件名可能包含空格。</p>
<p><code>find</code>命令有一个特别的参数<code>-print0</code>，指定输出的文件列表以<code>null</code>分隔。然后，<code>xargs</code>命令的<code>-0</code>参数表示用<code>null</code>当作分隔符。</p>
<blockquote>
<pre><code class="bash">$ find /path -type f -print0 | xargs -0 rm
</code></pre>
</blockquote>
<h4 id="xargs与复杂命令"><a href="#xargs与复杂命令" class="headerlink" title="xargs与复杂命令"></a>xargs与复杂命令</h4><p>如果<code>xargs</code>要将命令行参数传给多个命令，可以使用<code>-I</code>参数，并配合<code>sh -c</code> 执行命令</p>
<p><code>-I</code>指定每一项命令行参数的替代字符串。</p>
<pre><code class="bash">$ cat foo.txt
one
two
three

$ cat foo.txt | xargs -I file sh -c &#39;echo file; mkdir file&#39;
one 
two
three

$ ls 
one two three
</code></pre>
<p>我们希望对每一项命令行参数，执行两个命令（<code>echo</code>和<code>mkdir</code>），使用<code>-I file</code>表示<code>file</code>是命令行参数的替代字符串。执行命令时，具体的参数会替代掉<code>echo file; mkdir file</code>里面的两个<code>file</code>。</p>
<h4 id="xargs与重定向"><a href="#xargs与重定向" class="headerlink" title="xargs与重定向"></a>xargs与重定向</h4><p>如果脚本中包含重定向的命令，那么整个命令必须用双引号扩起来，如果双引号里面有<code>$</code>需要用<code>\</code>来转义，就比如下面的<code>$5</code></p>
<pre><code class="bash"> seq 5 10 |xargs -i sh -c &quot;awk -F\$&#39;\t&#39; &#39;\$5=={}&#39; file &gt; file_part_{}&quot; 
</code></pre>
<p>不过awk本身支持将不同的内容保存到不同的文件中</p>
<pre><code class="bash">awk &#39;NR!=1{print $4,$5 &gt; $6}&#39; netstat.txt
</code></pre>
<h4 id="xargs的限制"><a href="#xargs的限制" class="headerlink" title="xargs的限制"></a>xargs的限制</h4><p>其实是xargs的限制和缺点，但因为通过”-i”选项方便演示，所以此处使用”-i”选项。注意，不是”-i”选项的缺陷。</p>
<p>由于xargs -i传递数据时是在shell执行xargs命令的时候，根据<a href="http://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">shell解析命令行的流程</a> ，xargs后的命令如果有依赖于待传递数据的表达式，则无法正确执行。</p>
<p>第一：无法通过xargs传递数值做正确的算术扩展：</p>
<pre><code>echo 1  | xargs  -I &quot;x&quot; echo $((2*x))
0
</code></pre><p>第二：无法将数据传递到命令替换中。</p>
<pre><code>echo /etc/fstab | xargs -i `cat {}`     
cat: {}: No such file or directory
</code></pre><p>参考下图的shell命令行解析过程。</p>
<p><img src="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" class="lazyload" data-srcset="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" class="lazyload" data-srcset="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>这时要通过xargs正确实现目标，只能改变方法或寻找一些小技巧，例如：</p>
<pre><code>[root@xuexi ~]# echo 1  | xargs -i expr 2 \* {}    # 感谢楼下评论者提供的expr思路
2
[root@xuexi ~]# echo /etc/fstab | xargs -i cat $(echo {}) 
</code></pre><p>第三：xargs无法处理bash内置命令。例如：</p>
<pre><code>[root@xuexi ~]# echo /etc  | xargs -i cd {}
xargs: cd: No such file or directory
</code></pre><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>复制所有图片文件到 <code>/data/images</code> 目录下：</p>
<pre><code class="shell">ls *.jpg | xargs -n1 -I {} cp {} /data/images

# ls 出来的每一行文件名，都会通过 xargs 传递给 cp 命令
</code></pre>
<p>统计一个源代码目录中所有 php 文件的行数：</p>
<pre><code>find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l
</code></pre><h5 id="删除带空格的文件"><a href="#删除带空格的文件" class="headerlink" title="删除带空格的文件"></a>删除带空格的文件</h5><p>删除带空格的文件名，思路是让找到的“one space.log”成为一个段，而不是两个段。我给出了常见的两种。</p>
<p>方法一：通过常用的find的-print0选项使用\0来分隔而不是\n分隔，再通过xargs -0来配对保证one space.log的整体性。因为-print0后one space.log的前后各有一个\0，但是文件名中间没有。</p>
<pre><code>[root@xuexi tmp]# find -name &quot;* *.log&quot; -print0 | xargs -0 rm -rf
</code></pre><p>当然，能使用-0肯定也能使用-d了。</p>
<pre><code>[root@xuexi tmp]# find -name &quot;* *.log&quot; -print0 | xargs -d &quot;x&quot; rm -rf     #随意指定非文件名中的字符都行，不一定非要\0
</code></pre><p>方法二：不在find上处理，在xargs上处理，只要通过配合-i选项，就能宣告它的整体性。</p>
<pre><code>[root@xuexi tmp]# find -name &quot;* *.log&quot; | xargs -i rm -rf &quot;{}&quot;
</code></pre><p>相较而言，方法一使用的更广泛更为人所知，但是方法二更具有通用性，对于非find如ls命令也可以进行处理。</p>
<p>还可以使用tr将find的换行符换成其他符号再xargs分割配对也行。</p>
<p>除了find -print0可以输出\0字符，Linux中还有其他几个命令配合参数也可以实现：<strong>locate -0</strong>,<strong>grep -z</strong>或<strong>grep -Z</strong>,<strong>sort -z等</strong>。</p>
<p>其他小例子</p>
<pre><code class="shell"># cat test.txt | xargs -n3

a b c
d e f
g h i
j k l


# echo &quot;nameXnameXnameXname&quot; | xargs -dX

name name name name
</code></pre>
<p>参考：<a href="https://www.cnblogs.com/f-ck-need-u/p/5925923.html#auto_id_4" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/5925923.html#auto_id_4</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html</a></p>
<h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p><strong>tee命令</strong>可以把数据重定向到<strong>给定文件</strong>和<strong>屏幕</strong>上，相当于分流了</p>
<pre><code>-a：向文件中重定向时使用追加模式；
</code></pre><p><img src="/2019/08/04/linux常用命令/./tee.gif" class="lazyload" data-srcset="./tee.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tee"></p>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>TODO scp 的完整命令</p>
<p><strong>scp免密码</strong></p>
<ol>
<li>在A中执行命令：</li>
</ol>
<pre><code>ssh-keygen -t rsa -P &quot;&quot;
</code></pre><p>这会在 ~/.ssh 目录下生成两个文件：id_rsa 和 id_rsa.pub</p>
<ol>
<li>拷贝A的id_rsa.pub到B：</li>
</ol>
<pre><code>scp ~/.ssh/id_rsa.pub yliu@192.168.200.1:/home/yliu
</code></pre><ol>
<li>登录B，并把id_rsa.pub输入到B的authorized_keys文件中：</li>
</ol>
<pre><code>cat /home/yliu/id_rsa.pub &gt;&gt; /home/yliu/.ssh/authorized_keys
</code></pre><ol>
<li>最后一步：如果是第一次生成authorized_keys，需要授权：chmod 600 authorized_keys</li>
</ol>
<p>大功告成！此时在复制文件就无需输入密码了。而且，<strong>在A中ssh登录B也无需密码</strong>了。</p>
<p>反之亦然，在B中设置A的免密码登录完全一样，在此不做赘述。</p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="一行内指令"><a href="#一行内指令" class="headerlink" title="一行内指令"></a>一行内指令</h3><p>一行内指定依次运行的一系列指令</p>
<pre><code>$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls
</code></pre><h3 id="命令行中输入tab"><a href="#命令行中输入tab" class="headerlink" title="命令行中输入tab"></a>命令行中输入tab</h3><p>我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在<code>sort -t</code>选项后输入<code>字符），你可以先按`Ctrl-V`，然后再按Tab键，就可以输入</code>字符了。当然，你也可以使用<code>$&#39;\t&#39;</code>。</p>
<p>EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。</p>
<p>参考：<a href="https://awk.readthedocs.io/en/latest/chapter-one.html" target="_blank" rel="noopener">https://awk.readthedocs.io/en/latest/chapter-one.html</a></p>
</the></excerpt>
  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://jizx.vip/2019/08/04/linux常用命令/>https://jizx.vip/2019/08/04/linux常用命令/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-07-14T09:31:58+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Jul 14, 2020</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/linux/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>linux</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/awk/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>awk</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/ing/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>ing</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/命令/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>命令</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://jizx.vip/2019/08/04/linux常用命令/&title=linux常用命令 - 玖玖的博客&summary= 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://jizx.vip/2019/08/04/linux常用命令/&title=linux常用命令 - 玖玖的博客&summary= 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://jizx.vip/2019/08/04/linux常用命令/&title=linux常用命令 - 玖玖的博客&summary= 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2019/08/04/anaconda与jupyter使用与设置/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>anaconda与jupyter的使用和设置</p>
          <p class='content'> 

jupyter 使用介绍、与 anaconda 的虚拟环境结合 、右键打开配置





anaconda安装
清华镜像站下载 或者清华镜像站anaconda首页 或者anaconda官网...</p>
        </a>
      
      
        <a class='next' href='/2018/12/18/photoshop曲线原理与应用/'>
          <p class='title'>photoshop曲线原理与应用<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'> 

转载poco：photoshop曲线原理与应用，https://www.jb51.net/photoshop/532386.html




关键句：可以看到S型曲线中间部分，输入和输出值...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间"><span class="toc-text">时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#date"><span class="toc-text">date</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#格式化参数"><span class="toc-text">格式化参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#格式化"><span class="toc-text">格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间游走"><span class="toc-text">时间游走</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文本处理"><span class="toc-text">文本处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#echo"><span class="toc-text">echo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cat"><span class="toc-text">cat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tail"><span class="toc-text">tail</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniq"><span class="toc-text">uniq</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两个文件的交并集"><span class="toc-text">两个文件的交并集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-text">sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局选项"><span class="toc-text">全局选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#知识点"><span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#排序对象"><span class="toc-text">排序对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#建议"><span class="toc-text">建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多列排序"><span class="toc-text">多列排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-text">grep</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用参数"><span class="toc-text">常用参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展用法"><span class="toc-text">扩展用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不使用正则表达式"><span class="toc-text">不使用正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多模式匹配"><span class="toc-text">多模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#逻辑或"><span class="toc-text">逻辑或</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#从文件中读取匹配模式"><span class="toc-text">从文件中读取匹配模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#逻辑与"><span class="toc-text">逻辑与</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用功能"><span class="toc-text">常用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#检索文件内容"><span class="toc-text">检索文件内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0值字节后缀的-xargs"><span class="toc-text">0值字节后缀的 xargs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#比较两个文件相同内容与不同内容"><span class="toc-text">比较两个文件相同内容与不同内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#查找满足条件的文件是否匹配到文字"><span class="toc-text">查找满足条件的文件是否匹配到文字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tr"><span class="toc-text">tr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他参数"><span class="toc-text">其他参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cut"><span class="toc-text">cut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件分割-split"><span class="toc-text">文件分割 split</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sed"><span class="toc-text">sed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#替换s"><span class="toc-text">替换s</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#替换标记"><span class="toc-text">替换标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分隔符"><span class="toc-text">分隔符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#指定行"><span class="toc-text">指定行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多命令"><span class="toc-text">多命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入a与i"><span class="toc-text">插入a与i</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#插入多行"><span class="toc-text">插入多行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除行-d"><span class="toc-text">删除行 d</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符转换y"><span class="toc-text">字符转换y</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打印命令"><span class="toc-text">打印命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#p-命令"><span class="toc-text">p 命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#等号"><span class="toc-text">=等号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#显示特殊字符l"><span class="toc-text">显示特殊字符l</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#保存命令w"><span class="toc-text">保存命令w</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取命令"><span class="toc-text">读取命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-字段合并"><span class="toc-text">Join 字段合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本编码转换-iconv"><span class="toc-text">文本编码转换 iconv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临时文件-mktemp"><span class="toc-text">临时文件 mktemp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁盘"><span class="toc-text">磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mount"><span class="toc-text">mount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#df与-du-TODO"><span class="toc-text">df与 du TODO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩命令"><span class="toc-text">压缩命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他命令"><span class="toc-text">其他命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#seq"><span class="toc-text">seq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xarg"><span class="toc-text">xarg</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实验文件准备"><span class="toc-text">实验文件准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流程讲解"><span class="toc-text">流程讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#预处理"><span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分割"><span class="toc-text">分割</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分批行为"><span class="toc-text">分批行为</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分批的典型应用"><span class="toc-text">分批的典型应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#终止行为之-：xargs-E"><span class="toc-text">终止行为之 ：xargs -E</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多进程"><span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xargs与文件名"><span class="toc-text">xargs与文件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xargs与复杂命令"><span class="toc-text">xargs与复杂命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xargs与重定向"><span class="toc-text">xargs与重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xargs的限制"><span class="toc-text">xargs的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子-2"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#删除带空格的文件"><span class="toc-text">删除带空格的文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tee"><span class="toc-text">tee</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scp"><span class="toc-text">scp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他知识点"><span class="toc-text">其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一行内指令"><span class="toc-text">一行内指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行中输入tab"><span class="toc-text">命令行中输入tab</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>



      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 </a></p>

        </div>
      
    
  </footer>


      <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <!-- required -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->

  
  
  
    <script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/044.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('') {
          $('').backstretch(
            imgs,
          {
            duration: "100000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "100000",
            fade: "1500"
          });
        }
      });
    </script>
  







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  




  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
		if($(".highlight .code pre").length+$(".article pre code").length==0)return;
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>








  
  <script src="/js/valine.js"></script>

<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = $.trim($('#pjax-comment-placeholder').text()) || "快来评论吧~";

    let path = $.trim($('#pjax-comment-path').text());
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>







  <script src="/js/app.js"></script>



  
    <script src="/js/search.js"></script>
  


<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );
(function ($) {
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
})(jQuery);

</script>









  
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  



  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://jizx.vip' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://jizx.vip' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://jizx.vip' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>



<!-- more -->


    
      

<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>
<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
          
          if ('') {
            $('').backstretch("resize");
            if($('.cover-wrapper').is(':hidden')){
              $('.cover-backstretch').backstretch("pause");
            }else{
              $('.cover-backstretch').backstretch("next");
            }
          } else {
            $.backstretch("resize");
            if($('.cover-wrapper').is(':hidden')){
              $.backstretch("pause");
            }else{
              $.backstretch("next");
            }
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
        
        
          pjax_initCopyCode();
        
        
          pjax_valine();
        
        
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
