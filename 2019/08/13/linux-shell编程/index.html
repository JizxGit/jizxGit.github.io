<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="jizx">



<meta name="keywords" content="linux,shell">
<meta property="og:type" content="article">
<meta property="og:title" content="linux shell编程">
<meta property="og:url" content="https://jizx.vip/2019/08/13/linux-shell编程/index.html">
<meta property="og:site_name" content="玖玖的博客">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://jizx.vip/2019/08/13/linux-shell编程/shell配置文件加载顺序1.png">
<meta property="og:image" content="https://jizx.vip/2019/08/13/linux-shell编程/shell配置文件加载顺序2.png">
<meta property="og:image" content="https://jizx.vip/2019/08/13/linux-shell编程/shell展开.png">
<meta property="og:updated_time" content="2020-02-04T09:54:35.285Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linux shell编程">
<meta name="twitter:image" content="https://jizx.vip/2019/08/13/linux-shell编程/shell配置文件加载顺序1.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="玖玖的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="https://avatars1.githubusercontent.com/u/18480104?s=40&v=4">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>linux shell编程 | 玖玖的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">jizx</a></h1>
        </hgroup>

        
        <p class="header-subtitle">个人学习笔记，各种杂杂碎碎O(∩_∩)O</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">分类&amp;标签</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:1822980003@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/JizxGit" title="GitHub"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/anaconda/">anaconda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atom/">atom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/awk/">awk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ing/">ing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jupyter/">jupyter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logging/">logging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notepad/">notepad++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numpy/">numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pandas/">pandas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/photoshop/">photoshop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python进阶/">python进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python高级/">python高级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tensorflow/">tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/time/">time</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/window/">window</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/乱码/">乱码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/从句/">从句</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/传参/">传参</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健康/">健康</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/右键/">右键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同理心/">同理心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/吵架/">吵架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/命令/">命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复合句/">复合句</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多进程/">多进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心理/">心理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/截图/">截图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/所见所闻/">所见所闻</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打印/">打印</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/批评/">批评</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/效率/">效率</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/方法调用/">方法调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/时态/">时态</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/曲线/">曲线</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块/">模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境/">环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/类/">类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统优化/">系统优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码问题/">编码问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编辑器/">编辑器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">博客主题原作者MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">在读研究生二年级</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">jizx</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">jizx</a></h1>
            </hgroup>
            
            <p class="header-subtitle">个人学习笔记，各种杂杂碎碎O(∩_∩)O</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">分类&amp;标签</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:1822980003@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/JizxGit" title="GitHub"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-linux-shell编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/13/linux-shell编程/" class="article-date">
      <time datetime="2019-08-13T03:00:08.000Z" itemprop="datePublished">2019-08-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      linux shell编程
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/linux/">linux</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shell/">shell</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <excerpt in="" index="" |="" 首页摘要=""> 

<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="Shell-进程"><a href="#Shell-进程" class="headerlink" title="Shell 进程"></a>Shell 进程</h3><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><p>在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。 这个shell程序被称为子shell（child shell）。</p>
<p>在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中。这会对包括变量在内的一些东西造成影响。</p>
<h4 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h4><p>可以在一行内指定依次运行的一系列指令，通过<strong>命令列表</strong>来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> ; ls ; <span class="built_in">cd</span> /etc ; <span class="built_in">pwd</span> ; <span class="built_in">cd</span> ; <span class="built_in">pwd</span> ; ls</span><br></pre></td></tr></table></figure>
<p>命令列表要想成为<strong>进程列表</strong>，这些命令必须包含在括号里。括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令。</p>
<blockquote>
<p>  进程列表是一种命令分组（command grouping） 。另一种命令分组是将命令放入花括号中， 并在命令列表尾部加上分号（;）。语法为 <code>{ command; }</code>但是不会像进程列表那样创建出子shell。</p>
</blockquote>
<p>要想知道是否生成了子shell，得借助一个使用了环境变量的命令<code>echo $BASH_SUBSHELL</code>。如果该命令返回0，就表明没有子shell。如果返回 1或者其他更大的数字，就表明存在子shell。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> ;  <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span></span><br><span class="line">/Users/admin</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">$ &#123; <span class="built_in">pwd</span> ; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>; &#125;</span><br><span class="line">/Users/admin</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">$ (<span class="built_in">pwd</span> ; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>)</span><br><span class="line">/Users/admin</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">$ ( <span class="built_in">pwd</span> ; (<span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>))</span><br><span class="line">/Users/admin</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢处理速度。</p>
<p>  在交互式的CLI shell会话中，子shell同样存在问题。它并<strong>非真正的多进程</strong>处理，因为终端控制着子shell的I/O。</p>
<p>  在CLI中运用子shell的创造性方法之一就是将进程列表置入<strong>后台模式</strong>。你既可以在子shell中 进行繁重的处理工作，同时也不会让子shell的I/O受制于终端。</p>
</blockquote>
<h4 id="高效子进程"><a href="#高效子进程" class="headerlink" title="高效子进程"></a>高效子进程</h4><h5 id="后台模式"><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 3000&amp; </span><br><span class="line">[1] 2396</span><br></pre></td></tr></table></figure>
<p>在命令末尾加上字符<code>&amp;</code>，在shell CLI提示符返回之前，会出现一条信息，代表后台作业（background job）号（1）与后台作业的进程ID（2396）。</p>
<p>可以通过<code>ps -f</code> 或者 <code>jobs -l</code> 来查看</p>
<h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>协程 协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。 要进行协程处理，得使用coproc命令，还有要在子shell中执行的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coproc sleep 10</span><br><span class="line">coproc My_Job &#123; sleep 10; &#125; # 指定协程名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  通过使用扩展语法，协程的名字被设置成My_Job。这里要注意的是，扩展语法写起来有点 麻烦。必须确保在第一个花括号<code>{</code>和命令名之间有一个空格。还必须保证命令以分号<code>;</code>结 尾。另外，分号和闭花括号<code>}</code>之间也得有一个空格。</p>
</blockquote>
<h3 id="shell-内建命令"><a href="#shell-内建命令" class="headerlink" title="shell 内建命令"></a>shell 内建命令</h3><h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h4><p>外部命令，是存在于bash shell之外的程序。外部命令程序通常位于<code>/bin</code>、<code>/usr/bin</code>、<code>/sbin</code>或<code>/usr/sbin</code>中。</p>
<p>当外部命令执行时，会创建出一个子进程。这种操作被称为<strong>衍生</strong>（forking）。</p>
<p>当进程必须执行衍生操作时，它需<strong>要花费时间和精力来设置新子进程的环境</strong>。所以说，外部命令多少还是有代价的。</p>
<h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>内建命令和外部命令的区别在于前者<strong>不需要使用子进程来执行</strong>。它们已经和shell编译成了一体，作为shell工具的组成部分存在。比如<code>cd</code>和<code>exit</code></p>
<p>利用<code>type</code>命令来了解某个命令是否是内建的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ type cd</span><br><span class="line">cd is a shell builtin</span><br></pre></td></tr></table></figure>
<p>有些命令有多种实现。例如<code>echo</code>和<code>pwd</code>既有内建命令也有外部命令，要查看命令的不同实现，使用type命令的-a选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ type -a echo </span><br><span class="line">echo is a shell builtin </span><br><span class="line">echo is /bin/echo</span><br></pre></td></tr></table></figure>
<p>要使用外部命令 <code>pwd</code> ，可以输入<code>/bin/pwd</code> </p>
<h5 id="内建命令之-history"><a href="#内建命令之-history" class="headerlink" title="内建命令之 history"></a>内建命令之 history</h5><p>设置保存在bash历史记录中的命令数。要想实现这一点，你需要修改名为 <code>HISTSIZE</code> 的环境变量</p>
<p>输入<code>!!</code>可以重新执行上一条命令，<code>!编号</code>即可执行历史列表中的对应编号的命令</p>
<p>bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件<code>~/.bash_history</code>中。</p>
<p><code>~/.bash_history</code>文件只有在打开首个终端会话时才会被读取。</p>
<p>可以在退出shell会话之前强制将命令历史记录写入<code>.bash_history</code>文件。要实现强制写入，需要使用<code>history -a</code></p>
<p>要想强制重新读 取.bash_history文件，更新终端会话的历史记录，可以使用 <code>history -n</code> 命令。</p>
<h5 id="内建命令之-alias"><a href="#内建命令之-alias" class="headerlink" title="内建命令之 alias"></a>内建命令之 alias</h5><p>要查看当前可用 的别名，使用<code>alias</code>或者<code>alias -p</code>。</p>
<p>使用alias命令创建属于自己的别名。</p>
<p><code>alias li=&#39;ls -li&#39;</code></p>
<h3 id="shell-配置文件-TODO"><a href="#shell-配置文件-TODO" class="headerlink" title="shell 配置文件(TODO)"></a>shell 配置文件(TODO)</h3><p><a href="http://ddrv.cn/a/173848/" target="_blank" rel="noopener">http://ddrv.cn/a/173848/</a></p>
<p><code>Shell</code> 启动方式（TODO 到底是几种）</p>
<ul>
<li>交互式登录</li>
<li>交互式非登录</li>
<li>非交互式登录</li>
<li>非交互式非登录</li>
</ul>
<p>启动bash shell有3种方式：</p>
<ul>
<li>登录时作为默认登录shell</li>
<li>作为非登录shell的交互式shell </li>
<li>作为运行脚本的非交互shell</li>
</ul>
<blockquote>
<p>  <code>交互式</code>：一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动。<br>  <code>非交互式</code>：运行一个 <code>Shell 脚本</code> 文件，让所有命令批量化、一次性地执行。<br>  <code>登录式</code>：需要输入用户名和密码才能使用。<br>  <code>非登录式</code>：直接可以使用。</p>
</blockquote>
<h4 id="判断-shell-类型"><a href="#判断-shell-类型" class="headerlink" title="判断 shell 类型"></a>判断 shell 类型</h4><p><strong>如何判断是否为交互式 Shell? 有两种方式</strong></p>
<ol>
<li>查看特殊变量 <code>-</code> ，如果值包含 <code>i</code>，则是交互式，否则是非交互式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $-</span><br></pre></td></tr></table></figure>
<ol>
<li>查看变量 <code>PS1</code> 是否为空，如果不为空，则是交互式，否则为非交互式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PS1</span><br></pre></td></tr></table></figure>
<p><strong>如何判断是否为登录式 Shell ?</strong><br>执行命令 <code>shopt login_shell</code>，如果 <code>login_shell</code> 的值为 <code>on</code>表示登录式，为 <code>off</code>表示非登录式。</p>
<h5 id="登录-shell"><a href="#登录-shell" class="headerlink" title="登录 shell"></a>登录 shell</h5><p>当你登录Linux系统时，bash shell会作为登录shell启动。（对于没有图形化界面来说）</p>
<p>登录shell会从5个不同的启动文件里 读取命令：</p>
<ul>
<li><code>/etc/profile</code> ——&gt;会去读取<code>/etc/profile.d</code>目录下的配置文件</li>
<li><code>$HOME/.bash_profile</code></li>
<li><code>$HOME/.bashrc</code></li>
<li><code>$HOME/.bash_login</code></li>
<li><code>$HOME/.profile</code></li>
</ul>
<p><code>$HOME</code>目录下的启动文件 </p>
<p>剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环 境变量。大多数Linux发行版只用这四个启动文件中的1、2个：</p>
<ul>
<li><code>$HOME/.bash_profile</code></li>
<li><code>$HOME/.bashrc</code></li>
<li><code>$HOME/.bash_login</code></li>
<li><code>$HOME/.profile</code></li>
</ul>
<p>shell会按照按照下列顺序，运行第一个被找到的文件，忽略其他文件：</p>
<ul>
<li><code>$HOME/.bash_profile</code></li>
<li><code>$HOME/.bash_login</code></li>
<li><code>$HOME/.profile</code></li>
</ul>
<p>这个列表中没有<code>$HOME/.bashrc</code>文件是因为该文件<strong>通常通过其他文件运行</strong>的。比如 <code>.bash_profile</code>会先去检查HOME目录中是不是还有一个叫<code>.bashrc</code>的启动文件。如果有的话，会先执行启动文件里面的命令。因此<code>.bashrc</code>顺序最先，但是并不是优先级最高，因为<code>.bash_profile</code>设置的变量会覆盖 <code>.bashrc</code> 中的变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile </span></span><br><span class="line"><span class="comment"># Get the aliases and functions </span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span> </span><br><span class="line">	. ~/.bashrc </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="comment"># User specific environment and startup programs </span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin </span><br><span class="line"><span class="built_in">export</span> PATH </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h5 id="交互式-shell-进程"><a href="#交互式-shell-进程" class="headerlink" title="交互式 shell 进程"></a>交互式 shell 进程</h5><p>如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那 么你启动的shell叫作交互式shell。</p>
<p>作为交互式shell启动的，就<strong>不会访问<code>/etc/profile</code>文件</strong>，只会检查用户HOME目录中的<code>.bashrc</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bashrc # Source global definitions </span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span> </span><br><span class="line">	. /etc/bashrc </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br></pre></td></tr></table></figure>
<p><code>.bashrc</code>文件有两个作用：</p>
<ol>
<li>查看/etc目录下通用的bashrc文件</li>
<li>为用户提供一个定制自 己的命令别名和私有脚本函数的地方。</li>
</ol>
<h5 id="非交互式-shell"><a href="#非交互式-shell" class="headerlink" title="非交互式 shell"></a>非交互式 shell</h5><p>系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。</p>
<blockquote>
<p>  脚本能以不同的方式执行。只有其中的某一些方式能够启动子shell。</p>
</blockquote>
<p>bash shell提供了BASH_ENV环境变量。当shell启动一个非交互式shell进 程时，它会检查BASH_ENV来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。</p>
<p>但是 CentoS 与 Ubuntu 都没有该变量，shell脚本到哪里去获得它们的环境变量呢？</p>
<ul>
<li>有些 shell脚本是通过启动一个子shell来执行的。子shell可以继承父shell导出过的变量。</li>
<li>对于那些不启动子shell的脚本， 变量已经存在于当前shell中了。 所以就算没有设置 BASH_ENV，也可以使用当前shell的局部变量和全局变量。</li>
</ul>
<h4 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h4><p><a href="https://blog.csdn.net/bjnihao/article/details/51775854" target="_blank" rel="noopener">参考网站</a></p>
<p>正常启动</p>
<p><img src="/2019/08/13/linux-shell编程/./shell配置文件加载顺序1.png" alt=""></p>
<p>su 切换用户</p>
<p><img src="/2019/08/13/linux-shell编程/./shell配置文件加载顺序2.png" alt=""></p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的 shell可见。</p>
<p>查看环境变量的命令有<code>set</code>、<code>env</code>、<code>printenv</code></p>
<blockquote>
<p>  它们的区别：</p>
<p>  set 命令会显示出全局变量、局部变量以 及用户定义变量。它还会按照字母顺序对结果进行排序。</p>
<p>  env 和 printenv 命令不会对变量排序，也不会输出局部变量和用户定义变量。</p>
<p>  TODO env 与 printenv</p>
</blockquote>
<p>要显示个别环境变量的值，可以使用<code>printenv</code> 或者 <code>echo</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ printenv HOME </span><br><span class="line">/home/Christine</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$HOME</span> </span><br><span class="line">/home/Christine</span><br></pre></td></tr></table></figure>
<h4 id="设置局部变量"><a href="#设置局部变量" class="headerlink" title="设置局部变量"></a>设置局部变量</h4><p>变量名区分大小写。所有的环境变量名均使用大写字母，自己创建的局部变量或是shell脚本，请使用小写字母。</p>
<p>记住，变量名、等号和值之间<strong>没有空格</strong>：如果在赋值表达式中加上了空格， bash shell就会把值当成一个单独的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable = <span class="string">"Hello World"</span> </span><br><span class="line">-bash: my_variable: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>
<h4 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h4><p>创建全局环境变量的方法是先创建一个局部环境变量，然后通过<code>export</code>命令把它导出到全局环境中。变量名前面不需要加$。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=<span class="string">"I am Global now"</span> </span><br><span class="line">$ my_variable2=<span class="string">"I am Global now"</span> </span><br><span class="line">$ <span class="built_in">export</span> my_variable my_variable2  <span class="comment"># 可以同时导出多个变量</span></span><br></pre></td></tr></table></figure>
<p>修改<em>子shell</em>中全局环境变量并<strong>不会影响到父shell中该变量的值</strong>。这种改变仅在子shell中有效，并不会被反映到父shell中。甚至无法使用export命令改变父shell中全局环境变量的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=<span class="string">"I am Global now"</span> </span><br><span class="line">$ <span class="built_in">export</span> my_variable </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> I am Global now </span><br><span class="line">$ </span><br><span class="line"><span class="variable">$bash</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$ </span><br><span class="line">$ my_variable=<span class="string">"Null"</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">export</span> my_variable  <span class="comment"># 导出变量也没用</span></span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span></span><br><span class="line">Null </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">exit</span> </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="shell-编程"><a href="#shell-编程" class="headerlink" title="shell 编程"></a>shell 编程</h2><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><p>在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：</p>
<p><code>#!/bin/bash</code></p>
<p>在通常的shell脚本中，井号（#）用作注释行。然而， shell脚本文件的第一行是个例外。</p>
<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>默认情况下，不需要使用引号将要显示的文本字符串划定出来</p>
<p>可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在 文本中使用其中一种引号，而用另外一种来将字符串划定起来。</p>
<p>不换行<code>echo -n &quot;The time and date are: &quot;</code></p>
<blockquote>
<p>  反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p>
<p>  单引号（’’）：全局转义，转义其中所有的变量为单纯的字符串。</p>
<p>  双引号（””）：保留其中的变量属性，不进行转义处理。</p>
<p>  反引号（<code></code>）：把其中的命令执行后返回结果，等价于$(命令)</p>
</blockquote>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>通常别名定义在 <strong>$HOME/.bashrc</strong> 或者 <strong>$HOME/bash_aliases</strong> (在 <strong>$HOME/.bashrc</strong>被加载).</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -e $HOME/.bash_aliases ]; then</span><br><span class="line">    source $HOME/.bash_aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>推荐的别名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">alias ls='ls -F'   # 目录名后面加上/</span><br><span class="line">alias ll='ls -lh'  # 人类可读的方式显示容量，KB、GB</span><br><span class="line">alias gh='history|grep' # 查找历史命令</span><br><span class="line">alias count='find . -type f | wc -l' # 计算当前目录下文件总数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义函数最好保存在 bash_functions 文件中</span></span><br><span class="line">if [ -e $HOME/.bash_functions ]; then</span><br><span class="line">    source $HOME/.bash_functions</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换目录同时展示目录下的内容</span></span><br><span class="line">function cl() &#123;</span><br><span class="line">    DIR="$*";</span><br><span class="line">        # if no DIR given, go current dir</span><br><span class="line">        if [ $# -lt 1 ]; then</span><br><span class="line">                DIR=".";</span><br><span class="line">    fi;</span><br><span class="line">    builtin cd "$&#123;DIR&#125;" &amp;&amp; \</span><br><span class="line">    # use your preferred ls command</span><br><span class="line">        ls -F --color=auto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h4><p>在 shell 中<code>set</code>命令来显示一份完整的当前环境变量列表</p>
<p>在脚本中，你可以在环境变量名称之前加上美元符<code>$</code>来使用这些环境变量，或者<code>${variable}</code> 形式引用的变量。变量名两侧额外的花括号通常用来帮助识别美元符后的变量名</p>
<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><ul>
<li><p>由字母、数字或下划线组成的文本字符串，长度不超过20个</p>
</li>
<li><p>用户变量 区分大小写</p>
</li>
<li>使用等号将值赋给用户变量。在变量、等号和值之间<strong>不能出现空格</strong></li>
<li>在shell脚本结束时会被删除掉</li>
<li>用户变量可通过美元符引用</li>
</ul>
<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 <strong>readonly</strong> 下面的例子尝试更改只读变量，结果报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">myUrl=&quot;http://c.biancheng.net/shell/&quot;</span><br><span class="line">readonly myUrl</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="字符串的3种形式"><a href="#字符串的3种形式" class="headerlink" title="字符串的3种形式"></a>字符串的3种形式</h5><ol>
<li><p>由单引号<code>&#39; &#39;</code>包围的字符串：<br>任何字符都会原样输出，在其中使用<strong>变量是无效的</strong>。<br>字符串中<strong>不能出现单引号</strong>，即使对单引号进行转义也不行。</p>
</li>
<li><p>由双引号<code>&quot;</code> “包围的字符串：<br>如果其中包含了某个变量，那么该<strong>变量会被解析</strong>（得到该变量的值），而不是原样输出。<br>字符串中<strong>可以出现双引号</strong>，只要它被转义了就行。</p>
</li>
<li><p>不被引号包围的字符串<br>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号” “包围的字符串一样。<br>字符串中<strong>不能出现空格</strong>，否则空格后边的字符串会作为其他变量或者命令解析。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n=74</span><br><span class="line">str1=c.biancheng.net$n </span><br><span class="line">str2="shell \"script\" $n"</span><br><span class="line">str3='C语言中文网 $n'</span><br><span class="line"></span><br><span class="line">echo $str1</span><br><span class="line">echo $str2</span><br><span class="line">echo $str3</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">c.biancheng.net74</span><br><span class="line">shell "script" 74</span><br><span class="line">C语言中文网 $n</span><br></pre></td></tr></table></figure>
<h5 id="变量-字符串-拼接"><a href="#变量-字符串-拼接" class="headerlink" title="变量(字符串)拼接"></a>变量(字符串)拼接</h5><p>直接将两个变量写在一起就是拼接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="variable">$name</span><span class="variable">$url</span>      <span class="comment">#中间不能有空格，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析，</span></span><br><span class="line">str2=<span class="string">"<span class="variable">$name</span> <span class="variable">$url</span>"</span>   <span class="comment">#如果被双引号包围，那么中间可以有空格</span></span><br><span class="line">str3=<span class="variable">$name</span><span class="string">": "</span><span class="variable">$url</span>  <span class="comment">#中间可以出现别的字符串</span></span><br><span class="line">str4=<span class="string">"<span class="variable">$name</span>: <span class="variable">$url</span>"</span>  <span class="comment">#这样写也可以</span></span><br><span class="line">str5=<span class="string">"<span class="variable">$&#123;name&#125;</span>Script: <span class="variable">$&#123;url&#125;</span>index.html"</span>  <span class="comment">#这个时候需要给变量名加上大括号 加&#123; &#125;是为了帮助解释器识别变量的边界</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#string_name&#125;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h5><p>假设有变量 <code>var=http://www.aaa.com/123.htm</code></p>
<p><strong>1. # 号截取，删除左边字符，保留右边字符。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var#*//&#125;</span><br></pre></td></tr></table></figure>
<p> 其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符<br>即删除<code>http://</code><br>结果是 ：<code>www.aaa.com/123.htm</code></p>
<p><strong>2. ## 号截取，贪心地删除左边字符，保留右边字符。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var##*/&#125;</span><br></pre></td></tr></table></figure>
<p><code>##*/</code>表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符<br>即删除 <code>http://www.aaa.com/</code></p>
<p>结果是 <code>123.htm</code></p>
<p><strong>3. %号截取，删除右边字符，保留左边字符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var%/*&#125;</span><br></pre></td></tr></table></figure>
<p> <code>%/*</code> 表示从右边开始，删除第一个 / 号及右边的字符</p>
<p>结果是：<a href="http://www.aaa.com" target="_blank" rel="noopener">http://www.aaa.com</a></p>
<p><strong>4. %% 号截取，贪心地删除右边字符，保留左边字符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var%%/*&#125;</span><br></pre></td></tr></table></figure>
<p> <code>%%/*</code> 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符<br>结果是：<code>http:</code></p>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>记住不要使用<code>$</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset my_variable</span><br></pre></td></tr></table></figure>
<p>在处理<strong>全局环境变量</strong>时，如果你是在子进程中删除了一个全局环境变量， 这只对子进程有效。该全局环境变量在<strong>父进程中依然可用</strong>。</p>
<h4 id="变量前的-符号"><a href="#变量前的-符号" class="headerlink" title="变量前的 $ 符号"></a>变量前的 $ 符号</h4><p>记住一点就行了：如果要用到变量，使用<code>$</code>；如果要操作变量，不使用<code>$</code>。这条规则的一个例外就是使用 <code>printenv</code> 显示某个变量的值。</p>
<h4 id="与"><a href="#与" class="headerlink" title="$* 与$@"></a><code>$*</code> 与<code>$@</code></h4><p><code>$*</code> 和<code>$@</code> 都表示传递给函数或脚本的所有参数， 当 <code>$*</code> 和 <code>$@</code> 不被<strong>双引号<code>&quot;&quot;</code></strong>包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。</p>
<p>但是当它们被双引号<code>&quot; &quot;</code>包含时，就会<strong>有区别</strong>了：</p>
<ul>
<li><code>&quot;$*&quot;</code>会将所有的参数从<strong>整体上看做一份数据</strong>，而不是把每个参数都看做一份数据。</li>
<li><code>&quot;$@&quot;</code>仍然将每个参数都看作一份数据，彼此之间是独立的。</li>
</ul>
<p>比如传递了 5 个参数，那么对于<code>$*</code>来说，这 5 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于<code>$@</code>来说，这 5 个参数是相互独立的，它们是 5 份数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">echo "脚本的名字是："$0</span><br><span class="line">n=1</span><br><span class="line">echo "使用\$@的参数列表为："$@</span><br><span class="line">for temstr in "$@"</span><br><span class="line">do</span><br><span class="line">  echo "第$n个参数是：" $temstr</span><br><span class="line">  let n+=1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">n=1</span><br><span class="line">echo "使用\$*的参数列表为："$*</span><br><span class="line">for temstr in "$*"</span><br><span class="line">do</span><br><span class="line">  echo "第$n个参数是：" $temstr</span><br><span class="line">  let n+=1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### 结果 #####</span></span></span><br><span class="line"></span><br><span class="line">脚本的名字是：test.sh</span><br><span class="line">使用$@的参数列表为：1 2 3 4 5</span><br><span class="line">第1个参数是： 1</span><br><span class="line">第2个参数是： 2</span><br><span class="line">第3个参数是： 3</span><br><span class="line">第4个参数是： 4</span><br><span class="line">第5个参数是： 5</span><br><span class="line">使用$*的参数列表为：1 2 3 4 5</span><br><span class="line">第1个参数是： 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h4 id="0的含义"><a href="#0的含义" class="headerlink" title="$0的含义"></a><code>$0</code>的含义</h4><p>第一种情况：直接命令调用一个shell，比如bash，会打开一个新的bash子shell，这时<code>echo $0</code>显示 shell的名称，比如<code>sh</code>，或者<code>bash</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># bash</span><br><span class="line"># echo &apos;$0&apos; is $0</span><br><span class="line"># $0 is bash</span><br></pre></td></tr></table></figure>
<p>第二种情况：shell 调用脚本文件，那么在脚本文件中<code>echo $0</code>就是脚本的文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bash  main.sh</span><br><span class="line"># $0 is main.sh</span><br></pre></td></tr></table></figure>
<h4 id="环境变量持久化"><a href="#环境变量持久化" class="headerlink" title="环境变量持久化"></a>环境变量持久化</h4><p>对全局环境变量来说<strong>不要将变量、设置放在<code>/etc/profile</code></strong>文件中，因为在你升级了所用的发行版后， 这个文件也会跟着更新，那所有定制过的变量设置可就都没有了。</p>
<p><strong>最好</strong>是在<code>/etc/profile.d</code>目录中创建一个以<code>.sh</code>结尾的文件。把所有新的或修改过的全局环境变 量设置放在这个文件中。</p>
<p>在大多数发行版中，存储个人用户永久性bash shell变量的地方是<code>~/.bashrc</code>文件。这一点适用于所有类型的shell进程。 但如果设置了 BASH_ENV 变量， 那么记住， 除非它指向的是<code>~/.bashrc</code>，否则你应该将非交互式shell的用户变量放在别的地方。</p>
<h4 id="命令输出赋给变量、命令替换"><a href="#命令输出赋给变量、命令替换" class="headerlink" title="命令输出赋给变量、命令替换"></a>命令输出赋给变量、命令替换</h4><ul>
<li>反引号字符（`）</li>
<li><code>$()</code>格式</li>
</ul>
<blockquote>
<p>   原理：命令替换会创建一个子shell来运行对应的命令。子shell（ subshell）是由运行该脚本的shell 所创建出来的一个独立的子shell（child shell） 。正因如此，由该子shell所执行命令是无法 使用脚本中所创建的变量的。</p>
</blockquote>
<p>TODO 没明白</p>
<p>在命令行提示符下使用路径 ./ 运行命令的话，也会创建出子shell；要是运行命令的时候 不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。 在命令行提示符下运行脚本时一定要留心！</p>
<h4 id="变量截取"><a href="#变量截取" class="headerlink" title="变量截取"></a>变量截取</h4><p>假设我们定义了一个变量为：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码如下:</span><br><span class="line">file=<span class="regexp">/dir1/</span>dir2/dir3/my.file.txt</span><br></pre></td></tr></table></figure>
<p>可以用<code>${ }</code>分别替换得到不同的值：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;file<span class="comment">#*/&#125;：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt</span></span><br><span class="line">$&#123;file<span class="comment">##*/&#125;：删掉最后一个 /  及其左边的字符串：my.file.txt</span></span><br><span class="line">$&#123;file<span class="comment">#*.&#125;：删掉第一个 .  及其左边的字符串：file.txt</span></span><br><span class="line">$&#123;file<span class="comment">##*.&#125;：删掉最后一个 .  及其左边的字符串：txt</span></span><br><span class="line">$&#123;file<span class="string">%/*&#125;：删掉最后一个  /</span>  及其右边的字符串：/dir1/dir2/dir3</span><br><span class="line">$&#123;file<span class="string">%%/*&#125;：删掉第一个 /  及其右边的字符串：(空值)</span></span><br><span class="line"><span class="string">$&#123;file%</span>.*&#125;：删掉最后一个  .  及其右边的字符串：/dir1/dir2/dir3/my.file</span><br><span class="line">$&#123;file<span class="string">%%.*&#125;：删掉第一个  .   及其右边的字符串：/dir1/dir2/dir3/my</span></span><br></pre></td></tr></table></figure>
<p>记忆的方法为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码如下<span class="symbol">:</span></span><br><span class="line"><span class="comment"># 是 去掉左边（键盘上#在 $ 的左边）</span></span><br><span class="line">%是去掉右边（键盘上% 在$ 的右边）</span><br><span class="line">单一符号是最小匹配；两个符号是最大匹配</span><br><span class="line">$&#123;<span class="symbol">file:</span><span class="number">0</span><span class="symbol">:</span><span class="number">5</span>&#125;：提取最左边的 <span class="number">5</span> 个字节：/dir1</span><br><span class="line">$&#123;<span class="symbol">file:</span><span class="number">5</span><span class="symbol">:</span><span class="number">5</span>&#125;：提取第 <span class="number">5</span> 个字节右边的连续<span class="number">5</span>个字节：/dir2</span><br></pre></td></tr></table></figure>
<p>也可以对变量值里的字符串作替换：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">代码如下<span class="symbol">:</span></span><br><span class="line">$&#123;file/dir/path&#125;：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt</span><br><span class="line">$&#123;file/<span class="regexp">/dir/path</span>&#125;：将全部dir 替换为 path：/path1/path2/path3/my.file.txt</span><br><span class="line"></span><br><span class="line">利用 $&#123; &#125; 还可针对不同的变数状态赋值(沒设定、空值、非空值)：</span><br><span class="line"></span><br><span class="line">$&#123;file-my.file.txt&#125; ：假如 $file 沒有设定，則使用 my.file.txt 作传回值。(空值及非空值時不作处理) </span><br><span class="line">$&#123;<span class="symbol">file:</span>-my.file.txt&#125; ：假如 $file 沒有設定或為空值，則使用 my.file.txt 作傳回值。 (非空值時不作处理)</span><br><span class="line">$&#123;file+my.file.txt&#125; ：假如 $file 設為空值或非空值，均使用 my.file.txt 作傳回值。(沒設定時不作处理)</span><br><span class="line">$&#123;<span class="symbol">file:</span>+my.file.txt&#125; ：若 $file 為非空值，則使用 my.file.txt 作傳回值。 (沒設定及空值時不作处理)</span><br><span class="line">$&#123;file=my.file.txt&#125; ：若 $file 沒設定，則使用 my.file.txt 作傳回值，同時將 $file 賦值為 my.file.txt 。 (空值及非空值時不作处理)</span><br><span class="line">$&#123;<span class="symbol">file:</span>=my.file.txt&#125; ：若 $file 沒設定或為空值，則使用 my.file.txt 作傳回值，同時將 $file 賦值為my.file.txt 。 (非空值時不作处理)</span><br><span class="line">$&#123;file?my.file.txt&#125; ：若 $file 沒設定，則將 my.file.txt 輸出至 STDERR。 (空值及非空值時不作处理)</span><br><span class="line"></span><br><span class="line">$&#123;<span class="symbol">file:</span>?my.file.txt&#125; ：若 $file 没设定或为空值，则将 my.file.txt 输出至 STDERR。 (非空值時不作处理)</span><br><span class="line">$&#123;<span class="comment">#var&#125; 可计算出变量值的长度：</span></span><br><span class="line"></span><br><span class="line">$&#123;<span class="comment">#file&#125; 可得到 27 ，因为/dir1/dir2/dir3/my.file.txt 是27个字节</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.jb51.net/article/64804.htm" target="_blank" rel="noopener">参考来源</a></p>
<h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><ul>
<li>Bash Shell 只支持一维数组（不支持多维数组）。</li>
<li>初始化时不需要定义数组大小（与 PHP 类似）。</li>
<li>数组元素的下标由0开始。</li>
</ul>
<h4 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h4><p>Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 value2 … valuen)</span><br></pre></td></tr></table></figure>
<p>例如：my_array=(A B “C” D)</p>
<p>我们也可以使用下标来定义数组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure>
<h4 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h4><p>这样是行不通的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$mytest</span>      <span class="comment"># 打印数组只会显示第一个值</span></span></span><br><span class="line">one</span><br></pre></td></tr></table></figure>
<p>一般格式是：<code>${array_name[index]}</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br><span class="line">echo "第一个元素为: $&#123;my_array[0]&#125;"</span><br><span class="line">echo "第二个元素为: $&#123;my_array[1]&#125;"</span><br><span class="line">echo "第三个元素为: $&#123;my_array[2]&#125;"</span><br><span class="line">echo "第四个元素为: $&#123;my_array[3]&#125;"</span><br></pre></td></tr></table></figure>
<p><strong>获取数组中的所有元素</strong></p>
<p>使用<code>@</code> 或 <code>*</code> 可以获取数组中的所有元素，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br><span class="line">echo "数组的元素为: $&#123;my_array[*]&#125;"</span><br><span class="line">echo "数组的元素为: $&#123;my_array[@]&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数组的元素为: A B C D 数组的元素为: A B C D</span></span><br></pre></td></tr></table></figure>
<p><strong>获取数组的长度</strong></p>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br><span class="line">echo "数组元素个数为: $&#123;#my_array[*]&#125;"</span><br><span class="line">echo "数组元素个数为: $&#123;#my_array[@]&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数组元素个数为: 4 数组元素个数为: 4</span></span><br></pre></td></tr></table></figure>
<h4 id="删除某个值"><a href="#删除某个值" class="headerlink" title="删除某个值"></a>删除某个值</h4><p>unset命令删除数组中的某个值，但是要小心，这可能会有点复杂。看下面的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">unset</span> mytest[2]  </span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;mytest[*]&#125;  <span class="comment"># 遍历时会跳过被删除的索引位置</span></span><br><span class="line">one two four five </span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[2]&#125;</span> <span class="comment"># 但是该索引位置还占用着</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;mytest[3]&#125; </span><br><span class="line">four</span><br></pre></td></tr></table></figure>
<p>这个例子用unset命令删除在索引值为2的位置上的值。显示整个数组时，看起来像是索引 里面已经没这个索引了。但当专门显示索引值为2的位置上的值时，就能看到这个位置是空的。 最后，可以在unset命令后跟上数组名来删除整个数组。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> mytest   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;mytest[*]&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h4><p>首先创建一个数组 array=( A B C D 1 2 3 4)</p>
<h5 id="标准的for循环"><a href="#标准的for循环" class="headerlink" title="标准的for循环"></a><strong>标准的for循环</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(( i=0;i&lt;$&#123;#array[@]&#125;;i++)) #$&#123;#array[@]&#125;获取数组长度用于循环</span><br><span class="line">do    </span><br><span class="line">	echo $&#123;array[i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h5 id="for-…-in"><a href="#for-…-in" class="headerlink" title="for … in"></a><strong>for … in</strong></h5><p>不带数组下标</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for element in $&#123;array[@]&#125;    #也可以写成for element in $&#123;array[*]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $element</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>带数组下标</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in $&#123;!array[@]&#125;  </span><br><span class="line">do   </span><br><span class="line">   echo $i $&#123;array[$i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h5 id="while循环法"><a href="#while循环法" class="headerlink" title="while循环法"></a><strong>while循环法</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=0  </span><br><span class="line">while [ $i -lt $&#123;#array[@]&#125; ]    #当变量（下标）小于数组长度时进入循环体</span><br><span class="line">do  </span><br><span class="line">    echo $&#123;array[$i]&#125;   #按下标打印数组元素</span><br><span class="line">    let i++  </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="shell-展开"><a href="#shell-展开" class="headerlink" title="shell 展开"></a>shell 展开</h3><p>Bash 有七种扩展格式。本文只介绍其中五种：<code>~</code> 扩展、算术扩展、路径名称扩展、大括号扩展和命令替换。</p>
<p><img src="/2019/08/13/linux-shell编程/./shell展开.png" alt="shell 展开"></p>
<h4 id="花括号"><a href="#花括号" class="headerlink" title="{}花括号"></a><code>{}</code>花括号</h4><p>从一个包含花括号的模式中创建多个文本字符串。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 逗号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span></span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 序列</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> Num_&#123;1..5&#125;</span></span><br><span class="line">Num_1 Num_2 Num_3 Num_4 Num_5</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> Num_&#123;1..10..2&#125;  <span class="comment"># 间隔</span></span></span><br><span class="line">Num_1 Num_3 Num_5 Num_7 Num_9</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;Z..A&#125;          <span class="comment"># 倒序</span></span></span><br><span class="line">Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b <span class="comment">#嵌套</span></span></span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></table></figure>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="~扩展"></a><code>~</code>扩展</h4><p>Bash shell 把这个快捷方式展开成用户的完整的家目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ~</span></span><br><span class="line">/home/student</span><br></pre></td></tr></table></figure>
<h4 id="路径名称扩展"><a href="#路径名称扩展" class="headerlink" title="路径名称扩展"></a>路径名称扩展</h4><p>路径名称扩展是展开文件通配模式为匹配该模式的完整路径名称的另一种说法，匹配字符使用 <code>?</code> 和 <code>*</code></p>
<ul>
<li><p><code>?</code> — 匹配字符串中特定位置的一个任意字符</p>
</li>
<li><p><code>*</code> — 匹配字符串中特定位置的 0 个或多个任意字符</p>
</li>
</ul>
<h4 id="展开"><a href="#展开" class="headerlink" title="$展开"></a><code>$</code>展开</h4><p>‘$’ 符号引入了三种 shell 展开，包括 “参数展开”，“命令替换” 和 “算术表达式”。</p>
<h5 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$USER</span></span></span><br></pre></td></tr></table></figure>
<p>参数展开的基本的形式是 <code>${PARAMETER}</code>，整体被替换为 PARAMETER 的值。花括号如果 PARAMETER 是位置参数，而且由两个及以上的数字表示，这时必须使用花括号：<code>${10}</code>。另外当 PARAMETER 与其它字符相邻连接时，也必须使用花括号：<code>${Var}lala</code>。</p>
<h5 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h5><p>命令替换是让一个命令的标准输出数据流被当做参数传给另一个命令的扩展形式。</p>
<p>命令替换有两种格式：<code>command</code> 和 <code>$(command)</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Todays date is <span class="variable">$(date)</span>"</span></span></span><br><span class="line">Todays date is Sun Apr  7 14:42:59 EDT 2019</span><br></pre></td></tr></table></figure>
<h5 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h5><p>数字扩展的语法是 <code>$((arithmetic-expression))</code> ，分别用两个括号来打开和关闭表达式。算术扩展在 shell 程序或脚本中<strong>类似命令替换</strong>；表达式结算后的结果替换了表达式，用于 shell 后续的计算。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> Var1=5 ; Var2=7 ; Var3=$((Var1*Var2)) ; <span class="built_in">echo</span> <span class="string">"Var 3 = <span class="variable">$Var3</span>"</span></span></span><br><span class="line">Var 3 = 35</span><br></pre></td></tr></table></figure>
<h4 id="禁用展开"><a href="#禁用展开" class="headerlink" title="禁用展开"></a>禁用展开</h4><h5 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h5><p>把文本放在双引号中后，shell 使用的特殊字符，除了 <code>$</code>，<code>\</code> ，和 `（倒引号）之外， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割、路径名展开、波浪线展开、花括号展开都被禁止，<strong>然而参数展开，算术展开，命令替换仍然有效。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 多余的空格会被压缩</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a    <span class="built_in">test</span></span></span><br><span class="line">this is a test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 双引号关闭了单词分割功能</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"this is a    test"</span></span></span><br><span class="line">this is a    test</span><br></pre></td></tr></table></figure>
<p>案例2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 没有引用的命令替换导致命令行包含 38 个参数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(cal)</span></span><br><span class="line">January 2019 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 命令行只有一个参数，参数中包括嵌入的空格和换行符。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$(cal)</span>"</span></span></span><br><span class="line">    January 2019</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">       1  2  3  4  5</span><br><span class="line"> 6  7  8  9 10 11 12</span><br><span class="line">13 14 15 16 17 18 19</span><br><span class="line">20 21 22 23 24 25 26</span><br><span class="line">27 28 29 30 31</span><br></pre></td></tr></table></figure>
<h5 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h5><p>如果需要禁止所有的展开，需要使用单引号，包括转义符号<code>\</code></p>
<h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><p>在文件名中可能使用一些对于 shell 来说，有特殊含义的字符。这些字符包括 “$”, “!”, “ “ 等字符。在文件名中包含特殊字符，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv bad\&amp;filename good_filename</span><br></pre></td></tr></table></figure>
<p>注意在<strong>单引号</strong>中，反斜杠<strong>失去它的特殊含义</strong>，它会被看作普通字符。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>覆盖原本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 正常信息写入</span><br><span class="line">2&gt; 错误信息写入</span><br><span class="line">&amp;&gt; 不论是正确还是错误信息，都写入文件中</span><br></pre></td></tr></table></figure>
<p>追加文本文件，多一个<code>&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 正常信息写入</span><br><span class="line">2&gt;&gt; 错误信息写入</span><br><span class="line">&amp;&gt;&gt; 不论是正确还是错误信息，都写入文件中</span><br></pre></td></tr></table></figure>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;   # 输入重定向</span><br><span class="line">&lt;&lt;  # 内联输入重定向</span><br></pre></td></tr></table></figure>
<p>内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，你必须指定一个文本标记来划分输 入数据的开始和结尾。它的用途请看 数学运算那一章节的 bc 计算器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wc &lt;&lt; EOF</span><br><span class="line">&gt; test string 1</span><br><span class="line">&gt; test string 2</span><br><span class="line">&gt; test string 3</span><br><span class="line">&gt; EOF</span><br><span class="line">$ 3  9  42</span><br></pre></td></tr></table></figure>
<h4 id="重定向绑定-gt-amp"><a href="#重定向绑定-gt-amp" class="headerlink" title="重定向绑定&gt;&amp;"></a>重定向绑定<code>&gt;&amp;</code></h4><p><strong>原理</strong>：linux在执行shell命令之前，就<strong>会确定好所有的输入输出位置</strong>，并且<strong>从左到右依次执行重定向的命令</strong></p>
<p><code>command 2&gt;&amp;1</code></p>
<p>这条命令用到了<strong>重定向绑定</strong>，采用<code>&amp;</code>可以将两个输出绑定在一起，即错误输出将和标准输出共用一个文件描述符。</p>
<p>可以这样记住这条写法（虽然并不完全正确）首先，<code>2&gt;1</code> 会被解释成将<code>stderr</code> 重定向到一个名为 <code>1</code>的文件中。 因此加入<code>&amp;</code>来表示紧跟着的是文件描述符（file descriptor)而不是文件名，因此最终就是这样的形式： <code>2&gt;&amp;1</code></p>
<p>理解上面的原理后，就可以明白下面的例子了：</p>
<p><strong>标准输出和标准错误重定向到不同log文件中</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh mr_add_test.sh &gt;log.log 2&gt;log_err.log</span><br></pre></td></tr></table></figure>
<p><strong>将标准输出和标准错误重定向到同一log文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo &gt;file 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p><code>&gt;file</code> 将标准输出重定向到文件中<br><code>2&gt;&amp;1</code>  将错误绑定到标准输出上，此时标准输出已经重定向到file了</p>
<p><strong>输出标准输出和标准错误，同时保存到文件logfile</strong></p>
<p>方法一： <code>&lt;command&gt; 2&gt;&amp;1 | tee &lt;logfile&gt;</code></p>
<p>管道符号把一个进程的标准输出作为另一个进程的标准输入。<code>2&gt;&amp;1</code>是把标准错误重定向到标准输出的副本一起输出。上面的命令，把标准输出和标准错误都输出作为tee命令的标准输入，tee的作用为把标准输入的内容拷贝到文件，并输出。</p>
<p>方法二：<code>&lt;command&gt;  2&gt; logfile | cat - logfile</code></p>
<p>cat可以带多个文件参数，同时显示多个文件的内容。 <code>-</code>代表标准输入，logfile是管道前保存的标准错误文本。</p>
<p><strong>只输出错误，并保存到文件中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;command&gt; 2&gt;&amp;1 &gt;/dev/null | tee logfile</span><br></pre></td></tr></table></figure>
<p>这条命令其实分为两命令，一个是<code>&gt;/dev/null</code>，另一个是<code>2&gt;&amp;1</code>。</p>
<ol>
<li><code>2&gt;&amp;1</code>  将标准错误重定向到标准输出，注意，<strong>此时标准输出还没有被重定向</strong></li>
<li><code>/dev/null</code>文件是一个空设备，类似于windows内的回收站，使用<code>&gt;/dev/null</code>将标准输出重定向到<code>/dev/null</code>，即不显示标准输出的内容。所以这时的标准输出就仅变为重定向过来的标准错误了。</li>
</ol>
<p>相反，如果两者颠倒顺序，那标准输出连同它的副本都会被重定向到/dev/null，这是一个逻辑问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make 2&gt;&amp;1 &gt;/dev/null     # 顺序1，错误还是输出到屏幕</span><br><span class="line">make: *** No targets specified and no makefile found.  Stop.</span><br><span class="line"></span><br><span class="line">make &gt;/dev/null 2&gt;&amp;1     # 顺序2，不输出错误</span><br></pre></td></tr></table></figure>
<p><strong><code>&gt;/dev/null 2&gt;&amp;1</code> 与 <code>&gt;/dev/null 2&gt;/dev/null</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls a.txt b.txt &gt;out 2&gt;out</span><br><span class="line">cat out</span><br><span class="line"># a.txt</span><br><span class="line"># txt: No such file or directory</span><br></pre></td></tr></table></figure>
<p><code>out</code>中出现了丢失。采用这种写法，标准输出和错误输出会抢<strong>占往out文件的管道</strong>，所以可能会导致输出内容的时候出现缺失、覆盖等情况。有时候也有可能出现只有error信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。</p>
<p>而且，由于out文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体IO效率不如<code>&gt;/dev/null 2&gt;&amp;1</code>来得高。</p>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><h4 id="expr-不推荐"><a href="#expr-不推荐" class="headerlink" title="expr (不推荐)"></a>expr (不推荐)</h4><p>标准操作符在expr命令中工作得很好，但在脚本或命令行上使用它们时仍有问题出现。 许多expr命令操作符在shell中另有含义（比如星号）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ expr 5 * 2 </span><br><span class="line">expr: syntax error </span><br><span class="line"></span><br><span class="line"># 需要进行转义</span><br><span class="line">$ expr 5 \* 2</span><br></pre></td></tr></table></figure>
<h4 id="方括号-只支持整数"><a href="#方括号-只支持整数" class="headerlink" title="方括号(只支持整数)"></a>方括号(只支持整数)</h4><p>用<code>$[ operation ]</code>将数学表达式围起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var1=$[1 + 5]</span><br><span class="line">$ echo $var1 </span><br><span class="line"># 6</span><br></pre></td></tr></table></figure>
<p> <strong>注意</strong>：bash shell数学运算符<strong>只支持整数运算</strong>。若要进行任何实际的数学计算，这是一个巨大的限制。z shell（zsh）提供了完整的浮点数算术操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var1=100</span><br><span class="line">var2=45</span><br><span class="line">var3=$[$var1 / $var2]</span><br><span class="line">echo $var3</span><br><span class="line"># 2</span><br></pre></td></tr></table></figure>
<h4 id="bc计算器-浮点数计算"><a href="#bc计算器-浮点数计算" class="headerlink" title="bc计算器(浮点数计算)"></a>bc计算器(浮点数计算)</h4><p><strong>命令行</strong></p>
<p>bash计算器支持变量print语句允许你打印 变量和数字，<code>-q</code> 命令行选项可以不显示bash计算器冗长的欢迎信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bc  -q</span><br><span class="line">res=12 * 5.4 <span class="comment"># 变量</span></span><br><span class="line"><span class="built_in">print</span> res</span><br><span class="line">64.8</span><br><span class="line">1+res</span><br><span class="line">65.8    <span class="comment"># 计算结果</span></span><br><span class="line">quit	<span class="comment"># 退出</span></span><br></pre></td></tr></table></figure>
<p>浮点运算是由内建变量scale控制的。必须将这个值设置为你希望在计算结果中保留的小数 位数，否则无法得到期望的结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bc -q</span><br><span class="line">3.44 / 5 </span><br><span class="line">0 </span><br><span class="line">scale=4</span><br><span class="line">3.44 / 5 </span><br><span class="line">.6880 </span><br><span class="line">quit </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p><strong>脚本</strong></p>
<p>基本格式如下：</p>
<p><code>variable=$(echo &quot;options; expression&quot; | bc)</code></p>
<ul>
<li><p>options 允许你设置变量。 如果你需要不止一个变量， 可以用分号将其分开</p>
</li>
<li><p>expression参数定义了通过bc执行的数学表达式</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat test10 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">var1=100 </span><br><span class="line">var2=45 </span><br><span class="line">var3=$(<span class="built_in">echo</span> <span class="string">"scale=4; <span class="variable">$var1</span> / <span class="variable">$var2</span>"</span> | bc) </span><br><span class="line"><span class="built_in">echo</span> The answer <span class="keyword">for</span> this is <span class="variable">$var3</span> </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p> <strong>大量运算</strong></p>
<p>最好的办法是使用内联输入重定向，当然，必须用命令替换符号标识出用来给变量赋值的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat test12</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">var1=10.46</span><br><span class="line">var2=43.67</span><br><span class="line">var3=33.2</span><br><span class="line">var4=71</span><br><span class="line">var5=$(bc &lt;&lt; EOF </span><br><span class="line">scale = 4 </span><br><span class="line">a1 = ( <span class="variable">$var1</span> * <span class="variable">$var2</span>) </span><br><span class="line">b1 = (<span class="variable">$var3</span> * <span class="variable">$var4</span>) </span><br><span class="line">a1 + b1 </span><br><span class="line">EOF </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> The final answer <span class="keyword">for</span> this mess is <span class="variable">$var5</span> </span><br><span class="line">s$</span><br></pre></td></tr></table></figure>
<p>你可以在bash计算器中赋值给变量。这一点很重要：在bash 计算器中创建的变量只在bash计算器中有效，<strong>不能在shell脚本中使用</strong>。</p>
<h4 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h4><table>
<thead>
<tr>
<th style="text-align:left">运算操作符/运算命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>((a=10+66) ((b=a-15)) ((c=a+b))</code></td>
<td style="text-align:left">在 (( )) 中使用变量无需加上<code>$</code>前缀，(( )) 会自动解析变量名</td>
</tr>
<tr>
<td style="text-align:left"><code>a=$((10+66)</code><br> <code>b=$((a-15))</code><br> <code>c=$((a+b))</code></td>
<td style="text-align:left">使用<code>$</code>获取 (( )) 命令的结果</td>
</tr>
<tr>
<td style="text-align:left"><code>((a&gt;7 &amp;&amp; b==c))</code></td>
<td style="text-align:left">(( )) 也可以进行逻辑运算，在 if 语句中常会使用逻辑运算。</td>
</tr>
<tr>
<td style="text-align:left"><code>echo $((a+10))</code></td>
<td style="text-align:left">需要立即输出表达式的运算结果时，可以在 (( )) 前面加<code>$</code>符号。</td>
</tr>
<tr>
<td style="text-align:left"><code>c=$((a=3+5, b=a+10))</code></td>
<td style="text-align:left">多个表达式之间以逗号<code>,</code>分隔。以最后一个表达式的值作为整个 (( )) 命令的执行结果。</td>
</tr>
</tbody>
</table>
<p><strong>数字高级比较</strong> （双括号）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure>
<p>双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。但还是<strong>只支持整数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val++     # 后增 </span><br><span class="line">val--     # 后减</span><br><span class="line">++val     # 先增</span><br><span class="line">--val     # 先减</span><br><span class="line">!         # 逻辑求反</span><br><span class="line">~         # 位求反</span><br><span class="line">**        # 幂运算</span><br><span class="line">&lt;&lt;        # 左位移 </span><br><span class="line">&gt;&gt;        # 右位移</span><br><span class="line">&amp;         # 位布尔和</span><br><span class="line">|         # 位布尔或 </span><br><span class="line">&amp;&amp;        # 逻辑和 </span><br><span class="line">||        # 逻辑或</span><br></pre></td></tr></table></figure>
<p>注意，<strong>不需要将双括号中表达式里的大于号转义</strong>。这是双括号命令提供的另一个高级特性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> using double parenthesis </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">val1=10 </span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">if (( $val1 ** 2 &gt; 90 )) </span><br><span class="line">then</span><br><span class="line">    (( val2 = $val1 ** 2 ))</span><br><span class="line">    echo "The square of $val1 is $val2" </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p>shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。退出状态码是一个<strong>0～255</strong>的整数值，在命令结束运行时执行<code>exit code</code>传给shell。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>成功结束</td>
</tr>
<tr>
<td>1</td>
<td>一般性未知错误</td>
</tr>
<tr>
<td>2</td>
<td>不合适的 shell 命令</td>
</tr>
<tr>
<td>126</td>
<td>命令不可执行，比如没有权限</td>
</tr>
<tr>
<td>127</td>
<td>没有找到命令</td>
</tr>
<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>
<tr>
<td>128+x</td>
<td>与 Linux 信号 x 相关的严重错误</td>
</tr>
<tr>
<td>130</td>
<td>通过 Ctrl+C 终止的命令</td>
</tr>
<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody>
</table>
<h3 id="脚本的健壮性"><a href="#脚本的健壮性" class="headerlink" title="脚本的健壮性"></a>脚本的健壮性</h3><p>要写出健壮性更好的脚本，下面是一些相关的技巧：</p>
<ul>
<li>使用 <code>-e</code> 参数，如：<code>set -e</code> 或是 <code>#!/bin/sh -e</code>，这样设置会让你的脚本出错就会停止运行，这样一来可以防止你的脚本在出错的情况下还在拼拿地干活停不下来。</li>
<li>使用 <code>-u</code> 参数，如： <code>set -eu</code>，这意味着，如果你代码中有变量没有定义，就会退出。</li>
<li>你可以使用 <code>set -x</code> 来debug输出。</li>
<li>考虑使用 <code>set -o pipefail</code> 来限制错误。还可以使用trap来截获信号（如截获ctrl+c）。</li>
<li>对一些变理，你可以使用默认值。如：<code>${FOO:-&#39;default&#39;}</code></li>
<li>处理你代码的退出码。这样方便你的脚本跟别的命令行或脚本集成。</li>
<li>尽量使用 <code>&amp;&amp;</code> 来执行多个命令，而不是 <code>;</code>，这样会在出错的时候停止运行后续的命令。</li>
<li>对于一些字符串变量，使用引号括起，避免其中有空格或是别的什么诡异字符。</li>
<li>如果你的脚有参数，你需要检查脚本运行是否带了你想要的参数，或是，你的脚本可以在没有参数的情况下安全的运行。</li>
<li>为你的脚本设置 <code>-h</code> 和 <code>--help</code> 来显示帮助信息。千万不要把这两个参数用做为的功能。</li>
<li>使用 <code>$()</code> 而不是 “ 来获得命令行的输出，主要原因是易读。</li>
<li>小心不同的平台，尤其是 MacOS 和 Linux 的跨平台。</li>
<li>对于 <code>rm -rf</code> 这样的高危操作，需要检查后面的变量名是否为空，比如：<code>rm -rf $MYDIDR/*</code> 如果 <code>$MYDIR</code>为空，结果是灾难性的。</li>
<li>考虑使用 <code>find/while</code>而不是 <code>for/find</code>。如：<code>for F in $(find . -type f) ; do echo $F; done</code> 写成 <code>find . -type f | while read F ; do echo $F ; done</code> 不但可以容忍空格，而且还更快。</li>
<li>防御式编程，在正式执行命令前，把相关的东西都检查好，比如，文件目录有没有存在。</li>
</ul>
<p>你还可以使用网站<a href="https://www.shellcheck.net/" target="_blank" rel="noopener">ShellCheck</a>来帮助你检查你的脚本。</p>
<p>转至：<a href="https://coolshell.cn/articles/19219.html" target="_blank" rel="noopener">https://coolshell.cn/articles/19219.html</a></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h4><p><code>command1 &amp;&amp; command2</code> ：如果 command1 执行成功，那么接着执行 command2。如果 command1 失败，就跳过 command2。</p>
<p><code>command1 || command2</code>：如果 command1 失败，执行 command2。隐藏的逻辑是，如果 command1 成功，跳过 command2。</p>
<p><code>&amp;&amp;</code> 和 <code>||</code> 两种运算符结合起来才能发挥它们的最大功效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前置 commands ; command1 &amp;&amp; command2 || command3 ; 跟随 commands</span><br></pre></td></tr></table></figure>
<p>语法解释：假如 command1 退出时返回码为零，就执行 command2，否则执行 command3。<strong>类似于 if-else的逻辑</strong>。</p>
<p>用具体代码试试，在 root 的 home 目录下测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[student@studentvm1 ~]$ Dir=/root/testdir ; mkdir $Dir &amp;&amp; cd $Dir || echo "$Dir was not created."mkdir: cannot create directory '/root/testdir': Permission denied/root/testdir was not created.</span><br></pre></td></tr></table></figure>
<p>现在在你的家目录执行，你将会有权限创建这个目录了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[student@studentvm1 ~]$ Dir=~/testdir ; mkdir $Dir &amp;&amp; cd $Dir || echo "$Dir was not created."</span><br></pre></td></tr></table></figure>
<h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if command </span><br><span class="line">then</span><br><span class="line">    commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 推荐</span><br><span class="line">if command; then </span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  通过把分号放在待求值的命令尾部，就可以将 then 语句放在同一行上了，这样看起来更 像其他编程语言中的 if-then 语句。</p>
</blockquote>
<p>bash shell的if语句会运行<code>if</code>后面的那个命令。如果该命令的<strong>退出状态码是0</strong>，就执行<code>then</code>后的命令。在其他编程语言 中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。</p>
<p><strong>if else</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if command</span><br><span class="line">then</span><br><span class="line">    commands </span><br><span class="line">else</span><br><span class="line">    commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>if elif</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if command1 </span><br><span class="line">then</span><br><span class="line">    commands </span><br><span class="line">elif command2</span><br><span class="line">then</span><br><span class="line">    more commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  注意：记住， 在 elif 语句中， 紧跟其后的 else 语句属于 elif 代码块。 它们并不属于之前的 if-then 代码块。</p>
</blockquote>
<h4 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h4><p>if-then语句是否能测试命令退出状态码之外的条件。答案是不能。</p>
<p><code>test</code>命令提供了在<code>if-then</code>语句中测试不同条件的途径。如果test命令中列出的条件成立， <code>test</code>命令就会退出并返回退出状态码<code>0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if test condition </span><br><span class="line">then </span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h5 id="推荐写法"><a href="#推荐写法" class="headerlink" title="推荐写法"></a>推荐写法</h5><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ] </span><br><span class="line">then</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>方括号定义了测试条件。注意，</p>
<ul>
<li><strong>第一个方括号之后和第二个方括号之前必须加上一个空格</strong>， 否则就会报错。</li>
<li>括号内的大于号、小于号，需要进行转义，后面的双括号才不需要。</li>
</ul>
<p><strong>否定写法(感叹号)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -f $FILE ]; then  # !后有空格</span><br><span class="line">    echo &quot;source company doesn\&apos;t exist&quot;</span><br><span class="line">    exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h5 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h5><p>test命令可以判断三类条件：</p>
<ol>
<li>数值比较 </li>
<li>字符串比较</li>
<li>文件比较</li>
</ol>
<h6 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h6><p>我们不能在 test命令中使用浮点值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n1 -eq n2    # 检查n1是否=n2 </span><br><span class="line">n1 -ge n2    # 检查n1是否&gt;=n2 </span><br><span class="line">n1 -gt n2    # 检查n1是否&gt;n2 </span><br><span class="line">n1 -le n2    # 检查n1是否&lt;=n2 </span><br><span class="line">n1 -lt n2    # 检查n1是否&lt;n2 </span><br><span class="line">n1 -ne n2    # 检查n1是否!=n2</span><br></pre></td></tr></table></figure>
<p>test命令只能在比较中使用简单的 算术操作。双括号命令提供了更多的数学符号。请看后面内容。</p>
<h6 id="字符串比较-有坑"><a href="#字符串比较-有坑" class="headerlink" title="字符串比较(有坑)"></a>字符串比较(有坑)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = str2   # 检查str1是否和str2相同 </span><br><span class="line">str1 != str2  # 检查str1是否和str2不同 </span><br><span class="line">str1 \&lt; str2   # 检查str1是否比str2小，注意一定要转义</span><br><span class="line">str1 \&gt; str2   # 检查str1是否比str2大，注意一定要转义</span><br><span class="line">-n str1       # 检查str1的长度是否非0</span><br><span class="line">-z str1       # 检查str1的长度是否为0，未在shell脚本中定义过，所以它的字符串长度仍然 为0</span><br></pre></td></tr></table></figure>
<p><strong>字符串长度比较</strong></p>
<p>计算字符串的长度没有简单的方法。有很多种方法可以计算，但是我认为使用 <code>expr</code>（求值表达式）命令是相对最简单的一种。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyVar="How long is this?" ; expr length "$MyVar"    # 注意 mac 中并没有 length 这个命令</span><br></pre></td></tr></table></figure>
<p>这里会出现经常困扰shell程序员的问题：</p>
<ul>
<li><p>大于号和小于号必须转义，否则shell会把它们当作<strong>重定向符号</strong>，把字符串值当作文件名；</p>
</li>
<li><p>大于和小于顺序和sort命令所采用的不同</p>
<blockquote>
<p>  这是因为 比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort 命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺 序中小写字母出现在大写字母前。</p>
</blockquote>
</li>
<li><p>未在shell脚本中定义过，<code>-z</code>认为它的字符串长度为0</p>
</li>
</ul>
<p><strong>字符串中有空格的情况处理</strong></p>
<p>有些人从在文件名或者命令行参数中使用空格，你需要在编写脚本时时刻记得这件事。你需要时刻记得用引号包围变量。</p>
<p><code>if [ $filename = &quot;foo&quot; ];</code></p>
<p>当$filename变量包含空格时就会挂掉。可以这样解决：</p>
<p><code>if [ &quot;$filename&quot; = &quot;foo&quot; ];</code></p>
<p>使用<code>$@</code>变量时，你也需要使用引号，因为空格隔开的两个参数会被解释成两个独立的部分。</p>
<h6 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h6><table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-a filename</code></td>
<td style="text-align:left">如果文件存在，返回真值；文件可以为空也可以有内容，但是只要它存在，就返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-b filename</code></td>
<td style="text-align:left">如果文件存在且是一个块设备，如 <code>/dev/sda</code> 或 <code>/dev/sda1</code>，则返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-c filename</code></td>
<td style="text-align:left">如果文件存在且是一个字符设备，如 <code>/dev/TTY1</code>，则返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-d filename</code></td>
<td style="text-align:left">如果文件存在且是一个目录，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-e filename</code></td>
<td style="text-align:left">如果文件存在，返回真值；与上面的 <code>-a</code> 相同，可用于文件和目录</td>
</tr>
<tr>
<td style="text-align:left"><code>-f filename</code></td>
<td style="text-align:left">如果文件存在且是一个一般文件，不是目录、设备文件或链接等的其他的文件，则返回 真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-g filename</code></td>
<td style="text-align:left">如果文件存在且 <code>SETGID</code> 标记被设置在其上，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-h filename</code></td>
<td style="text-align:left">如果文件存在且是一个符号链接，则返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-k filename</code></td>
<td style="text-align:left">如果文件存在且粘滞位已设置，则返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-p filename</code></td>
<td style="text-align:left">如果文件存在且是一个命名的管道（FIFO），返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-r filename</code></td>
<td style="text-align:left">如果文件存在且有可读权限（它的可读位被设置），返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-s filename</code></td>
<td style="text-align:left">如果文件存在且大小大于 0，返回真值（存在并非空）；如果一个文件存在但大小为 0，则返回假值</td>
</tr>
<tr>
<td style="text-align:left"><code>-t fd</code></td>
<td style="text-align:left">如果文件描述符 <code>fd</code> 被打开且被关联到一个终端设备上，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-u filename</code></td>
<td style="text-align:left">如果文件存在且它的 <code>SETUID</code> 位被设置，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-w filename</code></td>
<td style="text-align:left">如果文件存在且有可写权限，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-x filename</code></td>
<td style="text-align:left">如果文件存在且有可执行权限，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-G filename</code></td>
<td style="text-align:left">如果文件存在且文件的组 ID 与当前用户相同，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-L filename</code></td>
<td style="text-align:left">如果文件存在且是一个符号链接，返回真值（同 <code>-h</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>-N filename</code></td>
<td style="text-align:left">如果文件存在且从文件上一次被读取后文件被修改过，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-O filename</code></td>
<td style="text-align:left">如果文件存在且你是文件的拥有者，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-S filename</code></td>
<td style="text-align:left">如果文件存在且文件是套接字，返回真值</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">在你尝试使用<code>ef</code>、<code>-nt</code>或 <code>-ot</code>比较文件之前，必须先确认文件是存在的。</td>
</tr>
<tr>
<td style="text-align:left"><code>file1 -ef file2</code></td>
<td style="text-align:left">如果文件 <code>file1</code> 和文件 <code>file2</code> 指向同一设备的同一 INODE 号，返回真值（即硬链接）</td>
</tr>
<tr>
<td style="text-align:left"><code>file1 -nt file2</code></td>
<td style="text-align:left">如果文件 <code>file1</code> 比 <code>file2</code> 新（根据修改日期），或 <code>file1</code> 存在而 <code>file2</code> 不存在，返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>file1 -ot file2</code></td>
<td style="text-align:left">如果文件 <code>file1</code> 比 <code>file2</code> 旧（根据修改日期），或 <code>file1</code> 不存在而 <code>file2</code> 存在</td>
</tr>
</tbody>
</table>
<p>判断文件存在并不为空的脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File="TestFile1"</span><br><span class="line">echo "This is $File" &gt; $File</span><br><span class="line">if [ -s $File ]</span><br><span class="line">   then</span><br><span class="line">   echo "$File exists and contains data."</span><br><span class="line">elif [ -e $File ]</span><br><span class="line">   then</span><br><span class="line">   echo "$File exists and is empty."</span><br><span class="line">else</span><br><span class="line">   echo "$File does not exist."</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h6 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h6><p>这些杂项操作符展示一个 shell 选项是否被设置，或一个 shell 变量是否有值，但是它不显示变量的值，只显示它是否有值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-o optname</code></td>
<td style="text-align:left">如果一个 shell 选项 <code>optname</code> 是启用的（查看内建在 Bash 手册页中的 set <code>-o</code> 选项描述下面的选项列表），则返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-v varname</code></td>
<td style="text-align:left">如果 shell 变量 <code>varname</code> 被设置了值（被赋予了值），则返回真值</td>
</tr>
<tr>
<td style="text-align:left"><code>-R varname</code></td>
<td style="text-align:left">如果一个 shell 变量 <code>varname</code> 被设置了值且是一个名字引用，则返回真值</td>
</tr>
</tbody>
</table>
<p><a href="https://linux.cn/article-11687-1.html" target="_blank" rel="noopener">https://linux.cn/article-11687-1.html</a></p>
<h5 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：  </span><br><span class="line">[ condition1 ] &amp;&amp; [ condition2 ] </span><br><span class="line">[ condition1 ] || [ condition2 ]</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing compound comparisons </span></span><br><span class="line"><span class="comment"># if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ] </span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The file exists and you can write to it"</span> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"I cannot write to the file"</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h4 id="双括号与双中括号-进阶"><a href="#双括号与双中括号-进阶" class="headerlink" title="双括号与双中括号(进阶)"></a>双括号与双中括号(进阶)</h4><h5 id="数字高级比较-（双括号）"><a href="#数字高级比较-（双括号）" class="headerlink" title="数字高级比较 （双括号）"></a>数字高级比较 （双括号）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure>
<p>双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。但还是<strong>只支持整数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val++     # 后增 </span><br><span class="line">val--     # 后减</span><br><span class="line">++val     # 先增</span><br><span class="line">--val     # 先减</span><br><span class="line">!         # 逻辑求反</span><br><span class="line">~         # 位求反</span><br><span class="line">**        # 幂运算</span><br><span class="line">&lt;&lt;        # 左位移 </span><br><span class="line">&gt;&gt;        # 右位移</span><br><span class="line">&amp;         # 位布尔和</span><br><span class="line">|         # 位布尔或 </span><br><span class="line">&amp;&amp;        # 逻辑和 </span><br><span class="line">||        # 逻辑或</span><br></pre></td></tr></table></figure>
<p>注意，<strong>不需要将双括号中表达式里的大于号转义</strong>。这是双括号命令提供的另一个高级特性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> using double parenthesis </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">val1=10 </span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">if (( $val1 ** 2 &gt; 90 )) </span><br><span class="line">then</span><br><span class="line">    (( val2 = $val1 ** 2 ))</span><br><span class="line">    echo "The square of $val1 is $val2" </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h5 id="字符串高级比较（双中括号）"><a href="#字符串高级比较（双中括号）" class="headerlink" title="字符串高级比较（双中括号）"></a>字符串高级比较（双中括号）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure>
<ul>
<li>不需要把变量名用双引号<code>&quot;&quot;</code>包围起来，即使变量是空值，也不会出错。</li>
<li>不需要、也不能对 &gt;、&lt; 进行转义，转义后反而会出错。</li>
</ul>
<blockquote>
<p>  双方括号在bashshell中工作良好。不过要小心，不是所有的shell都支持双方括号。</p>
</blockquote>
<h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -z &quot;$str1&quot; ] || [ -z &quot;$str2&quot; ]</span><br></pre></td></tr></table></figure>
<p>你也可以借助选项把多个表达式写在一个 test 命令中，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -z &quot;$str1&quot; -o -z &quot;$str2&quot; ]</span><br></pre></td></tr></table></figure>
<p>但是，这两种写法都有点“别扭”，[[ ]]  支持在括号内直接使用 &amp;&amp;、|| 和 ! 三种逻辑运算符。 使用 [[ ]] 对上面的语句进行改进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z $str1 || -z $str2 ]]</span><br></pre></td></tr></table></figure>
<p>这种写法就比较简洁漂亮了。注意，[[ ]] 剔除了 test 命令的<code>-o</code>和<code>-a</code>选项，你只能使用 || 和 &amp;&amp;。这意味着，你不能写成下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z $str1 -o -z $str2 ]] ×</span><br></pre></td></tr></table></figure>
<p>当然，使用逻辑运算符将多个 [[ ]] 连接起来依然是可以的，因为这是 Shell 本身提供的功能，跟 [[ ]] 或者 test 没有关系，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z $str1 ]] || [[ -z $str2 ]]</span><br></pre></td></tr></table></figure>
<h5 id="支持正则表达式"><a href="#支持正则表达式" class="headerlink" title="[[ ]] 支持正则表达式"></a>[[ ]] 支持正则表达式</h5><p>在 Shell [[ ]] 中，可以使用<code>=~</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ str =~ regex ]]</span><br><span class="line">if [[ $tel =~ ^1[0-9]&#123;10&#125;$ ]]</span><br></pre></td></tr></table></figure>
<p>有了 <code>[[ ]]</code>，你还有什么理由使用 test 或者 <code>[ ]</code>，<code>[[ ]]</code> 完全可以替代之，而且更加方便，更加强大。</p>
<p>但是 <code>[[ ]]</code> 对数字的比较仍然不友好，所以我建议，以后大家使用 <code>if</code> 判断条件时，用 <code>(())</code>来处理整型数字，用<code>[[ ]]</code> 来处理字符串或者文件。  </p>
<h4 id="swtich-case"><a href="#swtich-case" class="headerlink" title="swtich case"></a>swtich case</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span> </span><br><span class="line">pattern1 | pattern2) </span><br><span class="line">    commands1;; </span><br><span class="line">pattern3) </span><br><span class="line">    commands2;; </span><br><span class="line">*) </span><br><span class="line">    default_commands;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$USER</span> <span class="keyword">in</span> </span><br><span class="line">rich | barbara)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Welcome, <span class="variable">$USER</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Please enjoy your visit"</span>;; </span><br><span class="line">testing)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Special testing account"</span>;; </span><br><span class="line">jessica)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Do not forget to log off when you're done"</span>;; </span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Sorry, you are not allowed here"</span>;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>Python 风格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in list </span><br><span class="line">do </span><br><span class="line">    $var commands </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list; <span class="keyword">do</span> </span><br><span class="line">    <span class="variable">$var</span> commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>类似于 python，执行到 <code>for</code>的时候，已经将数据加载到 list 中了，并不是每次加载一行，然后赋值给变量。list 的内容其实已经全部通过 <code>IFS</code> 分割然后加载进来了。</p>
<p><strong>list是以空格分割的</strong></p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> Alabama Alaska Arizona Arkansas California Colorado <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The next state is <span class="variable">$test</span>"</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The last state we visited was <span class="variable">$test</span>"</span></span><br></pre></td></tr></table></figure>
<p>使用<code>$var</code> 获取列表中的值，for循环假定每个值都是用空格分割的。 如果有包含空格的数据值，就必须用双引号将这些值圈起来。或者查看【字段分隔符】章节的解决方案</p>
<p><strong>list 中有引号的情况</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> I don<span class="string">'t know if this'</span>ll work </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"word:<span class="variable">$test</span>"</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line">$ ./badtest1 </span><br><span class="line">word:I </span><br><span class="line">word:dont know <span class="keyword">if</span> thisll </span><br><span class="line">word:work</span><br></pre></td></tr></table></figure>
<p>shell看到了列表值中的单引号并尝试使用它们来定义一个单独的数据值，这真是把事情搞得一团糟。 有两种办法可解决这个问题：</p>
<ul>
<li>使用转义字符（反斜线）来将单引号转义； </li>
<li>使用双引号来定义用到单引号的值:<code>&quot;this&#39;ll&quot;</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> I don\<span class="string">'t know if "this'</span>ll<span class="string">" work </span></span><br><span class="line"><span class="string">do </span></span><br><span class="line"><span class="string">    echo "</span>word:<span class="variable">$test</span><span class="string">" </span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure>
<p><strong>list添加</strong></p>
<p>用<code>&quot;</code>进行拼接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=&quot;Alabama Alaska Arizona Arkansas Colorado&quot; </span><br><span class="line">list=$list&quot; Connecticut&quot; # 拼接</span><br></pre></td></tr></table></figure>
<p><strong>循环命令结果</strong></p>
<p>使用命令替换符号可以对命令的结果进行循环</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for RPM in `rpm -qa | sort | uniq` ; do rpm -qi $RPM ; done</span><br></pre></td></tr></table></figure>
<h5 id="字段分隔符"><a href="#字段分隔符" class="headerlink" title="字段分隔符"></a>字段分隔符</h5><p>特殊的环境变量<code>IFS</code>，叫作内部字段分隔符（internal field separator）。 IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字 符当作字段分隔符： </p>
<ul>
<li>空格 </li>
<li>制表符 </li>
<li>换行符</li>
</ul>
<p>如果你想修改<code>IFS</code>的值，使其只能识别换行符，那就必须这么做：<code>IFS=$&#39;\n&#39;</code></p>
<p>指定多个IFS字符，只要将它们在赋值行串起来就行。<code>IFS=$&#39;\n&#39;:;&quot;</code>  ，这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。</p>
<blockquote>
<p>  一个可参考的安全实践是在改变 IFS 之前保存原 来的 IFS 值，之后再恢复它。 这种技术可以这样实现：</p>
<p>  <code>IFS.OLD=$IFS</code></p>
<p>  <code>IFS=$&#39;\n&#39;</code></p>
<p>  &lt;在代码中使用新的IFS值&gt;</p>
<p>  <code>IFS=$IFS.OLD</code></p>
<p>  这就保证了在脚本的后续操作中使用的是 IFS 的默认值。</p>
</blockquote>
<h5 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h5><p>目录名和文件名中包含空格当然是合法的。要适应这种情况，一种方法是将<code>$file</code>变量用双引号圈起来。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for file in /home/rich/test/* </span><br><span class="line">do</span><br><span class="line">    if [ -d "$file" ] </span><br><span class="line">    then </span><br><span class="line">        echo "$file is a directory" </span><br><span class="line">    elif [ -f "$file" ] </span><br><span class="line">    then </span><br><span class="line">        echo "$file is a file" </span><br><span class="line">    fi </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>另一种方法是指定<code>IFS</code></p>
<p>典型的例子是处理/etc/passwd文件中的数据。这要求你逐行遍历/etc/passwd文件，并将IFS 变量的值改成冒号，这样就能分隔开每行中的各个数据段了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash # changing the IFS value</span></span><br><span class="line"></span><br><span class="line">IFS.OLD=<span class="variable">$IFS</span> </span><br><span class="line">IFS=$<span class="string">'\n'</span> <span class="comment"># 指定分隔符为换行</span></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> $(cat /etc/passwd) <span class="comment"># 这时数据已经通过\n加载在list中了</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Values in <span class="variable">$entry</span> –"</span></span><br><span class="line">    IFS=: <span class="comment"># 指定为冒号，后面不用恢复成\n，原因如上面的注释</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="variable">$entry</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">" <span class="variable">$value</span>"</span></span><br><span class="line">    <span class="keyword">done</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h5 id="c语言风格的-for"><a href="#c语言风格的-for" class="headerlink" title="c语言风格的 for"></a>c语言风格的 for</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( variable assignment ; condition ; iteration process ))</span><br></pre></td></tr></table></figure>
<p>这与之前的 bash shell 标准有些不同</p>
<ul>
<li>变量赋值可以有空格； </li>
<li>条件中的变量不以美元符开头； </li>
<li>迭代过程的算式未用expr命令格式；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"># multiple variables</span><br><span class="line"></span><br><span class="line">for ((i=1; i&lt;=100; i ++))</span><br><span class="line">do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (( a=1, b=10; a &lt;= 10 &amp;&amp; b&gt;=5; a++, b-- )) </span><br><span class="line">do </span><br><span class="line">    echo &quot;$a - $b&quot; </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="while-与-until"><a href="#while-与-until" class="headerlink" title="while 与 until"></a>while 与 until</h4><p>while命令的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while test_command </span><br><span class="line">do </span><br><span class="line">    other commands </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>例子1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while [ $var1 -gt 0 ]</span><br><span class="line">do</span><br><span class="line">    echo $var1</span><br><span class="line">    var1=$[ $var1 - 1 ] </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><code>while</code>命令允许你在while语句行定义多个测试命令：</p>
<ul>
<li>每个测试命令都出现在<strong>单独的一行</strong>上。</li>
<li>只有<strong>最后一个</strong>测试命令的退出状态码会被用来决定什么时候结束循环。</li>
<li>在每次迭代中所有的测试命令都会被执行，包括测试命令失败的最后一次迭代。要留心这种用法。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># multiple variables</span></span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">echo</span> <span class="variable">$var1</span> <span class="built_in">echo</span> “minglin2” <span class="comment"># 可以有多条命令，但是测试命令只能一行一条</span></span><br><span class="line">    [ <span class="variable">$var1</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"This is inside the loop"</span></span><br><span class="line">    var1=$[ <span class="variable">$var1</span> - 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>until命令和while命令工作的方式完全相反，只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。其他的与 <code>while</code> 相同</p>
<h4 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h4><p>默认 break 只跳出所在的最内层的循环。</p>
<p>有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值：</p>
<p><code>break n</code>其中n指定了要跳出的循环层级。</p>
<p>默认情况下，n为1，表明跳出的是当前的循环。如果你将 n设为2，break命令就会停止下一级的外部循环。</p>
<p>和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环：</p>
<p><code>continue n</code>其中n定义了要继续的循环层级。</p>
<p>默认情况下，n为1，表明当继续执行下一次循环。</p>
<p>例子：当 2&lt;a&lt;4时跳过循环</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">for (( a = 1; a &lt;= 5; a++ )) </span><br><span class="line">do</span><br><span class="line">    echo "Iteration $a:"</span><br><span class="line">    for (( b = 1; b &lt; 3; b++ )) </span><br><span class="line">    do</span><br><span class="line">        if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ]</span><br><span class="line">        then</span><br><span class="line">            continue 2 # 当 2&lt;a&lt;4时跳过循环</span><br><span class="line">        fi </span><br><span class="line">        var3=$[ $a * $b ] </span><br><span class="line">        echo " The result of $a * $b is $var3" </span><br><span class="line">    done</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test22 </span></span><br><span class="line">Iteration 1:</span><br><span class="line">    The result of 1 * 1 is 1 </span><br><span class="line">    The result of 1 * 2 is 2 </span><br><span class="line">Iteration 2:</span><br><span class="line">    The result of 2 * 1 is 2 </span><br><span class="line">    The result of 2 * 2 is 4 </span><br><span class="line">Iteration 3: # 跳过了第 3 次</span><br><span class="line">Iteration 4:</span><br><span class="line">    The result of 4 * 1 is 4 </span><br><span class="line">    The result of 4 * 2 is 8 </span><br><span class="line">Iteration 5:</span><br><span class="line">    The result of 5 * 1 is 5 </span><br><span class="line">    The result of 5 * 2 is 10</span><br></pre></td></tr></table></figure>
<h4 id="循环的重定向"><a href="#循环的重定向" class="headerlink" title="循环的重定向"></a>循环的重定向</h4><p>你可以对循环的输出使用管道或进行重定向。这可以通过在关键字<code>done</code>之后添加<code>&gt;</code>或 <code>|</code>命令来实现。</p>
<p>重定向到文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /home/rich/* </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$file</span>"</span> ] </span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a directory"</span> </span><br><span class="line">    <span class="keyword">elif</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a file"</span> </span><br><span class="line">    <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span> &gt; output.txt  <span class="comment"># 重定向到文件</span></span><br></pre></td></tr></table></figure>
<p>从文件中循环读取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># process new user accounts</span></span><br><span class="line"></span><br><span class="line">input=<span class="string">"users.csv"</span> </span><br><span class="line"><span class="keyword">while</span> IFS=<span class="string">','</span> <span class="built_in">read</span> -r userid name </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"adding <span class="variable">$userid</span>"</span></span><br><span class="line">    useradd -c <span class="string">"<span class="variable">$name</span>"</span> -m <span class="variable">$userid</span> </span><br><span class="line"><span class="keyword">done</span> &lt; <span class="string">"<span class="variable">$input</span>"</span></span><br></pre></td></tr></table></figure>
<p>​          </p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>所有函数<strong>在使用前必须定义</strong>。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [ ] 中括号表示可选</span></span><br><span class="line"></span><br><span class="line">[ function ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line">    [return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "第十个参数为 $10 !"</span><br><span class="line">    echo "第十个参数为 $&#123;10&#125; !"</span><br><span class="line">    echo "第十一个参数为 $&#123;11&#125; !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>位置参数变量是标准的数字：<code>$0</code>是程序名，<code>$1</code>是第 一个参数，<code>$2</code>是第二个参数，依次类推，直到第九个参数<code>$9</code>。</p>
<h4 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h4><p>4个最常用的转义字符如下所示。</p>
<blockquote>
<p>  反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p>
<p>  单引号（’’）：全局转义，转义其中所有的变量为单纯的字符串。</p>
<p>  双引号（””）：保留其中的变量属性，不进行转义处理。</p>
<p>  反引号（<code></code>）：把其中的命令执行后返回结果，等价于$(命令)</p>
</blockquote>
<h4 id="获取文件的绝对路径"><a href="#获取文件的绝对路径" class="headerlink" title="获取文件的绝对路径"></a>获取文件的绝对路径</h4><p><strong>误区一</strong></p>
<p>是使用 <strong>pwd</strong> 命令，print name of current/working directory</p>
<p>你可以试试 <code>bash shell/a.sh</code>，<code>a.sh</code> 内容是 <code>pwd</code>，你会发现，显示的是执行命令的路径 <code>/home/june</code>，并不是<code>a.sh</code> 所在路径：<code>/home/june/shell/a.sh</code></p>
<p><strong>误区二</strong></p>
<p> <strong>$0</strong>，这个也是不对的，这个$0是Bash环境下的特殊变量，其真实含义是：</p>
<p>这个<code>$0</code>有可能是好几种值，跟调用的方式有关系：</p>
<ul>
<li>使用一个文件调用bash，那$0的值，是那个文件的名字(没说是绝对路径噢)</li>
<li>使用-c选项启动bash的话，真正执行的命令会从一个字符串中读取，字符串后面如果还有别的参数的话，使用从$0开始的特殊变量引用(跟路径无关了)</li>
<li>除此以外，$0会被设置成调用bash的那个文件的名字(没说是绝对路径)</li>
</ul>
<p><strong>正确方法：dirname 配合 readlink</strong></p>
<p><code>dirname</code> ：可以获取所在目录，输出已经去除了尾部的“/”字符部分的名称；如果名称中不包含“/”，则显示“.”(表示当前目录)。</p>
<blockquote>
<p>  取决于你传递给它的是不是绝对路径</p>
</blockquote>
<p><code>readlink</code> 可以获取文件的完整路径</p>
<p>最终形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(dirname $(readlink -f "$0"))</span><br></pre></td></tr></table></figure>
<p>例子</p>
<p>下面对比下正确答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Jun@VAIO 192.168.1.216 23:52:54 ~ &gt;</span><br><span class="line">cat shell/a.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &apos;$0: &apos;$0</span><br><span class="line">echo &quot;pwd: &quot;`pwd`</span><br><span class="line">echo &quot;=============================&quot;</span><br><span class="line">echo &quot;scriptPath1: &quot;$(cd `dirname $0`; pwd)</span><br><span class="line">echo &quot;scriptPath2: &quot;$(pwd)</span><br><span class="line">echo &quot;scriptPath3: &quot;$(dirname $(readlink -f $0))</span><br><span class="line">echo &quot;scriptPath4: &quot;$(cd $(dirname $&#123;BASH_SOURCE:-$0&#125;);pwd)</span><br><span class="line">echo -n &quot;scriptPath5: &quot; &amp;&amp; dirname $(readlink -f $&#123;BASH_SOURCE[0]&#125;)</span><br><span class="line"></span><br><span class="line">Jun@VAIO 192.168.1.216 23:53:17 ~ &gt;</span><br><span class="line">bash shell/a.sh</span><br><span class="line">$0: shell/a.sh</span><br><span class="line">pwd: /home/Jun</span><br><span class="line">=============================</span><br><span class="line">scriptPath1: /home/Jun/shell</span><br><span class="line">scriptPath2: /home/Jun</span><br><span class="line">scriptPath3: /home/Jun/shell</span><br><span class="line">scriptPath4: /home/Jun/shell</span><br><span class="line">scriptPath5: /home/Jun/shell</span><br></pre></td></tr></table></figure>
<p>在此解释下 scriptPath1 ：</p>
<ul>
<li><code>dirname $0</code>，取得当前执行的脚本文件的父目录</li>
<li><code>cd dirname $0</code>，进入这个目录(切换当前工作目录)</li>
<li><code>pwd</code>，显示当前工作目录(cd执行后的)</li>
<li>由此，我们获得了当前正在执行的脚本的存放路径。</li>
</ul>
<h4 id="检查命令是否存在"><a href="#检查命令是否存在" class="headerlink" title="检查命令是否存在"></a>检查命令是否存在</h4><p>用 <code>which</code> 吗？最好不要用，因为很多操作系统的 <code>which</code> 命令没有设置退出状态码，这样你不知道是否是有那个命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> POSIX 兼容:</span></span><br><span class="line">command -v [the_command]</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> bash 环境:</span></span><br><span class="line">hash [the_command]</span><br><span class="line">type [the_command]</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例：</span></span><br><span class="line">gnudate() &#123;</span><br><span class="line">    if hash gdate 2&gt; /dev/null; then</span><br><span class="line">        gdate "$@"</span><br><span class="line">    else</span><br><span class="line">        date "$@"</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="路径中获取文件"><a href="#路径中获取文件" class="headerlink" title="路径中获取文件"></a>路径中获取文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chengdan_file="dir/file.txt"</span><br><span class="line">echo $chengdan_file</span><br><span class="line">file_name=$&#123;chengdan_file##*/&#125;   # 去除目录</span><br><span class="line">file_name=$&#123;file_name%%.*&#125;       # 去除后缀</span><br></pre></td></tr></table></figure>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bash3 Boilerplate. Copyright (c) 2014, kvz.io</span></span><br><span class="line"></span><br><span class="line">set -o errexit</span><br><span class="line">set -o pipefail</span><br><span class="line">set -o nounset</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> -o xtrace</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set magic variables <span class="keyword">for</span> current file &amp; dir</span></span><br><span class="line">__dir="$(cd "$(dirname "$&#123;BASH_SOURCE[0]&#125;")" &amp;&amp; pwd)"</span><br><span class="line">__file="$&#123;__dir&#125;/$(basename "$&#123;BASH_SOURCE[0]&#125;")"</span><br><span class="line">__base="$(basename $&#123;__file&#125; .sh)"</span><br><span class="line">__root="$(cd "$(dirname "$&#123;__dir&#125;")" &amp;&amp; pwd)" # &lt;-- change this as it depends on your app</span><br><span class="line"></span><br><span class="line">arg1="$&#123;1:-&#125;"</span><br></pre></td></tr></table></figure>
<ol>
<li>使用长的参数名，以便增加可读写，除非在命令行中简短的参数更快速 (<code>logger --priority</code> vs <code>logger -p</code>).</li>
<li><code>set -o errexit</code> (a.k.a <code>set -e</code>) 让脚本在<strong>运行出错</strong>时退出，而不会继续执行下去</li>
<li><code>set -o nounset</code> (a.k.a. <code>set -u</code>)让脚本在使用了<strong>未声明变量</strong>时退出.</li>
<li><code>set -o xtrace</code> (a.k.a <code>set -x</code>) 用于 debug</li>
<li><code>set -o pipefail</code> 用于捕获管道命令的出错，比如捕获 mysqldump 的在<code>mysqldump |gzip</code>中出现的错误</li>
<li><code>#!/usr/bin/env bash</code> 比 <code>#!/bin/bash</code>更有兼容性。</li>
<li>用<code>{}</code>括起你的变量</li>
<li>You don’t need two equal signs when checking <code>if [ &quot;${NAME}&quot; = &quot;Kevin&quot; ]</code>. TODO</li>
<li>在脚本的头部定义魔法变量、basename、目录等等。</li>
</ol>
<p>参考:<a href="https://kvz.io/bash-best-practices.html" target="_blank" rel="noopener">https://kvz.io/bash-best-practices.html</a></p>
</the></excerpt>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/08/13/linux-shell编程/">linux shell编程</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">jizx</a></p>
        <p><span>发布时间:</span>2019-08-13, 11:00:08</p>
        <p><span>最后更新:</span>2020-02-04, 17:54:35</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/08/13/linux-shell编程/" title="linux shell编程">https://jizx.vip/2019/08/13/linux-shell编程/</a>
            <span class="copy-path" data-clipboard-text="原文: https://jizx.vip/2019/08/13/linux-shell编程/　　作者: jizx" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/09/02/awk/">
                    awk
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/08/06/python小模块/">
                    python小模块
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本知识"><span class="toc-text">基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-进程"><span class="toc-text">Shell 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#父子进程"><span class="toc-text">父子进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程列表"><span class="toc-text">进程列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高效子进程"><span class="toc-text">高效子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#后台模式"><span class="toc-text">后台模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#协程"><span class="toc-text">协程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell-内建命令"><span class="toc-text">shell 内建命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#外部命令"><span class="toc-text">外部命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内建命令"><span class="toc-text">内建命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#内建命令之-history"><span class="toc-text">内建命令之 history</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内建命令之-alias"><span class="toc-text">内建命令之 alias</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell-配置文件-TODO"><span class="toc-text">shell 配置文件(TODO)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#判断-shell-类型"><span class="toc-text">判断 shell 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#登录-shell"><span class="toc-text">登录 shell</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#交互式-shell-进程"><span class="toc-text">交互式 shell 进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#非交互式-shell"><span class="toc-text">非交互式 shell</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置文件加载顺序"><span class="toc-text">配置文件加载顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境变量"><span class="toc-text">环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设置局部变量"><span class="toc-text">设置局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置全局变量"><span class="toc-text">设置全局变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell-编程"><span class="toc-text">shell 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建脚本"><span class="toc-text">创建脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打印"><span class="toc-text">打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#别名"><span class="toc-text">别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#环境变量-1"><span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用户变量"><span class="toc-text">用户变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#只读变量"><span class="toc-text">只读变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串的3种形式"><span class="toc-text">字符串的3种形式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#变量-字符串-拼接"><span class="toc-text">变量(字符串)拼接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串的长度"><span class="toc-text">字符串的长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串的截取"><span class="toc-text">字符串的截取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除变量"><span class="toc-text">删除变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量前的-符号"><span class="toc-text">变量前的 $ 符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与"><span class="toc-text">$* 与$@</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0的含义"><span class="toc-text">$0的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#环境变量持久化"><span class="toc-text">环境变量持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令输出赋给变量、命令替换"><span class="toc-text">命令输出赋给变量、命令替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量截取"><span class="toc-text">变量截取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组变量"><span class="toc-text">数组变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组定义"><span class="toc-text">数组定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取数组"><span class="toc-text">读取数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除某个值"><span class="toc-text">删除某个值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组遍历"><span class="toc-text">数组遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#标准的for循环"><span class="toc-text">标准的for循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-…-in"><span class="toc-text">for … in</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#while循环法"><span class="toc-text">while循环法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell-展开"><span class="toc-text">shell 展开</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#花括号"><span class="toc-text">{}花括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展"><span class="toc-text">~扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路径名称扩展"><span class="toc-text">路径名称扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#展开"><span class="toc-text">$展开</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#参数展开"><span class="toc-text">参数展开</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#命令替换"><span class="toc-text">命令替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算术扩展"><span class="toc-text">算术扩展</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁用展开"><span class="toc-text">禁用展开</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#双引号"><span class="toc-text">双引号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#单引号"><span class="toc-text">单引号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#转义字符"><span class="toc-text">转义字符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定向"><span class="toc-text">重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输出"><span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入"><span class="toc-text">输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重定向绑定-gt-amp"><span class="toc-text">重定向绑定&gt;&amp;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数学运算"><span class="toc-text">数学运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#expr-不推荐"><span class="toc-text">expr (不推荐)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方括号-只支持整数"><span class="toc-text">方括号(只支持整数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bc计算器-浮点数计算"><span class="toc-text">bc计算器(浮点数计算)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#圆括号"><span class="toc-text">圆括号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#退出脚本"><span class="toc-text">退出脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#脚本的健壮性"><span class="toc-text">脚本的健壮性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流程控制"><span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#逻辑符号"><span class="toc-text">逻辑符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if-else"><span class="toc-text">if else</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#test-命令"><span class="toc-text">test 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#推荐写法"><span class="toc-text">推荐写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#条件测试"><span class="toc-text">条件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#整数比较"><span class="toc-text">整数比较</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#字符串比较-有坑"><span class="toc-text">字符串比较(有坑)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#文件比较"><span class="toc-text">文件比较</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#其他杂项"><span class="toc-text">其他杂项</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#布尔逻辑"><span class="toc-text">布尔逻辑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双括号与双中括号-进阶"><span class="toc-text">双括号与双中括号(进阶)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数字高级比较-（双括号）"><span class="toc-text">数字高级比较 （双括号）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串高级比较（双中括号）"><span class="toc-text">字符串高级比较（双中括号）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#逻辑运算"><span class="toc-text">逻辑运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#支持正则表达式"><span class="toc-text">[[ ]] 支持正则表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#swtich-case"><span class="toc-text">swtich case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for"><span class="toc-text">for</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字段分隔符"><span class="toc-text">字段分隔符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#遍历目录"><span class="toc-text">遍历目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c语言风格的-for"><span class="toc-text">c语言风格的 for</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while-与-until"><span class="toc-text">while 与 until</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break-与-continue"><span class="toc-text">break 与 continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环的重定向"><span class="toc-text">循环的重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tips"><span class="toc-text">Tips</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#命令行参数"><span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用的转义字符"><span class="toc-text">常用的转义字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取文件的绝对路径"><span class="toc-text">获取文件的绝对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检查命令是否存在"><span class="toc-text">检查命令是否存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路径中获取文件"><span class="toc-text">路径中获取文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最佳实践"><span class="toc-text">最佳实践</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-5 i,
        .toc-level-5 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/09/02/awk/" title="上一篇: awk">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/08/06/python小模块/" title="下一篇: python小模块">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/02/python进阶/">python进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/04/attention图解/">attention图解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/04/keras/">keras</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/04/数据分析库/">python数据分析库</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/04/sklearn/">sklearn</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/07/python-多线程/">python 多线程与多进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/01/python-cookbook/">python cookbook</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/28/推荐网站/">推荐网站</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/python技巧/">python技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/开发环境搭建与效率技巧/">开发环境搭建与效率技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/hive/">hive</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/11/linux知识点/">linux知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/10/vim技巧/">vim技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/bash命令提示符个性化/">bash命令提示符个性化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/awk/">awk</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/13/linux-shell编程/">linux shell编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/python小模块/">python小模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/python模块-logging/">python模块-logging</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/04/anaconda与jupyter使用与设置/">anaconda与jupyter的使用和设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/04/linux常用命令/">linux常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/18/photoshop曲线原理与应用/">photoshop曲线原理与应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/18/正则表达式必知必会/">正则表达式必知必会</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/window添加右键用atom打开/">window添加右键用atom打开</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/12/notepad常用插件/">notepad常用插件与设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/chrome截取整个网页/">chrome截取整个网页</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Git教程/">Git教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/python编码问题/">python编码问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/java方法传参问题/">java方法传参问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/17/如何有效批评而不是吵架/">如何有效批评而不是吵架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/17/剑指offer/">剑指offer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/喜欢人的理由为什么说不出来/">喜欢人的理由为什么说不出来</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/全球公认的最健康的一天作息图解/">全球公认的最健康的一天作息图解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/如何提高「钝感力」，从此不再「想太多」/">如何提高「钝感力」，从此不再「想太多」</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/03/java嵌套类/">java嵌套类</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/英语语法——中级：第3章-完成时态/">英语语法——中级：第3章.完成时态</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/英语语法——中级：第2章-名词、定语、状语从句/">英语语法——中级：第2章.名词、定语、状语从句</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/英语语法——中级：第1章-简单句与复合句/">英语语法——中级：第1章.简单句与复合句</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/08/vim/">vim</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2020 jizx
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 8;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>