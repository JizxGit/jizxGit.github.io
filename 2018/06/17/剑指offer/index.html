<!DOCTYPE html>
<html>
<head hexo-theme="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4"><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="x-dns-prefetch-control" content="on">

  <!-- 页面元数据 -->
  
  <title>剑指offer - 玖玖的博客</title>
  
    <meta name="keywords" content="java,算法,面试">
  

  
    <meta name="description" content=" 

剑指offer题目（持续更新）">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">
  

  

  

  

  

  <!-- import link -->
  

  
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">
    
  
  
    <link rel="stylesheet" href="/css/style.css">
  
  
  
  <!-- 脚本懒加载函数 -->
  <script>
  function loadScript(src, cb) {
    var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
    var script = document.createElement('script');
    script.setAttribute('type','text/javascript');
    if (cb) script.onload = cb;
    script.setAttribute('src', src);
    HEAD.appendChild(script);
  }
  //https://github.com/filamentgroup/loadCSS
  !function(c){"use strict";var e=function(e,t,n,r){var o,i=c.document,a=i.createElement("link");if(t)o=t;else{var d=(i.body||i.getElementsByTagName("head")[0]).childNodes;o=d[d.length-1]}var f=i.styleSheets;if(r)for(var l in r)r.hasOwnProperty(l)&&a.setAttribute(l,r[l]);a.rel="stylesheet",a.href=e,a.media="only x",function e(t){if(i.body)return t();setTimeout(function(){e(t)})}(function(){o.parentNode.insertBefore(a,t?o:o.nextSibling)});var s=function(e){for(var t=a.href,n=f.length;n--;)if(f[n].href===t)return e();setTimeout(function(){s(e)})};function u(){a.addEventListener&&a.removeEventListener("load",u),a.media=n||"all"}return a.addEventListener&&a.addEventListener("load",u),(a.onloadcssdefined=s)(u),a};"undefined"!=typeof exports?exports.loadCSS=e:c.loadCSS=e}("undefined"!=typeof global?global:this);
  </script>
  <script id="loadcss"></script>
</head>

<body>
  <header class="l_header auto shadow blur " style='opacity: 0' >
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div class="l_body">
    <div class="l_cover">
  
    
    
        <div class='cover-wrapper post search' style="display: none;">
          
            <div class='cover-backstretch'></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">玖玖</p>
    
    
      <p class="subtitle">^_^</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="Search..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              id="v4getting-started">
              <p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              id="faqs">
              <p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              id="examples">
              <p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              id="contributors">
              <p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <p>博客</p>
            </a>
          
            <a href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              id="https:githubcomvolantis-xhexo-theme-volantis">
              <p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>
  
    <div class='safearea'>
      <div class='body-wrapper' id="pjax-container">
        
          <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">true</div> 
  <div id="pjax-pageTitle">剑指offer</div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path"></div> 
  <div id="pjax-comment-placeholder"></div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("half" == "none") { // 移除封面 
    document.getElementsByClassName('cover-wrapper')[0].style.display = "none"; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("half" == "half") { // 半屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'half'); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("half" == "full") { // 全屏 
      document.getElementsByClassName('cover-wrapper')[0].setAttribute('id', 'full'); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover-wrapper')[0].style.display = ""; 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 
 

        
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        剑指offer
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="">
    <p>玖玖</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <a class='notlink'>
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <a class="category-link" href="/categories/算法/">算法</a><span class="sep"></span><a class="category-link" href="/categories/算法/java/">java</a>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Jun 17, 2018</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="剑指offer" data-path="/2018/06/17/剑指offer/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>13.7k words</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>68 min</p>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <excerpt in="" index="" |="" 首页摘要=""> 

<p>剑指offer题目（持续更新）</p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><pre><code class="java">/**
 * 线程不安全
 */
class Singleton1 {

    private static Singleton1 instance = null;

    // 构造方法私有化，防止外部使用new创建对象
    private Singleton1() {
        System.out.println(&quot;单例模式1&quot;);
    }

    // 获取实例的方法
    public static Singleton1 getInstance() {
        if (instance == null) {
            instance = new Singleton1();
        }
        return instance;
    }
}
</code></pre>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>有人提出在getInstance()方法上同步锁，但是锁住一整个方法可能粒度过大，不利于效率。既然锁方法不太好，那么锁代码呢？</p>
<pre><code class="java">class Singleton2 {

    private static Singleton2 instance = null;
    // 构造方法私有化，防止外部使用new创建对象
    private Singleton2() {
        System.out.println(&quot;单例模式2&quot;);
    }
    // 获取实例的方法
    public static Singleton2 getInstance() {
        if (instance == null) {
            synchronized (Singleton2.class) {
                instance = new Singleton2();
            }
        }
        return instance;
    }
}
</code></pre>
<p><strong>这样做看似解决了线程安全问题，其实不然</strong>。设现有线程A和B，在t1时刻线程A和B均已通过判空语句但都未取得锁资源；t2时刻时，A先取得锁资源进入临界区（被锁的代码块），执行new操作创建实例对象，然后退出临界区，释放锁资源。t3时刻，B取得被A释放的锁资源进入临界区，执行new操作创建实例对象，然后退出临界区，释放锁资源。明显地，Singleton被实例化两次。</p>
<p>改进：</p>
<pre><code class="java">/**
 * 线程安全，但是如果instance已经存在不能直接返回，也会被锁住，效率很低下，还可以优化
 */
class Singleton3 {
    private static Singleton3 instance = null;

    private Singleton3() {
        System.out.println(&quot;单例模式3&quot;);
    }

    public static Singleton3 getInstance() {
        synchronized (Singleton3.class) {
            if (instance == null) {
                instance = new Singleton3();
            }
        }
        return instance;
    }
}
</code></pre>
<h4 id="双检查锁机制（推荐）"><a href="#双检查锁机制（推荐）" class="headerlink" title="双检查锁机制（推荐）"></a>双检查锁机制（推荐）</h4><pre><code class="java">class Singleton4 {
    //注意此处加上了volatile关键字
    private static Singleton4 instance = null;

    private Singleton4() {
        System.out.println(&quot;单例模式4&quot;);
    }

    public static Singleton4 getInstance() {
        if (instance == null) {
            synchronized (Singleton4.class) {
                if (instance == null) {
                    instance = new Singleton4();
                }
            }
        }
        return instance;
    }
}
</code></pre>
<p>在JDK1.5以前，DCL（双检查锁机制）是不稳定的，有时也可能创建多个实例，在1.5以后开始提供volatile关键字修饰变量来达到稳定效果。</p>
<h4 id="多线程测试入口"><a href="#多线程测试入口" class="headerlink" title="多线程测试入口"></a>多线程测试入口</h4><pre><code class="java">public class Test {
    public static void main(String[] args) {
        //创建实现了Runnable接口的匿名类
        Runnable run = () -&gt; Singleton2.getInstance();
        for (int i = 0; i &lt; 50; i++) {
            Thread thread = new Thread(run);
            thread.start();
        }
    }
}
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>单例是为了保证系统中只有一个实例，其关键点有：</p>
<ol>
<li>私有构造函数</li>
<li>声明静态单例对象</li>
<li>构造单例对象之前要加锁（lock一个静态的object对象）</li>
<li>需要两次检测单例实例是否已经被构造，分别在锁之前和锁之后</li>
</ol>
<p><strong>1.为何要检测两次？</strong></p>
<p>如上面所述，有可能延迟加载或者缓存原因，造成构造多个实例，违反了单例的初衷。</p>
<p><strong>2.构造函数能否公有化？</strong></p>
<p>不行，单例类的构造函数必须私有化，单例类不能被实例化，单例实例只能静态调用</p>
<p><strong>3.lock住的对象为什么要是object对象，可以是int吗？</strong></p>
<p>不行，锁住的必须是个引用类型。如果锁值类型，<strong>每个不同的线程在声明的时候值类型变量的地址都不一样，那么上个线程锁住的东西下个线程进来会认为根本没锁，相当于每次都锁了不同的门，</strong>没有任何卵用。而引用类型的变量地址是相同的，每个线程进来判断锁多想是否被锁的时候都是判断同一个地址，相当于是锁在通一扇门，起到了锁的作用。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="二维有序数组中查找"><a href="#二维有序数组中查找" class="headerlink" title="二维有序数组中查找"></a>二维有序数组中查找</h4><p><img src="/2018/06/17/剑指offer/3.png" class="lazyload" data-srcset="3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>思路：用target与数组右上角的值进行比较，小于右上角，则跳过该列，大于右上角，则跳过该行</p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        int[][] arr = {
                {1, 2, 8, 9},
                {2, 4, 9, 12},
                {4, 7, 10, 13},
                {6, 8, 11, 15},
        };
        int[][] arr2 = {
                {1, 2, 8, 9},

        };
        System.out.println(find(arr, 11));
    }

    public static boolean find(int[][] arr, int target) {
        if (arr.length &lt; 1) return false;

        int i = 0, j = arr[0].length - 1;
        // 用target与数组右上角的值进行比较
        while (j &gt; 0 &amp;&amp; i &lt; arr.length - 1) {
            // target小于右上角，则跳过该列
            while (target &lt; arr[i][j] &amp;&amp; j &gt; 0) {
                j--;
            }
            // target大于右上角，则跳过该行
            while (target &gt; arr[i][j] &amp;&amp; i &lt; arr.length - 1) {
                i++;
            }
            if (target == arr[i][j]) {
                System.out.println(&quot;i:&quot; + (i + 1) + &quot;,j:&quot; + (j + 1));
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h4><p><img src="/2018/06/17/剑指offer/8.png" class="lazyload" data-srcset="8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>主要考虑三种情况：</p>
<ol>
<li>正常情况：{7,8,1,2,3,4,5,6}</li>
<li>有序情况：{1, 2, 3, 4, 5, 6}</li>
<li>相等情况：{1, 1, 0, 1, 1, 1, 1, 1}</li>
</ol>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        // int[] a = {5,6,7,8,1,2,3,4};
        // int[] a = {1, 1, 0, 1, 1, 1, 1, 1};
        int[] a = {1, 2, 3, 4, 5, 6};
        System.out.println(findMin(a));
    }

     /**
     * 使用二分法进行查找
     */
    public static int findMin(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int left = 0;
        int right = arr.length - 1;
        int mid = left;//初始值原因见下方
        /**
         * 正常情况，左边会大于等于右边，否则就已经是有序的数组，第一个就是最小值，因此mid初始为left
         */
        while (arr[left] &gt;= arr[right]) {
            if (right - left == 1) {
                mid = right;
                break;
            }

            mid = (left + right) / 2;
            // 左边=中间=右边，只能遍历,{1, 1, 0, 1, 1, 1, 1, 1};
            if (arr[left] == arr[right] &amp;&amp; arr[right] == arr[mid]) {
                int min = Integer.MAX_VALUE;
                for (int i = left; i &lt;= right; i++) {
                    if (min &gt; arr[i]) {
                        min = arr[i];
                    }
                }
                return min;
            }

            // 左边&lt;=中间，说明最小值在[mid,right]
            if (arr[left] &lt;= arr[mid]) {
                left = mid;
            }
            // 右边&gt;=中间，说明最小值在[left,mid]
            else if (arr[right] &gt;= arr[mid]) {
                right = mid;
            }
        }
        return arr[mid];
    }
</code></pre>
<h4 id="调整数组-使奇数在偶数前面"><a href="#调整数组-使奇数在偶数前面" class="headerlink" title="调整数组 使奇数在偶数前面"></a>调整数组 使奇数在偶数前面</h4><p><img src="/2018/06/17/剑指offer/14.png" class="lazyload" data-srcset="14.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>基本解法</p>
<pre><code class="java">//基本解法
public static void sort(int[] numbers) {
        if (numbers == null || numbers.length == 0) {
            return;
        }

        int left = 0, right = numbers.length - 1;
        while (left &lt;= right) {
            while ((numbers[left] &amp; 0x1) == 1) left++;
            while ((numbers[right] &amp; 0x1) == 0) right--;
            if (left &lt;= right) {
                int tmp = numbers[left];
                numbers[left] = numbers[right];
                numbers[right] = tmp;
            }
        }
    }
</code></pre>
<p>可扩展的实现，解耦，完成各种条件</p>
<pre><code class="java">// 可扩展的实现
public class Test {
    public static void main(String[] args) {
        int[] arr = {2, 2, 1, 3, 6, 9, 8, 10, 7, 4, 5};
        sort(arr, new Condition() {
            @Override
            public boolean check(int a) {
                if ((a &amp; 0x1) == 1)
                    return false;
                else {
                    return true;
                }
            }
        });

        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }
    }

    public static void sort(int[] numbers, Condition c) {
        if (numbers == null || numbers.length == 0) {
            return;
        }

        int left = 0, right = numbers.length - 1;
        while (left &lt;= right) {
            while (left &lt;= right &amp;&amp; c.check(numbers[left])) left++;
            while (left &lt;= right &amp;&amp; !c.check(numbers[right])) right--;
            if (left &lt;= right) {
                int tmp = numbers[left];
                numbers[left] = numbers[right];
                numbers[right] = tmp;
            }
        }
    }

    private interface Condition {
        public boolean check(int a);
    }
}
</code></pre>
<p>保证顺序</p>
<pre><code class="java">import java.util.*;
public class Solution {
    //O(n^2)
    public void reOrderArray(int [] array) {
        if (array == null || array.length == 0) {
            return;
        }
        for (int i = 0; i &lt; array.length; i++) {
            for (int j = array.length - 1; j &gt; i; j--) {
                if (array[j] % 2 == 1 &amp;&amp; array[j - 1] % 2 == 0) {
                    int temp = array[j];
                    array[j] = array[j - 1];
                    array[j - 1] = temp;
                }
            }
        }
    }
    // O(n),辅助空间
    public void reOrderArray2(int [] array) {
        if (array == null || array.length == 0) {
            return;
        }
        int left = 0;
        int right = array.length - 1;
        int[] copy = new int[array.length];
        int i = 0;
        int j = array.length - 1;
        //从前向后扫描奇数
        while (left &lt; array.length ) {
            if(array[left] % 2 == 1)
                copy[i++] = array[left];
            left++;
        }
        //从后向前扫描偶数
        while (right &gt;= 0 ) {
            if(array[right] % 2 == 0)
                copy[j--] = array[right];
            right--;
        }
        for(int k=0;k&lt;array.length;k++){
            array[k]=copy[k];
        }
    }
}
</code></pre>
<h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><p><img src="/2018/06/17/剑指offer/20.png" class="lazyload" data-srcset="20.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
         int[][] matrix = {
                {1, 2, 3, 4},
                {12, 13, 14, 5},
                {11, 16, 15, 6},
                // {10,9,8,7},
        };
        ArrayList&lt;Integer&gt; list = printMatrix(matrix);
        for (int i : list) {
            System.out.print(i + &quot; &quot;);
        }
    }

    public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) {
         if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return null;
        }
        int start = 0;// 因为每次打印都是从对角线[0,0]、[1,1]……的开始，因此只需要一个变量来标记
        int row = matrix.length;
        int col = matrix[0].length;
        ArrayList&lt;Integer&gt; printList = new ArrayList&lt;&gt;();
        while (start * 2 &lt; row &amp;&amp; start * 2 &lt; col) {
            ArrayList&lt;Integer&gt; result = print(matrix, row, col, start);
            printList.addAll(result);
            ++start;
        }
        return printList;
    }

    public static ArrayList&lt;Integer&gt; print(int[][] matrix, int row, int col, int start) {
        int endX = col - start - 1;
        int endY = row - start - 1;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        // 打印从左到右的上面一行 :第一行肯定要打印的
        for (int i = start; i &lt;= endX; i++) {
            list.add(matrix[start][i]);
        }
        // 打印从上到下的右面的一列：第二行能不能打印的条件在循环中了
        for (int i = start + 1; i &lt;= endY; i++) {
            list.add(matrix[i][endX]);
        }

        if (start &lt; endX &amp;&amp; start &lt; endY) {
            for (int i = endX - 1; i &gt;= start; i--) {
                list.add(matrix[endY][i]);
            }
        }
        if (start &lt; endX &amp;&amp; start &lt; endY - 1) {
            for (int i = endY - 1; i &gt; start; i--) {
                list.add(matrix[i][start]);
            }
        }
        return list;
    }
}
</code></pre>
<h4 id="数组中超过一半的数字（还有一种解法）"><a href="#数组中超过一半的数字（还有一种解法）" class="headerlink" title="数组中超过一半的数字（还有一种解法）"></a>数组中超过一半的数字（还有一种解法）</h4><p><img src="/2018/06/17/剑指offer/29.png" class="lazyload" data-srcset="29.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>解法1：基于partition的函数的O(n)算法，因为数字超过半数，因此将原数组排序后，中位数一定就是那个数值（如果输入是）</p>
<pre><code>
</code></pre><p>解法2：一个数字出现次数超过数组长度的一半，说明他出现的次数比其他所有数字出现的次数还多。因此可以用result，time来分别保存统计的数字，以及出现的次数。遍历时如果相同time+1，不同time-1，当time=0时，result更新为当前数字，time重置为1</p>
<pre><code class="java">public static int MoreThanHalfNum_Solution(int[] array) {
        //1.输入合法性验证
        if (array == null || array.length == 0) return 0;

        //2.统计超过半数的数字
        int result = array[0];
        int time = 1;
        for (int i = 1; i &lt; array.length; i++) {
            //当time=0时，result更新为当前数字，time重置为1
            if (time == 0) {
                result = array[i];
                time = 1;
                continue;
            }
            //遍历时如果相同time+1，不同time-1
            if (result == array[i])
                time++;
            else
                time--;
        }

        //3.是否超过半数验证
        time = 0;
        for (int i = 0; i &lt; array.length; i++) {
            if (result == array[i]) {
                time++;
            }
        }
        if (time * 2 &lt;= array.length)
            result = 0;
        return result;
    }
</code></pre>
<h4 id="最小的k个数（包含海量数据）"><a href="#最小的k个数（包含海量数据）" class="headerlink" title="最小的k个数（包含海量数据）"></a>最小的k个数（包含海量数据）</h4><p><img src="/2018/06/17/剑指offer/30.png" class="lazyload" data-srcset="30.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>解法1，小数据量：快排方法 O(n)</p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        int[] array = {2, 3, 0, 2, 5, 7, 8, 9, 1};
        ArrayList&lt;Integer&gt; re = GetLeastNumbers_Solution(array, 10);
        System.out.println(re);
    }

    public static ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();

        //输入检验
        if (input == null || input.length == 0 || k &lt;= 0 || k &gt; input.length) return result;

        int index = parttition(input, 0, input.length - 1);
        int start = 0;
        int end = input.length - 1;
        while (index != k - 1) {
            if (index &lt; k - 1) {
                start = index + 1;
            } else {
                end = index - 1;
            }
            index = parttition(input, start, end);
        }

        for (int i = 0; i &lt; k; i++) {
            result.add(input[i]);
        }
        return result;
    }

    public static int parttition(int[] input, int low, int high) {
        int i = low;
        int j = high;
        int mid = (low + high) / 2;
        swap(input, mid, low);
        int pivot = input[low];
        while (i &lt; j) {
            while (input[j] &gt;= pivot &amp;&amp; i &lt; j) j--;
            while (input[i] &lt;= pivot &amp;&amp; i &lt; j) i++;
            swap(input, i, j);
        }
        swap(input, i, low);
        return i;
    }

    public static void swap(int[] input, int i, int j) {
        int temp = input[i];
        input[i] = input[j];
        input[j] = temp;
    }
}
</code></pre>
<p>解法2，海量数据：使用红黑树 O(nlogk)，类似下面介绍的方法5</p>
<p>常见解法思路：</p>
<ul>
<li>最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求，该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。</li>
<li>第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字与容器内的最小数字相比，如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。</li>
<li>第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。</li>
</ul>
<ul>
<li>第四种方法是Hash法。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。</li>
</ul>
<ul>
<li>第五种方法采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（n*mlogm），空间复杂度是10000（常数）。</li>
</ul>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        int[] array = {2, 3, 0, 2, 5, 7, 8, 9, 1};
        ArrayList&lt;Integer&gt; re = GetLeastNumbers_Solution(array, 10);
        System.out.println(re);
    }

    public static ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();
         //输入检验
        if (input == null || input.length == 0 || k &lt;= 0 || k &gt; input.length) return result;

        TreeSet&lt;Integer&gt; topk=new TreeSet();
        for (int val : input) {
            if (topk.size() &lt; k) {
                topk.add(val);
            } else {
                if(topk.last()&gt;val){
                    topk.pollLast();
                    topk.add(val);
                }
            }
        }
        result.addAll(topk);
        return result;
    }
}
</code></pre>
<h4 id="访问次数最多的IP"><a href="#访问次数最多的IP" class="headerlink" title="访问次数最多的IP"></a>访问次数最多的IP</h4><p>参考：<a href="http://yueyemaitian.iteye.com/blog/1180299" target="_blank" rel="noopener">http://yueyemaitian.iteye.com/blog/1180299</a></p>
<p>算法思想：分而治之+Hash</p>
<p>1、IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；</p>
<p>2、可以考虑采用分而治之的思想，按照IP地址的Hash(IP) % 1024值，把海量IP日志分别存储到1024个小文件中，这样，每个小文件最多包含4MB个IP地址；</p>
<p>​     <strong>这里解释一下为什么用Hash(IP) % 1024值，如果不用，而直接分类的话，可能会出现这样一种情况，就是有个IP在每个小文件中都存在，而且这个IP并不一定在那个小文件中是数量最多的，那么最终可能选择的结果会有问题，所以这里用了Hash(IP)%1024值，这样的话，通过计算IP的Hash值，相同IP肯定会放到一个文件中，当然了不同的IP的Hash值也可能相同，就存在一个小文件中。</strong></p>
<p>3、对于每一个小文件，可以构建一个IP为key，出现的次数为value的Hash Map，同时记录当前出现次数最多的那个IP地址；</p>
<p>4、可以得到1024个小文件中的出现次数最多的那个IP，再依据常规的排序算法得出总体上出现次数最多的IP。</p>
<h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><p><img src="/2018/06/17/剑指offer/31.png" class="lazyload" data-srcset="31.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>解法1 <strong>O(n)，思路如下：</strong></p>
<p><img src="/2018/06/17/剑指offer/31-1.png" class="lazyload" data-srcset="31-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        int[] array = {1,-2,3,10,-4,7,2,-5};
        System.out.println(FindGreatestSumOfSubArray(array));
    }

    public static int FindGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0) return 0;

        int start = 0;
        int end = 0;
        int max = array[0];
        int sum = array[0];  // 初始化为数组中的第一个数
        for (int i = 1; i &lt; array.length; i++) {
            // 如果之前的和&lt;=0，说明从之前某个位置开始的子数组的和 会小于 从当前位置开始的子数组的和
            // 因此可以不考虑之前的子数组，Sum重置为当前位置的值
            if (sum &lt;= 0) {
                start = i;
                end = i;
                sum = array[i];
            }else{
                sum = sum + array[i];
            }
            // 更新最大和
            if (sum &gt; max) {
                max = sum;
                end = i; //更新子数组最后的下标
            }
        }
        System.out.println(&quot;[&quot;+start+&quot;,&quot;+end+&quot;]&quot;);
        return max;
    }
}
</code></pre>
<p>解法2：动态规划</p>
<pre><code class="java"> public static int FindGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0) return 0;

        int len = array.length;
        int[] f = new int[len];
        f[0] = array[0];
        for (int i = 1; i &lt; len; i++) {
            // 递归公式
            // f[i] = array[i]             # i=0 或者 f[i-1]&lt;=0
            // f(i) = f[i - 1] + array[i]  # f[i-1]&gt;0
            f[i] = f[i - 1] &lt;= 0 ? array[i] : f[i - 1] + array[i];
        }

        int max = Integer.MIN_VALUE;
        for (int i : f) {
            if (max &lt; i) {
                max = i;
            }
        }
        return max;
    }
</code></pre>
<p>解法3：分治（未实现）</p>
<h4 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h4><p><img src="/2018/06/17/剑指offer/33.png" class="lazyload" data-srcset="33.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">import java.util.*;

public class Solution {
    public String PrintMinNumber(int [] numbers) {
        // 输入合法性检测
        if (numbers == null || numbers.length == 0) {
            return &quot;&quot;;
        }

        // 将数字转为字符串类型
        ArrayList&lt;String&gt; nums = new ArrayList&lt;&gt;();
        for (int i : numbers) {
            nums.add(Integer.toString(i));
        }

        // 使用自定义的规则 进行排序
        Collections.sort(nums, new Comparator&lt;String&gt;() {
            @Override
            public int compare(String s1, String s2) {
                //为了避免长度问题，将其拼接后再进行字符串比较
                return (s1 + s2).compareTo(s2 + s1);
            }
        });

        // 处理最后的结果
        return String.join(&quot;&quot;,nums);
    }
}
</code></pre>
<h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h4><p><img src="/2018/06/17/剑指offer/36.png" class="lazyload" data-srcset="36.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public static int InversePairs(int[] array) {
        if (array == null || array.length &lt;= 0) {
            return 0;
        }
        return countInverse(array, 0, array.length - 1) % 1000000007;
    }

    public static int countInverse(int[] array, int low, int high) {
        if (low &gt;= high) {
            return 0;
        }

        int mid = (low + high) / 2;
        int leftCount = countInverse(array, low, mid);
        int rightCount = countInverse(array, mid + 1, high);

        // 拷贝一份数组的左右部分，用于排序并统计，注意copyOfRange[begin,end)，不包括end位置
        int[] leftCopy = Arrays.copyOfRange(array, low, mid + 1);
        int[] rightCopy = Arrays.copyOfRange(array, mid + 1, high + 1);

        // 排序并统计逆序对
        int i = leftCopy.length - 1;
        int j = rightCopy.length - 1;
        int index = high;
        int count = 0;
        while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
            if (leftCopy[i] &lt;= rightCopy[j]) {
                array[index--] = rightCopy[j--];
            } else {
                array[index--] = leftCopy[i--];
                count += (j + 1);
                // 避免数据溢出，进行取余
                if (count &gt; 1000000007) count %= 1000000007;
            }
        }

        // 将剩余的部分拷贝回原数组
        for (; i &gt;= 0; i--) {
            array[index--] = leftCopy[i];
        }
        for (; j &gt;= 0; j--) {
            array[index--] = rightCopy[j];
        }
        // 避免数据溢出，进行取余
        int result = leftCount + rightCount + count;
        if (result &gt; 1000000007) result %= 1000000007;
        return result;
    }
</code></pre>
<h4 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h4><p><img src="/2018/06/17/剑指offer/38.png" class="lazyload" data-srcset="38.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">    public static int GetNumberOfK(int[] array, int k) {
        int count = 0;
        if (array != null || array.length &gt; 0) {
            // 先找到第一个位置
            int start = getFirstK(array, k, 0, array.length - 1);
            if (start == -1) return 0;// 查找不到在则直接返回
            // 再找最后出现的位置
            int end = getLastK(array, k, 0, array.length - 1);
            count = end - start + 1;
        }
        return count;
    }

    public static int getFirstK(int[] array, int k, int low, int high) {
        if (low &gt; high) {
            return -1;
        }

        int mid = (low + high) / 2;
        int midData = array[mid];

        if (midData == k) {
            // 如果已经是数组第一个 或者 mid前一个位置小于k，则说明已经找到第一个k的位置了
            if (mid == 0 || (mid &gt; 0 &amp;&amp; array[mid - 1] &lt; k)) {
                return mid;
            } else {
                high = high - 1;
            }
        } else if (midData &lt; k) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
        return getFirstK(array, k, low, high);
    }

    public static int getLastK(int[] array, int k, int low, int high) {
        if (low &gt; high) {
            return -1;
        }

        int mid = (low + high) / 2;
        int midData = array[mid];

        if (midData == k) {
            // 如果已经是数组最后一个 或者 mid后一个位置大于k，则说明已经找到最后一个k的位置了
            if (mid == high || (mid &lt; high &amp;&amp; array[mid + 1] &gt; k)) {
                return mid;
            } else {
                low = mid + 1;
            }
        } else if (midData &lt; k) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
        return getLastK(array, k, low, high);
    }
</code></pre>
<h4 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h4><p><img src="/2018/06/17/剑指offer/40.png" class="lazyload" data-srcset="40.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p><img src="/2018/06/17/剑指offer/40-1.png" class="lazyload" data-srcset="40-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p><img src="/2018/06/17/剑指offer/40-2.png" class="lazyload" data-srcset="40-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
         int[] array = {2, 4, 3, 6, 3, 2, 5, 5};
        int[] num1 = new int[1];
        int[] num2 = new int[1];
        FindNumsAppearOnce(array, num1, num2);
        System.out.println(num1[0]);
        System.out.println(num2[0]);
    }

    public static void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
        if (array == null || array.length &lt; 2) return;

        // 先遍历一遍求出异或的结果
        int xorResult = 0;
        for (int i : array) {
            xorResult ^= i;
        }
        int index = findFirstBit(xorResult); //找到第一个bit为1的下标

        // 利用第一个bit为1的下标将数组分割为两部分，每部分index位置的bit相同
        int n1 = 0;
        int n2 = 0;
        for (int i : array) {
            if (isSameBit(i, index))
                n1 ^= i;
            else
                n2 ^= i;
        }
        num1[0] = n1;
        num2[0] = n2;
    }

    // 从右往左寻找第一个为1的二进制下标
    public static int findFirstBit(int num) {
        int i = 1;
        int index = 0;
        while (index &lt; Integer.SIZE) {
            if ((i &amp; num) == i) break;
            i = i &lt;&lt; 1;
            index++;
        }
        return index;
    }

    // 判断指定下标的位置的二进制是否为1
    public static boolean isSameBit(int num, int leftShift) {
        int i = 1 &lt;&lt; leftShift;
        return (num &amp; i) == i;
    }
}
</code></pre>
<p>相似题：leetcode：single-number、 single-number-ii</p>
<h4 id="在数组中寻找-和为s的两个数字"><a href="#在数组中寻找-和为s的两个数字" class="headerlink" title="在数组中寻找 和为s的两个数字"></a>在数组中寻找 和为s的两个数字</h4><p><img src="/2018/06/17/剑指offer/41.png" class="lazyload" data-srcset="41.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>思路：分别从最左和最右逼近，如果和小于s，则i++，如果和大于s，则j–</p>
<pre><code class="java">// 如果有多对数字的和等于S，输出两个数的乘积最小的。
    public static ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (array == null || array.length &lt; 2) return result;
        int i = 0;
        int j = array.length - 1;
        while (i &lt; j) {
            if (array[i] + array[j] == sum) {
                result.add(array[i]);
                result.add(array[j]);
                return result;
            } else if (array[i] + array[j] &lt; sum) {
                i++;
            } else {
                j--;
            }
        }
        return result;
    }
</code></pre>
<h4 id="寻找和为s的连续序列"><a href="#寻找和为s的连续序列" class="headerlink" title="寻找和为s的连续序列"></a>寻找和为s的连续序列</h4><p><img src="/2018/06/17/剑指offer/41-1.png" class="lazyload" data-srcset="41-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code>    public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) {
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        if (sum &lt;= 0) return result;

        // 初始化将sum分为一大一小的2个数字
        int small = sum / 2;
        int big = sum / 2 + 1;
        int curSum = small + big;

        while (small &gt;= 1) {
            if (curSum == sum) {
                ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
                for (int i = small; i &lt;= big; i++) {
                    list.add(i);
                }
                result.add(list);
                // 通过添加更小的small，获得产生新的序列
                small--;
                curSum += small;
            } else if (curSum &gt; sum) {
                // 偏大，则剪去big，加上更小的small
                small--;
                curSum = curSum - big + small;
                big--;
            } else {
                // 偏小则再加一个更小的small
                small--;
                curSum += small;
            }
        }
        // 序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
        result.sort(Comparator.comparingInt(c -&gt; c.get(0)));
        return result;
    }
</code></pre><h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>思路：</p>
<pre><code class="java">public class Solution {
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        if (numbers == null || numbers.length &lt;= 1) return false;

        for (int i = 0; i &lt; length; i++) {
            while (numbers[i] != i) {
                int m = numbers[i];
                // 如果m和第m个数字相等，则说明m该去的位置被人占了，就找到了第一个重复的数字
                if (m == numbers[m]) {
                    duplication[0] = m;
                    return true;
                }
                // 否则交换m到对应的第m个位置
                numbers[i] = numbers[m];
                numbers[m] = m;
            }
        }
        return false;
    }
}
</code></pre>
<h4 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h4><p><img src="/2018/06/17/剑指offer/66.png" class="lazyload" data-srcset="66.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p><img src="/2018/06/17/剑指offer/66-1.png" class="lazyload" data-srcset="66-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>先算左边部分A0–Ai，再乘以右边部分Ai-1—An-1</p>
<pre><code class="java">package offer;

/**
 * 构建乘积数组
 *
 * @author jizx
 * @date 2018/07/24 17:27
 */
public class Multiply {

    public int[] multiply(int[] A) {
        if (A == null || A.length == 0) return null;

        int len = A.length;
        int[] B = new int[len];

        //自底向上地累乘A[i-1]
        B[0] = 1;
        for (int i = 1; i &lt; len; i++) {
            B[i] = B[i - 1] * A[i - 1];
        }

        //自上向下地在原来基础上，再累成A[i]
        int temp = 1;//这就是右半部分的乘积
        for (int i = len - 1; i &gt;= 0; i--) {
            B[i] = B[i] * temp;
            temp = temp * A[i];
        }
        return B;
    }
}
</code></pre>
<h4 id="有序数组的交集"><a href="#有序数组的交集" class="headerlink" title="有序数组的交集"></a>有序数组的交集</h4><pre><code class="java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 有序数组的交集
 *
 * @author jizx
 * @date 2018/08/19 10:18
 */
public class Jiaoji {
    public static void main(String[] args) {
        int[] a = {1, 3, 8, 10, 11};
        int[] b = {1, 3, 9, 10, 12};
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        jiaoji(a, b, result);
        System.out.println(result);
    }

    public static void jiaoji(int[] a, int[] b, List&lt;Integer&gt; result) {
        if (a == null || b == null || a.length == 0 || b.length == 0) return;
        int[] min = a;
        int[] max = b;
        if (a.length &gt; b.length) {
            min = b;
            max = a;
        }

        int index = Arrays.binarySearch(max, min[min.length / 2]);
        if (index &gt;= 0) {
            result.add(max[index]);
            // min中去除min[min.length / 2]，max中去除max[index]因为以及找到了
            jiaoji(Arrays.copyOfRange(min, 0, min.length / 2), Arrays.copyOfRange(max, 0, index), result);
            jiaoji(Arrays.copyOfRange(min, min.length / 2 + 1, min.length), Arrays.copyOfRange(max, index + 1, max
                    .length), result);
        } else {
            index = -index - 1;
            jiaoji(Arrays.copyOfRange(min, 0, min.length / 2), Arrays.copyOfRange(max, 0, index), result);
            jiaoji(Arrays.copyOfRange(min, min.length / 2 + 1, min.length), Arrays.copyOfRange(max, index, max.length),
                    result);
        }
    }
}
</code></pre>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="4-字符串替换空格（未实现）"><a href="#4-字符串替换空格（未实现）" class="headerlink" title="4.字符串替换空格（未实现）"></a>4.字符串替换空格（未实现）</h4><p><img src="/2018/06/17/剑指offer/4.png" class="lazyload" data-srcset="4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p><img src="/2018/06/17/剑指offer/4-2.png" class="lazyload" data-srcset="4-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<ol>
<li>先遍历一次字符串，这样就能统计出字符串中空格的总数</li>
<li>准备两个指针p1，p2,。p1指向原始字符串的末尾，p2指向替换后的字符串的末尾</li>
<li>p1、p2同时移动，先前复制，直到p1遇到空格</li>
<li>p2向前插入‘%20’</li>
<li>p1、p2继续同时先前移动，直到p1与p2相遇</li>
</ol>
<p><img src="/2018/06/17/剑指offer/4-1.png" class="lazyload" data-srcset="4-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">
</code></pre>
<h4 id="35-第一个只出现一次的字符"><a href="#35-第一个只出现一次的字符" class="headerlink" title="35.第一个只出现一次的字符"></a>35.第一个只出现一次的字符</h4><p><img src="/2018/06/17/剑指offer/35.png" class="lazyload" data-srcset="35.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">import java.util.*;
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        // 非法输入检测
        if (str == null || &quot;&quot;.equals(str)) return -1;

        char[] chars = str.toCharArray();
        HashMap&lt;Character, Integer&gt; counter = new HashMap&lt;&gt;();

        // 第一遍遍历进行统计
        for (char c : chars) {
            int num = counter.get(c) != null ? counter.get(c) + 1 : 1;
            counter.put(c, num);
        }

        // 第二遍遍历进行搜索
        int index = 0;
        for (char c : chars) {
            if (counter.get(c) == 1) return index;
            index++;
        }
        return -1;
    }
}
</code></pre>
<h4 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h4><p><img src="/2018/06/17/剑指offer/42.png" class="lazyload" data-srcset="42.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        System.out.println(ReverseSentence(&quot;student. a am I&quot;));
    }

    public static String ReverseSentence(String str) {
        if (str == null || str.length() &lt;= 0) return &quot;&quot;;

        char[] chars = str.toCharArray();
        // 先将整个字符串翻转
        reverseChars(chars, 0, chars.length);

        // 通过空格来定位每个单词的位置，然后进行单词的翻转
        int start = 0;//指向单词第一个字符
        int end = 0;//指向单词后的第一个空格
        for (char c : chars) {
            if (c != &#39; &#39;) {
                end++;
                if (end == chars.length)
                    reverseChars(chars, start, end);
            } else {
                // start与end之间是一个单词的情况
                if (start != end) {
                    reverseChars(chars, start, end);
                }
                end++;
                start = end;// start移动到end位置
            }
        }
        return new String(chars);
    }

    // start：翻转的开始位置，不包括end位置的字符
    public static void reverseChars(char[] str, int start, int end) {
        int i = start;
        int j = end - 1;
        while (i &lt; j) {
            char c = str[i];
            str[i] = str[j];
            str[j] = c;
            i++;
            j--;
        }
    }
}
</code></pre>
<h4 id="左旋转字符串-循环左移字符串"><a href="#左旋转字符串-循环左移字符串" class="headerlink" title="左旋转字符串(循环左移字符串)"></a>左旋转字符串(循环左移字符串)</h4><p>题目描述（推荐）：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<p><img src="/2018/06/17/剑指offer/42-2.png" class="lazyload" data-srcset="42-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p><img src="/2018/06/17/剑指offer/42-3.png" class="lazyload" data-srcset="42-3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        System.out.println(LeftRotateString(&quot;abcXYZdef&quot;,3));
    }

    public String LeftRotateString(String str,int n) {
        if (str == null || str.length() &lt;= 0) return &quot;&quot;;

        char[] chars = str.toCharArray();
        // 通过3次翻转即可实现
        reverseChars(chars,0,n);
        reverseChars(chars,n,chars.length);
        reverseChars(chars,0,chars.length);

        return new String(chars);
    }
      // 字符翻转
    public static void reverseChars(char[] str, int start, int end) {
        int i = start;
        int j = end - 1;
        while (i &lt; j) {
            char c = str[i];
            str[i] = str[j];
            str[j] = c;
            i++;
            j--;
        }
    }
}
</code></pre>
<h4 id="将字符串转换为整数"><a href="#将字符串转换为整数" class="headerlink" title="将字符串转换为整数"></a>将字符串转换为整数</h4><p>题目描述：</p>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<pre><code class="java">// 测试用例有:+123,-123,234k234
    public static int StrToInt(String str) {
        if (str == null || str.length() &lt;= 0) return 0;

        int result = 0;
        boolean isMinus = false;
        char[] chars = str.toCharArray();
        for (int i = 0; i &lt; chars.length; i++) {
            // 如果不是数字，则判断是否是在第一位的正负号
            if (chars[i] &lt; &#39;0&#39; || chars[i] &gt; &#39;9&#39;) {
                if ((i != 0) || (chars[i] != &#39;+&#39; &amp;&amp; chars[i] != &#39;-&#39;)) return 0;
                else {
                    if (chars[i] == &#39;-&#39;) isMinus = true;
                    continue;
                }
            }
            result = result * 10 + chars[i] - &#39;0&#39;;// 注意字符要与‘0’进行相减，才是真正对应的数字
        }
        return isMinus ? -1 * result : result;
    }
</code></pre>
<h4 id="字符串判断是否为有效数值"><a href="#字符串判断是否为有效数值" class="headerlink" title="字符串判断是否为有效数值"></a>字符串判断是否为有效数值</h4><pre><code class="java">package offer;

/**
 * 判断字符串是否为有效的数值
 *
 * @author jizx
 * @date 2018/07/24 17:45
 */
public class IsNumeric {
    public static void main(String[] args) {
        IsNumeric app=new IsNumeric();
        System.out.println(app.isNumeric(&quot;-1.e0&quot;.toCharArray()));
    }


    public boolean isNumeric(char[] str) {
        if (str == null || str.length == 0) return false;
        boolean dot = false;
        boolean e = false;
        boolean sign = false;

        for (int i = 0; i &lt; str.length; i++) {
            if ((str[i] == &#39;+&#39; || str[i] == &#39;-&#39;)) {
                if (i == 0) sign = true;// 首位
                else if (str[i - 1] == &#39;e&#39; || str[i - 1] == &#39;E&#39;) {}  // 紧跟在e后面
                else return false;
            } else if (str[i] == &#39;e&#39; || str[i] == &#39;E&#39;) {
                if (e == true) return false;// 已经有e了
                else if (i == str.length - 1) return false; // e后面没有数字了
                else e = true;
            } else if (str[i] == &#39;.&#39;) {
                // 在e后面，不能有小数点、或者已经有小数点了
                if (e == true || dot == true) return false;
                else dot = true;
            } else {
                if (str[i] &lt; &#39;0&#39; || str[i] &gt; &#39;9&#39;) return false; // 其他非法字符
            }
        }
        return true;
    }
}
</code></pre>
<h4 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h4><p><img src="/2018/06/17/剑指offer/28.png" class="lazyload" data-srcset="28.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">import java.util.ArrayList;
import java.util.*;
public class Solution {

    ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;();

    public ArrayList&lt;String&gt; Permutation(String str) {
        if (str == null || str.length() == 0) return result;
        char[] chars = str.toCharArray();
        permutation(0, chars);
          // 
        HashSet&lt;String&gt; set=new HashSet&lt;&gt;(result);
        result.clear();
        result.addAll(set);
        Collections.sort(result);
        return result;
    }

    public void permutation(int prefix, char[] str) {
        if (prefix == str.length) {
            result.add(new String(str));
            return;
        }

        // [a,b,c]，prefix表示固定的位置，比如a，然后将a与后面的字符依次进行交换
        for (int i = prefix; i &lt; str.length; i++) {

            // 将固定位置的值与数组中的第i个字符交换
            char temp = str[i];
            str[i] = str[prefix];
            str[prefix] = temp;

            // 递归处理[b,c]
            permutation(prefix + 1, str);

            //还原交换
            temp = str[i];
            str[i] = str[prefix];
            str[prefix] = temp;
        }
    }
}
</code></pre>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="java实现链表"><a href="#java实现链表" class="headerlink" title="java实现链表"></a>java实现链表</h4><pre><code class="java">/**
 * @author jizx
 * @date 2018/04/20 15:09
 */
public class Test {
    public static void main(String[] args) {
        LinkedList&lt;String&gt; list = new LinkedList();
        list.add(&quot;a&quot;);
        list.add(&quot;c&quot;);
        list.add(&quot;bb&quot;);
        list.insert(3, &quot;1&quot;);
        list.printList();
        // System.out.println(list.find(&quot;2&quot;));
        System.out.println(list.search(3));

        list.printList();
    }
}

class LinkedList&lt;E&gt; {

    private class Node&lt;E&gt; {
        private E data;
        Node next = null;

        public Node() {
            data = null;
        }

        public Node(E data) {
            this.data = data;
        }
    }

    private Node head;
    private Node tail;
    private int length;

    public LinkedList() {
        head = new Node();
        tail = head;
        length = 0;
    }

    public void add(E data) {
        Node newNode = new Node(data);
        tail.next = newNode;
        tail = newNode;
        length++;
    }

    public void insert(int position, E data) {
        if (position &gt;= 0 &amp;&amp; position &lt;= length) {
            int i = 0;
            Node current = head;
            while (i &lt; position) {
                current = current.next;
                i++;
            }
            Node temp = current.next;
            Node newNode = new Node(data);
            newNode.next = temp;
            current.next = newNode;
        } else {
            System.out.println(&quot;超出范围&quot;);
        }
        length++;
    }

    public void remove(E data) {
        Node pre = head;
        Node current = head.next;
        while (current != null) {
            if (current.data.equals(data)) {
                pre.next = current.next;
                break;
            } else {
                pre = current;
                current = current.next;
            }
        }
    }

    public void set(int position, E data) {
        Node current = head.next;
        while (current != null) {
            if (current.data.equals(data)) {
                break;
            } else {
                current = current.next;
            }
        }
    }

    public int find(E data) {
        E result = null;
        Node current = head.next;
        int position = 0;
        while (current != null) {
            if (current.data.equals(data)) {
                return position;
            } else {
                current = current.next;
                position++;
            }
        }
        return -1;
    }

    public E search(int position) {
        int i = -1;
        Node current = head;
        if (position &gt;= 0 &amp;&amp; position &lt; length) {
            while (i &lt; position) {
                i++;
                current = current.next;
            }
            return (E) current.data;
        } else {
            System.out.println(&quot;超出范围&quot;);
            return null;
        }
    }

    public int length() {
        return length;
    }

    public void printList() {
        Node current = head.next;
        while (current != null) {
            System.out.println(current.data);
            current = current.next;
        }
    }
}
</code></pre>
<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><p><img src="/2018/06/17/剑指offer/5.png" class="lazyload" data-srcset="5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">
</code></pre>
<h4 id="O-1-时间删除链表结点-未实现"><a href="#O-1-时间删除链表结点-未实现" class="headerlink" title="O(1)时间删除链表结点(未实现)"></a>O(1)时间删除链表结点(未实现)</h4><p><img src="/2018/06/17/剑指offer/13.png" class="lazyload" data-srcset="13.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code>
</code></pre><h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h4><p><img src="/2018/06/17/剑指offer/15.png" class="lazyload" data-srcset="15.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p><img src="/2018/06/17/剑指offer/15-1.png" class="lazyload" data-srcset="15-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        ListNode head = new ListNode(1);
        ListNode cur = head;
        for (int i = 2; i &lt;= 5; i++) {
            ListNode node = new ListNode(i);
            cur.next = node;
            cur = node;
        }
        try {
            ListNode newHead = findKNode(head, 0);
            while (newHead != null) {
                System.out.println(newHead.val);
                newHead = newHead.next;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static ListNode findKNode(ListNode head, int k) {
        if (head == null|| k &lt;= 0) {
            return null;
        }

        ListNode ahead = head;
        ListNode behind = ahead;

        // 两者相差k-1个位置，因此ahead先走k-1个位置
        for (int i = 0; i &lt; k - 1; i++) {
            if (ahead.next != null)
                ahead = ahead.next;
            else
                return null;
        }
        // 然后两者一起移动
        while (ahead.next != null) {
            ahead = ahead.next;
            behind = behind.next;
        }
        return behind;
    }

}

class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
</code></pre>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p><img src="/2018/06/17/剑指offer/16.png" class="lazyload" data-srcset="16.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        ListNode head = new ListNode(0);
        ListNode cur=head;
        for (int i = 1; i &lt;= 10; i++) {
            ListNode node = new ListNode(i);
            cur.next = node;
            cur = node;
        }
        try {
            ListNode newHead = ReverseList(head);
            while (newHead != null) {
                System.out.println(newHead.val);
                newHead = newHead.next;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static ListNode ReverseList(ListNode head) {

        // 边界处理
        if (head == null) return null;
        if (head.next == null)  return head;

        ListNode remainHead = null;      // h:剩余未反转的链表头
        ListNode handlingNode = head;    // i:正在处理的结点，从head开始，它的next指向原方向，因此正要反转
        ListNode reversedHead = null;    // j:已经反转的链表头

        while (handlingNode != null) {
            // 原来  reversedHead  handlingNode --&gt; remainHead --&gt;k
            // 反转  reversedHead &lt;-- handlingNode   remainHead --&gt;k
            remainHead = handlingNode.next;
            handlingNode.next = reversedHead;

            // 更新结点为下一次要处理的位置
            reversedHead = handlingNode;
            handlingNode = remainHead;
        }
        return reversedHead;
    }
}

class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
</code></pre>
<h4 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h4><p><img src="/2018/06/17/剑指offer/17.png" class="lazyload" data-srcset="17.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        ListNode list1 = new ListNode(1);
        ListNode list2 = new ListNode(2);
        ListNode cur1 = list1;
        ListNode cur2 = list2;
        for (int i = 3; i &lt;= 10; i++) {
            ListNode node1 = new ListNode(i);
            ListNode node2 = new ListNode(++i);
            cur1.next = node1;
            cur2.next = node2;
            cur1 = node1;
            cur2 = node2;
        }
        ListNode newHead = Merge(list1, list2);
        while (newHead != null) {
            System.out.print(newHead.val + &quot; &quot;);
            newHead = newHead.next;
        }
    }

    public static ListNode Merge(ListNode list1, ListNode list2) {
        // 有一个链表为空，直接返回另一个链表
        if (list1 == null) return list2;
        if (list2 == null)  return list1;

        // 新链表的头结点初始化为较小的链表的头结点
        ListNode head = list1.val &lt; list2.val ? list1 : list2;
        ListNode temp;
        while (list1 != null &amp;&amp; list2 != null) {
            if (list1.val &lt; list2.val) {
                temp = list1.next;
                list1.next = list2;
                list1 = temp;
            } else {
                temp = list2.next;
                list2.next = list1;
                list2 = temp;
            }
        }
        return head;
    }
}

class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
</code></pre>
<h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h4><p><img src="/2018/06/17/剑指offer/26.png" class="lazyload" data-srcset="26.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if(pHead==null){
            return null;
        }
        copyChain(pHead);
        copySibling(pHead);
        return splitChain(pHead);
    }
    /**第一步：复制链表，暂时不考虑random 字段
     *  A-&gt;B-&gt;C 变为 A-&gt;A&#39;-&gt;B-&gt;B&#39;-&gt;C-&gt;C&#39;
     * */
    public void copyChain(RandomListNode pHead) {
        RandomListNode cur = pHead;
        while (cur != null) {
            RandomListNode n = new RandomListNode(cur.label);
            n.next = cur.next;
            cur.next = n;
            cur = n.next;
        }
    }

    /**第二步：考虑复制sibling字段*/
    public void copySibling(RandomListNode pHead) {
        RandomListNode cur = pHead;
        while (cur != null) {
            RandomListNode clone = cur.next;
            RandomListNode sibling = cur.random;
            if (sibling != null) {
                clone.random = sibling.next;
            }
            cur = clone.next;
        }
    }

    /**第三步：拆分链表，抽取出copy链表*/
    public RandomListNode splitChain(RandomListNode pHead) {
        RandomListNode copy = pHead.next;
        RandomListNode cur1 = pHead;
        RandomListNode cur2 = pHead.next;

        while (cur1 != null &amp;&amp; cur2 != null) {
            cur1.next = cur2.next;
            cur1 = cur1.next;
            if(cur1!=null){
                cur2.next=cur1.next;
            }
            cur2=cur2.next;
        }
        return copy;
    }
}
</code></pre>
<h4 id="查找链表的中间节点（未实现）"><a href="#查找链表的中间节点（未实现）" class="headerlink" title="查找链表的中间节点（未实现）"></a>查找链表的中间节点（未实现）</h4><p>思路：采用快慢指针的方式查找单链表的中间节点，快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针刚好到达中间节点</p>
<pre><code>
</code></pre><h4 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h4><p><img src="/2018/06/17/剑指offer/37.png" class="lazyload" data-srcset="37.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">import java.util.*;
public class Test {
    public static void main(String[] args) {
       ListNode a1=new ListNode(1);
        ListNode a2=new ListNode(2);
        ListNode a3=new ListNode(3);
        ListNode a4=new ListNode(4);
        ListNode a5=new ListNode(5);
        ListNode a6=new ListNode(6);
        ListNode a7=new ListNode(7);
        a1.next=a2;
        a2.next=a3;
        a3.next=a6;
        a4.next=a5;
        a5.next=a6;
        a6.next=a7;
        System.out.println(FindFirstCommonNode(a1,a4));
    }
public static ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        if (pHead1 == null || pHead2 == null) return null;

        // 先遍历一遍找出两个链表的长度
        int len1 = getLength(pHead1);
        int len2 = getLength(pHead2);

        ListNode longList = pHead1;
        ListNode shortList = pHead2;
        int diff = len1 - len2;
        if (len1 &lt; len2) {
            longList = pHead2;
            shortList = pHead1;
            diff = len2 - len1;
        }

        // 然后让长的链表先走多的长度
        for (int i = 0; i &lt; diff; i++) {
            longList = longList.next;
        }

        // 最后一起走，第一个相同结点就是公共结点
        while (longList != null &amp;&amp; shortList != null) {
            if (longList == shortList){
                return longList;
            }
            longList = longList.next;
            shortList = shortList.next;
        }
        return null;
    }

    public static int getLength(ListNode list) {
        int len = 0;
        ListNode current = list;
        while (current != null) {
            current = current.next;
            len++;
        }
        return len;
    }
}
</code></pre>
<h4 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h4><p>如果一个链表中包含环，如何找出环的入口节点？</p>
<pre><code class="java">import java.util.*;

/**
 * 链表中环的入口
 *
 * @author jizx
 * @date 2018/07/03 18:39
 */
public class EntryNodeOfLoop {
    public static void main(String[] args) {
        EntryNodeOfLoop app = new EntryNodeOfLoop();
        ListNode a1=new ListNode(1);
        ListNode a2=new ListNode(2);
        ListNode a3=new ListNode(3);
        ListNode a4=new ListNode(4);
        ListNode a5=new ListNode(5);
        ListNode a6=new ListNode(6);
        a1.next=a2;
        a2.next=a3;
        a3.next=a4;
        a4.next=a5;
        a5.next=a6;
        a6.next=a3;
        System.out.println(app.EntryNodeOfLoop(null));
    }

    public ListNode EntryNodeOfLoop(ListNode pHead) {

        // 1.判断是否有环,如果有则返回环内的一个节点
        ListNode loopNode = meetingNode(pHead);
        if (loopNode == null) return null;

        // 2.计数环的长度
        int count = 1;
        ListNode search = loopNode.next;
        while (loopNode != search) {
            count++;
            search = search.next;
        }

        // 3.找到入口
        ListNode behind = pHead;// 慢指针
        ListNode prev = pHead;//快指针
        // 让快指针先走count个节点，这样才能保证他们相遇的节点是入口节点
        while (count-- &gt; 0) {
            prev = prev.next;
        }
        while(prev!=behind){
            prev=prev.next;
            behind=behind.next;
        }
        return prev;
    }

    /**
     * 使用快慢指针，当其相遇时有环，快指针==null时无环
     */
    private ListNode meetingNode(ListNode head) {
        if (head == null) return null;

        ListNode slow = head;// 慢指针
        ListNode fast = slow.next;//快指针

        while (slow != null &amp;&amp; fast != null) {
            // 如果快慢指针相遇、快指针的下一个是慢指针，则有环
            if (slow == fast || fast.next == slow) {
                return slow;
            }
            // 更新快慢指针位置
            slow = slow.next;
            fast = fast.next;
            if (fast != null) fast = fast.next;
        }
        return null;
    }
}
</code></pre>
<h4 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<pre><code class="java">
/**
 * 删除链表中重复的结点
 *
 * @author jizx
 * @date 2018/07/06 10:41
 */
public class DeleteDuplication {
    public static void main(String[] args) {
        DeleteDuplication app = new DeleteDuplication();
        int[] nums = {1, 1, 2, 3, 3, 4, 5, 5};
        ListNode a1 = app.create(nums);
        a1 = app.deleteDuplication(a1);
        while (a1 != null) {
            System.out.print(a1.val + &quot;--&gt;&quot;);
            a1 = a1.next;
        }
    }

    public ListNode deleteDuplication(ListNode pHead) {
        // null或者只有一个结点时 直接返回
        if (pHead == null || pHead.next == null) return pHead;

        ListNode newHead = new ListNode(0);// 新链表的头结点
        newHead.next = pHead;
        ListNode pre = newHead;// 记录前一个不重复的结点
        ListNode cur = pre.next;// 当前结点
        while (cur != null &amp;&amp; cur.next != null) {
            // 当前结点与下一结点相等
            if (cur.val == cur.next.val) {
                do{
                    cur = cur.next;
                }
                while (cur.next != null &amp;&amp; cur.next.val == cur.val);
                cur = cur.next; // 更新到这个暂时不重复的点
                pre.next = cur; // pre的next连接到这个暂时不重复的点
            }

            // 当前结点与下一结点不相等
            else {
                pre = cur;// 则pre更新到这个可以确认是不重复的点上
                cur = cur.next; // 移动cur
            }
        }
        return newHead.next;
    }

    // 保留一个重复结点
    public ListNode deleteDuplication2(ListNode pHead) {
        ListNode p = pHead;
        while (p != null) {
            ListNode q = p;
            while (q.next != null) {
                if (p.val == q.next.val) {
                    q.next = q.next.next;
                } else
                    q = q.next;
            }
            p = p.next;
        }
        return pHead;
    }

    public ListNode create(int[] nums) {
        ListNode cur = new ListNode(0);
        ListNode head = cur;
        for (int i = 0; i &lt; nums.length; i++) {
            cur.next = new ListNode(nums[i]);
            cur = cur.next;
        }
        return head.next;
    }
}
</code></pre>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p><img src="/2018/06/17/剑指offer/6.png" class="lazyload" data-srcset="6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Solution {
       public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
        if (pre.length == 0 || in.length == 0) {
            return null;
        }
        //先取【先序】的第一个元素，作为根结点
        TreeNode root = new TreeNode(pre[0]);
        //然后遍历【中序】，找到对应的根结点，进行划分数组
        for (int i = 0; i &lt; in.length; i++) {
            if (in[i] == pre[0]) {
                //注意i对应的是中序的下标，因此是截取pre[1，i+1]
                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1,
                        in.length));
            }
        }
        return root;
    }
}
</code></pre>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p><img src="/2018/06/17/剑指offer/23.png" class="lazyload" data-srcset="23.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">  public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {

        ArrayList&lt;Integer&gt; result=new ArrayList&lt;&gt;();
        if(root==null){
            return result;
        }

        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode node=queue.poll();
            result.add(node.val);
            if(node.left!=null) queue.offer(node.left);   
            if(node.right!=null) queue.offer(node.right);   
        }
        return result;
    }
</code></pre>
<h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><p><img src="/2018/06/17/剑指offer/18.png" class="lazyload" data-srcset="18.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}

public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        boolean isTree = false;
        if (root1 != null &amp;&amp; root2 != null) {
            // 如果当前两个根结点相等，则进行检查
            if (root1.val == root2.val) isTree = isSubTree(root1, root2);
            // 否则递归对root1的左子树判断
            if (!isTree) isTree = HasSubtree(root1.left, root2);
            // 左子树也没有，则递归对root1的右子树判断
            if (!isTree) isTree = HasSubtree(root1.right, root2);
        }
        return isTree;
    }
     public boolean isSubTree(TreeNode root1, TreeNode root2) {
        if(root2==null) return true;  //root2匹配完了，因此true
        if(root1==null) return false; //root2不为null而root1==null，则不相同
        if(root1.val!=root2.val) return false;
        //当前结点相等，则判断左子树，然后判断右子树
        return  isSubTree(root1.left, root2.left) &amp;&amp;  isSubTree(root1.right, root2.right);
    }
}
</code></pre>
<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h4><p><img src="/2018/06/17/剑指offer/19.png" class="lazyload" data-srcset="19.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}

public class Solution {
    // 先序遍历的方法
    public static void Mirror(TreeNode root) {
        if (root == null) {
            return;
        }
        // 交换子节点
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        // 递归处理子节点
        Mirror(root.left);
        Mirror(root.right);
    }
}
</code></pre>
<h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h4><p><img src="/2018/06/17/剑指offer/24.png" class="lazyload" data-srcset="24.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        int[] a = {5, 7, 6, 9, 11, 10, 8};
        int[] b = {6, 8, 7, 5};
        int[] c = {4, 8, 6, 12, 16, 14, 10};
        int[] d = {};
        System.out.println(VerifySquenceOfBST(d));
    }

    public static boolean VerifySquenceOfBST(int[] sequence) {
        // 为空则false
        if (sequence == null || sequence.length == 0) {
            return false;
        }
        // 只有一个点，则为true，直接返回不用递归了
        if (sequence.length == 1) {
            return true;
        }

        int i = 0;
        int high = sequence.length - 1;
        int root = sequence[high];

        // 以root判断大小，寻找划分点，i最终会落在第一个大于root的位置
        while (sequence[i] &lt; root) {
            i++;
        }

        //判断右子树是否都大于root，否则就不可能是后序遍历
        for (int j = i; j &lt; high; j++) {
            if (root &gt; sequence[j]) 
                return false;
        }
        //  copyOfRange : [begin,end),不包含end
        int[] leftTree = Arrays.copyOfRange(sequence, 0, i);
        int[] rightTree = Arrays.copyOfRange(sequence, i, high);
        boolean leftResult = true;
        boolean rightResult = true;
        if (leftTree.length &gt; 0) {
            leftResult = VerifySquenceOfBST(leftTree);
        }
        if (rightTree.length &gt; 0) {
            rightResult = VerifySquenceOfBST(rightTree);
        }
        return leftResult &amp;&amp; rightResult;
    }
}
</code></pre>
<p><img src="/2018/06/17/剑指offer/24-1.png" class="lazyload" data-srcset="24-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><p><img src="/2018/06/17/剑指offer/25.png" class="lazyload" data-srcset="25.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) {
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allRoad = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        if (root != null) {
            Stack&lt;Integer&gt; road = new Stack&lt;&gt;();
            path(root, target, road, 0, allRoad);
        }
        return allRoad;
    }

    public static void path(TreeNode root, int target, Stack&lt;Integer&gt; road, int currentSum, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allRoad) {
        currentSum = root.val + currentSum;
        TreeNode left = root.left;
        TreeNode right = root.right;
        // 超过目标值，不必向下继续
        if (currentSum &gt; target) {
            return;
        }
        // 叶结点,但值不等于目标值,返回
        if (left == null &amp;&amp; right == null &amp;&amp; currentSum != target) {
            return;
        }

        road.push(root.val);
        // 叶结点，值等于目标值，添加路径
        if (left == null &amp;&amp; right == null &amp;&amp; currentSum == target) {
            ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
            for (int i : road) {
                result.add(i);
            }
            allRoad.add(result);
        }
        if (left != null) {
            path(left, target, road, currentSum, allRoad);
        }
        if (right != null) {
            path(right, target, road, currentSum, allRoad);
        }
        road.pop();
    }
</code></pre>
<h4 id="二叉搜索树与双向链表转换"><a href="#二叉搜索树与双向链表转换" class="headerlink" title="二叉搜索树与双向链表转换"></a>二叉搜索树与双向链表转换</h4><p><img src="/2018/06/17/剑指offer/27.png" class="lazyload" data-srcset="27.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="二叉搜索树与双向链表转换"></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        TreeNode n1 = new TreeNode(1);
        TreeNode n2 = new TreeNode(2);
        TreeNode n3 = new TreeNode(3);
        TreeNode n4 = new TreeNode(4);
        TreeNode n5 = new TreeNode(5);
        TreeNode n6 = new TreeNode(6);
        TreeNode n7 = new TreeNode(7);
        //构建树
        n4.left = n2;
        n4.right = n6;
        n2.left = n1;
        n2.right = n3;
        n6.left = n5;
        n6.right = n7;
        Convert(n4);
    }

    public static TreeNode Convert(TreeNode pRootOfTree) {
        TreeNode lastVisitNode = null;
        // 注意，不可以将lastVisitNode直接传入，因为就像传入null，不会赋值给lastVisitNode
        lastVisitNode = convertNode(pRootOfTree, lastVisitNode);
        // 完成转换，从lastVisitNode往前遍历，到头结点
        TreeNode first = lastVisitNode;
        while (first != null) {
            if(first.left==null)  break;
            first = first.left;
        }
        return first;
    }

    /**
     * currentNode：当前节点
     * lastVisitNode：最后访问的节点，同时也是双向链表的最右节点
     */
    public static TreeNode convertNode(TreeNode currentNode, TreeNode lastVisitNode) {
        if (currentNode == null) return null;

        //先处理左子树，同时获得左子树最右边的点（最大点）
        if (currentNode.left != null) {
            lastVisitNode = convertNode(currentNode.left, lastVisitNode);
        }

        //互相连接，当前节点的left连接lastVisitNode,同时lastVisitNode的right连接当前节点
        currentNode.left = lastVisitNode;
        if (lastVisitNode != null) lastVisitNode.right = currentNode;
        lastVisitNode = currentNode; //最后访问的节点更新为当前节点

        // 处理右子树
        if (currentNode.right != null) {
            lastVisitNode = convertNode(currentNode.right, lastVisitNode);
        }
        return lastVisitNode;
    }
}


class TreeNode {
    int val = 0;
    TreeNode left = null;   // 连接小的结点
    TreeNode right = null;  // 连接大的结点

    public TreeNode(int val) {
        this.val = val;
    }
}
</code></pre>
<h4 id="二叉树的深度-以及是否是平衡二叉树"><a href="#二叉树的深度-以及是否是平衡二叉树" class="headerlink" title="二叉树的深度,以及是否是平衡二叉树"></a>二叉树的深度,以及是否是平衡二叉树</h4><p><img src="/2018/06/17/剑指offer/39.png" class="lazyload" data-srcset="39.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {

    }

    public static int TreeDepth(TreeNode root) {
        if (root == null) return 0;

        int leftDepth = TreeDepth(root.left);
        int rightDepth = TreeDepth(root.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
</code></pre>
<p><img src="/2018/06/17/剑指offer/39-2.png" class="lazyload" data-srcset="39-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        TreeNode a1 = new TreeNode(1);
        TreeNode a2 = new TreeNode(2);
        TreeNode a3 = new TreeNode(3);
        TreeNode a4 = new TreeNode(4);
        TreeNode a5 = new TreeNode(5);
        TreeNode a6 = new TreeNode(6);
        TreeNode a7 = new TreeNode(7);
        TreeNode a8 = new TreeNode(8);
        a1.left=a2;
        a1.right=a3;
        a2.left=a4;
        a2.right=a5;
        a5.right=a7;
        a3.left=a8;
        a3.right=a6;
        System.out.println(IsBalanced_Solution(a1));
    }

    public static boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) return true;
        return isBalanced(root) != -1;
    }

    // 返回值 -1：非平衡树，0：null结点，正数：树的深度
    public static int isBalanced(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = isBalanced(root.left);
        int rightDepth = isBalanced(root.right);

        // 如果左右子树都是平衡树，则进行深度比较；如果深度差满足要求，则返回最大深度
        if (leftDepth != -1 &amp;&amp; rightDepth != -1) {
            if (Math.abs(leftDepth - rightDepth) &lt;= 1) {
                return Math.max(leftDepth, rightDepth) + 1;
            }
        }
        return -1;
    }
}
class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
</code></pre>
<h4 id="中序遍历二叉树-求某一节点的下一中序节点"><a href="#中序遍历二叉树-求某一节点的下一中序节点" class="headerlink" title="中序遍历二叉树,求某一节点的下一中序节点"></a>中序遍历二叉树,求某一节点的下一中序节点</h4><pre><code class="java">    public static TreeLinkNode GetNext(TreeLinkNode pNode) {
        if (pNode == null) return null;

        // 1.有右结点，则找该右结点的最左结点
        if (pNode.right != null) {
            pNode = pNode.right;
            while (pNode.left != null) {
                pNode = pNode.left;
            }
            return pNode;
        }

        /* 2.没有右节点，则向上找父节点
                 a          a
           b                    b
               c                    c
            d                     d
        c是当前节点。确定c是在某个节点(a)的左子树中，还是(a)的右子树中；
        如果在左子树中，则找到的第一个包含c的节点就是下一个中序输出的节点；
        否则，就没有下一个节点了
        * */
        TreeLinkNode parent = pNode.next;
        while (parent != null) {
            if (parent.left == pNode) return parent;
            pNode = parent;
            parent = parent.next;
        }
        return null;
    }
</code></pre>
<h4 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h4><p>给定一颗二叉搜索树，请找出其中的第k小的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<pre><code class="java">
</code></pre>
<h4 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h4><pre><code class="java">import java.util.*;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/

public class Solution {
      // 序列化
    String Serialize(TreeNode root) {
        if (root == null) return &quot;&quot;;

        String node = Integer.toString(root.val);
        node += &quot;,&quot;;//父节点后添加逗号

        if (root.left == null)
            node += &quot;#&quot;;
        else
            node += Serialize(root.left);
        node += &quot;,&quot;;//左节点后添加逗号

        if (root.right == null)
            node += &quot;#&quot;;
        else
            node += Serialize(root.right);
        //右节点后 不添加逗号
        return node;
    }

      // 反序列化
    TreeNode Deserialize(String str) {
        if (str == null || str.length() &lt;= 0) return null;
        String[] nodes = str.split(&quot;,&quot;);
        return Deserialize2(nodes);
    }

    // 正在处理的结点下标
    int index=0;
    TreeNode Deserialize2(String[] nodes) {
        String node = nodes[index++];
        if (&quot;#&quot;.equals(node)) return null;

        TreeNode root = new TreeNode(Integer.parseInt(node));
        root.left = Deserialize2(nodes);
        root.right = Deserialize2(nodes);
        return root;
    }
}
</code></pre>
<h3 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h3><h4 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h4><p><img src="/2018/06/17/剑指offer/7.png" class="lazyload" data-srcset="7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">import java.util.Stack;

public class Solution {
    Stack&lt;Integer&gt; inStack = new Stack&lt;Integer&gt;();// 入队保存的栈
    Stack&lt;Integer&gt; outStack = new Stack&lt;Integer&gt;(); // 出队保存的栈
    private int size = 0;

    public void push(int node) {
        inStack.push(node);
        size++;
    }

    public int pop() {
        if (size == 0)  return -1; 
        size--;

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.pop();
    }
}
</code></pre>
<h4 id="用两个队列实现栈（未实现）"><a href="#用两个队列实现栈（未实现）" class="headerlink" title="用两个队列实现栈（未实现）"></a>用两个队列实现栈（未实现）</h4><pre><code>
</code></pre><h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><p><img src="/2018/06/17/剑指offer/21.png" class="lazyload" data-srcset="21.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">class Solution {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();

    public void push(int node) {
        stack.push(node);
        if (minStack.empty()) {
            minStack.push(node);
            return;
        }

        if (node &lt; minStack.peek()) {
            minStack.push(node);
        } else {
            minStack.push(minStack.peek());
        }
    }

    public void pop() {
        if (!stack.empty()) {
            stack.pop();
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int min() {
        return minStack.peek();
    }
}
</code></pre>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><p><img src="/2018/06/17/剑指offer/22.png" class="lazyload" data-srcset="22.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        int [] a={1,2,3,4,5};
        int [] b={4,5,3,1,2};
        System.out.println(IsPopOrder(a,b));
    }

    public static boolean IsPopOrder(int[] pushA, int[] popA) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int i = 0, j = 0, lena = pushA.length, lenb = popA.length;
        boolean isPopOrder = true;

        while (i &lt; lena) {
            stack.push(pushA[i]);
            i++;
            // 栈顶与popA[j]相同，则出栈，否则继续进栈
            while (stack.peek() == popA[j] &amp;&amp; j &lt; lenb) {
                stack.pop();
                j++;
            }
        }

        // 栈不为空，或者popA没有遍历完，则不是
        if (!stack.isEmpty() || j != lenb) {
            isPopOrder = false;
        }
        return isPopOrder;
    }
}
</code></pre>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="员工年龄排序"><a href="#员工年龄排序" class="headerlink" title="员工年龄排序"></a>员工年龄排序</h4><p><img src="/2018/06/17/剑指offer/8-1.png" class="lazyload" data-srcset="8-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        int[] a = {23,26,27,28,25,30,54,23,23};
        sortAge(a);
        for (int i = 0; i &lt; a.length; i++) {
            System.out.println(a[i]);
        }
    }

    public static int[] sortAge(int[] arr) {
        if (arr == null || arr.length == 0) {
            return null;
        }
        int oldest = 100;
        // 创建0-100的数组来统计每个年龄有多少人
        int[] ages = new int[oldest + 1];

        // 遍历数组进行统计
        for (int i = 0; i &lt; arr.length; i++) {
            int age = arr[i];
            ages[age]++;
        }

        int index = 0;
        // 遍历统计的数组，将年龄存回原数组
        for (int age = 0; age &lt;= oldest; age++) {
            for (int i = 0; i &lt; ages[age]; i++) {
                arr[index] = age;
                index++;
            }
        }
        return arr;
    }
}
</code></pre>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><p><img src="/2018/06/17/剑指offer/矩阵中的路径.png" class="lazyload" data-srcset="矩阵中的路径.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="矩阵中的路径"></p>
<pre><code class="java">/**
 * 判断矩阵中是否有路径
 *
 * @author jizx
 * @date 2018/07/09 20:18
 */
public class HasPath {
    public static void main(String[] args) {
        HasPath app = new HasPath();

        char[] matrix = &quot;ABCESFCSADEE&quot;.toCharArray();
        char[] str = &quot;ABCB&quot;.toCharArray();
        System.out.println(app.hasPath(matrix, 3, 4, str));
    }

    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
        if (matrix == null || rows &lt; 1 || cols &lt; 1 || str == null) return false;

        boolean[][] visited = new boolean[rows][cols];

        // 遍历矩阵中每个位置，穷举
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                if (findStr(matrix, rows, cols, i, j, str, visited))
                    return true;
            }
        }
        return false;
    }

    private int strIndex = 0;

    private boolean findStr(char[] matrix, int rows, int cols, int row, int col, char[] str, boolean[][]  visited) {

        if (strIndex == str.length) return true;

        boolean find = false;

        // 矩阵中matrix[row][col] 的字符 与 str[strIndex]的相同，则继续探索该位置的四周与str[strIndex++]是否一样
        if (row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; !visited[row][col] &amp;&amp; matrix[row * cols + col] == str[strIndex]) {
            strIndex++;
            visited[row][col] = true;

            find = findStr(matrix, rows, cols, row - 1, col, str, visited) ||
                    findStr(matrix, rows, cols, row + 1, col, str, visited) ||
                    findStr(matrix, rows, cols, row, col - 1, str, visited) ||
                    findStr(matrix, rows, cols, row, col + 1, str, visited);
            // 如果该点的四周都没有找到符合下一字符的，则退回，重置该位置的状态，以及字符匹配的位置
            if (!find) {
                visited[row][col] = false;
                strIndex--;
            }
        }

        return find;
    }
}
</code></pre>
<h4 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h4><p><img src="/2018/06/17/剑指offer/机器人的运动范围.png" class="lazyload" data-srcset="机器人的运动范围.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="机器人的运动范围"></p>
<pre><code class="java">/**
 * 机器人的运动范围
 *
 * @author jizx
 * @date 2018/07/09 21:45
 */
public class RobotMovingCount {

    public static void main(String[] args) {
        RobotMovingCount app = new RobotMovingCount();
        System.out.println(app.movingCount(18, 3, 4));
    }

    public int movingCount(int threshold, int rows, int cols) {
        if (rows &lt; 0 || cols &lt; 0 || threshold &lt; 0) return 0;
        boolean[][] visited = new boolean[rows][cols];
        return movingCount(threshold, rows, cols, 0, 0, visited);
    }

    public int movingCount(int threshold, int rows, int cols, int row, int col, boolean[][] visited) {
        int count = 0;
        if (canIn(rows, cols, row, col, threshold, visited)) {
            visited[row][col] = true;
            // 能够到达的位置：当前位置+其他四个方向能够到达的总和
            count = 1 + movingCount(threshold, rows, cols, row - 1, col, visited) +
                    movingCount(threshold, rows, cols, row + 1, col, visited) +
                    movingCount(threshold, rows, cols, row, col - 1, visited) +
                    movingCount(threshold, rows, cols, row, col + 1, visited);
        }
        return count;
    }

    // 判断是否能进入该位置
    public boolean canIn(int rows, int cols, int row, int col, int threshold, boolean[][] visited) {
        if (!visited[row][col] &amp;&amp; row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols) {
            int sum = 0;
            while (row != 0) {
                sum += row % 10;
                row /= 10;
            }
            while (col != 0) {
                sum += col % 10;
                col /= 10;
            }
            return sum &lt;= threshold;
        }
        return false;
    }
}
</code></pre>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="斐波那契数数列"><a href="#斐波那契数数列" class="headerlink" title="斐波那契数数列"></a>斐波那契数数列</h4><p><img src="/2018/06/17/剑指offer/9.png" class="lazyload" data-srcset="9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Solution {
    // 非递归
    public int Fibonacci(int n) {
        int[] initial = {0, 1}; //初始化第0项、第1项
        if (n &lt; 2) return initial[n];

        // fn=f(n-1)+f(n-2)
        int fn_1 = 1;
        int fn_2 = 0;
        int fn = 0;
        for (int i = 2; i &lt;= n; i++) {
            fn = fn_1 + fn_2;
            fn_2 = fn_1;
            fn_1 = fn;
        }
        return fn;
    }
}
</code></pre>
<h5 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h5><p><img src="/2018/06/17/剑指offer/9-1.png" class="lazyload" data-srcset="9-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>但是要注意<strong>与斐波那契数列的下标起始位置不太一样</strong> ，第0 项是1,即：1 1 2 3 5 。。。</p>
<pre><code class="java">    public static int JumpFloor(int target) {
        int[] initial = {0, 1};
        if (target &lt; 2) return initial[target];

        int jumpn_1 = 1; //第1项是1
        int jumpn_2 = 1; //第0项是1
        int num = 0;
        for (int i = 2; i &lt;= target; i++) {
            num = jumpn_1 + jumpn_2;
            jumpn_2 = jumpn_1;
            jumpn_1 = num;
        }
        return num;
    }
</code></pre>
<hr>
<p><img src="/2018/06/17/剑指offer/9-2.png" class="lazyload" data-srcset="9-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<hr>
<h5 id="矩阵覆盖问题"><a href="#矩阵覆盖问题" class="headerlink" title="矩阵覆盖问题"></a>矩阵覆盖问题</h5><p><img src="/2018/06/17/剑指offer/9-3.png" class="lazyload" data-srcset="9-3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h4 id="10-二进制中1的个数"><a href="#10-二进制中1的个数" class="headerlink" title="10.二进制中1的个数"></a>10.二进制中1的个数</h4><p><img src="/2018/06/17/剑指offer/10.png" class="lazyload" data-srcset="10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>用1扫描法：</p>
<p><img src="/2018/06/17/剑指offer/10-2.png" class="lazyload" data-srcset="10-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public static int numOf1(int n) {
    int count = 0;
    int matcher = 1;
    while (matcher != 0) {
        // n与matcher按位 与运算，如果matcer的1 对应n的1，就不会为0
        // n:0000101
        // m:0000100
        if ((n &amp; matcher) != 0) count++;
        //让matcer左移，进行扫描
        matcher = matcher &lt;&lt; 1;
    }
    return count;
}
</code></pre>
<p>减1法</p>
<p><img src="/2018/06/17/剑指offer/10-1.png" class="lazyload" data-srcset="10-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">   public static int numOf1(int n) {
        int count = 0;
        while (n != 0) {
            // 把一个整数减去1，再和原整数做 与运算，就会把该整数最右边一个1变成0
            n = (n - 1) &amp; n;
            count++;
        }
        return count;
    }
</code></pre>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><h4 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h4><p>由于精度原因，<strong>不能用等号判断两个double 小数是否相等</strong>。</p>
<p>当小数点后位数 大于15位时，jvm就会忽略这个精度，这种情况，我们在开发时如果需要更精确的比较double类型，就要用到 BigDecimal 这个类了。</p>
<pre><code>// jdk1.8
double x1= 4.000000000000002;
double x2= 4.000000000000005;
x1&lt;x2  true

BigDecimal x3=new BigDecimal(4.0000000000000002);
BigDecimal x4=new BigDecimal(4.0000000000000005);
x3&lt;x4 true

000000000000002      // double(15位)
0000000000000002     // BigDecimal（16位）
</code></pre><h4 id="数值的整数次方pow-x-n"><a href="#数值的整数次方pow-x-n" class="headerlink" title="数值的整数次方pow(x,n)"></a>数值的整数次方pow(x,n)</h4><p>思路：分治</p>
<p>简洁版</p>
<pre><code class="java">    public double pow(double x, int n) {
         // 底数为0,不可以直接用等号判断，因为有精度的问题
        if (Double.compare(x, 0.0) == 0) return 0.0;

        //指数&lt;0的情况，取绝对值，最后进行求倒数即可
        if (n &lt; 0) return 1.0 / powWithUnsign(x, -n);
        else return powWithUnsign(x, n);
    }
    public double powWithUnsign(double x, int n) {
        if (n == 0) return 1.0;
        if (n == 1) return x;
        double result = powWithUnsign(x, n/2);
        if ((n&amp;1) == 1)
            return result * result * x;
        else
            return result * result;
    }
</code></pre>
<p>详细版</p>
<pre><code class="java">public static double Power(double basse, int exponent) throws Exception {
        // 输入底数为0，指数小于0
        if (Double.compare(basse, 0.0) == 0 &amp;&amp; exponent &lt; 0) {
            throw new Exception(&quot;非法&quot;);
        }

        int absExponent = exponent;//指数取绝对值
        if (exponent &lt; 0) {
            absExponent = exponent * -1;
        }

        double result = PowerWithUnsignedExponent(basse, absExponent);
        if (exponent &lt; 0) {
            result = 1.0 / result;
        }
        return result;
    }

    public static double PowerWithUnsignedExponent(double base, int exponent) {
        // 判断人为输入为0的情况，并不是右移产生的
        if (exponent == 0) {
            return 1;
        }
        if (exponent == 1) {
            return base;
        }

        double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1);
        result *= result;
        if ((exponent &amp; 0x1) == 1) {
            result *= base;
        }
        return result;
    }
</code></pre>
<h4 id="打印1到最大的n位数"><a href="#打印1到最大的n位数" class="headerlink" title="打印1到最大的n位数"></a>打印1到最大的n位数</h4><p><img src="/2018/06/17/剑指offer/12.png" class="lazyload" data-srcset="12.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">   public static void printNMax(int n) {
        if (n &lt;= 0) {
            return;
        }
        char[] number = new char[n];
        for (int i = 0; i &lt; number.length; i++) {
            number[i] = &#39;0&#39;;
        }
        int a = number[1];
        while (!increase(number, 8)) {
            printNum(number);
        }
    }

    public static boolean increase(char[] number, int add) {
        int sum = 0;
        int takeOver = 0;// 进位
        boolean isMax = false;
        // 从最后一位开始加一
        for (int i = number.length - 1; i &gt;= 0; i--) {
            sum = number[i] - &#39;0&#39; + takeOver;

            // 个位进行加一
            if (i == number.length - 1) {
                sum += add;
            }
            // 和大于10，则有进位，否则就可以结束循环
            if (sum &gt;= 10) {
                // 如果是最高位，则结束
                if (i == 0) isMax = true;
                else {
                    sum -= 10;
                    takeOver = 1;
                    number[i] = (char) (&#39;0&#39; + sum);
                }
            } else {
                number[i] = (char) (&#39;0&#39; + sum);
                break;
            }
        }
        return isMax;
    }

    public static void printNum(char[] number) {
        int i = 0;
        boolean isStart = false;
        while (i &lt; number.length) {
            if (number[i] == &#39;0&#39; &amp;&amp; !isStart) {

            } else {
                isStart = true;
                System.out.print(number[i]);
            }
            i++;
        }
        System.out.println();
    }
</code></pre>
<h4 id="34-丑数"><a href="#34-丑数" class="headerlink" title="34.丑数"></a>34.丑数</h4><p><img src="/2018/06/17/剑指offer/34.png" class="lazyload" data-srcset="34.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public static int GetUglyNumber_Solution(int index) {
        if (index &lt;= 0) {
            return 0;
        }
        // 保存丑数的数组，并初始化第一个丑数
        int[] uglyNum = new int[index];
        uglyNum[0] = 1;
        // 指向对应乘积刚好大于当前找到的丑数的下标
        int base2 = 0;// 乘以2后的值，刚好略大于当前丑数的下标
        int base3 = 0;// 乘以3后的值，刚好略大于当前丑数的下标
        int base5 = 0;// 乘以5后的值，刚好略大于当前丑数的下标
        int currentIndex = 1;
        while (currentIndex &lt; index) {
            int nextNum = Math.min(Math.min(uglyNum[base2] * 2, uglyNum[base3] * 3), uglyNum[base5] * 5);
            uglyNum[currentIndex] = nextNum;
            // 更新下标，使得下标在刚好略大于当前丑数的下标
            while (uglyNum[base2] * 2 &lt;= nextNum) base2++;
            while (uglyNum[base3] * 3 &lt;= nextNum) base3++;
            while (uglyNum[base5] * 5 &lt;= nextNum) base5++;
            currentIndex++;
        }
        return uglyNum[index - 1];
    }
</code></pre>
<h4 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h4><p><img src="/2018/06/17/剑指offer/47.png" class="lazyload" data-srcset="47.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>思路：</p>
<p><img src="/2018/06/17/剑指offer/47-1.png" class="lazyload" data-srcset="47-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">public class Solution {
    public int Add(int num1,int num2) {
        int sum = 0;
        int carry = 0;
        do {
            sum = num1 ^ num2;
            carry = (num1 &amp; num2) &lt;&lt; 1;
            num1 = sum;
            num2 = carry;
        } while (carry != 0);
        return num1;
    }
}
</code></pre>
<h4 id="不使用新变量交换两个变量的值"><a href="#不使用新变量交换两个变量的值" class="headerlink" title="不使用新变量交换两个变量的值"></a>不使用新变量交换两个变量的值</h4><p><img src="/2018/06/17/剑指offer/47-2.png" class="lazyload" data-srcset="47-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">// 基于加减法
a = a + b;
b = a - b;
a = a - b;
// 基于异或
a = a ^ b;
b = a ^ b;
a = a ^ b;
</code></pre>
<h3 id="抽象建模"><a href="#抽象建模" class="headerlink" title="抽象建模"></a>抽象建模</h3><h4 id="44-扑克牌的顺子"><a href="#44-扑克牌的顺子" class="headerlink" title="44.扑克牌的顺子"></a>44.扑克牌的顺子</h4><p><img src="/2018/06/17/剑指offer/44.png" class="lazyload" data-srcset="44.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<pre><code class="java">import java.util.*;
public class Solution {
    public boolean isContinuous(int [] numbers) {
        if (numbers == null || numbers.length != 5) return false;

        Arrays.sort(numbers);

        // 统计大王的个数
        int king = 0;
        for (int i : numbers) {
            if (i == 0) king++;
            else break;
        }
        // 统计不连续间隔
        int gaps = 0;
        // i=king的个数+1，从而跳过王
        for (int i = king+1; i &lt; numbers.length; i++) {
            if (numbers[i] == numbers[i - 1]) return false; // 出现对子，不可能是顺子
            gaps += numbers[i] - numbers[i - 1] - 1;
        }
        return gaps &lt;= king;
    }
}
</code></pre>
</the></excerpt>
  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://jizx.vip/2018/06/17/剑指offer/>https://jizx.vip/2018/06/17/剑指offer/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-11-18T21:09:31+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Nov 18, 2018</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>java</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/算法/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>算法</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/面试/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>面试</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://jizx.vip/2018/06/17/剑指offer/&title=剑指offer - 玖玖的博客&summary= 

剑指offer题目（持续更新）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://jizx.vip/2018/06/17/剑指offer/&title=剑指offer - 玖玖的博客&summary= 

剑指offer题目（持续更新）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://jizx.vip/2018/06/17/剑指offer/&title=剑指offer - 玖玖的博客&summary= 

剑指offer题目（持续更新）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2018/07/04/java方法传参问题/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>java方法传参问题</p>
          <p class='content'> 






一、基本类型 和 引用类型的不同之处int num = 10;
String str = &quot;hello&quot;;

首先变量其实是堆栈中的地址索引。然后 基本类型的...</p>
        </a>
      
      
        <a class='next' href='/2018/03/03/java嵌套类/'>
          <p class='title'>java嵌套类<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>讲解java中嵌套类的概念，也就是在类中定义另一个类的概念（未完待续。。。）



嵌套类java语言允许你在一个类中定义另一个类，这样的类称为嵌套类，形式如下：
class OuterClas...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单线程"><span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双检查锁机制（推荐）"><span class="toc-text">双检查锁机制（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程测试入口"><span class="toc-text">多线程测试入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二维有序数组中查找"><span class="toc-text">二维有序数组中查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#旋转数组的最小数字"><span class="toc-text">旋转数组的最小数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调整数组-使奇数在偶数前面"><span class="toc-text">调整数组 使奇数在偶数前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#顺时针打印矩阵"><span class="toc-text">顺时针打印矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中超过一半的数字（还有一种解法）"><span class="toc-text">数组中超过一半的数字（还有一种解法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小的k个数（包含海量数据）"><span class="toc-text">最小的k个数（包含海量数据）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问次数最多的IP"><span class="toc-text">访问次数最多的IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连续子数组的最大和"><span class="toc-text">连续子数组的最大和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#把数组排成最小的数"><span class="toc-text">把数组排成最小的数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中的逆序对"><span class="toc-text">数组中的逆序对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数字在排序数组中出现的次数"><span class="toc-text">数字在排序数组中出现的次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中只出现一次的数字"><span class="toc-text">数组中只出现一次的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在数组中寻找-和为s的两个数字"><span class="toc-text">在数组中寻找 和为s的两个数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找和为s的连续序列"><span class="toc-text">寻找和为s的连续序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中重复的数字"><span class="toc-text">数组中重复的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构建乘积数组"><span class="toc-text">构建乘积数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序数组的交集"><span class="toc-text">有序数组的交集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-字符串替换空格（未实现）"><span class="toc-text">4.字符串替换空格（未实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-第一个只出现一次的字符"><span class="toc-text">35.第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#翻转单词顺序"><span class="toc-text">翻转单词顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#左旋转字符串-循环左移字符串"><span class="toc-text">左旋转字符串(循环左移字符串)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将字符串转换为整数"><span class="toc-text">将字符串转换为整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串判断是否为有效数值"><span class="toc-text">字符串判断是否为有效数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串的排列"><span class="toc-text">字符串的排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java实现链表"><span class="toc-text">java实现链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从尾到头打印链表"><span class="toc-text">从尾到头打印链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-1-时间删除链表结点-未实现"><span class="toc-text">O(1)时间删除链表结点(未实现)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表中倒数第k个节点"><span class="toc-text">链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反转链表"><span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合并两个有序的链表"><span class="toc-text">合并两个有序的链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂链表的复制"><span class="toc-text">复杂链表的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找链表的中间节点（未实现）"><span class="toc-text">查找链表的中间节点（未实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个链表的第一个公共结点"><span class="toc-text">两个链表的第一个公共结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表中环的入口节点"><span class="toc-text">链表中环的入口节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除链表中重复的结点"><span class="toc-text">删除链表中重复的结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树"><span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重建二叉树"><span class="toc-text">重建二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层序遍历"><span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#树的子结构"><span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的镜像"><span class="toc-text">二叉树的镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉搜索树的后序遍历序列"><span class="toc-text">二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树中和为某一值的路径"><span class="toc-text">二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉搜索树与双向链表转换"><span class="toc-text">二叉搜索树与双向链表转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的深度-以及是否是平衡二叉树"><span class="toc-text">二叉树的深度,以及是否是平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中序遍历二叉树-求某一节点的下一中序节点"><span class="toc-text">中序遍历二叉树,求某一节点的下一中序节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉搜索树的第k个结点"><span class="toc-text">二叉搜索树的第k个结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#序列化二叉树"><span class="toc-text">序列化二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列与栈"><span class="toc-text">队列与栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两个栈实现队列"><span class="toc-text">两个栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用两个队列实现栈（未实现）"><span class="toc-text">用两个队列实现栈（未实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#包含min函数的栈"><span class="toc-text">包含min函数的栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的压入、弹出序列"><span class="toc-text">栈的压入、弹出序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#员工年龄排序"><span class="toc-text">员工年龄排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回溯法"><span class="toc-text">回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#矩阵中的路径"><span class="toc-text">矩阵中的路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#机器人的运动范围"><span class="toc-text">机器人的运动范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#斐波那契数数列"><span class="toc-text">斐波那契数数列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#青蛙跳台阶"><span class="toc-text">青蛙跳台阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#矩阵覆盖问题"><span class="toc-text">矩阵覆盖问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制"><span class="toc-text">二进制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-二进制中1的个数"><span class="toc-text">10.二进制中1的个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值"><span class="toc-text">数值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#精度问题"><span class="toc-text">精度问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值的整数次方pow-x-n"><span class="toc-text">数值的整数次方pow(x,n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打印1到最大的n位数"><span class="toc-text">打印1到最大的n位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-丑数"><span class="toc-text">34.丑数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不用加减乘除做加法"><span class="toc-text">不用加减乘除做加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不使用新变量交换两个变量的值"><span class="toc-text">不使用新变量交换两个变量的值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象建模"><span class="toc-text">抽象建模</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#44-扑克牌的顺子"><span class="toc-text">44.扑克牌的顺子</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>



      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.0.0-rc.4" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 </a></p>

        </div>
      
    
  </footer>


      <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <!-- required -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->

  
  
  
    <script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/044.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('') {
          $('').backstretch(
            imgs,
          {
            duration: "100000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "100000",
            fade: "1500"
          });
        }
      });
    </script>
  







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  




  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
		if($(".highlight .code pre").length+$(".article pre code").length==0)return;
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>








  
  <script src="/js/valine.js"></script>

<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = $.trim($('#pjax-comment-placeholder').text()) || "快来评论吧~";

    let path = $.trim($('#pjax-comment-path').text());
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>







  <script src="/js/app.js"></script>



  
    <script src="/js/search.js"></script>
  


<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );
(function ($) {
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
})(jQuery);

</script>









  
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  



  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://jizx.vip' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://jizx.vip' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://jizx.vip' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>



<!-- more -->


    
      

<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>
<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
          
          if ('') {
            $('').backstretch("resize");
            if($('.cover-wrapper').is(':hidden')){
              $('.cover-backstretch').backstretch("pause");
            }else{
              $('.cover-backstretch').backstretch("next");
            }
          } else {
            $.backstretch("resize");
            if($('.cover-wrapper').is(':hidden')){
              $.backstretch("pause");
            }else{
              $.backstretch("next");
            }
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
        
        
          pjax_initCopyCode();
        
        
          pjax_valine();
        
        
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
