{"meta":{"title":"玖玖的博客","subtitle":"个人学习笔记，各种杂杂碎碎O(∩_∩)O","description":null,"author":"jizx","url":"https://jizx.vip","root":"/"},"pages":[{"title":"","date":"2019-05-18T08:28:19.321Z","updated":"2019-01-02T02:45:47.308Z","comments":true,"path":"baidu_verify_HnDOMKijpC.html","permalink":"https://jizx.vip/baidu_verify_HnDOMKijpC.html","excerpt":"","text":"HnDOMKijpC"},{"title":"","date":"2020-02-26T12:52:41.020Z","updated":"2019-01-02T06:10:43.709Z","comments":true,"path":"googled639c0b4eecb867f.html","permalink":"https://jizx.vip/googled639c0b4eecb867f.html","excerpt":"","text":"google-site-verification: googled639c0b4eecb867f.html"},{"title":"404 Not Found：该页无法显示","date":"2018-02-26T14:45:08.000Z","updated":"2018-11-18T09:02:40.862Z","comments":false,"path":"/404.html","permalink":"https://jizx.vip//404.html","excerpt":"","text":""},{"title":"about","date":"2018-02-10T05:38:11.000Z","updated":"2018-11-18T09:02:40.917Z","comments":true,"path":"about/index.html","permalink":"https://jizx.vip/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-09T14:14:46.000Z","updated":"2018-11-18T09:02:40.917Z","comments":true,"path":"tags/index.html","permalink":"https://jizx.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"scp免密传输文件","slug":"scp免密传输文件","date":"2020-09-09T06:01:31.000Z","updated":"2020-09-10T14:51:41.704Z","comments":true,"path":"2020/09/09/scp免密传输文件/","link":"","permalink":"https://jizx.vip/2020/09/09/scp免密传输文件/","excerpt":"如何免密在两台Linux机器之间相互传输文件","text":"如何免密在两台Linux机器之间相互传输文件 使用scp在两台Linux机器之间相互传输文件，常用参数如下： 123scp file.txt work@linux2:/home/work/somedirscp -p file.txt work@linux2:/home/work/somedir # 保留创建时间、属性scp -r xxx_dir work@linux2:/home/work/somedir # 复制目录 为了避免每次传输都需要对方机器的密码，配置步骤如下： 第一步：配置机器1的的公钥 1234# 在机器1上ssh-keygen -t rsacat ~/.ssh/id_rsa.pub 第二步：复制公钥到机器2上 12# 在机器2上，打开 authorized_keys，追加在后面（文件不存在则新建）vim ~/.ssh/authorized_keys 然后反过来操作一遍。","categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"}],"tags":[{"name":"scp","slug":"scp","permalink":"https://jizx.vip/tags/scp/"}]},{"title":"pytorch与tensorflow环境搭建","slug":"pytorch与tensorflow环境搭建","date":"2020-08-09T15:21:01.000Z","updated":"2020-08-09T16:32:09.030Z","comments":true,"path":"2020/08/09/pytorch与tensorflow环境搭建/","link":"","permalink":"https://jizx.vip/2020/08/09/pytorch与tensorflow环境搭建/","excerpt":"记录pytorch与tensorflow的环境搭建","text":"记录pytorch与tensorflow的环境搭建 conda安装pytorch1、添加conda的镜像源 1234conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes#下载时显示文件来源 2、然后去pytorch官网，找到它给的命令，去掉-c后面部分，（它指定默认地址下属路径，若不删掉，他就又去default地址找资源了） conda install pytorch torchvision -c pytorch tensorflow安装直接conda安装即可 1conda install tensorflow 如果使用pip的话 1pip install tensorflow==2.3 -i https://pypi.tuna.tsinghua.edu.cn/simple Huggingface安装12 pip install tokenizers -i https://pypi.tuna.tsinghua.edu.cn/simple","categories":[],"tags":[]},{"title":"hadoop streaming","slug":"hadoop-streaming","date":"2020-07-12T02:30:50.000Z","updated":"2020-09-10T14:51:41.701Z","comments":true,"path":"2020/07/12/hadoop-streaming/","link":"","permalink":"https://jizx.vip/2020/07/12/hadoop-streaming/","excerpt":"hadoop streaming","text":"hadoop streaming mapper、reducer 模板Python3版本的 mapper、reducer 模板，一行一行的读取并处理 注意：hadoop上的默认编码有可能不是 utf-8，因此不论python2、3都建议使用codecs模块，使用 codecs.open(file, ‘r’, encoding=’utf-8’) 是个好习惯 如果你使用的是 for line in sys.stdin: 出现下面的错误怎么办呢——&gt;How to prevent “UnicodeDecodeError” when reading piped input from sys.stdin? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python# -*- coding=utf8 -*-\"\"\"@Author :@Created Time : 2020-05-21 15:00:32@Description : TODO\"\"\"import sysimport loggingimport codecs as csfrom sys import stdin, stdout # 用于判断hadoop默认编码环境logging.warning(stdin.encoding)logging.warning(stdout.encoding)def process(): # TODO pass def main(): \"\"\" main \"\"\" # python3 建议这样处理编码，从标准输入读取，下面两种方式等价 for line in cs.open(stdin.fileno(), 'r', encoding='utf-8', errors='replace'): #for line in cs.open(0, 'r', encoding='utf-8', errors='replace'): # 1.输入 line = line.strip('\\r\\n') cols = line.split('\\t') # 2.列数校验 if len(cols) != 2: logging.warning(line) continue # 3.TODO 具体处理逻辑 results = process() # 4.输出 for result in results: stdout.write(result) stdout.write('\\n') if __name__ == \"__main__\": main() shell版的mapper、reducer，下面是一个统计词频的功能 注意：头部不可以加 source ~/.bashrc ,因为hadoop环境没有该文件 12345678# mapper.shecho $LANG &gt;&amp;2awk -F\"\\t\" '&#123;print $1\"\\t\"1&#125;' # reducer.shecho $LANG &gt;&amp;2awk -F\"\\t\" '&#123;dict[$1]+=1&#125; END&#123;for(w in dict)print w\"\\t\"dict[w]&#125;' 本地测试通过模拟MapReduce进行测试，排查问题。只有本地测试通过，才能确保在hadoop上运行成功。 python测试 构造一份测试数据到 test_data.txt 中，然后下载hadoop上的python包（自己编译的），进行测试 12345hadoop fs -get /xxx/python3.6.tar.gz .tar -zxvf python3.6.tar.gz # 注意使用解压后的python，非本地开发机的pythoncat test_data.txt | python3.6/bin/python mapper.py | python3.6/bin/python reducer.py 如需安装其他模块请使用 ./python3.6/bin/python -m pip install xxx ，并重新打包压缩，上传到你的hadoop目录 其他测试 mapper 与 reducer可以是 python、shell脚本，并且可以混合使用，如下： 12cat test_data.txt | python3.6/bin/python mapper.py | sh reducer.sh # python 与 shell脚本cat test_data.txt | python3.6/bin/python mapper.py | sort -k1,1 # python 与 命令 hadoop stream 模板 如果只有2、3个代码文件，使用 -file xxx.py 指定； 如果有较多文件，如下图，建议将整个src目录压缩成 src.tar.gz，上传到指定的hadoop目录，如果还用到别的目录，比如config、data也一起打包上传，并使用 -cacheArchive hadoop路径 指定；（hadoop支持zip, jar, tar.gz格式的压缩包，由于Java解压zip压缩包时会丢失文件权限信息而且遇到中文文件名会出错，所以建议采用tar.gz压缩包。） hadoop上的目录结构，可以理解与本地的工程目录是相同的，只要你打包与解压的方式是对的，因此相对路径啥的，只要本地测试通过，hadoop上也不会有问题； 具体使用请看下面的模板； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#!/usr/bin/shsource ~/.bashrc DATE=`date -d \"$1\" +\"%Y%m%d\"`HADOOP_DIR=\"\" # TODO hadoop路径HADOOP_INPUT=\"$&#123;HADOOP_DIR&#125;/input/\"HADOOP_OUTPUT=\"$&#123;HADOOP_DIR&#125;/output/\"SRC=\"$&#123;HADOOP_DIR&#125;/src.tar.gz\"DATA_CONFIG=\"$&#123;HADOOP_DIR&#125;/data.tar.gz\"PYTHON=\"$&#123;HADOOP_DIR&#125;/python3.6.tar.gz\"TASK_NAME=\"task_name\" hadoop fs -test -e $HADOOP_DIRif [ $? -ne 0 ]; then echo \"Hadoop路径有误：$HADOOP_DIR，请检查\" exit 8fi# 上传本地工程代码到 hadoopfunction upload() &#123; LOCAL_FILE=$1 # 本地文件 HADOOP_FILE=$2 # hadoop目录 echo -e \"$1\\n上传到↑=====↓ \\n $2\" hadoop fs -test -e $HADOOP_FILE if [ $? -eq 0 ]; then hadoop fs -rmr $HADOOP_FILE fi hadoop fs -put $LOCAL_FILE $HADOOP_FILE&#125; function info() &#123; echo -e \"############### $1 ##############\\n\"&#125; archives_dir=\"./archives\" # 本地缓存压缩包的目录[ ! -e $&#123;archives_dir&#125; ] &amp;&amp; mkdir $&#123;archives_dir&#125; info '[开始]更新本地代码到hadoop'tar -czvf $&#123;archives_dir&#125;/src.tar.gz src/ &amp;&amp; upload $&#123;archives_dir&#125;/src.tar.gz $SRCtar -czvf $&#123;archives_dir&#125;/data.tar.gz data/ &amp;&amp; upload $&#123;archives_dir&#125;/data.tar.gz $DATA_CONFIG# 针对不经常修改的、含有大文件的目录，避免每次都压缩，可以如下加个判断#if [ ! -f $&#123;archives_dir&#125;/config.tar.gz ]; then # config是大文件，避免每次压缩# tar -czvf $&#123;archives_dir&#125;/config.tar.gz config/ &amp;&amp; upload $&#123;archives_dir&#125;/config.tar.gz $NLPC_CONFIG#fiinfo '[完成]更新本地代码到hadoop' hadoop fs -test -e $HADOOP_OUTPUTif [ $? -eq 0 ]; then hadoop fs -rmr $HADOOP_OUTPUTfi # 务必使用如下的-cmdenv指定环境的编码为UTF8hadoop streaming \\ -input $HADOOP_INPUT \\ -output $HADOOP_OUTPUT \\ -mapper \"sh src/script/mapper.sh\" \\ -reducer \"sort -u\" \\ -file xxx.py \\ -file yyy.sh \\ -cacheArchive $&#123;DATA_CONFIG&#125;\\ -cacheArchive $&#123;SRC&#125;\\ -cacheArchive $&#123;PYTHON&#125;\\ -cmdenv LANG=zh_CN.utf8 \\ -cmdenv PYTHONIOENCODING=utf_8 \\ -jobconf mapred.job.name=$TASK_NAME \\ -jobconf mapred.job.map.capacity=400 \\ -jobconf mapred.map.tasks=100 \\ -jobconf mapred.reduce.tasks=100 \\ -jobconf stream.memory.limit=5120 \\ -jobconf abaci.split.optimize.enable=false \\ -jobconf mapred.map.over.capacity.allowed=false \\ -jobconf mapred.job.priority=NORMAL \\ -jobconf abaci.job.base.environment=centos6u3_hadoop if [ $? -ne 0 ] then echo \"hadoop error\" exit 1fi 参数说明输入输出文件 -input &lt;path&gt;：指定作业输入，path可以是文件或者目录，可以使用*通配符，-input选项可以使用多次指定多个文件或目录作为输入。 -output &lt;path&gt;：指定作业输出目录，path必须不存在，而且执行作业的用户必须有创建该目录的权限，-output只能使用一次。 上传 单个mapper、reducer文件 -file xxx.py -file yyy.sh 上传较多代码文件 建议本地打包后上传到hadoop上，并使用 -cacheArchive 指定，该命令会自动解压；注意第3个有#号的例子，这不是注释，而是指定了解压的目录，相当于 tar -xzvf python.tar.gz -C ./target_dir 123-cacheArchive $&#123;DATA_CONFIG&#125;\\-cacheArchive $&#123;SRC&#125;\\-cacheArchive $&#123;PYTHON&#125;#target_dir\\ 解决reduce积压到一个reducer的问题 -jobconf stream.map.output.field.separator=. # 指定“.”作为map输出内容的分隔符，默认是\\t，这个参数不建议添加和修改 -jobconf stream.num.map.output.key.fields=2 # 从在第2个“\\t”之前的部分作为key，之后的部分作为value 自己指定mapper的数量，否则abaci会自动优化 12-jobconf abaci.split.optimize.enable=false -jobconf mapred.map.tasks=200 但并不是你指定多少就是多少mapper 指定reducer数量 1-jobconf mapred.reduce.tasks=100 同时运行的mapper、reducer数量限制 12-jobconf mapred.job.map.capacity=200 最多同时运行map任务数-jobconf mapred.job.reduce.capacity=200 最多同时运行reduce任务数 设置环境变量 -cmdenv NAME=VALUE：给mapper和reducer程序传递额外的环境变量，NAME是变量名，VALUE是变量值。 12-cmdenv LANG=zh_CN.utf8 \\-cmdenv PYTHONIOENCODING=utf_8 \\ # 如果上面的环境变量不生效，再试试加上这个 可以设置的编码请用: locale -a |grep zh 查看，原因请看：Python3.6 sys.stdout.encoding的输出为ANSI_X3.4-1968(python3.6的坑) 官方教程官方教程：Hadoop Streaming","categories":[{"name":"hadoop","slug":"hadoop","permalink":"https://jizx.vip/categories/hadoop/"}],"tags":[{"name":"hadoop streaming","slug":"hadoop-streaming","permalink":"https://jizx.vip/tags/hadoop-streaming/"}]},{"title":"pandas","slug":"pandas","date":"2020-06-23T05:52:49.000Z","updated":"2020-09-10T14:51:41.700Z","comments":true,"path":"2020/06/23/pandas/","link":"","permalink":"https://jizx.vip/2020/06/23/pandas/","excerpt":"panda入门笔记","text":"panda入门笔记 推荐入门链接Python数据分析之Pandas——基础篇 ​ 1. Python数据分析实战 | 初识Pandas 备用链接 ​ 2. Python数据分析实战 | 灵活的Pandas索引 备用链接 ​ 3. Python数据分析实战 | 清洗常用4板斧 备用链接 ​ 4. Pandas中第二好用的函数 | 优雅的apply 备用链接 Python数据分析之Pandas——实战篇 数据分析必知必会 | TGI指数分析实战 备用链接 Python处理分析128张Excel表格不到3秒？ 备用链接 不到70行Python代码，玩转RFM用户分析模型 备用链接 4.Python数据分析实战 | 经典的同期群分析 官网中文 官网十分钟入门 Pandas One hot处理pandas提供对one-hot编码的函数是：pd.get_dummies() 123456789101112131415# import pandas as pddata = pd.DataFrame(&#123;'size':['s','xxl','m','l','xl'],'gender':['M','F','F','M','N/A']&#125;)print(data)# one hot处理one_hot_size = pd.get_dummies(data['size'])one_hot_gender = pd.get_dummies(data['gender'])print(one_hot_size)print()print(one_hot_gender)# 拼接result = pd.DataFrame()pd.concat([result, one_hot_size, one_hot_gender],axis = 1)","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://jizx.vip/tags/pandas/"}]},{"title":"bash高效快捷键","slug":"bash高效快捷键","date":"2020-05-09T14:21:43.000Z","updated":"2020-07-14T01:31:58.685Z","comments":true,"path":"2020/05/09/bash高效快捷键/","link":"","permalink":"https://jizx.vip/2020/05/09/bash高效快捷键/","excerpt":"为了提高Linux下工作效率，自然而然的就变成了如何高效使用Bash的问题。虽然上一篇Shell下的一些特殊字符在使用的时候，能够一定程度上提高效率，后一篇关于Bash下的历史扩展也能很大程度提高效率，但Bash上的一些快捷键才是提高效率的最简单也是最直接方式。本文正是奔着这个目标来的！","text":"为了提高Linux下工作效率，自然而然的就变成了如何高效使用Bash的问题。虽然上一篇Shell下的一些特殊字符在使用的时候，能够一定程度上提高效率，后一篇关于Bash下的历史扩展也能很大程度提高效率，但Bash上的一些快捷键才是提高效率的最简单也是最直接方式。本文正是奔着这个目标来的！ bash 敲命令的快捷键快捷键有个规律，Ctrl开头的快捷键一般是针对字符的，而Alt开头的快捷键一般是针对词的。 Bash下，如果使用的是shell脚本文件，快捷键不一定是一样的，有的时候会出现同一个快捷键有不同的表现，这种情况一般是由于Bash所处的模式不同而引起的，你可以通过set命令来调整模式： 123456set -o emacs##切到emacs模式set -o vi##切到vi模式set -o## 查看当前选项的设置状态 本文使用的是emacs模式 CTRL=C：这个键是指PC键盘上的Ctrl键 ALT=M：这个键是PC键盘上的ALT键，如果你键盘上没有这个键，可以尝试使用ESC键代替 SHIFT=S：此键是PC上的Shift键 ESC=E：这个键是PC键盘上的ESC键，此键一般在键盘的左上角 BACKSPACE=DEL：此键是是PC键盘上的Backspace键，一般位于主键盘区的右上角 文中”[]”括住的为快捷键内容，”-“两边的内容是按住左边键，再按右边键获得，”,”逗号两边的内容是先按左边键，松开后再按右边键。如：[CTRL-v]是表示按下Ctrl键之后，不要松开，再按下v键。 默认的情况下，快捷键的组成格式是：&lt;CTRL | ALT | ESC &gt;-[SHIFT-]&lt;char&gt;。即由Ctrl、Alt、Esc之一开头，中划线，Shift，中划线，和一个字符组成。其中，中括号内的Shift和”-“有时可省略。 默认情况下，快捷键只有最后一个为字符，其他的键值均为功能键 出现[CTRL-?]这类快捷键，由于”?”是需要使用Shift按键才能获得的字符，因此此类快捷键默认使用的是[CTRL-SHIFT-?] 常用快捷键 快捷键 说明 定位相关 CTRL-A 将光标移到行首（在命令行下） CTRL-E 将光标移动到行尾（在命令行下） ALT-F 光标往前跳一个词(移动到光标所在词的末尾)。 ALT-B 光标往回跳一个词，词以非字母为界(跳动到当前光标所在词的开头)。 编辑相关 CTRL-Y 将之前已经清除的文本粘贴回来（主要针对CTRL-U或CTRL-W或CTRL-K）。 CTRL-W 删除从在光标处往回的第一个空白符之间的内容。在某些设置里, CTRL-W 删除光标往后（回）到第一个非文字和数字之间的字符。 CTRL-U 删除从光标位置开始到行首的所有字符内容。在某些设置下，CTRL-U会不以光标位置为参考而删除整行的输入。 CTRL-K 删除从光标所在处到行尾的所有字符（在命令行下） ALT-D 删除光标所在位置到光标所在词的结尾位置的所有内容(如果光标是在词开头，则删除整个词)。 ALT-BASKSPACE 删除光标所在位置到词开头的所有内容。 ALT-R 取消所有变更，并将当前行恢复到在历史记录中的原始状态(前提是当前命令是从历史记录中来的，如果是手动输入，则会清空行)。 特殊字符相关 CTRL-V 在输入文本的时候，按下C-V之后，可以插入控制字符。比如：echo -e ‘\\x0a&#39;;和echo &lt;CTRL-V&gt;&lt;CTRL-J&gt;;这两种效果一样。这点功能在文本编辑器内非常有效。 CTRL-M 回车(Carriage return)。 CTRL-I 水平制表符。 CTRL-K 垂直制表符(Vertical tab)，（输入状态） CTRL-R 回溯搜索(Backwards search)history缓冲区内的文本（在命令行下）。注意：按下之后，提示符会变成(reverse-i-search)&#39;&#39;:输入的搜索内容出现在单引号内，同时冒号后面出现最近最匹配的历史命令。 CTRL-L 跳纸，换页(Formfeed)，清屏。清空终端屏幕。在终端上，这个命令的作用和clear命令一样。但当这个命令发送到打印机时，Ctrl-L会直接跳到纸张(Paper sheet)的末尾。 程序相关 快捷键 说明 CTRL-C 中断，终结一个前台作业。 CTRL-Z 暂停一个前台的作业；在某些文本处理程序中也作为替换操作；在MSDOS文件系统中作为EOF（End-of-file)字符。 用fg恢复。 CTRL-S Suspend(XOFF)，挂起。这个是冻结终端的stdin。要恢复可以按CTRL-Q。 CTRL-Q Resume (XON)。恢复/解冻，这个命令是恢复终端的stdin用的，可参见CTRL-S。 案例避免重复输入文件名 12345678touch /tmp/a-test-file-from-blog.useasp.net ## 如果不使用快捷键，文件名要重新输入chmod u+x /tmp/a-test-file-from-blog.useasp.net ##使用快捷键chmod u+x &lt;ALT-.&gt;## 快捷键[M-.]自动会将上面的最后一个参数附加 自定义快捷键使用bind命令即可，Bash中的快捷键其实是Readline来提供的，因此，这里快捷键的设置其实就是配置Readline，Readline中分两种快捷键，一种是Readline内部的函数快捷键，另外一种是执行Shell命令，设置的时候稍有不同： 1234567891011121314##查看Readline中可以使用的函数名称bind -l##查看当前绑定的案件配置与其对应的功能bind -v##已经绑定的快捷键bind -p ##绑定自定义执行命令shell命令的快捷键bind -x '\"\\C-x\\C-l\":ls -al'## 绑定后，按[C-x,C-L]就能执行ls -al ## 绑定内置函数功能bind \"\\C-x\":backword-delte-char##这个是这行Readline库中的函数backword-delte-char 说明： 在配置文件中，\\C代表CTRL，\\M代表ALT，\\e代表ESC，\\\\是反斜杠\\，\\&#39;是单引号，\\&quot;是双引号； 如果要查看某一个功能键的字符序列可以通过[CTRL-V]来实现，或者输入cat后回车，进入编辑中，直接按快捷键; 配置文件中可能会使用八进制或者十六进制来表示字符; 为了能够让设置的快捷键永久有效，我们就需要将快捷键的配置写入文件。在Linux系统中，能永久保存快捷键的地方有两个，全局和用户的配置文件，全局的是/etc/inputrc，而用户的是在用户的根目录下~/.inputrc，全局的会影响所有的用户，而用户根目录下的只会对相应的用户产生影响。 inputrc文件的大概样子像下面这样： 12345678910111213141516171819202122232425262728293031## 本例来自CentOS6.4的默认配置文件$if mode=emacs # for linux console and RH/Debian xterm\"\\e[1~\": beginning-of-line\"\\e[4~\": end-of-line# commented out keymappings for pgup/pgdown to reach begin/end of history#\"\\e[5~\": beginning-of-history#\"\\e[6~\": end-of-history\"\\e[5~\": history-search-backward\"\\e[6~\": history-search-forward\"\\e[3~\": delete-char\"\\e[2~\": quoted-insert\"\\e[5C\": forward-word\"\\e[5D\": backward-word\"\\e[1;5C\": forward-word\"\\e[1;5D\": backward-word # for rxvt\"\\e[8~\": end-of-line\"\\eOc\": forward-word\"\\eOd\": backward-word # for non RH/Debian xterm, can't hurt for RH/DEbian xterm\"\\eOH\": beginning-of-line\"\\eOF\": end-of-line # for freebsd console\"\\e[H\": beginning-of-line\"\\e[F\": end-of-line$endif TODO ‘\\e[H‘ 到底表示什么 推荐的自定义 1234bind \"\\C-f\":forward-word # 向前移动一个词 （以英文单词）bind \"\\C-b\":backward-word # 向后移动一个词bind \"\\C-f\":vi-fword # 向前移动一个词(以空格划分)bind \"\\C-b\":vi-bword # 向后移动一个词 全部快捷键 快捷键 快捷键说明 CTRL-A 将光标移到行首（在命令行下） CTRL-B 退格 (非破坏性的)，这个只是将光标位置往回移动一个位置。 CTRL-C 中断，终结一个前台作业。 CTRL-D “EOF” (文件结尾：end of file)。它用于表示标准输入（stdin）的结束。在控制台或xterm 窗口输入文本时，CTRL-D 删除在光标下的字符。从一个shell中退出 (类似于exit)。如果没有字符存在，CTRL-D 则会登出该会话。在一个xterm窗口中，则会产生关闭此窗口的效果。 CTRL-E 将光标移动到行尾（在命令行下） CTRL-F 将光标向前移动一个字符（在命令行下） CTRL-G BEL。在一些老式打印机终端上，这会引发一个响铃。在xterm终端上可能是哔的一声。 CTRL-H 擦除(Rubout)(破坏性的退格)。在光标往回移动的时候，同时擦除光标前的一个字符。 CTRL-I 水平制表符。 CTRL-J 新行(换行[line feed]并到行首)。在脚本中，也可能表示为八进制形式(‘\\012’)或十六进制形式(‘\\x0a’)。 CTRL-K 垂直制表符(Vertical tab)。在控制台或 xterm 窗口输入文本时，CTRL-K会删除从光标所在处到行尾的所有字符。在脚本中，也可能表示为八进制形式(‘\\013’)或十六进制形式(‘\\x0b’)。在脚本中，CTRL-K可能会有不一样的行为，下面的例子给出其不一样的行为：`#!/bin/bash## 一个CTRL-K垂直制表符的例子 var=$’\\x0aBottom Line\\x0bTop line\\x0a’## 直接输出echo “$var”## 使用col来过滤控制字符echo “$var” col ## 上面的显示将会不一样 exit 0` CTRL-L 跳纸，换页(Formfeed)，清屏。清空终端屏幕。在终端上，这个命令的作用和clear命令一样。但当这个命令发送到打印机时，Ctrl-L会直接跳到纸张(Paper sheet)的末尾。 CTRL-M 回车(Carriage return)。 CTRL-N 擦除从history缓冲区召回的一行文本（在命令行下）。如果当前输入是历史记录中选择的时候，这个是从这个历史记录开始，每按一次，是更接近的一条命令。 CTRL-O 产生一个新行（在命令行下）。 CTRL-P 从history缓冲区召回上一次的命令（在命令行下）。此快捷键召回的顺序是由近及远的召回，即按一次，召回的是前一次的命令，再按一次，是召回上一次之前的命令，这和CTRL-N都是以当前的输入为起点，但是两个命令操作刚好相反，CTRL-N是从起点开始由远及近（如果起点是历史命令的话）。 CTRL-Q Resume (XON)。恢复/解冻，这个命令是恢复终端的stdin用的，可参见CTRL-S。 CTRL-R 回溯搜索(Backwards search)history缓冲区内的文本（在命令行下）。注意：按下之后，提示符会变成(reverse-i-search)&#39;&#39;:输入的搜索内容出现在单引号内，同时冒号后面出现最近最匹配的历史命令。 CTRL-S Suspend(XOFF)，挂起。这个是冻结终端的stdin。要恢复可以按CTRL-Q。 CTRL-T 交换光标位置与光标的前一个位置的字符内容（在命令行下）。比如：echo $var;，假设光标在a上，那么，按下C-T之后，v和a将会交换位置：echo $avr;。 CTRL-U 擦除从光标位置开始到行首的所有字符内容。在某些设置下，CTRL-U会不以光标位置为参考而删除整行的输入。 CTRL-V 在输入文本的时候，按下C-V之后，可以插入控制字符。比如：echo -e ‘\\x0a&#39;;和echo ;这两种效果一样。这点功能在文本编辑器内非常有效。 CTRL-W 当在控制台或一个xterm窗口敲入文本时, CTRL-W 会删除从在光标处往后（回）的第一个空白符之间的内容。在某些设置里, CTRL-W 删除光标往后（回）到第一个非文字和数字之间的字符。 CTRL-X 在某些文字处理程序中，这个控制字符将会剪切高亮的文本并且将它复制到剪贴板中。 CTRL-Y 将之前已经清除的文本粘贴回来（主要针对CTRL-U或CTRL-W）。 CTRL-Z 暂停一个前台的作业；在某些文本处理程序中也作为替换操作；在MSDOS文件系统中作为EOF（End-of-file)字符。 CTRL-\\ 退出。和CTRL-C差不多，也可能dump一个”core”文件到你的工作目录下(这个文件可能对你没用)。 CTRL-/ 撤消操作，Undo。 CTRL-_ 撤消操作。 CTRL-xx 在行首和光标两个位置间进行切换，此处是两个”x”字符。 ALT-B 光标往回跳一个词，词以非字母为界(跳动到当前光标所在词的开头)。 ALT-F 光标往前跳一个词(移动到光标所在词的末尾)。 ALT-D 删除光标所在位置到光标所在词的结尾位置的所有内容(如果光标是在词开头，则删除整个词)。 ALT-BASKSPACE 删除光标所在位置到词开头的所有内容。 ALT-C 将光标所在位置的字母转为大写(如果光标在一个词的起始位置或之前，则词首字母大写)。 ALT-U 将光标所在位置到词尾的所有字母转为大写。 ALT-L 将光标位置到词尾的所有字母转为小写。 ALT-R 取消所有变更，并将当前行恢复到在历史记录中的原始状态(前提是当前命令是从历史记录中来的，如果是手动输入，则会清空行)。 ALT-T 当光标两侧都存在词的时候，交换光标两侧词的位置。如：abc bcd -&gt; bcd abc ALT-. 使用前一次命令的最后一个词(命令本身也是一个词，参见后一篇的Bang命令中的词指示符概念)。 ALT-_ 同ALT-.。 ALT-数值 这个数值可以是正或者是负，这个键单独没有作用，必须后面再接其他内容，如果后面是字符，则表示重复次数。如：[ALT-10,k]则光标位置会插入10个k字符(负值在这种情况下无效)；如果后面接的是命令，则数字会影响后面命令的执行结果，如：[ALT--`10,CTRL-D]则向CTRL-D`默认方向相反(负数)的方向执行10次操作。 ALT-&lt; 移动到历史记录中的第一行命令。 ALT-&gt; 移动到历史的最后一行，即当前正在输入的行(没有输入的情况下为空)。 ALT-P 从当前行开始向前搜索，有必要则向”上”移动，移动时，使用非增量搜索查找用户提供的字符串。 ALT-N 从当前行开始向后搜索，如果有必要向”下”移动，移动时，使用非增量搜索查找用户提供的字符串。 ALT-CTRL-Y 在标志点上插入前一个命令的第一个参数(一般是前一行的第二个词)。如果有参数n，则插入前一个命令的第n个词(前一行的词编号从0开始，见历史扩展)。负的参数将插入冲前一个命令的结尾开始的第n个词。参数n通过M-No.的方式传递，如：[ALT-0,ALT-CTRL-Y]插入前一个命令的第0个词(命令本身)。 ALT-Y 轮询到删除环，并复制新的顶端文本。只能在yank[CTRL-Y]或者yank-pop[M-Y]之后使用这个命令。 ALT-? 列出能够补全标志点前的条目。 ALT-* 把能够补全[ALT-?]命令能生成的所有文本条目插入到标志点前。 ALT-/ 试图对标志点前的文本进行文件名补全。[CTRL-X,/]把标志点前的文本当成文件名并列出可以补全的条目。 ALT-~ 把标志点前的文本当成用户名并试图进行补全。[CTRL-X,~]列出可以作为用户名补全标志点前的条目。 ALT-$ 把标志点前的文本当成Shell变量并试图进行补全。[CTRL-X,$]列出可以作为变量补全标志点前的条目。 ALT-@ 把标志点前的文本当成主机名并试图进行补全。[CTRL-X,@]列出可以作为主机补全标志点前的条目。 ALT-! 把标志点前的文本当成命令名并试图进行补全。进行命令名补全时会依次使用别名、保留字、Shell函数、shell内部命令，最后是可执行文件名。[CTRL-X,!]把标志点前的文本当成命令名并列出可补全的条目。 ALT-TAB 把标志点前的文本与历史记录中的文本进行比较以寻找匹配的并试图进行补全。 ALT-{ 进行文件名补全，把可以补全的条目列表放在大括号之间，让shell可以使用。 Bash 快捷键大全","categories":[],"tags":[]},{"title":"python进阶","slug":"python进阶","date":"2020-03-01T16:12:58.000Z","updated":"2020-07-19T15:33:49.206Z","comments":true,"path":"2020/03/02/python进阶/","link":"","permalink":"https://jizx.vip/2020/03/02/python进阶/","excerpt":"python进阶内容，帮助理解让你摸不着头脑的一些问题","text":"python进阶内容，帮助理解让你摸不着头脑的一些问题 python之前术语 KISS 原则：“Keep It Simple, Stupid”的首字母缩写。这个原则要求尽量寻找最简单的方案，尽量减少可变部分。这个警句是 Kelly Johnson 首创的。 统一访问原则：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。 objects, types, classes, instances的区别object 对象对象 (object) 是 python 对数据的抽象总称。在 python 编程中，所有的数据都是以 对象 或者 对象 之间的关系表示的，每个对象都有对应的 ID、类型(type)和值(value)。 [data model 原文] Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer,” code is also represented by objects.) Every object has an identity, a type and a value. python 中一切都是对象，list、42、函数、模块都是 object 12345678def foo(): passtype(foo), id(foo)# (&lt;class 'function'&gt;, 38110760)type(foo.__code__), id(foo.__code__)# (&lt;class 'code'&gt;, 38111680) type 类型一个对象的类型决定了该对象所能支持的操作(比如，能不能计算长度)，也定义了 该类型的对象 的 值。 An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type. 因此每个对象都属于某个类型 (type)，通过type内置函数可以确定对象的类型。类型 type 也是一个对象，因此它也有对应的类型，而这个类型是 type (The type is an object too, so it has a type of its own, which is called type.) 12345678type(42)# &lt;class 'int'&gt;type(type(42))# &lt;class 'type'&gt;type(type(type(42)))# &lt;class 'type'&gt; 是的，就这样无限循环下去了 ，Yep, it’s turtles all the way down. Classes 类A class defines the blueprint, which can be instantiated to create Object(s) class 是一种机制，让我们通过 python 代码 创建新的用户自定义的类型 (type) 123456class Joe: passj = Joe()type(j)# &lt;class '__main__.Joe'&gt; 使用 class 机制，我们创建了 Joe——用户定义的新类型，j是类Joe的一个实例，换句话说：j是一个对象，它的类型是Joe Class 和 type 是指代相同概念的两个名称的示例。为了避免产生误解，当表示类型时，我尽量说”type” ，当指的是通过 class 新创建的类型时，我尽量说 “user-defined class” (or “user-defined type”) I will always try to say “type” when I mean a type, and “user-defined class” (or “user-defined type”) when referring to a new type created using the class construct. Instances 实例不像 class 和 type，instance 和 object 是同义词，可以这样理解：对象(object)是某种类型(type)的实例 (instance)，因此 “42 is an instance of the type int“ 等价于 “42 is an int object”. python 版本1234567891011import platform print(platform.python_version())# 2.7.15import sys print(sys.version)# 2.7.15 |Anaconda, Inc.| (default, Oct 23 2018, 13:35:16) [GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)]print(sys.version_info)# sys.version_info(major=2, minor=7, micro=15, releaselevel='final', serial=0) python 反编译dis模块为反汇编 Python 函数字节码提供了简单的方式 1234567891011121314151617181920212223from dis import disb = 6def f(a): global b print(a) print(b) b=9&gt;&gt;&gt; dis(f) 3 0 LOAD_GLOBAL 0 (print) 2 LOAD_FAST 0 (a) 4 CALL_FUNCTION 1 6 POP_TOP 4 8 LOAD_GLOBAL 0 (print) 10 LOAD_GLOBAL 1 (b) 12 CALL_FUNCTION 1 14 POP_TOP 5 16 LOAD_CONST 1 (9) 18 STORE_GLOBAL 1 (b) 20 LOAD_CONST 0 (None) 22 RETURN_VALUE 数据结构序列基础部分常见序列序列的种类 容器序列存放的是它们所包含的任意类型的对象的引用。 扁平序列里存放的是元素的值本身，而不是其他对象的引用。换句话说，扁平序列其实是一段连续的内存空间。由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。 推导式推导式 包括：列表推导、生成器表达式，以及同它们很相似的集合（set）推导和字典（dict）推导。通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。 如果列表推导的代码超过了两行，你可能就要考虑是不是得用 for 循环重写了。 Python 2.x 中，在列表推导中 for 关键词之后的赋值操作可能会影响列表推导上下文 中的同名变量。像下面这个 Python 2.7 控制台对话，x 原本的值被取代了： 1234x = 'my precious'dummy = [x for x in 'ABC]print(x)# 'C' 但是这种情况在 Python 3 中是不会出现的。 推导式在Python3中都有了自己的局部作用域，就像函数似的。表达式内部的变量和赋值只在局部起作用，表达式的上下文里的同名变量不会被覆盖，还可以被正常引用。 生成器生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已。 如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围起来。 123symbols = '$¢£¥€¤'t = tuple( ord(symbol) for symbol in symbols )# (36, 162, 163, 165, 8364, 164) 元组元组的不可变性 其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。 1234567891011t1 = (1, 2, [30, 40])t2 = (1, 2, [30, 40])t1 == t2# Trueid(t1[-1])# 4302515784t1[-1].append(99)t1 # (1, 2, [30, 40, 99])id(t1[-1]) # 4302515784 拆包在进行拆包的时候，我们不总是对元组里所有的数据都感兴趣，_占位符能作为占位符。 如果做的是国际化软件，那么_可能就不是一个理想的占位符，因为它也是 gettext.gettext 函数的常用别名，gettext 模块的文档 （https://docs.python.org/3/library/gettext.html）里提到了这一点。在其他情况下，`_` 会 是一个很好的占位符。 除此之外，在元组拆包中使用 *也可以帮助我们把注意力集中在元组的部分元素上，来处理剩下的元素 namedtuple元组已经设计得很好用了，但作为记录来用的话，还是少了一个功能：我们时常会需要给记录中的字段命名。namedtuple函数的出现帮我们解决了这个问题。 创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者 可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。 12City = namedtuple('City', 'name country population coordinates')City = namedtuple('City', [name,country,population,coordinates]) 类属性_fields、类方法_make(iterable) _replace(key=new_value)和实例方法_asdict()。 _fields属性是一个包含这个类所有字段名称的元组。 用 _make()通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟City(*delhi_data) 是一样的。 _replace(key=new_value)，可以创建一个元组的浅副本，并修改其中的一些字段key等于new_value。 _asdict() 把具名元组以collections.OrderedDict的形式返回，我们可以利用它 来把元组里的信息友好地呈现出来。 对序列的操作切片a:b:c 这种用法只能作为索引或者下标用在 [] 中来返回一个切片对象：slice(a, b, c) 命名切片可以给切片对象进行命名，方便管理 1234567891011121314151617invoice = \"\"\"0.....6................................40........52...55........1909 Pimoroni PiBrella $17.50 3 $52.501489 6mm Tactile Switch x20 $4.95 2 $9.901510 Panavise Jr. - PV-201 $28.00 1 $28.001601 PiTFT Mini Kit 320x240 $34.95 1 $34.95\"\"\"SKU = slice(0, 6) # 第1列DESCRIPTION = slice(6, 40) # 第2列UNIT_PRICE = slice(40, 52) # 第3列QUANTITY = slice(52, 55) # 第4列ITEM_TOTAL = slice(55, None)# 第5列line_items = invoice.split('\\n')[2:]for item in line_items: print(item[UNIT_PRICE], item[DESCRIPTION]) # 打印第3列、第2列 切片赋值 如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。 切片的长度，可以不等于 赋值的迭代对象的长度，可以认为是把一个片段剪切为另一个片段 但是如果是[a:b:c]中跨度c不为1的话，长度就必须相同。 1234567891011121314151617l = list(range(10))# l [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]l[2:5] = [20, 30] # 长度大于的情况# l [0, 1, 20, 30, 5, 6, 7, 8, 9]del l[5:7]# l [0, 1, 20, 30, 5, 8, 9]l[3::2] = [11, 22]# l [0, 1, 20, 11, 5, 22, 9]l[2:5] = 100# 报错l[2:5] = [100]# l [0, 1, 100, 22, 9] 对序列使用+和*c = a + b：将a、b两个 list 中的元素复制到一个新的 list c 中 c = a * n：将 list a[a,b,c]中的元素，复制n次，得到新的 list c[a,b,c, a,b,c, a,b,c] a,b,c不能是引用类型的对象，不然复制后，改变其中一个就会改变所有 案例：生成一个3x3的方格 正确例子，使用列表生成式 12345board = [['_'] * 3 for i in range(3)]print(board)# [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]board[1][2] = 'X'# board [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']] 等价于 1234board = []for i in range(3): row=['_'] * 3 board.append(row) 错误例子，相当于weird_board = [[&#39;_&#39;,&#39;_&#39;,&#39;_&#39;]] * 3， 将内部元素 list 复制了3份，但其实是同一个引用 12345678weird_board = [['_'] * 3] * 3print(weird_board)# [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]weird_board[1][2] = 'O'print(weird_board)# weird_board [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']] 等价于 1234row=['_'] * 3 board = [] for i in range(3): board.append(row) 增量赋值+=+= 背后的特殊方法是 __iadd__ （用于“就地加法”）。但是如果一个类没有实现这个方法的话，Python 会退一步调用 __add__ 。 在这个表达式中，变量名会不会被关联到新的对象，完全取决于这个类型有没有实现 `iadd` 这 个方法。 如果 a 实现了 __iadd__ 方法，就会调用这个方法。同时对可变序列（例如 list、bytearray 和 array.array）来说，a 会就地改动，就像调用了 a.extend(b) 一样。 如果 a 没有实现 __iadd__ 的话，a += b 这个表达式的效果就变得跟 a = a + b 一样了：首先计算 a + b，得到一个新的对象，然后赋值给 a。 一个诡异的现象 12345678t = (1, 2, [30, 40])t[2] += [50, 60] # t[2].extend([50, 60]) 就能避免这个异常Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; TypeError: 'tuple' object does not support item assignmentprint(t)# (1, 2, [30, 40, 50, 60]) t[2].extend([50, 60])就能避免这个异常 背后原理 需要理解s[a] += b 生成的字节码： 将 s[a] 的值存入 TOS（Top Of Stack，栈的顶端）。 计算 TOS += b。这一步能够完成，是因为 TOS 指向的是一个可变对象（也就是示例 2-15 里的列表）。 s[a] = TOS 赋值。这一步失败，是因为 s 是不可变的元组（示例 2-15 中的元组 t）。\\ 原因就是：第1步中将引用存在了临时变量中，最后又重新进行赋值，tuple 又不可变，因此报错，得到的经验： 不要把可变对象放在元组里面。 增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了 操作。 排序 list.sort 方法会就地排序列表，也就是说不会把原列表复制一份。这也是这个方法的 返回值是 None 的原因 内置函数 sorted，它会新建一个列表作为返回值 参数： key：传入一个只有一个参数的函数，列表中的每个元素都会作为参数传入，得到的返回值将作为排序算法依赖的对比关键字。默认是一个恒等函数——参数是自己，返回值也是自己的函数 reverse： False（默认）：升序，True：降序 其他列表类型array与C语言的数组很像，只能存放同一种类型的数组，因此比较节省空间。 12345678910111213141516171819from array import arrayfrom random import randomfloats = array('d', (random() for i in range(10**7))) # 从生成器中获取数据print(floats[-1])# 0.07802343889111107'''保存数据到文件中'''fp = open('floats.bin', 'wb')floats.tofile(fp)fp.close()'''从文件中读取数据'''floats2 = array('d')fp = open('floats.bin', 'rb')floats2.fromfile(fp, 10**7)fp.close()print(floats2[-1])# 0.07802343889111107 从 Python 3.4 开始，数组类型不再支持诸如 list.sort() 这种就地排序方法。要给 数组排序的话，得用 sorted 函数新建一个数组：a = array.array(a.typecode, sorted(a)) memoryview不太了解，主要与numpy 相关 collections.deque我们可以把列表list当作栈或者队列来用（比如，把 .append 和 .pop(0) 合起来用，就能模拟栈的“先进先出”的特点）。但是删除列表的第一个元素 （抑或是在第一个元素之前添加一个元素）之类的操作是很耗时的，因为这些操作会牵扯到移动列表里的所有元素。 heapqPython中使用列表就可实现堆，主要的用法如下： heappop，heappush：入堆\\出堆 heapify：将列表转为堆 nlargest, nsmallest：获取top n的堆中的元素 12345678910111213141516from heapq import heappop, heappush, heapify, nlargest, nsmallestheap_list = list()arr = [-5, 51, 2, 1, 15, 5, 6, 7]for x in arr: heappush(heap_list, x) # 入堆 # 获取最大\\最小n的元素print(nsmallest(3, heap_list))print(nlargest(3, heap_list))heapify(arr) # 将arr列表heap化print(arr==heap_list)for i in range(len(heap_list)): print(heappop(heap_list)) # 出堆 Queue TODO队列 序列高级部分可迭代对象可迭代对象的定义在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如， Python 的序列协议只需要 __len__ 和 __getitem__ 两个方法。 1234567891011121314151617181920import reRE_WORD = re.compile('\\w+')class Sentence: def __init__(self, text): self.text = text self.words = RE_WORD.findall(text) def __getitem__(self, item): return self.words[item] def __iter__(self): for word in self.words: yield wordsen = Sentence(\"abc def 123 456\")for i in sen: print(i) 我们发现 __iter__ 和 __getitem__中实现任意一个，对象就是可迭代的，怎么解释这种情况呢，Python 解释器中有这样的描述： 解释器需要迭代对象 x 时， 会自动调用 iter(x)内置的 iter 函数有以下作用： 优先检查对象是否实现了 __iter__ 方法， 如果实现了就调用它， 获取一个迭代器。 如果没有实现 __iter__ 方法， 但是实现了 __getitem__ 方法，Python 会创建一个迭代器， 尝试按顺序（从索引 0 开始） 获取元素。之所以对 __getitem__ 方法做特殊处理，是为了向后兼容，而未来可能不会再这么做。 如果尝试失败， Python 抛出 TypeError 异常， 通常会提示“C object is not iterable”（C 对象不可迭代） 因此我们自定义可迭代对象需要实现 __iter__ 函数；严格来讲，我们还需要实现 __getitem__ 函数，这个函数的主要作用是使当前对象可通过下标取值。 判断是否可迭代什么是可迭代对象：使用 iter 内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的 __iter__ 方法，那么对象就是可迭代的。 如果有一个未知的对象，我们怎么判断该对象是否可迭代呢，两种方式（推荐第一种）： iter(x)这是最准确的判断方式，传入要判断的对象，只要对象实现了__getitem__ 、 __iter__中的其中一个，该对象都是可迭代的，否则抛出TypeError: ‘C’ object is not iterable 异常；这儿有个区别(有待考证)，如果仅仅实现了 __getitem__ ，调用 iter(x) 返回的是迭代器对象，如果实现的是 __iter__ ，那么调用iter(x)返回的是生成器对象； isinstance(x, abc.Iterable)该方式会自动忽略__getitem__函数，仅当对象实现了 __iter__ 函数才返回 True，其他一律返回 False 从 Python 3.4 开始，检查对象 x 能否迭代，最准确的方法是：调用 iter(x) 函数，如果不可迭代，再处理 TypeError 异常。这比使用 isinstance(x, abc.Iterable) 更准确，因为 iter(x) 函数会考虑到遗留的 __getitem__ 方法， 而 abc.Iterable 类则不考虑。 https://www.jianshu.com/p/048d40d86759 迭代器迭代器的定义迭代器是这样的对象：实现了无参数的 __next__ 方法，返回序列中的下一个元素； 如果没有元素了，那么抛出 StopIteration 异常。Python 中的迭代器还实现了 __iter__ 方法，因此迭代器也可以迭代。 123456789101112131415161718&gt;&gt;&gt; a='abc'&gt;&gt;&gt; it=iter(a)&gt;&gt;&gt; it&lt;str_iterator object at 0x1042e4940&gt;&gt;&gt;&gt; next(it)'a'&gt;&gt;&gt; next(it)'b'&gt;&gt;&gt; next(it)'c'&gt;&gt;&gt; next(it)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;StopIteration&gt;&gt;&gt; list(it)[]&gt;&gt;&gt; list(iter(a))['a', 'b', 'c'] 注意事项： 没有办法检查是否还有遗留的元素 如果想再次迭代，那就要调用 iter(…)，传入之前构建迭代器的可迭代对象 判断是否为迭代器检查对象 x 是否为迭代器最好的方式是调用 isinstance(x, abc.Iterator)。得益于 Iterator.__subclasshook__ 方法，即使对象 x 所属的类不是 Iterator 类的真实子类或虚拟子类，也能这样检查。 在 Python 3.4 中，Lib/types.py， 12345&gt; # Iterators in Python aren&apos;t a matter of type but of protocol. A large &gt; # and changing number of builtin types implement *some* flavor of &gt; # iterator. Don&apos;t check the type! Use hasattr to check for both &gt; # &quot;__iter__&quot; and &quot;__next__&quot; attributes instead.&gt; 这就是 abc.Iterator 抽象基类中 subclasshook 方法的作用 1234567891011121314151617181920&gt; class Iterator(Iterable):&gt; __slots__ = ()&gt; &gt; @abstractmethod&gt; def __next__(self):&gt; 'Return the next item from the iterator. When exhausted, raise StopIteration'&gt; raise StopIteration&gt; &gt; def __iter__(self):&gt; return self&gt; &gt; @classmethod&gt; def __subclasshook__(cls, C):&gt; if cls is Iterator:&gt; &gt; if (any(\"__next__\" in B.__dict__ for B in C.__mro__) and&gt; any(\"__iter__\" in B.__dict__ for B in C.__mro__)):&gt; return True&gt; return NotImplemented&gt; 自定义迭代器既是可迭代对象又是迭代器(bad idea)构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。 除了__iter__ 方法之外，你可能还想在某个类（可迭代对象）中实现 __next__ 方法，让实例既是可迭代的对象，也是自身的迭代器。可是，这种想法非常糟糕。 迭代器可以迭代，但是可迭代的对象不是迭代器 可迭代的对象一定不能是自身的迭代器。 也就是说，可迭代的对象必须实现 __iter__ 方法，但不能实现 __next__ 方法。 迭代器应该一直可以迭代。迭代器的 __iter__ 方法应该返回自身。 迭代器模式可用来： 访问一个聚合对象的内容而无需暴露它的内部表示 支持对聚合对象的多种遍历 为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代） 为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用 iter(my_iterable) 都新建一个独立的迭代器。这就是为什么这个示例需要定义SentenceIterator 类。 123456789101112131415161718192021222324252627282930313233# 正确做法import reimport reprlibRE_WORD = re.compile(&apos;\\w+&apos;)class Sentence: def __init__(self, text): self.text = text self.words = RE_WORD.findall(text) def __repr__(self): return &apos;Sentence(%s)&apos; % reprlib.repr(self.text) def __iter__(self): return SentenceIterator(self.words)class SentenceIterator: def __init__(self, words): self.words = words self.index = 0 def __next__(self): try: word = self.words[self.index] except IndexError: raise StopIteration() self.index += 1 return word def __iter__(self): return self python 风格的迭代器符合 Python 习惯的方式是，用生成器函数代替 SentenceIterator 类。 惰性实现 惰性实现是指尽可能延后生成值。这样做能节省内存，而且或许还可以避免做无用的处理。因此修改如下： 惰性实现：生成器函数1 12345678910111213141516import reimport reprlibRE_WORD = re.compile(&apos;\\w+&apos;)class Sentence: def __init__(self, text): self.text = text self.words = RE_WORD.findall(text) def __repr__(self): return &apos;Sentence(%s)&apos; % reprlib.repr(self.text) def __iter__(self): for word in self.words: yield word return 生成器函数定义体中的 return 语句会触发生成器对象抛出 StopIteration 异常。 惰性实现：生成器函数2 re.finditer 函数是 re.findall 函数的惰性版本，返回的不是列表，而是一个生成器，按需生成 re.MatchObject 实例 1234567891011121314151617import reimport reprlibRE_WORD = re.compile(&apos;\\w+&apos;)class Sentence: def __init__(self, text): self.text = text # 取消了 self.words def __repr__(self): return &apos;Sentence(%s)&apos; % reprlib.repr(self.text) # 生成器函数2 def __iter__(self): for match in RE_WORD.finditer(self.text): yield match.group() 惰性实现：生成器表达式 生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少 Sentence 类的代码 生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利 123# 生成器表达式 def __iter__(self): return (match.group() for match in RE_WORD.finditer(self.text)) 如果函数或构造方法只有一个参数，传入生成器表达式时只写一对括号就行了。不用写一对调用函数的括号，再写一对括号围住生成器表达式。 1234def func(var): pass func(n for n in range(10)) # (n for n in range(10))是生成器表达式，传入单参数的函数时不用外层的括号 iter 函数鲜为人知的用法1iter(calllable, stop_flag) 第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值 第二个参数是个标记值（哨符），当可调用的对象返回这个值时，触发迭代器抛出 StopIteration 异常，而不产出哨符 内置函数iter的文档中有个实用的例子。这段代码逐行读取文件，直到遇到空行或者到达文件末尾为止 123with open('mydata.txt') as fp: for line in iter(fp.readline, ''): process_line(line) 可迭代对象与迭代器的区别可迭代的对象和迭代器之间的关系：Python 从可迭代的对象中获取迭代器，并且迭代器本身也是可迭代对象，但是可迭代的对象不是迭代器 标准的迭代器接口有两个方法： __next__：返回下一个可用的元素，如果没有元素了，抛出 StopIteration 异常。 __iter__：返回 self，以便在需要使用可迭代对象的地方可以用迭代器代替，例如在 for 循环中。 迭代器在 collections.abc.Iterator 抽象基类中制定。这个类定义了 __next__ 抽象方法，而且继承自 Iterable 类 for 循环的原理当进行 for 循环时: 会调用 iter(iterable)从__getitem__ 、__iter__中，获取迭代器iterator 然后使用 next(iterator)，执行迭代器iterator 的__next__()函数，获取元素 因此： 可迭代对象至少实现__getitem__ 、 __iter__中的1个。 迭代器必须实现__next__函数 代码演示 1234567s = [1,2,3]for n in s: print(n)#1#2#3 等价于 123456789s = [1,2,3]it = iter(s)while True: try: print(next(it)) except StopIteration: del it break 为了更好的理解迭代器的内部结构，我们先来定义一个生成斐波拉契数的迭代器： 123456789101112131415161718# fib 既是可迭代对象，又是迭代器class fib: def __init__(self): self.prev = 0 self.curr = 1 def __iter__(self): return self def __next__(self): value = self.curr self.curr += self.prev self.prev = value return valuefrom itertools import islicef = fib()print(list(islice(f, 0, 10))) 注意这个类既是可迭代的 （因为具有__iter__()方法），也是它自身的迭代器(因为具有__next__()方法)。 迭代器内部状态保存在当前实例对象的prev以及cur属性中，在下一次调用中将使用这两个属性。每次调用next()方法都会执行以下两步操作： 修改状态，以便下次调用next()方法 计算当前调用的结果 https://www.jianshu.com/p/4c8e4fb4ef37# 切片切片的真相iterable[index]会调用 __getitem__，index 会转为 slice 对象，TOOD getitem 详细 1234567891011class MySeq: def __getitem__(self, index): return index s = MySeq()s[1] # 1s[1:4] # slice(1, 4, None)s[1:4:2] # slice(1, 4, 2)s[1:4:2, 9] # (slice(1, 4, 2), 9)s[1:4:2, 7:9] # (slice(1, 4, 2), slice(7, 9, None)) 元组中甚至可以有多个切片对象 slice 是内置的类型（2.4.2 节首次出现）。 通过审查 slice，发现它有 start、stop 和 step 数据属性，以及 indices 方法。TODO indices 方法内容 indices用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片，该方法会“整顿”元组，把 start、stop 和 stride 都变成非负数，而且都落在指定长度序列的边界内 12345&gt;&gt;&gt; slice(None, 10, 2).indices(5)# ➊ (0, 5, 2) 'ABCDE'[:10:2] 等同于 'ABCDE'[0:5:2]&gt;&gt;&gt; slice(-3, None, None).indices(5) # ➋ (2, 5, 1) 'ABCDE'[-3:] 等同于 'ABCDE'[2:5:1] 能正确处理切片的 getitem 方法12345678910111213141516import numbersclass Vector(): typecode = 'd' def __init__(self, components): self._components = array(self.typecode, components) def __getitem__(self, index): cls = type(self) # 获取类的类型，用于类型转换 if isinstance(index, slice): return cls(self._components[index])#转为同类型对象 elif isinstance(index, numbers.Integral): return self._components[index] #返回单个元素 else: msg = '&#123;cls.__name__&#125; indices must be integers' raise TypeError(msg.format(cls=cls)) 生成器生成器其实就是一种特殊的迭代器。它是一种更为高级、更为优雅的迭代器。 在Python中有两种类型的生成器：生成器函数以及生成器表达式。 生成器表达式(括号) 简单的逻辑可以使用表达式 生成器表达式与列表解析式类似（一个是[],另一个是()）。 12345### 创建 listnumbers = [1, 2, 3, 4, 5, 6]l = [x * x for x in numbers] print(l)# [1, 4, 9, 16, 25, 36] 12345678### 创建生成器numbers = [1, 2, 3, 4, 5, 6]lazy_squares = (x * x for x in numbers) next(lazy_squares)# 1list(lazy_squares)# [4, 9, 16, 25, 36]# 注意我们第一次调用next()之后，lazy_squares对象的状态已经发生改变，所以后面后面地调用list()方法只会返回部分元素组成的列表。 注意我们第一次调用next()之后，lazy_squares对象的状态已经发生改变，所以后面地调用list()方法只会返回部分元素组成的列表。 生成器函数(yield) 复杂的逻辑使用函数 12345678def fib(): prev, curr = 0, 1 while True: yield curr prev, curr = curr, prev + curr f = fib() list(islice(f, 0, 10)) 当调用f = fib()时，生成器被实例化并返回，这时并不会执行任何代码，生成器处于空闲状态 https://www.jianshu.com/p/4c8e4fb4ef37# yield注意事项yield 关键字只能把最近的外层函数变成生成器函数 调用f()，会得到一个无限循环，而不是生成器。 123456789101112def f(): def do_yield(n): yield n x = 0 while True: x += 1 gen = do_yield(x) print(gen) # &lt;generator object f.&lt;locals&gt;.do_yield at 0x12c76fa98&gt; print(f()) 可以使用yield from把工作委托给第三方完成。 1234567def f(): def do_yield(n): yield n x = 0 while True: x += 1 yield from do_yield(x) yield from12345yield from iterable# 等价于for i in iterable:... yield i 会从迭代器中依次产生值出来，因此可以把这句话看做是一个生成器，yield from 不仅仅是语法糖而已，还会创建通道，把生成器当成协程使用时，这个通道特别重要，更多请参考协程部分TODO 协程 生成器函数库主要是在 itertools 和 functools 模块 TODO 参考：流畅的 python14.9节 总结：关于可迭代对象、迭代器、生成器等之间的关系以下几种对象之间的关系： 容器(container) 可迭代对象(Iterable) 迭代器(Iterator) 生成器(generator) 生成器表达式 {list, set, dict} 解析式 相关的内建模块itertools，该模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是迭代对象，只有用for循环迭代的时候才真正计算。 字典字典推导式{} 包起来的就是字典推导式，[]包起来的是列表推导式，()包起来的是生成器 123456789101112131415161718192021222324252627282930from pprint import pprintDIAL_CODES = [ (86, 'China'), (91, 'India'), (1, 'United States'), (62, 'Indonesia'), (55, 'Brazil'), (92, 'Pakistan'), (880, 'Bangladesh'), (234, 'Nigeria'), (7, 'Russia'), (81, 'Japan'),]country_code = &#123;country: code for code, country in DIAL_CODES&#125;pprint(country_code)\"\"\"&#123;'Bangladesh': 880, 'Brazil': 55, 'China': 86, 'India': 91, 'Indonesia': 62, 'Japan': 81, 'Nigeria': 234, 'Pakistan': 92, 'Russia': 7, 'United States': 1&#125;\"\"\" 让字典提供默认值get1d.get(k, [default]) 返回键 k 对应的值，如果字典里没有键 k，则返回 None 或者 default setdefault1d.setdefault(k, [default]) 若字典⾥有键 k，则返回对应的值v； 若⽆则让d[k]=default，然后返回default如果v是引用类型的话，可以进行如下操作： 1my_dict.setdefault(key, []).append(new_value) 跟这样写： 123if key not in my_dict: my_dict[key] = [] my_dict[key].append(new_value) 二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用 setdefault 只需要一次就可以完成整个操作。 使用带默认值的字典 defaultdict在单纯地查找取值（而不是通过查找来插入新值）的时候，该怎么处理找不到的键呢？这就需要 defaultdict 来帮忙 12d = defaultdict(default_factory)# default_factory 必须是一个函数，可以返回默认值 默认值由 list 提供空列表[] 123456s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]d = defaultdict(list)for k, v in s: d[k].append(v)sorted(d.items())# [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])] 默认值由 int 提供 0 123456s = 'mississippi'd = defaultdict(int)for k in s: d[k] += 1print(sorted(d.items()))# [('i', 4), ('m', 1), ('p', 2), ('s', 4)] 默认值由 lambda 函数提供 123456def constant_factory(value): return lambda: valued = defaultdict(constant_factory('&lt;missing&gt;'))d.update(name='John', action='ran')print('%(name)s %(action)s to %(object)s' % d)# 'John ran to &lt;missing&gt;' 总结 这种技术比起等价的操作dict.setdefault()来得更加简单快捷 defaultdict 里的 default_factory 只会在 __getitem__ (TODO 这个方法)里被调用，在其他的方法里完全不会发挥作用。比如，dd 是个 defaultdict，k 是个找不到的键，dd[k] 这个表达式会调用 default_factory 创造某个默认值，而 dd.get(k)则会返回 None。 特殊方法__miss__基类 dict 并没有定义这个方法，但是 dict 是知道有这么个东西存在的。也就是说，如果有一个类继承了 dict，然后这个继承类提供了 __missing__ 方法，那么在 __getitem__ 碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 KeyError 异常。 注意：__missing__ 方法只会被 __getitem__ 调用 例子：数字1与字符串数字&#39;1&#39;映射到同一个值v上 123456789101112131415class StrKeyDict0(dict): def __missing__(self, key): if isinstance(key, str): # 如果键本身就是字符串，那就抛出 KeyError 异常。 raise KeyError(key) return self[str(key)] # 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。 def get(self, key, default=None): try: return self[key] # get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会。 except KeyError: return default def __contains__(self, key): return key in self.keys() or str(key) in self.keys() 视图由dict.keys()、dict.values()、dict.items()返回得到的对象，都是视图对象，视图提供了字典条目的动态视图，意味着当字典被改动时，视图也跟着变化，反映出字典的变化 Keys views are set-like since their entries are unique and hashable. If all values are hashable, so that (key, value) pairs are unique and hashable, then the items view is also set-like. (Values views are not treated as set-like since the entries are generally not unique.) For set-like views, all of the operations defined for the abstract base class collections.abc.Set are available (for example, ==, &lt;, or ^). 12345678910111213141516171819202122232425262728dishes = &#123;'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500&#125;keys = dishes.keys()values = dishes.values()# 迭代n = 0for val in values: n += valprint(n)# 504# keys、values 以一样的顺序进行迭代输出(insertion order)list(keys)# ['eggs', 'sausage', 'bacon', 'spam']list(values)# [2, 1, 1, 500]# view 对象能够动态反映 dict 的改变del dishes['eggs']del dishes['sausage']list(keys)# ['bacon', 'spam']# 集合操作print(keys &amp; &#123;'eggs', 'bacon', 'salad'&#125;)# &#123;'bacon'&#125;print (keys ^ &#123;'sausage', 'juice'&#125;)# &#123;'juice', 'sausage', 'bacon', 'spam'&#125; 集合 集合中的元素必须是可散列的，set 类型本身是不可散列的，但是 frozenset 可以。 如果是空集，那么必须写成 set()的形式。如果写成{} 的形式，你创建的其实是个空字典。 文本和字节序列从 Python 3 的 str 对象中获取的元素是 Unicode 字符，这相当于从 Python 2 的 unicode 对象中获取的元素 常见字符集 latin1（即 iso8859_1）：一种重要的编码，是其他编码的基础，例如 cp1252 和 Unicode（注意，latin1 与 cp1252 的字节值是一样的，甚至连码位也相同）。 cp1252 ：Microsoft 制定的 latin1 超集，添加了有用的符号，例如弯引号和€（欧元）；有些 Windows 应用把它称为“ANSI”，但它并不是 ANSI 标准。 cp437：IBM PC 最初的字符集，包含框图符号。与后来出现的 latin1 不兼容。 gb2312 ：用于编码简体中文的陈旧标准；这是亚洲语言中使用较广泛的多字节编码之一。 utf-8：目前 Web 中最常见的 8 位编码； 与 ASCII 兼容（纯 ASCII 文本是有效的 UTF-8 文 本）。 utf-16le：UTF-16 的 16 位编码方案的一种形式；所有 UTF-16 支持通过转义序列（称为“代理 对”，surrogate pair）表示超过 U+FFFF 的码位。 编码的二进制显示二进制序列其实是整数序列，各个字节的值可能会使用下列三种不同的方式显示： 可打印的 ASCII 范围内的字节（从空格到 ~），使用 ASCII 字符本身 制表符、换行符、回车符和 \\对应的字节，使用转义序列 \\t、\\n、\\r和 \\\\。 其他字节的值，使用十六进制转义序列（例如，\\x00 是空字节） 编码与解码编码：把码位转换成字节序列的过程 把文本转换成字节序列 时，如果目标编码中没有定义某个字符，那就会抛出 UnicodeEncodeError 异常 编码时指定 error=&#39;ignore&#39; 处理方式悄无声息地跳过无法编码的字符；这样做通常很是不妥。 error=&#39;replace&#39;，把无法编码的字符替换成 ?；数据损坏了，但是用户知道出了问题。 error=&#39;xmlcharrefreplace&#39; 把无法编码的字符替换成 XML 实体。 1234city = 'São Paulo'city.encode('cp437', errors='ignore')city.encode('cp437', errors='replace')city.encode('cp437', errors='xmlcharrefreplace') 解码：把字节序列转换成码位的过程 不是每一个字节都包含有效的 ASCII 字符，也不是每一个字符序列都是有效的 UTF-8 或 UTF-16。因此，把二进制序列转换成文本时，遇到无法转换的字节序列时会抛出 UnicodeDecodeError。 12345678910111213141516octets = b'Montr\\xe9al'octets.decode('cp1252') # 'Montréal'octets.decode('iso8859_7') # 'Montrιal'octets.decode('koi8_r')# 'MontrИal'octets.decode('utf_8') Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 5: invalid continuation byteoctets.decode('utf_8', errors='replace')# 'Montr�al' 使用 ‘replace’ 错误处理方式，\\xe9 替换成了“� ”（码位是 U+FFFD），这是官方指定的 REPLACEMENT CHARACTER（替换字符），表示未知字符。 SyntaxErrorPython 3 默认使用 UTF-8 编码源码，Python 2（从 2.5 开始）则默认使用 ASCII。 如果加载的 .py 模块中包含 UTF-8 之外的数据，而且没有声明编码，会得到类似下面的消息 1SyntaxError: Non-UTF-8 code starting with '\\xe1' in file ola.py on line 为了修正这个问题，可以在文件顶部添加一个神奇的 coding 注释 12345# -*- coding: UTF-8 -*-print('可以打印中文了。')# coding: cp1252print('Olá, Mundo!') 如何知道字节序列的编码一般情况是不能。必须有人告诉你。有些通信协议和文件格式，如 HTTP 和 XML，包含明确指明内容编码的首部。 但是如果假定字节流是人类可读的纯文本，就可以通过试探和分析找出编码。 例如，如果 b’\\x00’ 字节经常出现，那么可能是 16 位或 32 位编码，而不是 8 位编码方案，因为纯文本中不能包含空字符；如果字节序列 b’\\x20\\x00’ 经常出现，那么可能是 UTF-16LE 编码中的空格字符（U+0020），而不是 鲜为人知的 U+2000 EN QUAD 字符——谁知道这是什么呢！ 统一字符编码侦测包 Chardet就是这样工作的，它能识别所支持的 30 种编码。Chardet是一个 Python 库，可以在程序中使用，也提供了命令行工具 chardetect。 BOM(byte-order mark)字节序只影响一个字（word）占多个字节的编码（如 UTF-16 和 UTF-32），以及像 long这种多字节的数据类型，也受字节序影响。 在UCS 编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE“的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输 字符”ZERO WIDTH NO-BREAK SPACE“。如果接收者收到FEFF，就表明这个字节流是大字节序的；如果收到FFFE，就表明这个字节流是小字节序的。因此字符”ZERO WIDTH NO-BREAK SPACE“又被称作BOM。 123u16 = 'El Niño'.encode('utf_16')print(u16)b'\\xff\\xfeE\\x00l\\x00 \\x00N\\x00i\\x00\\xf1\\x00o\\x00' 在小字节序系统中，这个字符编码为b&#39;\\xff\\xfe&#39;（十进制数 255, 254）。 在大字节序系统中，这个字符编码为b&#39;\\xfe\\xff&#39;（十进制数 254, 255）。 所以编解码器知道该用哪个字节序。 UTF-16 有两个变种： UTF-16LE，显式指明使用小字节序； UTF-16BE，显式指明使用大 字节序。 如果使用这两个变种，不会生成 BOM： 123456u16le = 'El Niño'.encode('utf_16le')list(u16le) # [69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111, 0]u16be = 'El Niño'.encode('utf_16be')list(u16be) # [0, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111] Intel x86 架构用的是小字节序，因此有很多文件用的是不带 BOM 的小字节序 UTF-16 编码。 UTF-8 的一大优势是，不管设备使用哪种字节序，生成的字节序列始终一致，因此不需要 BOM UTF-8以字节为编码单元，根据当前字节中开头几个1，就可以知道后面还有几个字节是共同组成一个字的。 比如下面的第2行，读取第1个字节后发现有2个1开头，就可以知道后面还有1个字节，共同组成一个字 0xxxxxxx //文字符号0~127（ASCII）110xxxxx 10xxxxxx //128～20471110xxxx 10xxxxxx 10xxxxxx //2048～6553511110xxx 10xxxxxx 10xxxxxx 10xxxxxx //65535～0x10ffff 尽管如此，某些 Windows 应用（尤其是 Notepad）依然会在 UTF-8 编码的 文件中添加 BOM； UTF-8 编码的 U+FEFF 字符是一个三字节序列：b&#39;\\xef\\xbb\\xbf&#39;。因此，如果文件以这三个字节开头，有可能是带有 BOM 的 UTF-8 文件。 默认编码(最好不要使用)1234567891011121314151617181920import sys, localeexpressions = \"\"\" locale.getpreferredencoding() type(my_file) my_file.encoding sys.stdout.isatty() sys.stdout.encoding sys.stdin.isatty() sys.stdin.encoding sys.stderr.isatty() sys.stderr.encoding sys.getdefaultencoding() sys.getfilesystemencoding() \"\"\"my_file = open('dummy', 'w')for expression in expressions.split(): value = eval(expression) print(expression.rjust(30), '-&gt;', repr(value)) locale.getpreferredencoding() 返回的编码是最重要的：这是打开文件的默认编码，也是重定向到文件的 sys.stdout/stdin/stderr 的默认编码。 因此，关于编码默认值的最佳建议是：别依赖默认值。 规范化 Unicode 字符串Unicode 有组合字符（变音符号和附加到前一个字符上的记号，打印时作为一个整体），所以字符串比较起来很复杂。 “café”这个词可以使用两种方式构成，分别有 4 个和 5 个码位，但是结果完全一样 12345678s1 = 'café's2 = 'cafe\\u0301'print(s1, s2)# ('café', 'café')print(len(s1), len(s2))# (4, 5)s1 == s2 # False 在 Unicode 标准中，é和 e\\u0301 这样的序列叫“标准等价物”（canonical equivalent），应用程序应该把它们视作相同的字符。但是，Python 看到的是不同的码位序列，因此判定二者不相等。 解决方案是使用 unicodedata.normalize 函数提供的 Unicode 规范化。这个 函数的第一个参数可以是：’NFC’、’NFD’、’NFKC’ 和 ‘NFKD’。 NFC与NFD NFC（Normalization Form C）使用最少的码位构成等价的字符串， NFD 把组合字符分解成基字符和单独的组合字符。 123456789101112131415from unicodedata import normalizes1 = 'café' # 把\"e\"和重音符组合在一起s2 = 'cafe\\u0301' # 分解成\"e\"和重音符len(s1), len(s2) # (4, 5)len(normalize('NFC', s1)), len(normalize('NFC', s2)) # (4, 4)len(normalize('NFD', s1)), len(normalize('NFD', s2)) # (5, 5)normalize('NFC', s1) == normalize('NFC', s2) # Truenormalize('NFD', s1) == normalize('NFD', s2) # True NFKC 与 NFKD 字母 K 表 示“compatibility”（兼容性） 虽然 Unicode 的目标是为各个字符提供“规范的”码位，但是为了兼容现有的标准，有些字符会出现多次。 虽然希腊字母表中有“μ”这个字母（码位是 U+03BC，GREEK SMALL LETTER MU），但是 Unicode 还是加入了微符号 ‘µ’（U+00B5），以便与 latin1 相互转 换。因此，微符号是一个“兼容字符”。 兼容字符：个人理解就是比较复杂的字符，出现在其他字符集中的字符，为了兼容其他字符集而出现在 unicode 中，因此称作兼容字符，这些字符可以被替换成一个或者多个字符。 在 NFKC 和 NFKD 形式中，各个兼容字符会被替换成一个或多个“兼容分解”字符，即便这样有些格式损失，但仍是“首选”表述。如下： 二分之一 ‘½’（U+00BD）经过兼容分解后得到的是 三个字符序列 ‘1/2’； 微符号 ‘µ’（U+00B5）经过兼容分解后得到的是小写字母 ‘μ’（U+03BC）。 大小写折叠(TODO)流畅的 python 一书中 123456789101112131415161718192021222324252627282930# Utility functions for normalized Unicode string comparison.from unicodedata import normalizedef nfc_equal(str1, str2): return normalize('NFC', str1) == normalize('NFC', str2)def fold_equal(str1, str2): return (normalize('NFC', str1).casefold() == normalize('NFC', str2).casefold())# Using Normal Form C, case sensitive:s1 = 'café's2 = 'cafe\\u0301'print(s1 == s2) # Falseprint(nfc_equal(s1, s2)) # Trueprint(nfc_equal('A', 'a')) # False# Using Normal Form C with case folding:s3 = 'Straße's4 = 'strasse'print(s3 == s4) # Falseprint(nfc_equal(s3, s4)) # Falseprint(fold_equal(s3, s4)) # Trueprint(fold_equal(s1, s2)) # Trueprint(fold_equal('A', 'a')) # True 去掉变音符号维基百科中介绍圣保罗市São Paulo——&gt; Sao_Paulo ，这就是去除变音符号。 版本1（过滤掉所有组合记号）： 123456789101112import unicodedata import stringdef shave_marks(txt):\"\"\"去掉全部变音符号\"\"\" # 把所有字符分解成基字符和组合记号。 norm_txt = unicodedata.normalize('NFD', txt) # 过滤掉所有组合记号 shaved = ''.join(c for c in norm_txt if not unicodedata.combining(c)) # 重组所有字符 return unicodedata.normalize('NFC', shaved) 版本2（只去除拉丁文字的变音符号）： 1234567891011121314151617def shave_marks_latin(txt): \"\"\"把拉丁基字符中所有的变音符号删除\"\"\" norm_txt = unicodedata.normalize('NFD', txt) is_latin_base = False keepers = [] for c in norm_txt: # 忽略拉丁基字符上的变音符号 if unicodedata.combining(c) and is_latin_base: continue keepers.append(c) # 如果不是组合字符，那就是新的基字符，判断是否为拉丁字符 if not unicodedata.combining(c): is_latin_base = c in string.ascii_letters shaved = ''.join(keepers) return unicodedata.normalize('NFC', shaved) 总结对大多数应 用来说，NFC 是最好的规范化形式。不区分大小写的比较应该使用 str.casefold() 文本排序(比较复杂，而且不一定成功，只适合 Unix) 在Python中，非ASCII文本的标准排序方式是使用locale.strxfrm函数，根据locale模块的文档，这个函数会“把字符串转换成适合所在区域进行比较的形式”。 使用 locale.strxfrm 函数之前，必须先为应用设定合适的区域设置： 123456import localelocale.setlocale(locale.LC_COLLATE, 'pt_BR.UTF-8')fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola']sorted(fruits, key=locale.strxfrm)# ['açaí', 'acerola', 'atemoia', 'cajá', 'caju'] PyUCA 库(推荐)1234567import pyucacoll = pyuca.Collator()fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola']sorted_fruits = sorted(fruits, key=coll.sort_key)print(sorted_fruits)# ['açaí', 'acerola', 'atemoia', 'cajá', 'caju'] PyUCA 没有考虑区域设置。如果想定制排序方式，可以把自定义的排序表路径传给 Collator() 构造方法。PyUCA 默认使用项目自带的 allkeys.txt（https://github.com/jtauber/pyuca），这就是 Unicode 6.3.0 的“Default Unicode Collation Element Table”的副本。 Unicode数据库Unicode标准提供了一个完整的数据库（许多格式化的文本文件），不仅包括码位与字符名称之间的映射，还有各个字符的元数据，以及字符之间的关系。例如，Unicode数据库记录了字符是否可以打印、是不是字母、是不是数字，或者是不是其他数值符号。字符串的isidentifier、isprintable、isdecimal和isnumeric等方法就是靠这些信息作判断的。 123456789101112131415import unicodedataimport rere_digit = re.compile(r'\\d')sample = '1\\xbc\\xb2\\u0969\\u136b\\u216b\\u2466\\u2480\\u3285'for char in sample: print('U+%04x' % ord(char),char.center(6), 're_dig' if re_digit.match(char) else '-', 'isdig' if char.isdigit() else '-', 'isnum' if char.isnumeric() else '-', format(unicodedata.numeric(char), '5.2f'), unicodedata.name(char), sep='\\t') unicodedata模块更多函数的说明（https://docs.python.org/3/library/unicodedata.html 支持字符串和字节序列的双模式API正则表达式中的双模式如果使用字节序列构建正则表达式，\\d和\\w等模式只能匹配ASCII字符； 如果是字符串模式，就能匹配ASCII之外的Unicode数字或字母。 1234567891011121314151617181920212223242526import rere_numbers_str = re.compile(r'\\d+')re_words_str = re.compile(r'\\w+')re_numbers_bytes = re.compile(rb'\\d+')re_words_bytes = re.compile(rb'\\w+')text_str = (\"Ramanujan saw \\u0be7\\u0bed\\u0be8\\u0bef\" \" as 1729 = 1³ + 12³ = 9³ + 10³.\")text_bytes = text_str.encode('utf_8')print('Text', repr(text_str), sep='\\n ')print('Numbers')print(' str :', re_numbers_str.findall(text_str))print(' bytes:', re_numbers_bytes.findall(text_bytes))print('Words')print(' str :', re_words_str.findall(text_str))print(' bytes:', re_words_bytes.findall(text_bytes))# Text# 'Ramanujan saw ௧௭௨௯ as 1729 = 1³ + 12³ = 9³ + 10³.'# Numbers# str : ['௧௭௨௯', '1729', '1', '12', '9', '10']# bytes: [b'1729', b'1', b'12', b'9', b'10']# Words# str : ['Ramanujan', 'saw', '௧௭௨௯', 'as', '1729', '1³', '12³', '9³', '10³']# bytes: [b'Ramanujan', b'saw', b'as', b'1729', b'1', b'12', b'9', b'10'] os 中的双模式(TODO)不是很明白 GNU/Linux内核不理解Unicode，因此你可能发现了，对任何合理的编码方案来说，在文件名中使用字节序列都是无效的，无法解码成字符串。 os模块中的所有函数、文件名或路径名参数既能使用字符串，也能使用字节序列。如果这样的函数使用字符串参数调用，该参数会使用sys.getfilesystemencoding()得到的编解码器自动编码，然后操作系统会使用相同的编解码器解码。这几乎就是我们想要的行为，与Unicode三明治最佳实践一致。 函数编程语言理论家把“一等对象”定义为满足下述条件的程序实体： 在运行时创建 能赋值给变量或数据结构中的元素 能作为参数传给函数 能作为函数的返回结果 在 Python 中，整数、字符串和字典都是一等对象——没什么特别的。有了一等函数，就可以使用函数式风格编程。函数式编程的特点之一是使用高阶函数。Python 不支持重载方法或函数。 术语非绑定方法（unbound method）：直接通过类访问的实例方法没有绑定到特定的实例上，因此把这种方法称为“非绑定 方法”。若想成功调用非绑定方法，必须显式传入类的实例作为第一个参数。那个实例会 赋值给方法的 self 参数。 形参与实参形参（parameter）：声明函数时指定的零个或多个“形式参数”，这些是未绑定的局部变量。调用函数时， 传入的实参（“实际参数”）会绑定给这些变量。有5种： 位置或关键字参数(positional-or-keyword)：def func(foo, bar=None): ... 任意数量的位置参数(var-positional)：在名字前面加*的参数，如下面的args，除了已被其他参数(arg1,arg2)接受的任何位置参数，剩下的位置参数都提供给 args，如：def func(arg1, arg2, *args, **kwargs): ... 任意数量的关键字参数(var-keyword)：在名字前面加**的参数，如上例的kwargs，除了被其他形参接收的实参，剩下的关键字参数都提供给 kwargs 仅位置参数(positional-only)：只能通过位置提供，不能以关键词提供的参数，新版的python可以通过/来划分了。def func(posonly1, posonly2, /, positional_or_keyword): ... 仅关键字参数(keyword-only)：只能以关键字形式提供的参数，在*arg这种任意数量的位置参数或 单单一个* 后面的形参，就是仅关键字参数，如下面的kw_only1,kw_only2：def func(arg, *, kw_only1, kw_only2): ... 注意：上例只接收3个参数，这个*不接收任何参数，这只是定义仅关键字参数的语法，调用形式：func(1, kw_only1=2, kw_only2=3) 综合例子： 12345678910111213141516171819202122def tag(name, *content, cls=None, **attrs): \"\"\"生成一个或多个HTML标签\"\"\" if cls is not None: attrs['class'] = cls if attrs: attr_str = ''.join(' %s=\"%s\"' % (attr, value) for attr, value in sorted(attrs.items())) else: attr_str = '' if content: return '\\n'.join('&lt;%s%s&gt;%s&lt;/%s&gt;' % (name, attr_str, c, name) for c in content) else: return '&lt;%s%s /&gt;' % (name, attr_str) print(tag('p', 'hello', 'world', id=33))print(tag(name=\"img\", content='testing',))my_tag = &#123;'name': 'img', 'title': 'Sunset Boulevard', 'src': 'sunset.jpg', 'cls': 'framed'&#125;print(tag(**my_tag))# &lt;p id=\"33\"&gt;hello&lt;/p&gt; &lt;p id=\"33\"&gt;world&lt;/p&gt;# &lt;img content=\"testing\" /&gt;# &lt;img class=\"framed\" src=\"sunset.jpg\" title=\"Sunset Boulevard\" /&gt; 在示例中，举例了各种形参，同时也给出了他们定义时的位置要求，顺序如下： name是位置或关键字参数。 content是任意数量的位置参数，name参数后面的任意个参数会被 *content 捕获，存入一个元组。 cls是仅关键字参数。 attrs是任意数量的关键字参数，没有明确指定名称的关键字参数会被 **attrs 捕获，存入一个字典。 定义函数时若想指定仅限关键字参数，要把它们放到前面有 * 的参数后面。如果不想支持任意数量的位置参数，但是想支持仅限关键字参数，在签名中放一个*，如下所示：12345def f(a, *, b): return a, bf(1, b=2) #(1, 2) 注意，仅限关键字参数不一定要有默认值，可以像下例中 b 那样，强制必须传入实参。 参考：parameter 实参（argument）：调用函数(或方法)时传给函数(或方法)的值，有2种： 位置参数：出现在参数列表的前面位置 或者 通过*解压的可迭代对。 12complex(3, 5)complex(*(3, 5)) 关键字参数：name=val或者通过**解压的字典 12complex(real=3, imag=5)complex(**&#123;'real': 3, 'imag': 5&#125;) 参考：argument 高阶函数接受函数为参数，或者把函数作为结果返回的函数是高阶函数 列表推导或生成器表达式具有map和filter两个函数的功能，而且更易于阅读 123456789list(map(fact, range(6))) # [1, 1, 2, 6, 24, 120][fact(n) for n in range(6)] # 列表推导式代替 map# [1, 1, 2, 6, 24, 120]list(map(factorial, filter(lambda n: n % 2, range(6))))# [1, 6, 120][factorial(n) for n in range(6) if n % 2] # if 代替 filter，列表推导式代替 map# [1, 6, 120] reduce在 Python 2 中是内置函数，在Python3中放到functools模块里了。这个函数最常用于求和，自2003年发布的Python2.3开始，最好使用内置的sum函数。 1234567from functools import reducefrom operator import add reduce(add, range(100)) # 4950sum(range(100))# 4950 匿名函数为了使用高阶函数，有时创建一次性的小型函数更便利。这便是匿名函数存在的原因。Python 简单的句法限制了 lambda 函数的主体只能是一个表达式，而不是一个代码块，不能赋值，也不能使用 while 和 try 等。 输入是传入到参数列表argument_list的值，输出是根据表达式expression计算得到的值。 lambda x, y: x*y；函数输入是x和y，输出是它们的积x*y lambda:None；函数没有输入参数，输出是None 函数专有属性重点说明函数专有而用户定义的一般对象没有的属性 12345class C: passobj = C() def func(): pass sorted(set(dir(func)) - set(dir(obj))) # ['__annotations__', '__call__', '__closure__', '__code__', '__defaults__', '__get__', '__globals__', '__kwdefaults__', '__name__', '__qualname__'] 获取函数参数的信息(不太明白TODO)使用 inspect 模块 函数注解123def clip(text:str, max_len:'int &gt; 0'=80) -&gt; str: \"\"\"在max_len前面或后面的第一个空格处截断文本 \"\"\" pass 各个参数可以在: 之后增加注解表达式。如果参数有默认值，注解放在参数名和 = 号之间。 如果想注解返回值，在 )和函数声明末尾的:之间添加-&gt; 和一个表达 式。 注解表达式可以是任何类型，注解中最常用的类型是类（如 str 或 int）和字符串 （如 ‘int &gt; 0’） Python 对注解所做的唯一的事情是，只是存储在函数的 __annotations__ 属性（字典）中。换句话说，注解对 Python 解释器没有任何意义。注解只是元数据，可以供 IDE、框架和装饰器等工具使用。 支持函数式编程的包operator模块 以 _ 开头的名称，因为它们基本上是实现细节 以 i开头、后面是另一个运算符的那些名称（如 iadd、iand 等），对应的是增量赋值运算符（如 +=、&amp;= 等） 一、operator 模块为多个算术运算符提供了对应的函数 12345from functools import reduce from operator import mul # mul对应乘法函数def fact(n): return reduce(mul, range(1, n+1)) 二、operator 模块中还有一类函数，能替代从序列中取出元素或读取对象属性的 lambda 表达式 itemgetter 的常见用途：根据元组的某个字段给元组列表排序，如果把多个参数传给 itemgetter，它构建的函数会返回提取的值构成的元组 12345678910111213141516metro_data = [ ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833))]from operator import itemgetterfor city in sorted(metro_data, key=itemgetter(1)): print(city)cc_name = itemgetter(1, 0)# 如果把多个参数传给 itemgetter，会返回提取的值构成的元组for city in metro_data: print(cc_name(city)) attrgetter与itemgetter作用类似，它创建的函数根据名称提取对象的属性。如果把多个属性名传给attrgetter，它也会返回提取的值构成的元组。 此外，如果参数名中包含 .（点号），attrgetter 会深入嵌套对象，获取指定的属性。 123456789101112131415161718192021222324252627metro_data = [ ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833))]from collections import namedtupleLatLong = namedtuple('LatLong', 'lat long')Metropolis = namedtuple('Metropolis', 'name cc pop coord')metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long)) for name, cc, pop, (lat, long) in metro_data ]# .的例子from operator import attrgettername_lat = attrgetter('name', 'coord.lat')for city in sorted(metro_areas, key=attrgetter('coord.lat')): print(name_lat(city))# ('Sao Paulo', -23.547778)# ('Mexico City', 19.433333)# ('Delhi NCR', 28.613889)# ('Tokyo', 35.689722)# ('New York-Newark', 40.808611) functoolsfunctools.partial 这个高阶函数用于部分应用一个函数。 部分应用：基于一个函数创建一个新的可调用对象，把原函数的某些参数固定。 partial 的第一个参数是一个可调用对象(callable)，后面跟着任意个要绑定的定位参数和关键字参数 123456789101112131415161718192021import unicodedata, functoolsnfc = functools.partial(unicodedata.normalize, 'NFC')s1 = 'café's2 = 'cafe\\u0301'print( s1, s2)#('café', 'café')print(s1 == s2,nfc(s1) == nfc(s2) )# False True# partial 函数的一些属性print(nfc)# functools.partial(&lt;built-in function normalize&gt;, 'NFC')print(nfc.func)# &lt;built-in function normalize&gt;print(nfc.args)# ('NFC',)print(nfc.keywords)# &#123;&#125; 变量作用域对于理解装饰器、闭包非常重要。 闭包(自由变量)闭包 是指 延伸了作用域的函数，其中包含函数定义体中引用、但是不在函数定义体中定义 的非全局变量__closure__。函数是不是匿名的没有关系，关键是它能访问函数定义体之外定义的非全局变量。 类对象编程 123456789# 可调用对象方式class Averager(): def __init__(self): self.series = [] def __call__(self, new_value): self.series.append(new_value) total = sum(self.series) return total/len(self.series) 函数式编程 123456789# 函数式编程def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averager 这两个示例有共通之处：调用 Averager() 或 make_averager() 得到一个可调用 对象 avg，它会更新历史值，然后计算当前均值。 在 averager 函数中，series 是自由变量（free variable），指未在本地作用域中绑定的变量(包括外层函数的参数，比如 make_averager(arg),arg也算是) 123456789101112avg = make_averageravg.__code__.co_varnames # 局部变量# ('new_value', 'total')avg.__code__.co_freevars # 自由变量# ('series',)avg.__closure__ # (&lt;cell at 0x107a44f78: list object at 0x107a91a48&gt;,)avg.__closure__[0].cell_contents # [10, 11, 12] 审查返回的 averager 对象，我们发现 Python 在__code__属性（表示编译后的函数定义 体）中保存局部变量和自由变量的名称。 __closure__是每个被返回的函数的属性，如：avg，并非是make_averager的属性 avg.__closure__中的各个元素对应于avg.__code__.co_freevars中的一个名称。这些元素是 cell 对象，有个 cell_contents 属性，保存着真正的值。 123# 遍历 闭包中的 自由变量for cl in avg.__closure__: print(cl.cell_contents) 综上：闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时， 虽然定义作用域不可用了，但是仍能使用那些绑定。 注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。 如果对自由变量赋值呢？特别是不可变类型，会发生什么问题？，请看 nolocal 的作用 nolocal声明123456789101112131415def make_averager(): count = 0 total = 0 def averager(new_value): count += 1 total += new_value return total / count return averageravg = make_averager()avg(10)# Traceback (most recent call last):# UnboundLocalError: local variable 'count' referenced before assignment count += 1 语句的作用其实与count = count + 1一样。因此，我们在 averager 的定义体中为 count 赋值了，这会把自由变量 count 变成局部变量。 闭包一节中没有这个问题，是利用了列表是可变的对象这一事实。但是对数字、字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑 定，例如 count = count + 1，其实会隐式创建局部变量 count。 为了解决这个问题，Python 3 引入了 nonlocal 声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。 Python 2 没有 nonlocal，因此需要变通方法，基本上，这种处理方式是把内部函数需要修改 的变量（如 count 和 total）存储为可变对象（如字典或简单的实例）的元素或属性，并且把那个对象绑定给一个自由变量。 装饰器什么是装饰器装饰器是一个返回值为函数inner的函数，其第一个参数是另一个函数func，二者接受相同的参数，装饰器的典型行为：把被装饰的函数func替换成新函数inner，使得在执行func前后执行一些额外的操作，类似于装饰func，因此称为装饰器。 函数装饰器 用于在源码中“标记”函数，以某种方式增强函数的行为。 1234567# 定义装饰器函数，增强 func 的功能(日志功能)def decorate(func): def inner(*args): print(\"begin %s\" % func.__name__) func(*args) print(\"end %s\" % func.__name__) return inner 然后强化 target 函数 1234def target(): print('running target()')target = decorate(target) @语法糖，等价于 1234@decoratedef target(): print('running target')target() @装饰器函数对象(函数名) 、@装饰器工厂函数(参数)。@后面必须跟着装饰器函数对象，调用装饰器工厂函数也一样可以得到装饰器对象。 装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。 第二个特性是，装饰器 在加载模块时立即执行。而被装饰的函数只在明确调用时运行。 自定义装饰器的最佳实践使用functools.wrap实现装饰器的完整定义。 123456789101112131415161718# deco 是装饰器，第一个参数是“可调用对象”def deco(func): def inner(num): '''内部函数，打印 num''' print('running inner(%s)' %num) return inner# target 被作为参数传入到 deco 中，并且 target 变成了 inner@decodef target(n): print('running target()')target(10)# running inner() 其实变成了 inner 函数print(target) # &lt;function deco.&lt;locals&gt;.inner at 0x10063b598&gt; 其实变成了 inner 函数print(target.__doc__) # 内部函数，打印 numprint(target.__name__) # inner 实现的 target 装饰器有几个缺点：不支持关键字参数，而且遮盖了被装饰函数的__name__和__doc__属性。 使用 functools.wraps装饰器可以把相关的属性从 func 复制到inner 中。此外，这个新版还能正确处理关键字参数。 12345678import functools# functools的使用def deco(func): @functools.wraps(func) def inner(num): '''内部函数，打印 num''' print('running inner(%s)' %num) return inner 装饰器在真实代码中的常用方式： 装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。 大多数装饰器会在内部定义一个新的函数，然后将其返回。 叠加装饰器把 @d1 和@d2 两个装饰器按顺序应用到 f 函数上，作用相当于f = d1(d2(f))。 也就是说，下述代码： 1234@d1 @d2 def f(): print('f') 等同于 1234def f(): print('f')f = d1(d2(f)) 带参数的装饰器Python 把被装饰的函数作为第一个参数传给装饰器函数。那怎么让装饰器接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。TODO 网上其他例子？ 123456789101112131415161718192021222324registry = set()def register(active=True):# 装饰器工厂，利用参数定制【装饰器】 def decorate(func): # 真正的装饰器 print('running register(active=%s)-&gt;decorate(%s)' % (active, func)) if active: registry.add(func) else: registry.discard(func) return func return decorate # 装饰器工厂 返回定制后的[装饰器]@register(active=False)def f1(): print('running f1()')# 即使不传入参数，register 也必须作为函数调用，返回真正的 装饰器 decorate。@register() def f2(): print('running f2()')def f3(): print('running f3()') 这里的关键是，register() 要返回 decorate，然后把它应用到被装饰的函数上。 因此如果不使用 @ 句法，那就要像常规函数那样使用 register；装饰 f 函数的句法是 register()(f)；不想添加（或把它删除）的话，句法是 register(active=False)(f) register()(f)=decorate(f)，因为decorate是register()运行结果 标准库中的装饰器Python 内置了三个用于装饰方法的函数：property、classmethod 和 staticmethod； 常见的装饰器是 functools.wraps，它的作用是协助构建行为良好的装饰器； 标准库中最值得关注的两个装饰器是 lru_cache 和全新的 singledispatch（Python 3.4 新增）； functools.lru_cache 实现缓存1functools.lru_cache(maxsize=128, typed=False) maxsize 参数指定存储多少个调用的结果。 typed 参数如果设为 True，把不同参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数参数（如 1 和 1.0）区分开。 lru_cache 使用字典存储结果，而且键根据调用时传入的定位 参数和关键字参数创建，所以被 lru_cache 装饰的函数，它的所有参数都必须是可散列 的。 它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU 三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。 123456789101112131415161718192021222324252627282930import functoolsimport timedef clock(func): @functools.wraps(func) def clocked(*args, **kwargs): t0 = time.time() result = func(*args, **kwargs) elapsed = time.time() - t0 name = func.__name__ arg_lst = [] if args: arg_lst.append(', '.join(repr(arg) for arg in args)) if kwargs: pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())] arg_lst.append(', '.join(pairs)) arg_str = ', '.join(arg_lst) print('[%0.8fs] %s(%s) -&gt; %r ' % (elapsed, name, arg_str, result)) return result return clocked@functools.lru_cache()@clockdef fibonacci(n): if n&lt;2: return n return fibonacci(n-1)+fibonacci(n-2)if __name__=='__main__': print(fibonacci(6)) functools.singledispatch 实现函数/方法重载 是 Python 3.4 增加的，PyPI 中的 singledispatch 包（https://pypi.python.org/pypi/singledispatch）可以向后兼容 Python 2.6 到 Python 3.3。 123456import numbersimport htmldef htmlize(obj): content = html.escape(repr(obj)) return '&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'.format(content) 这个函数适用于任何 Python 类型，但是现在我们想做个扩展，让它针对不同的参数类型使用不同的方式来显示。 str：把内部的换行符替换为 &lt;br&gt;\\n；不使用 &lt;pre&gt;，而是使用 &lt;p&gt;。 int：以十进制和十六进制显示数字。 list：输出一个 HTML 列表，根据各个元素的类型进行格式化。 由于Python 不支持重载方法或函数，所以我们不能使用不同的签名定义 htmlize 的变体，也无法使用不同的方式处理不同的数据类型。 singledispatch 装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用 @singledispatch 装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。 这是单分派。如果根据多个参数选择专门的函数，那就是多分派了。 123456789101112131415161718192021222324252627282930313233343536373839from functools import singledispatchfrom collections import abcimport numbersimport html@singledispatchdef htmlize(obj): content = html.escape(repr(obj)) return '&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'.format(content)@htmlize.register(str)def _(text): content = html.escape(text).replace('\\n', '&lt;br&gt;\\n') return '&lt;p&gt;&#123;0&#125;&lt;/p&gt;'.format(content)@htmlize.register(numbers.Integral)def _(n): return '&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'.format(n)# 可以叠放多个 register 装饰器，让同一个函数支持不同类型@htmlize.register(tuple)@htmlize.register(abc.MutableSequence)def _(seq): inner = '&lt;/li&gt;\\n&lt;li&gt;'.join(htmlize(item) for item in seq) return '&lt;ul&gt;\\n&lt;li&gt;' + inner + '&lt;/li&gt;\\n&lt;/ul&gt;' print(htmlize(12))print(htmlize(\"hello\"))print(htmlize([1,2,3,4,5]))#&lt;pre&gt;12 (0xc)&lt;/pre&gt;#&lt;p&gt;hello&lt;/p&gt;#&lt;ul&gt;#&lt;li&gt;&lt;pre&gt;1 (0x1)&lt;/pre&gt;&lt;/li&gt;#&lt;li&gt;&lt;pre&gt;2 (0x2)&lt;/pre&gt;&lt;/li&gt;#&lt;li&gt;&lt;pre&gt;3 (0x3)&lt;/pre&gt;&lt;/li&gt;#&lt;li&gt;&lt;pre&gt;4 (0x4)&lt;/pre&gt;&lt;/li&gt;#&lt;li&gt;&lt;pre&gt;5 (0x5)&lt;/pre&gt;&lt;/li&gt;#&lt;/ul&gt; 注册的函数应该尽量处理抽象基类（如 numbers.Integral 和 abc.MutableSequence），而不要处理具体实现（如 int 和 list），这样代码支持的兼容类型更广泛。 面向对象基础引用首先，我们要抛弃变量是存储数据的盒子这一错误观念，应该理解为附加在对象上的标注 为了理解 Python 中的赋值语句，应该始终先读右边。对象在右边创建或获取， 在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。 1234a = [1, 2, 3]b = aa.append(4)b [1, 2, 3, 4] is和== is 运算符比较两个对象的标识；id() 函数返回对象标识的 整数表示。 == 运算符比较两个对象的值（对象中保存的数据） 通常，我们关注的是值，而不是标识，因此 Python 代码中 ==出现的频率比is 高。 在变量和单例值之间比较时，应该使用 is。最常使用 is 检查变量绑定的值是不是 None。推荐的写法：x is None is 运算符比== 速度快，因为它不能重载，所以 Python 不用寻找并调用特殊方法，而是 直接比较两个整数 ID 浅复制与深复制 《Python特性》-4.4克隆对象 浅复制构造方法list()或[:] 做的是浅复制：即复制了最外层容器，副本中的元素是源容器中元素的引用。 如果所有元素都是不可变的，那么这样没有问题，还能节省内存。 l2 = list(l1) 赋值后的程序状态。 l1 和l2 指代不同的列表， 但是二者引用同一个列表 [66, 55, 44] 和元组 (7, 8, 9)（图表由Python Tutor网站生成） 深复制copy 模块提供的 deepcopy 和 copy 函数能为任意对象做深复制和浅复制。 1234567891011121314151617181920212223242526272829303132class Bus: def __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = list(passengers) def pick(self, name): self.passengers.append(name) def drop(self, name): self.passengers.remove(name) import copybus1 = Bus(['Alice', 'Bill', 'Claire', 'David'])bus2 = copy.copy(bus1)bus3 = copy.deepcopy(bus1)id(bus1), id(bus2), id(bus3)# (4301498296, 4301499416, 4301499752) ➊ bus id均不同id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)# (4302658568, 4302658568, 4302657800) ➌ 只有第3个深拷贝的乘客id不同bus1.drop('Bill')bus2.passengers# ['Alice', 'Claire', 'David'] ➋ bus1 中的 'Bill' 下车后，bus2 中也没有他了bus3.passengers# ['Alice', 'Bill', 'Claire', 'David'] ➍ 此外，深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值。我们可以实现特殊方法 __copy__()和 __deepcopy__()，控制 copy 和 deepcopy 的行 为，详情参见 copy 模块的文档（http://docs.python.org/3/library/copy.html）。 函数传参：参数共享Python 唯一支持的参数传递模式是共享传参 共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参 是实参的别名。 不要使用可变类型作为参数的默认值 123456789class HauntedBus: \"\"\"备受幽灵乘客折磨的校车\"\"\" def __init__(self, passengers=[]): self.passengers = passengersbus1 = HauntedBus()bus2 = HauntedBus()HauntedBus.__init__.__defaults__[0] is bus1.passengers # Truebus2.passengers is bus1.passengers # True 问题在于，没有指定初始乘客的 HauntedBus 实例会共享同一个乘客列表。 del和垃圾回收del 语句删除名称，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。 123456789101112131415161718192021import weakrefs1 = &#123;1, 2, 3&#125;s2 = s1def bye(): print('Gone with the wind...')ender = weakref.finalize(s1, bye)ender.alive# Truedel s1 # del 不删除对象，而是删除对象的引用 ender.alive # Trues2 = 'spam' # 重新绑定最后一个引用 s2，让 &#123;1, 2, 3&#125; 无法获取。对象被销毁了，调用了 bye 回调，ender.alive 的值变成了 False。# Gone with the wind...ender.alive# False 你可能觉得奇怪，为什么示例中的 {1, 2, 3} 对象被销毁了？毕竟，我们把 s1 的引用传给finalize函数了呀，而为了监控对象和调用回调，必须要有引用。其实这是因为finalize 持有的是{1, 2, 3} 的弱引用。 弱引用TODO弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。 weakref 模块的文档指出，weakref.ref 类其实是低层接口，供高级用途使用，多数程序最好使用weakref集合和 finalize。TODO，这是什么意思。 注意 for 循环的变量的作用范围而导致的意外；for 循环中的变量 cheese 是全局变量，除非显式删除，否则不会消失，如下例： 12345678910111213141516171819202122232425262728import weakrefclass Cheese: def __init__(self, kind): self.kind = kind def __repr__(self): return 'Cheese(%r)' % self.kind stock = weakref.WeakValueDictionary()catalog = [Cheese('Red Leicester'), Cheese('Tilsit'), Cheese('Brie'), Cheese('Parmesan')]# 添加到弱引用 stock 中for cheese in catalog: stock[cheese.kind] = cheesesorted(stock.keys())# ['Brie', 'Parmesan', 'Red Leicester', 'Tilsit']del catalogsorted(stock.keys()) # 因为变量cheese还有对Cheese('Parmesan')的强引用# ['Parmesan']del cheesesorted(stock.keys())# [] 弱引用的局限不是每个 Python 对象都可以作为弱引用的目标（或称所指对象）。 基本的 list 和 dict 实例不能作为所指对象，但是它们的子类可以。 set 实例可以作为所指对象 用户定义的类型也没问题，这就解释了示例中为什么使用那个简单的 Cheese 类 int 和 tuple 实例不能作为弱引用的目标，甚至它们的子类也不行 面向对象：类类（class） 定义新类型的程序结构，里面有数据属性，以及用于操作数据属性的方法。 类型（type） 程序中的各种数据，限定可取的值和可对数据做的操作。有些 Python 类型近似于机器数据类型（例如 float 和 bytes），而另一些则是机器数据类型的扩展（例如，int 不受 CPU 字长的限制，str 包含多字节 Unicode 数据码位）和特别高层的抽象（例如 dict、 deque，等等）。类型分为两类：用户定义的类型和解释器内置的类型。在 Python 2.2 统一类型和类之前，类型和类是不同的实体，用户定义的类不能扩展内置的类型。而在那之后，内置的类型和新式类兼容了，类是 type 的实例。在 Python 3 中，所有类都是新式类。 类型判断Python判断变量的类型有两种方法：type(obj)和isinstance(obj，C) 对于基本的数据类型两个的效果都一样 1234567ip_port = ['219.135.164.245', 3128]### type()if type(ip_port) is list: print('list数组')### isinstance()if isinstance(ip_port, list): print('list数组') 区别之处 isinstance() 和type() 的区别在于： isinstance(obj，C) 会判断 C 是不是父类类型，可判断继承 type(obj) == C不会认为子类是一种父类类型 12345678910class A: passclass B(A): passisinstance(A(), A) # returns Truetype(A()) == A # returns Trueisinstance(B(), A) # returns Truetype(B()) == A # returns False 属性访问权限一、_var“单下划线” 开始的成员变量叫做保护变量（protected），(不过《流畅的 python》9.7章不这样认为)，比如_name，按照约定俗成的规定，只有类对象和子类对象能访问到这些变量；外部访问需通过类提供的接口（方法）进行访问。“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 Python 解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多 Python 程序员 严格遵守的约定，他们不会在类外部访问这种属性 二、 __var“双下划线” 开始的是私有成员（private），只有类对象自己能访问，连子类对象也不能访问到这个数据。 Python解释器对外把Student类的__name变量改成了_Student__name（所以通过这个名字还是可以访问到的） 注意下面的这种错误写法： 12345678bart = Student('Bart Simpson', 59)bart.get_name()# 'Bart Simpson'bart.__name = 'New Name' # 设置__name变量！，并没有修改成功！print(bart.__name)# 'New Name'bart.get_name() # get_name()内部返回self.__name# 'Bart Simpson' 三、变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量。 导入时： 在一个模块中以单下划线开头的变量和函数被默认当作内部函数，如果使用 from a_module import * 导入时，这部分变量和函数不会被导入。如果使用 import a_module 这样导入模块，仍然可以用 a_module._some_var 这样的形式访问到这样的对象，或者from mymod import _privatefunc。 参考：https://www.cnblogs.com/work115/p/5606981.html 类属性与实例属性 实例属性 给实例绑定属性的方法是通过实例变量.，或者通过self变量： 123456class Student(object): def __init__(self, name): self.name = name # 实例属性绑定方法1s = Student('Bob')s.score = 90 # 实例属性绑定方法2 类属性 直接在class中定义属性，这种属性是类属性，归Student类所有，这个属性虽然归类所有，但类的所有实例都可以访问到。 12class Student(object): name = 'Student' 属性覆盖Python 有个很独特的特性：类属性可用于为实例属性提供默认值。 使用self.var 读取它的值。因为实例本身没有 var 属性，所以 self.var 默认获 取的是Class.var类属性的值。 如果为不存在的实例属性赋值，会新建实例属性。同名类属性不受影响，也就是把同名类属性遮盖了。借助这一特性，可以为各个实例的属性定制不同的值。 但是如果使用的好，就会出现下面的问题 查找顺序（大坑） 实例属性-&gt;类属性 12345678910111213141516171819202122232425class Student(object): name = 'Student's = Student()''' 访问 '''print(s.name) # 实例并没有name属性，所以会继续查找class的name属性# Studentprint(Student.name) # 打印类的name属性# Student''' 修改 '''s.name = 'Michael' # 给实例绑定name属性print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性# Michaelprint(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问# StudentStudent.name='new Student' # 这才是修改类属性print(Student.name) # new Student''' 删除 '''del s.name # 如果删除实例的name属性print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了# new Student 从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 属性获取Python下一切皆对象，每个对象都有多个属性(attribute)，Python对属性有一套统一的管理方案。 一共有4种： 使用属性运算符 print(xmr.name) 通过属性字典__dict__print(xmr.__dict__[&#39;name&#39;]) 通过getattr函数print(getattr(xmr, &#39;name&#39;)) operator.attrgetter (可用于排序) 123import operatorop = operator.attrgetter('name')print(op(xmr) 12345678import operator people = [Person('xiemanR', 18), Person('zhangshan', 17), Person('lisi', 20), Person('wangwu', 25)] r = sorted(people, key=operator.attrgetter('age')) for i in r: print(i) __dict__与dir()的区别： dir()是一个内建函数，返回的是list；dir()用来寻找一个对象的所有属性，包括__dict__中的属性，包括从父类中继承的属性)。 __dict__是一个字典，键为属性名，值为属性值； 并不是所有对象都拥有dict属性。许多内建类型就没有__dict__属性，如list，此时就需要用dir()来列出对象的所有属性。 实例的__dict__仅存储与该实例相关的实例属性(self.xx，但不包括@property)，正是因为实例的__dict__属性，每个实例的实例属性才会互不影响。 类的__dict__存储所有实例共享的变量和函数(类属性，方法等)，类的__dict__并不包含其父类的属性。 属性操作：xxxattr函数仅仅把属性和方法列出来是不够的，配合内建函数getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态： getattr(obj, 属性名/方法名, 默认值) setattr(obj, 属性名/方法名, 值) hasattr(obj, 属性名/方法名) 1234567891011121314151617181920212223class MyObject(object): def __init__(self): self.x = 9 def power(self): return self.x * self.xobj = MyObject()### 访问、修改属性if hasattr(obj, 'x'): print(getattr(obj, 'x'))if not hasattr(obj, 'y'): setattr(obj, 'y', 23) print(obj.y)print(getattr(obj, 'z', 0)) # 属性不存在时，提供默认值### 获取方法if hasattr(obj,'power'): fn = getattr(obj,'power') print(fn()) 属性查找失败后，解释器会调用__getattr__方法。 多数时候，如果实现了__getattr__ 方法，那么也要定义 __setattr__ 方法，以防对象的行为不一致。默认情况：在超类上调用 __setattr__ 方法，提供标准行为。 为了实现只读的功能，可以通过__setattr__方法进行控制 12345678910111213def __setattr__(self, name, value): cls = type(self) if len(name) == 1: if name in cls.shortcut_names: error = 'readonly attribute &#123;attr_name!r&#125;' elif name.islower(): error = \"can't set attributes 'a' to 'z' in &#123;cls_name!r&#125;\" else: error = '' if error: msg = error.format(cls_name=cls.__name__, attr_name=name) raise AttributeError(msg) super().__setattr__(name, value) 特性 @property在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改 装饰器（decorator）可以给函数动态加上功能。对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的。 内置的 property 经常用作装饰器，但它其实是一个类 特性是用于 管理实例属性的类属性，真正的值存储在私有属性 __var 中 使用方式方式1： 1234567891011121314151617181920class LineItem: def __init__(self, description, weight, price): self.description = description self.weight = weight # self.weight 会找到类属性(特性)weight，然后就会进入set_weight方法(访问顺序请看下面介绍) self.price = price def subtotal(self): return self.weight * self.price def get_weight(self): return self.__weight def set_weight(self, value): if value &gt; 0: self.__weight = value else: raise ValueError('value must be &gt; 0') weight = property(get_weight, set_weight) 类中的特性能影响实例属性的寻找方式，而一开始这种方式可能会让人觉得意外(访问顺序请看下面介绍) 方式2： 12345678910111213141516171819202122class Student(object): def __init__(self): self._score = 0 @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = values = Student()print(s.score) # OK，实际转化为s.get_score()s.score = 60 # OK，实际转化为s.set_score(60)print(s.score) # OK，实际转化为s.get_score()s.score = 9999 # 报错 只定义getter方法，不定义setter方法就是一个只读属性 删除操作 可以使用 @my_propety.deleter 装饰器包装一个方法，负责删除特性管理 的属性 123456789101112131415# 来自电影《巨蟒与圣杯》，感觉这个例子不太好，看不出效果class BlackKnight: def __init__(self): self.members = ['an arm', 'another arm', 'a leg', 'another leg'] self.phrases = [\"'Tis but a scratch.\", \"It's just a flesh wound.\", \"I'm invincible!\", \"All right, we'll call it a draw.\"] @property def member(self): print('next member is:') return self.members[0] @member.deleter def member(self): text = 'BLACK KNIGHT (loses &#123;&#125;)\\n-- &#123;&#125;' print(text.format(self.members.pop(0), self.phrases.pop(0))) 测试 12345678910111213141516171819knight = BlackKnight()knight.member# next member is: 'an arm'del knight.member# BLACK KNIGHT (loses an arm)# -- 'Tis but a scratch.del knight.member# BLACK KNIGHT (loses another arm)# -- It's just a flesh wound.del knight.member# BLACK KNIGHT (loses a leg)# -- I'm invincible!del knight.member# BLACK KNIGHT (loses another leg)# -- All right, we'll call it a draw. 在不使用装饰器的经典调用句法中，fdel 参数用于设置删值函数。 1member = property(member_getter, fdel=member_deleter) 特性的文档如果使用经典调用句法，为 property 对象设置文档字符串的方法是传入 doc 参数： 1weight = property(get_weight, set_weight, doc='weight in kilograms') 使用装饰器创建 property 对象时，读值@property 装饰的方法的文档变成特性的文档。 123456789class Foo: @property def bar(self): '''The bar attribute''' return self.__dict__['bar'] @bar.setter def bar(self, value): self.__dict__['bar'] = value Property源码其实Property是数据描述符，参考：Properties¶ 123456789101112131415161718192021222324252627282930313233343536class Property(object): \"Emulate PyProperty_Type() in Objects/descrobject.c\" def __init__(self, fget=None, fset=None, fdel=None, doc=None): self.fget = fget self.fset = fset self.fdel = fdel if doc is None and fget is not None: doc = fget.__doc__ self.__doc__ = doc def __get__(self, obj, objtype=None): if obj is None: return self if self.fget is None: raise AttributeError(\"unreadable attribute\") return self.fget(obj) def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"can't set attribute\") self.fset(obj, value) def __delete__(self, obj): if self.fdel is None: raise AttributeError(\"can't delete attribute\") self.fdel(obj) def getter(self, fget): return type(self)(fget, self.fset, self.fdel, self.__doc__) def setter(self, fset): return type(self)(self.fget, fset, self.fdel, self.__doc__) def deleter(self, fdel): return type(self)(self.fget, self.fset, fdel, self.__doc__) 特性工厂工厂函数构建的特性利用，weight 特性覆盖了 weight 实例属性，对 self.weight 或 nutmeg.weight 的每个引用都由特性函数处理，只有 直接存取 __dict__ 属性才能跳过特性的处理逻辑 在真实的系统中，分散在多个类中的多个字段可能要做同样的验证，此时最好把 quantity 工厂函数放在实用工具模块中，以便重复使用。 12345678910111213# 特性工厂def quantity(storage_name): # 运行这两个函数时，它们会从闭包中读取 storage_name，确定从哪里获取属性 的值，或者在哪里存储属性的值 def qty_getter(instance): return instance.__dict__[storage_name] def qty_setter(instance, value): if value &gt; 0: instance.__dict__[storage_name] = value else: raise ValueError('value must be &gt; 0') return property(qty_getter, qty_setter) 特性是类属性。构建各个 quantity 特性对象时，要传入 LineItem 实例属性 的名称，让特性管理。 1234567891011class LineItem: weight = quantity('weight') # 特性 weight 定义为类属性 price = quantity('price') def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price __slots__参考：Customizing attribute access 类可以定义这个这属性，限制实例能有哪些属性。 原因：默认情况下，Python 在各个实例中名为 __dict__ 的字典里存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。 原理：如果要处理数百万个属性不多的实例，通过 __slots__ 类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不用字典。 注意： 父类中声明的 __slots__ 会被子类继承，但是子类默认拥有__dict__ 和__weakref__，因此子类默认是可以动态赋值，除非子类也定义了 __slots__ ，只需定义额外的、父类中没有的 slots 即可. 12345678class A: __slots__ = ('a','b')class B(A): __slots__ = ('c','d') # 如果没有这一行，B类可以任意添加属性，因为有 __dict__属性a = B()a.a, a.b, a.c a.d= 10, 20, 30, 40 在类中定义 __slots__ 属性之后， 不再拥有__dict__和 __weakref__属性，除非显式在 slots 中声明，或者父类中可用 如果不把 ‘__dict__‘ 加入 __slots__，实例不能再有 __slots__ 中所列名称之外的其他属性，失去动态添加属性的功能 如果不把 ‘__weakref__‘ 加入 __slots__，实例就不能作为弱引用的目标 __slots__实现方式是在类的层面上为每个变量创建描述符，因此不能定义与__slots__中的重名的类属性，比如想用于为实例提供默认值的类属性 在类中定义告诉解释器：“这个类中的所有实例属性都在这儿了！ __slots__ 属性的值是一个字符 串组成的元组，指明允许有的属性。 123456789101112131415161718class Vector2d: __slots__ = ('x', 'y') def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return '&lt;&#123;&#125;,&#123;&#125;&gt;'.format(self.x, self.y) v=Vector2d(1,2)&gt;&gt;&gt; v.x2# 不允许赋值了给未知的属性&gt;&gt;&gt; v.o=10Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Vector2d' object has no attribute 'o' 属性访问优先顺序特性都是类属性，但是特性管理的其实是实例属性的存取 如果实例和所属的类有同名数据属性，那么实例属性会覆盖（或称遮盖）类属性 但是实例属性不会遮盖类特性 直接从 Class 中读取 prop 特性，获取的是特性对象本身，不会运行特性的读值方法 obj.attr 这样的表达式不会从 obj 开始寻找 attr，而是从 obj.__class__ 开始，而且，仅当类中没有名为 attr 的特性时，Python 才会在 obj 实例中寻找。这条规则不仅适用于特性，还适用于一整类描述符——覆盖型描述符 （overriding descriptor） 具体看描述符的 【属性访问的优先级规则】 一章 12345678910111213141516171819202122232425class Class: data = 'the class data attr' @property def prop(self): return 'the prop value'Class.prop # ➊ 直接从 Class 中读取 prop 特性，获取的是特性对象本身，不会运行特性的读值方法# &lt;property object at 0x1072b7408&gt;obj.prop # ➋ 执行特性的读值方法# 'the prop value'obj.prop = 'foo' # ➌ 执行特性的赋值方法# Traceback (most recent call last): AttributeError: can't set attributeobj.__dict__['prop'] = 'foo' # ➍ 绕过特性，给实例添加 prop 属性vars(obj) # ➎ &#123; 'data': 'bar','prop': 'foo'&#125;obj.prop # ➏ 仍会运行特性的读值方法。特性没被实例属性遮盖。# 'the prop value'Class.prop = 'baz' # ➐覆盖 Class.prop 特性，销毁特性对象obj.prop # ➑# 'foo' 特殊属性的访问参考：Special method lookup 结论：特殊方法的查找与普通属性一样，只有隐式的调用才会绕过一些限制 隐式调用特殊方法（如使用len(),repr(),hash()就会隐式调用__len__等方法），只有当方法是定义在object 的类中 而不是在 object 实例的字典中时才能正确执行，(if defined on an object’s type, not in the object’s instance dictionary. )这也是为什么下面的代码会出现异常： 1234567class C: passc = C()c.__len__ = lambda: 5len(c)# TypeError: object of type 'C' has no len() 但是下面这样就没有问题： 123456class C: def __len__(self): return 10c = C()len(c) # 10 这种现象在很多特殊方法上都有：__hash__,__repr__ 隐式调用特殊方法时，它会绕过 必须传入实例参数 的限制： 1234567891 .__hash__() == hash(1) # 实例调用特殊方法，会将本身传入第一个参数# Trueint.__hash__() == hash(int) # 类调用特殊方法，必须显式传入实例参数，否则报错# TypeError: descriptor '__hash__' of 'int' object needs an argumenttype(1).__hash__(1) == hash(1) # 等价于上面，显式传入实例参数，就不会出错# Truetype(int).__hash__(int) == hash(int) # 调用元类的特殊方法，也需要显式传入实例参数，只不过这个实例是一个类对象# True 同时，它也会 绕过类、甚至元类的__getattribute__()方法 123456789101112131415161718192021class Meta(type): def __getattribute__(*args): print(\"Metaclass getattribute invoked\") return type.__getattribute__(*args)class C(object, metaclass=Meta): def __len__(self): return 10 def __getattribute__(*args): print(\"Class getattribute invoked\") return object.__getattribute__(*args) c = C()c.__len__() # ❶ 通过实例显式调用特殊方法，会调用\"类\"的 __getattribute__# Class getattribute invoked# 10type(c).__len__(c) # ❷通过类显式调用特殊方法，会调用“元类\"的 __getattribute__# Metaclass getattribute invoked# 10len(c) # 隐式调用,绕过 __getattribute__# 10 ❷ 请参考：元类编程中的【类属性访问优先级】，就可以明白为什么会调用元类的方法 总结：处理属性的重要属性与函数重要属性 __class__ ：对象所属类的引用，即 obj.__class__ 与 type(obj) 的作用相同 __dict__ ：一个映射，存储对象或类的可写属性。有 __dict__ 属性的对象，任何时候都能随意设置新属性。如果类有 __slots__ 属性，它的实例可能没有 __dict__属性。 __slots__ ：类可以定义这个这属性，限制实例能有哪些属性。__slots__ 属性的值是一个元组，每个元素是字符串，指明允许有的属性。 如果 __slots__ 中没有 ‘__dict__‘，那么该类的实例没有 __dict__ 属性，实例只允许有指定名称的属性。 内置函数 dir([object])：列出对象的大多数属性。官方文档说dir函数的目的是交互式使用， 因此没有提供完整的属性列表，只列出一组【重要的】属性名。 dir 函数能审查有或没有 dict 属性的对象。 dir 函数不会列出 dict 属性本身，但会列出其中的键。 dir 函数也不会列出类的几个特殊属性，例如 mro、bases 和 name。 如果没有指定可选的 object 参数，dir 函数会列出当前作用域中的名称。 vars([object]) ：返回 object 对象的 __dict__ 属性； 如果实例所属的类定义了 __slots__ 属性， 实例没有 __dict__ 属性，那么 vars 函数不能处理那个实例（dir 函数能处理这样的实例）。如果没有指定参数，那么 vars() 函数的作用与 locals() 函数一样：返回表示本地作用域的字典。 getattr(object, name[, default]) ：从 object 对象中获取 name 字符串对应的属性。获取的属性可能来自对象所属的类或超类。如果没有找到指定的属性，getattr 函数抛出 AttributeError 异常，或者返回 default 参数的值。 hasattr(object, name)：如果object 对象中存在指定的属性，或者能以某种方式（例如继承）通过 object 对象获取指定的属性，返回 True。文档说：“这个函数的实现方法是调用 getattr(object, name) 函数，看看是否抛出 AttributeError 异常。” setattr(object, name, value) ：把 object 对象指定属性的值设为 value，前提是 object 对象能接受那个值。 这个函数可能会创建一个新属性，或者覆盖现有的属性。 特殊方法​ 使用点号或内置的 getattr、hasattr 和 setattr 函数存取属性都会触发下述列表中相应的特殊方法。直接通过实例的 __dict__ 属性读写属性不会触发这些特殊方法 ​ 仅当特殊方法在对象所属的类型上定义，而不是在对象的实例字典中定义时，才能确保隐式调用特殊方法调用成功（obj.attr 和 getattr(obj, &#39;attr&#39;, 42) 都会触发 Class.__getattribute__(obj, &#39;attr&#39;) 方法） ​ 特殊方法 不会被同名实例属性遮盖 __dir__(self)：把对象传给 dir 函数时调用，列出属性。例如，dir(obj) 触发 Class.__dir__(obj) 方法。 __getattr__(self, name)：仅当搜索过 obj、Class 和超类之后，获取指定的属性失败时调用。也就是只有当试图访问不存在的属性时它才会被调用。表达式 obj.no_such_attr、getattr(obj, &#39;no_such_attr&#39;) 和 hasattr(obj, &#39;no_such_attr&#39;) 可能会触发 Class.__getattr__(obj, &#39;no_such_attr&#39;) 方法，但是，仅当在 obj、Class 和超类中找不到指定的属性时才会触发。__getattr__只在对象的类中寻找，而不在实例中寻找（这句话不是很明白）。 __getattribute__(self, name)：点号、 getattr 和 hasattr 内置函数会触发这个方法。尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法时除外。 调用 __getattribute__ 方法且抛出 AttributeError 异常时，才会调用 __getattr__ 方法。为了在获取 obj 实例的属性时不导致无限递归，__getattribute__ 方法的实现要使用 super().__getattribute__(obj, name) 123456789class A: '''__getattr__ 与 __getattribute__的调用顺序''' def __getattribute__(self, item): if item == \"attr\": raise AttributeError # 会进入__getattr__方法 return \"__getattribute__\" def __getattr__(self, item): return \"__getattr__\" __setattr__(self, name, value)：尝试设置指定的属性时总会调用这个方法。 点号和 setattr 内置函数会触发这个方法。例如，obj.attr = 42 和 setattr(obj, &#39;attr&#39;, 42) 都会触发 Class.__setattr__(obj, ‘attr’, 42) 方法。 __delattr__(self, name) ：只要使用 del 语句删除属性，就会调用这个方法。例如，del obj.attr 语句触发 Class.__delattr__(obj, &#39;attr&#39;) 方法。 注意：特殊方法 __getattribute__ 和 __setattr__不管怎样都会调用，几乎会影响每一次属性存取 实例方法、类方法、静态方法首先形式上的区别： 实例方法隐含的参数为类实例self。 类方法隐含的参数为类本身cls。 如果存在类的继承，那类方法获取的类是类树上最底层（具体）的类（子类）。 静态方法无隐含参数，主要为了类实例也可以直接调用静态方法。 123456789101112131415161718192021222324252627282930class A: class_var = \"class_var\" def method(self, name): print(self) self.class_var = name # 绑定了实例属性class_var，并不会影响到外层真正的类属性 print(self.class_var) @classmethod def classMethod(cls, name): print(cls) print(cls.class_var) @staticmethod def staticMethod(name): print(name)a = A()a.class_var = \"this is new\"a.method(\"name\")# A.method(\"name\") # 报错A.method(a, \"name\") # 除非手动传入 实例对象print(\"A的类属性不变：\", A.class_var)a.classMethod(\"name\") # 会自动传入实例a的类AA.classMethod(\"name\")a.staticMethod(\"name\")A.staticMethod(\"name\") 实例方法 类方法 静态方法 实例调用 a.method(a,…) a.classMethod(type(a),…) a.staticMethod() 类调用 A.method(a,…)需要显式传入实例对象 a A.classMethod(A,…) A.staticMethod() 实例方法（普通方法）：随着实例属性的改变而改变 类方法（无论是类调用还是实例调用）：都是类属性的值，不随实例属性的变化而变化 静态方法：不可以访问类属性，故直接输出传入方法的值 classmethod 最常见的用途是当函数只需要类的引用而不关心实例是什么的情况，另一个功能是定义备选 构造方法 staticmethod 不是特别有用，如果想定义不需要与类交互的函数，那么在模块中定义就好了。有时，函数虽然从不处理类，但是函数的功能与类紧密相关，因此想把它放在近处。即便如此，在同一模块中的类前面或后面定义函数也就行了。 技术审校之一 Leonardo Rochael 不同意我对 staticmethod 的见解，作为反驳，他推荐阅读 Julien Danjou 写的一篇博客文章，题为“The Definitive Guide on How to Use Static, Class or Abstract Methods in Python”。Danjou 的这篇文章写得很好，我推 荐阅读。 继承(TODO)12章节 12345678910class A: def __init__(self): self.a=10class B: def __init__(self): self.b=20class C(A,B): pass # def __init__(self): # super().__init__() 与 java 不同，C 并不会继承实例的属性，默认__init__会调用超类的构造方法，因此会得到 a 属性，但是如果覆盖了__init__方法，没有调用超类的构造方法，就会失去 a 属性 内置函数(特殊方法)首先明确一点，特殊方法的存在是为了被 Python 解释器调用的，你自己并不需要调用它们。也就是说没有my_object.__len__()这种写法，而应该使用len(my_object)。 特殊方法 不会被同名实例属性遮盖 12345678910class A: def __str__(self): return \"class A\"a=A()print(a)# class Aa.__str__=None #并不会被覆盖print(a)# class A 在执行len(my_object)的时候： 如果my_object是一个自定义类的对象，Python会自己去调用其中由你实现的__len__方法。 如果是 Python 内置的类型，比如列表（list）、字符串（str）、字节序列 （bytearray）等，那么 CPython 会抄个近路，__len__ 实际上会直接返回 PyVarObject 里的 ob_size 属性。PyVarObject 是表示内存中长度可变的内置对象的 C 语言结构体。直接读取这个值比调用一个方法要快很多。 很多时候，特殊方法的调用是隐式的，比如 for i in x: 这个语句，背后其实用的是 iter(x)，而这个函数的背后则是 x.__iter__() 方法。当然前提是这个方法在 x 中被实现了。 通常你的代码无需直接使用特殊方法。通过内置的函数（例如len、iter、str，等等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。 init TODOnew用于新建 cls 类的实例， __new__() 是静态方法（通过特殊方法实现的，不用@staticmethod）第一个参数是 需要创建出来的实例对应的类， 剩余的参数args将被传到 对象构造表达式（object constructor expression：cls(args)），__new__() 的返回值必须是一个新的对象，通常就是cls的实例。 覆盖 new 方法的一种典型实现是调用超类的 __new__ 方法： super().__new__(cls[, ...]) 然后对 新创建的实例 进行需要的操作，最后返回实例。 如果返回的是 cls类的实例，就会调用该实例的 init 方法： __init__(self[, ...]), self 就是这个实例本身，其他的参数与传递给 new 方法一样。 如果返回的不是 cls类的实例，就不会调用该实例的 init 方法 __new__() 主要是用于允许不可变类的子类(如 int, str, or tuple) 自定义实例的创建。 也常常在自定义的元类中被覆盖，用于自定义类的创建 new方法接受的参数虽然也是和init一样，init 和 new 最主要的区别在于： new 是创建这个类实例的方法，通常用于控制生成一个新实例的过程。它是类级别的方法。 init 在得到 new 方法返回的实例后，用于初始化这个实例，控制这个初始化的过程，比如添加一些属性，做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。 12345678910111213141516171819class Person(object): '''Silly Person''' def __new__(cls, name, age): print('__new__ called.') return super(Person, cls).__new__(cls, name, age) # 调用超类的 new 方法 # super().__new__(cls) 就会调用 object.__new__(Person)创建一个 Person 实例 def __init__(self, name, age): print('__init__ called.') self.name = name self.age = age def __str__(self): return '&lt;Person: %s(%s)&gt;' % (self.name, self.age) if __name__ == '__main__: piglei = Person(‘piglei’, 24) print(piglei) 执行结果： 123__new__ called.__init__ called.&lt;Person: piglei(24)&gt; 作用实现单例事实上，当我们理解了new方法后，我们还可以利用它来做一些其他有趣的事情，比如实现 设计模式中的 单例模式(singleton) 。因为类每一次实例化后产生的过程都是通过new来控制的，所以通过重载new方法，我们 可以很简单的实现单例模式。 123456789101112def __new__(cls): # 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象 if not hasattr(cls, 'instance'): cls.instance = super(Singleton, cls).__new__(cls) return cls.instance obj1 = Singleton()obj2 = Singleton() obj1.attr1 = 'value1'print obj1.attr1, obj2.attr1print obj1 is obj2 输出结果： 1True TODO：有参数的单例模式怎么实现 创建对象1234567891011121314151617181920212223242526272829class FrozenJSON: \"\"\"一个只读接口，使用属性表示法访问JSON类对象 \"\"\" def __new__(cls, arg): if isinstance(arg, abc.Mapping): return super().__new__(cls) elif isinstance(arg, abc.MutableSequence): return [cls(item) for item in arg] else: return arg def __init__(self, mapping): self.__data = &#123;&#125; for key, value in mapping.items(): if iskeyword(key): key += '_' self.__data[key] = value def __getattr__(self, name): if hasattr(self.__data, name): return getattr(self.__data, name) else: return FrozenJSON(self.__data[name])s=&#123;\"key1\":&#123;\"num\":11&#125;,\"key2\":[1,2,3]&#125;ss=FrozenJSON(s)print(ss.key1.num)print(ss.key2)# 11# [1, 2, 3] repr与 str __repr__ 返回的字符串应该准确、无歧义，并且尽可能表达出如何用代码创建出这个被打印的对象。交互式控制台和调试程序（debugger）用 repr 函数来获取字符串表示形式； __str__ 返回的字符串对终端用户更友好，在str()函数或是在用print函数打印一个对象的时候才被调用的 如果你只想实现这两个特殊方法中的一个，__repr__ 是更好的选择，因为如果一个对象 没有 __str__ 函数，而 Python 又需要调用它的时候，解释器会用 __repr__ 作为替代。 使用 reprlib 模块可以生成长度有限的表示形式，reprlib.repr() 函数用于生成大型结构或递归结构的安全表示形式，它会限制输出字符串的长度，用 ‘…’ 表示截断的部分，如 array(&#39;d&#39;, [0.0, 1.0, 2.0, 3.0, 4.0, …])。 Difference between str and repr format格式化显示内置的format()函数和 str.format()方法把各个类型的格式化方式委托给相应的 .__format__(format_spec) 方法。format_spec 是格式说明符，它是： format(my_obj, format_spec) 的第二个参数，或者 str.format() 方法的str中{} 代换字段中冒号后面的部分 1234567n=1/3format(n, '0.4f') # 格式说明符是 '0.4f'# 0.3333'n is &#123;rate:0.2f&#125;'.format(rate=n) #格式说明符是 '0.2f'# n is 0.33 {0.mass:5.3e} 这样的格式字符串其实包含两部分， 冒号左边的 0.mass 在代换字段句法中是字段名， 冒号后面的 5.3e 是格式说明符。 格式说明符使用的表示法叫格式规范微语言(Format Specification MiniLanguage) 自定义格式化代码如果类没有定义__format__方法，从 object 继承的方法__format__会返回 str(my_object)，然而，如果传入格式说明符，object.__format__ 方法会抛出 TypeError 格式规范微语言是可扩展的，因为各个类可以自行决定如何解释 format_spec 参数。 为自定义的格式代码选择字母时，我会避免使用其他类型用过的字母。在格式 规范微语言(Format Specification MiniLanguage)中我们看到，整数使用的代码有 ‘bcdoxXn’，浮点数使用的代码有 ‘eEfFgGn%’，字符串使用的代码 有 ‘s’。因此，为极坐标选的代码是 ‘p’。各个类使用自己的方式解释格式代码， 在自定义的格式代码中重复使用代码字母是不会出错，但是可能会让用户困惑。 123456789101112131415import mathclass Vector(): def angle(self): return math.atan2(self.y, self.x) def __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): fmt_spec = fmt_spec[:-1] #删除 'p' 后缀 coords = (abs(self), self.angle()) #极坐标：(magnitude, angle) outer_fmt = '&lt;&#123;&#125;, &#123;&#125;&gt;' else: coords = self outer_fmt = '(&#123;&#125;, &#123;&#125;)' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*components) hash为了把实例变成可散列的： 必须使用 __hash__ 方法，还需要__eq__方法 此外，还要让实例不可变 根据特殊方法 hash 的文档 （https://docs.python.org/3/reference/datamodel.html），最好使用位运算符异或（^）**混合各分量的散列值**——我们会这么做。 123456789101112131415161718192021222324class Vector2d: typecode = 'd' def __init__(self, x, y): self.__x = float(x) self.__y = float(y) @property def x(self): return self.__x @property def y(self): return self.__y def __hash__(self): return hash(self.x) ^ hash(self.y) def __eq__(self, other): return tuple(self) == tuple(other) # 是为了 tuple 方法能够使用 def __iter__(self): return (i for i in (self.x, self.y)) iter(TODO)byte调用bytes() 函数时，会调用类中的__byte__()，返回字节序 dict__dict__是一个字典或者 mapping 类型的对象，用于保存对象可读写的属性（保存着实例中的全部属性） 属性引用[Attribute references]会被转换为在__dict__字典中查找， m.x 等价于 m.__dict__[&quot;x&quot;]. 属性赋值[Attribute assignment] 会更新模块的命名空间字典（module’s namespace dictionary）， m.x = 1 等价于 m.__dict__[&quot;x&quot;] = 1. 更新实例的 __dict__ 属性，把值设为一个映射，能快速地在那个实例中创建一堆属性。 可以使用vars(obj)获取dict 123456789101112class Record: def __init__(self, **kwargs): self.key = 0 self.__dict__.update(kwargs)dic = &#123;'key1': 1, 'key2': 2&#125;r = Record(**dic)print(r.__dict__)print(vars(r))# &#123;'key': 0, 'key1': 1, 'key2': 2&#125;# &#123;'key': 0, 'key1': 1, 'key2': 2&#125; Python 标准库中至少有两个与 Record 类似的类，其实例可以有任意个属性， 由传给构造方法的关键字参数构建——multiprocessing.Namespace 类和 argparse.Namespace 类 getattr(TODO)个人结论：对找不到属性是，应该自定义 getattr，进行处理 getattribute(TODO)尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法 时除外。点号与 getattr 和 hasattr 内置函数会触发这个方法。调用 getattribute 方法且抛出 AttributeError 异常时，才会调用 getattr 方 法。为了在获取 obj 实例的属性时不导致无限递归，getattribute 方法的实现要 使用 super().getattribute(obj, name)。 Called unconditionally to implement attribute accesses for instances of the class. If the class also defines __getattr__(), the latter will not be called unless __getattribute__() either calls it explicitly or raises an AttributeError. This method should return the (computed) attribute value or raise an AttributeError exception. In order to avoid infinite recursion in this method, its implementation should always call the base class method with the same name to access any attributes it needs, for example, object.__getattribute__(self, name). This method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See Special method lookup. __setattr__(TODO)属性描述符背景在前面我们了解了对象属性访问和行为控制的一些特殊方法，例如__getattribute__、__getattr__、__setattr__、__delattr__。这些方法具有属性的”普适性”，可以用于属性查找、设置、删除的一般逻辑，也就是说所有的属性都可以使用这些方法实现属性的查找、设置、删除等操作。 但是，这并不能很好地实现对某个具体属性的访问控制行为。假如要实现控制dog.age属性的类型只能是整数，如果单单去修改__setattr__方法满足它，那这个方法便有可能不能支持其他的属性设置。对属性的控制行为就由属性对象来控制。 这里单独抽离出来一个属性对象，在属性对象中定义这个属性的查找、设置、删除行为。这个属性对象就是描述符。描述符对象一般是作为其他类对象的属性而存在。在其内部定义了三个方法用来实现属性对象的查找、设置、删除行为，描述符是实现了特定协议的类： __get__(self, instance, owner)：定义当试图取出描述符的值时的行为, owner 参数是托管类的 class 引用，instance 是该 class 的实例，self是描述符实例(具体术语请看后面定义) __set__(self, instance, value)：定义当描述符的值改变时的行为。 __delete__(self, instance)：定义当描述符的值被删除时的行为。 术语概念 描述符类：实现描述符协议的类。在图中，是 Quantity 类。 托管类：使用描述符对象管理类中某个属性的类，把描述符实例声明为类属性——图中的 LineItem 类。 描述符实例：描述符类的各个实例，声明为托管类的类属性。在图中，各个描述符实例使用箭头和带下划线的名称表示（在 UML 中，下划线表示类属性）。与黑色菱形接触的 LineItem 类包含描述符实例。 托管实例：托管类的实例。在这个示例中，LineItem 实例是托管实例（没在类图中展示）。 储存属性：托管【实例】中的属性instance.__dict__[storage_name]，用于存储由描述符管理的属性的值。在图中，LineItem 实例的 weight 和 price 属性是储存属性。这种属性与描述符属性不同，描述符属性都是类属性。 托管属性：托管类中由描述符实例处理的公开属性，值存储在储存属性中。虽然托管属性在托管类中定义，但是作用相当于实例属性（即各个实例通常有各自的值，存储在储存属性中）也就是说，描述符实例和储存属性为托管属性建立了基础。 用法描述符的用法是，创建 一个实例，作为另一个类的类属性。 12345678910111213141516171819202122class Quantity: def __init__(self, storage_name): self.storage_name = storage_name def __set__(self, instance, value): if value &gt; 0: # 必须直接处理托管实例的 __dict__ 属性；如果使用内置的 setattr 函数，因为[托管属性]和[储存属性]的名称不同，会再次触发 __set__ 方法，导致无限递归。 instance.__dict__[self.storage_name] = value else: raise ValueError('value must be &gt; 0')class LineItem: weight = Quantity('weight') price = Quantity('price') def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price 不能试图使用下面这种错误的写法： 1self.dict[self.storage_name] = value 错误的原因：想想 __set__ 方法里的self 和 instance的意思。这里，self 是描述符实例，它其实是托管类的类属性。同一时刻，内存中可能有几千个 LineItem 实例，不过只会有2个描述符实例：LineItem.weight 和 LineItem.price。因此，存储在描述符实例中的数据，其实会变成 LineItem 类的类属性，从而由全部 LineItem 实例共享。 重复的属性名解决方案想要实现下面代码，避免重复的属性名 123class LineItem: weight = Quantity() price = Quantity() 但是，赋值语句右手边的表达式先执行，而此时变量还不存在。 Quantity() 表达式计算的结果是创建描述符实例，而此时 Quantity 类中的代码无法猜出要把描述符绑定给哪个变量。 这里实现一个不太优雅但是可行的方案，更好的解决方案是使用类装饰器或元类： 想法：我们将为每个 Quantity 实例的 storage_name 属性自动生成一个唯一的字符串 12345678910111213141516171819202122232425262728293031323334class Quantity: __counter = 0 # ❶ __counter 统计 Quantity 实例的数量 def __init__(self): cls = self.__class__ prefix = cls.__name__ index = cls.__counter self.storage_name = '_&#123;&#125;#&#123;&#125;'.format(prefix, index) # ❷ cls.__counter += 1 def __get__(self, instance, owner): if instance is None: # ❹ return self else: return getattr(instance, self.storage_name) # ➎ def __set__(self, instance, value): # ➏ if value &gt; 0: setattr(instance, self.storage_name, value) else: raise ValueError('value must be &gt; 0')class LineItem: weight = Quantity() price = Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price ❷：定义[储存属性]，也就是price = Quantity(&#39;price&#39;)中右边的’price’，自动生成类似_Quantity#0 的储存属性名 ❹：考虑A.x这种类直接访问属性的情况，具体看下面的 【触发 get 的几种形式】 ➎，➏：这里可以使用内置的高阶函数 getattr 和 setattr 存取值，无需使用 instance.__dict__，因为托管属性和储存属性的名称不同 触发 get 的几种形式参考：Descriptor HowTo Guide、Invoking Descriptors 描述符的方法调用起始于绑定a.x，从而触发__getattribute__方法，而参数如何装配，取决于a是实例还是类 直接调用（少见）：代码直接调用描述符的 __get__ 方法： x.__get__(a) 实例绑定：a.x 由object.__getattribute__()转变为type(a).__dict__[&#39;x&#39;].__get__(a, type(a)). 类绑定：A.x 由type.__getattribute__()转变为A.__dict__[&#39;x&#39;].__get__(None, A). 超类绑定：If a is an instance of super, then the binding super(B,obj).m() searches obj.class.mro for the base class Aimmediately preceding B and then invokes the descriptor with the call: A.__dict__[&#39;m&#39;].__get__(obj, obj.__class__).(不太明白TODO) 演示用的伪代码(TODO，不太明白) 123456def __getattribute__(self, key): \"Emulate type_getattro() in Objects/typeobject.c\" v = object.__getattribute__(self, key) if hasattr(v, '__get__'): return v.__get__(None, self) return v 特性工厂函数与描述符类比较1234567891011121314151617def quantity(): try: quantity.counter += 1 # counter 定义为 quantity 函数自身的属性 except AttributeError: quantity.counter = 0 storage_name = '_&#123;&#125;:&#123;&#125;'.format('quantity', quantity.counter) def qty_getter(instance): return getattr(instance, storage_name) def qty_setter(instance, value): if value &gt; 0: setattr(instance, storage_name, value) else: raise ValueError('value must be &gt; 0') return property(qty_getter, qty_setter) 我喜欢描述符类那种方式，主要有下列两个原因。 描述符类可以使用子类扩展；若想重用工厂函数中的代码，除了复制粘贴，很难有其他方法。 与工厂函数中使用函数属性和闭包保持状态相比，在类属性和实例属性中保持状态更易于理解。 继承描述符商品的描述信息不能为空，我们要再创建一个描述符：NonBlank。在设计 NonBlank 的过程中，我们发现，它与 Quantity 描述符很像，只是验证逻辑不同。 回想 Quantity 的功能，我们注意到它做了两件不同的事：管理托管实例中的储存属性， 以及验证用于设置那两个属性的值。由此可知，我们可以重构，并创建两个基类。 模板方法设计模式：一个模板方法用一些抽象的操作定义一个算法，而子类将重定义这些操作以提供具体 的行为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import abcclass AutoStorage: __counter = 0 def __init__(self): cls = self.__class__ prefix = cls.__name__ index = cls.__counter self.storage_name = '_&#123;&#125;#&#123;&#125;'.format(prefix, index) cls.__counter += 1 def __get__(self, instance, owner): if instance is None: return self else: return getattr(instance, self.storage_name) def __set__(self, instance, value): setattr(instance, self.storage_name, value)class Validated(abc.ABC, AutoStorage): '''抽象基类''' def __set__(self, instance, value): value = self.validate(instance, value) # set之前调用验证方法 super().__set__(instance, value) @abc.abstractmethod def validate(self, instance, value): \"\"\"return validated value or raise ValueError\"\"\"class Quantity(Validated): \"\"\"继承Validated，实现具体的验证逻辑\"\"\" def validate(self, instance, value): if value &lt;= 0: raise ValueError('value must be &gt; 0') return valueclass NonBlank(Validated): \"\"\"继承Validated，实现具体的验证逻辑：at least one non-space character\"\"\" def validate(self, instance, value): value = value.strip() if len(value) == 0: raise ValueError('value cannot be empty or blank') return value class LineItem: description = NonBlank() weight = Quantity() price = Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price 描述符的种类参考：https://docs.python.org/3/howto/descriptor.html 任意实现__get__、__set__、__delete__方法中的一个就可以认为是描述符； 只实现__get__ 方法的对象是非数据描述符（non-data descriptor），意味着在初始化之后它们只能被读取，会被实例属性覆盖。常用于方法(方法其实是非属性描述符) 实现了__get__ 和__set__ 的对象是数据描述符（data descriptor） 个人结论：只有__set__的对象不是数据描述符 实现__set__、__delete__中的任意一个的对象是数据描述符，意味着这种属性是可读写的。通常__get__ 和__set__ 都会定义，会覆盖普通实例属性；如果没有定义 __get__ ，在实例中没有同名的实例属性的情况，返回描述符本身，否则返回实例属性 描述符的调用由__getattribute__() 方法触发，覆盖该方法可以阻止描述符的调用 http://python.jobbole.com/88582/ 特性(property)是数据描述符，不论有没有使用`@attr.setter定义赋值函数，因为这个类实现了set`方法，默认抛出 AttributeError: can’t set attribute(具体看【特性】-property 源码 这一节) 推荐看属性的【访问优先级规则】，才能深刻理解为什么会有下面的现象 定义做实验的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758### 辅助函数，仅用于显示 ###def cls_name(obj_or_cls): cls = type(obj_or_cls) if cls is type: cls = obj_or_cls return cls.__name__.split('.')[-1]def display(obj): cls = type(obj) if cls is type: return '&lt;class &#123;&#125;&gt;'.format(obj.__name__) elif cls in [type(None), int]: return repr(obj) else: return '&lt;&#123;&#125; object&gt;'.format(cls_name(obj))def print_args(name, *args): pseudo_args = ', '.join(display(x) for x in args) print('-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'.format(cls_name(args[0]), name, pseudo_args))### 对这个示例重要的类 ###class Overriding: \"\"\"也称数据描述符或强制描述符\"\"\" def __get__(self, instance, owner): print_args('get', self, instance, owner) def __set__(self, instance, value): print_args('set', self, instance, value)class OverridingNoGet: # ➌ \"\"\"没有``__get__``方法的覆盖型描述符\"\"\" def __set__(self, instance, value): print_args('set', self, instance, value)class NonOverriding: # ➍ \"\"\"也称非数据描述符或遮盖型描述符\"\"\" def __get__(self, instance, owner): print_args('get', self, instance, owner)class Managed: # ➎ 托管类，使用各个描述符类的一个实例。 over = Overriding() over_no_get = OverridingNoGet() non_over = NonOverriding() def spam(self): # ➏ 方法也是描述符，下一节会介绍 print('-&gt; Managed.spam(&#123;&#125;)'.format(display(self))) 同时有 get和set的数据描述符特性(property)是数据描述符，不论有没有使用`@attr.setter定义赋值函数，因为这个类实现了set`方法 1234567891011121314151617181920obj = Managed()obj.over # ➋ 触发描述符 __get__ 方法，第二个参数（instance）的值是托管实例 obj# -&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)Managed.over # ➌ 触发描述符 __get__ 方法，第二个参数（instance）的值是 None# -&gt; Overriding.__get__(&lt;Overriding object&gt;, None, &lt;class Managed&gt;)obj.over = 7 # ➍ 触发描述符 __set__ 方法# -&gt; Overriding.__set__(&lt;Overriding object&gt;, &lt;Managed object&gt;, 7)obj.over # -&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)obj.__dict__['over'] = 8 # ➏ 跳过描述符vars(obj)# &#123;'over': 8&#125;obj.over # ➑ 即使有名为 over 的实例属性，Managed.over 描述符仍会覆盖读取 obj.over 这个操作。# -&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;) 只有 set 的数据描述符覆盖型描述符既会实现 __set__ 方法，也会实现 __get__ 方法，不过也可以只实 现 __set__ 方法。 赋值操作还是由描述符的 __set__ 接管，而取值操作，分2种情况： 有同名实例属性：返回实例属性 没有同名实例属性：返回描述符对象本身 也就是说，实例属性的读操作 会遮盖描述符 1234567891011121314151617181920212223obj=Managed()obj.over_no_get # ➊ 没有同名实例属性，返回描述符本身# &lt;__main__.OverridingNoGet object at 0x665bcc&gt;Managed.over_no_get # ➋ 直接从类属性中获取描述符本身，不考虑实例属性# &lt;__main__.OverridingNoGet object at 0x665bcc&gt;obj.over_no_get = 7 # ➌# -&gt; OverridingNoGet.__set__(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)obj.over_no_get # ➍ 没有同名实例属性，仍然返回描述符本身# &lt;__main__.OverridingNoGet object at 0x665bcc&gt;obj.__dict__['over_no_get'] = 9 # 添加同名实例属性obj.over_no_get # ➏ 同名实例属性会遮盖描述符# 9obj.over_no_get = 7 # ➐ 赋值经过描述符的 __set__ 方法处理# -&gt; OverridingNoGet.__set__(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)obj.over_no_get # ➑ 读取时，只要有同名的实例属性，描述符就会被遮盖# 9 只有 get 的非数据描述符如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。 作用：类中的方法就是非数据描述符，请看 【方法是非数据描述符 】一节 123456789101112131415obj = Managed()obj.non_over ➊# -&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)obj.non_over = 7 ➋obj.non_over # ➌ 现在，obj 有名为 non_over 的实例属性，把 Managed 类的同名描述符属性遮盖掉# 7Managed.non_over # ➍ 描述符依然存在，会通过类截获这次访问，触发描述符的__get__# -&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, None, &lt;class Managed&gt;)del obj.non_over # ➎ 删除实例属性obj.non_over # ➏ 恢复触发类中描述符的 __get__ 方法# -&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;) 在类中覆盖描述符从上面例子可以看出，依附在类上的描述符无法控制为类属性赋值的操作。其实，这意味着为类属性赋值能覆盖 描述符属性 不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。这是一种猴子补丁技术 123456obj = Managed()Managed.over = 1Managed.over_no_get = 2Managed.non_over = 3obj.over, obj.over_no_get, obj.non_over# (1, 2, 3) 揭示了读写属性的另一种不对等：读类属性的操作可以由依附在托管类上定义有 __get__ 方法的描述符处理，但是写类属性的操作不会由依附在托管类上定义有 __set__ 方法的描述符处理 若想控制设置类属性的操作，要把描述符依附在类的类上，即依附在元类上。 默认情况下，对用户定义的类来说，其元类是 type 描述符用法建议内置的 property 类创建的其实是覆盖型描述符，set 方法和 get 方法都 实现了，即便不定义设值方法也是如此。特性的 set 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特 性 只读描述符并非只实现 get，__get__ 和 __set__ 两个方法必须都定义，否则，实例的同名属性会遮盖描述符，只读属性__set__方法只需抛出 AttributeError 异常即可 用于验证的描述符仅用于验证的描述符attr，__set__ 方法应该检查 value 参数获得的值，然后使用描述符实例的名称为键，直接设置 instance.__dict__[&#39;attr&#39;]=value 可以没有 __get__ 方法，这样，从实例中读取同名属性的速度很快，因为不用经过 __get__ 方法处理 只有 __get__的描述符(高效缓存)那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，得到 value，然后通过instance.__dict__[&#39;attr&#39;]=value中设置同名属性，缓存结果，实例属性就会覆盖描述符。 特殊方法不会被实例属性覆盖像my_obj.the_method = 7 这样简单赋值之后，后续通过该实例访问 the_method 得到的是数字 7，特殊方法不受这个问题的影响。解释器只会在类中寻找特殊的方法，也就是说 repr(x) 执行的其实是 x.__class__.__repr__(x) 属性访问的优先级规则参考：Invoking Descriptors¶ 获取属性时，必然调用默认 Class.__getattribute__，其内部逻辑如下： 123456789101112131415161718192021222324def __getattribute__(): cls_attr = None # 类中找到的属性 # 遍历父类链，查看每个类的 dict for class in obj.mro(): if class.__dict__['x'] is not None: # 类字典中查找 cls_attr =class .__dict__['x'] break if cls_attr is not None and is Data Descriptor： return cls_attr.__get__() # 返回数据描述符的值(get 和 set 都有) if obj.__dict__['x'] is not None: return obj.__dict__['x'] # 实例字典中查找 if cls_attr is not None if cls_attr is Non-Data Descriptor：#(只有 get) return cls_attr.__get__() return cls_attr # 普通数据、只有set的描述符 raise AttributeError if Class has the special method __getattr__: return Class.__getattr__() 如图所示： 图来自：http://python.jobbole.com/88582/ 实验验证的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879### 辅助函数，仅用于显示 ###def cls_name(obj_or_cls): cls = type(obj_or_cls) if cls is type: cls = obj_or_cls return cls.__name__.split('.')[-1]def display(obj): cls = type(obj) if cls is type: return '&lt;class &#123;&#125;&gt;'.format(obj.__name__) elif cls in [type(None), int]: return repr(obj) else: return '&lt;&#123;&#125; object&gt;'.format(cls_name(obj))def print_args(name, *args): pseudo_args = ', '.join(display(x) for x in args) print('-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'.format(cls_name(args[0]), name, pseudo_args))### 对这个示例重要的类 ###class Overriding: \"\"\"也称数据描述符或强制描述符\"\"\" def __get__(self, instance, owner): print_args('get', self, instance, owner) def __set__(self, instance, value): print_args('set', self, instance, value)class OverridingNoGet: # ➌ \"\"\"没有``__get__``方法的覆盖型描述符\"\"\" def __set__(self, instance, value): print_args('set', self, instance, value)class NonOverriding: # ➍ \"\"\"也称非数据描述符或遮盖型描述符\"\"\" def __get__(self, instance, owner): print_args('get', self, instance, owner)class Parent: over = Overriding() def __getattr__(self, item): return \"getattr\"class Managed(Parent): # ➎ 托管类，使用各个描述符类的一个实例。 def __init__(self): self.__dict__['over'] = \"obj.over\" self.__dict__['over_no_get'] = \"obj.over_no_get\" self.__dict__['non_over'] = \"obj.non_over\" over_no_get = OverridingNoGet() over_no_get_cls = OverridingNoGet() attr_cls = 'attr_cls' non_over = NonOverriding() def spam(self): # ➏ 方法也是描述符，下一节会介绍 print('-&gt; Managed.spam(&#123;&#125;)'.format(display(self)))dd = Managed()print(dd.over) # -&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)print(dd.over_no_get) # obj.over_no_getprint(dd.over_no_get_cls) # &lt;__main__.OverridingNoGet object at 0x10d0ca320&gt;print(dd.attr_cls) # attr_clsprint(dd.non_over) # obj.non_overprint(dd.none) # getattr 方法是非数据描述符参考：Functions and Methods 在类中定义的函数属于绑定方法类型（bound method）一种可调用类型，因为用户定义的函数都有 __get__ 方法，但没有__set__方法，所以依附到类上时，就相当于非数据描述符 1234567class Function(object): def __get__(self, obj, objtype=None): \"Simulate func_descr_get() in Objects/funcobject.c\" if obj is None: return self return types.MethodType(self, obj) s12345678class StaticMethod(object): \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\" def __init__(self, f): self.f = f def __get__(self, obj, objtype=None): return self.f s 123456789101112class ClassMethod(object): \"Emulate PyClassMethod_Type() in Objects/funcobject.c\" def __init__(self, f): self.f = f def __get__(self, obj, klass=None): if klass is None: klass = type(obj) def newfunc(*args): return self.f(klass, *args) return newfunc z 1234567891011121314class Managed: # ➎ 托管类，使用各个描述符类的一个实例 #over = Overriding() #over_no_get = OverridingNoGet() #non_over = NonOverriding() def spam(self): # ➏ 方法也是描述符，下一节会介绍 print('-&gt; Managed.spam(&#123;&#125;)'.format(display(self)))o = Managed()print(o.spam) # ➊# &lt;bound method Managed.spam of &lt;__main__.Managed object at 0x10909f160&gt;&gt;print(Managed.spam) # ❷ # &lt;function Managed.spam at 0x109097730&gt; ➊ obj.spam 获取的是绑定方法对象。 ❷ 但是 Managed.spam 获取的是函数。 深入理解这种机制 12345678import collectionsclass Text(collections.UserString): def __repr__(self): return 'Text(&#123;!r&#125;)'.format(self.data) def reverse(self): return self[::-1] 1234567891011121314151617181920212223242526272829303132word = Text('forward')print(word) #➊# Text('forward')print(word.reverse()) #➋# Text('drawrof')print(Text.reverse(word)) # ➌等价于➋，显示地传入self参数:word对象# Text('drawrof')#与上面一样，显示地传入self参数:各种可迭代对象list(map(Text.reverse, ['repaid', (10, 20, 30), Text('stressed')]))# ['diaper', (30, 20, 10), Text('desserts')]type(word.reverse),type(Text.reverse) # ➍# (&lt;class 'function'&gt;, &lt;class 'method'&gt;)Text.reverse.__get__(word) # ➏ 等价于 word.reverse# &lt;bound method Text.reverse of Text('forward')&gt;Text.reverse.__get__(None, Text) # ➐ 等价于 Text.reverse# &lt;function Text.reverse at 0x101244e18&gt;word.reverse.__self__ # ➑# Text('forward')word.reverse.__func__ is Text.reverse # ➒ # Trueword.reverse.__call__ # ➓ # &lt;method-wrapper '__call__' of method object at 0x100aae988&gt; ❽ 绑定方法对象有个 __self__ 属性，其值是调用这个方法的实例引用 ➒ 绑定方法的 __func__ 属性是依附在托管类上那个原始函数的引用 类中的方法第一个参数是 self 的秘密➓ 与描述符一样， 通过托管类访问时，函数的 __get__ 方法会返回自身的引用。但是， 通过实例访问时，函数的 __get__ 方法返回的是绑定方法对象：一种可调用的对象，➓ 有个 __call__ 方法，用于处理真正的调用过程。这个方法会调用 __func__ 属性引用的原始函数，把函数的第一个参数设为绑定方法的 __self__ 属性。 接口Python - 协议和鸭子类型 鸭子类型（duck typing）​ 忽略对象的真正类型，转而关注对象有没有实现所需 的方法、签名和语义 ​ 多态的一种形式，在这种形式中，不管对象属于哪个类，也不管声明的具体接口是什 么，只要对象实现了相应的方法，函数就可以在对象上执行操作。 ​ 对 Python 来说，这基本上是指避免使用 isinstance 检查对象的类型（更别提 type(foo) is bar 这种更糟的检查方式了 由来： When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.——James Whitcomb Riley 不关注对象的类型，而关注对象的行为(方法)。它的行为是鸭子的行为，那么可以认为它是鸭子。 协议 在面向对象编程中，协议是非正式的接口，是一组方法，但只是一种文档，语言不对施加特定的措施或者强制实现。 虽然协议是非正式的，在Python中，应该把协议当成正式的接口。 Python中存在多种协议，用于实现鸭子类型（对象的类型无关紧要，只要实现了特定的协议（一组方法）即可）。 需要成为相对应的鸭子类型，那就实现相关的协议，即相关的__method__。例如实现序列协议(__len__和__getitem__)，这个类就表现得像序列。 协议是正式的，没有强制力，可以根据具体场景实现一个具体协议的一部分。例如，为了支持迭代，只需实现__getitem__，不需要实现__len__。 在Python文档中，如果看到“文件类对象“（表现得像文件的对象），通常说的就是协议，这个对象就是鸭子类型。这是一种简短的说法，意思是：“行为基本与文件一致，实现了部分文件接口，满足上下文相关需求的东西。” 猴子补丁：在运行时修 改类或模块，而不改动源码。 抽象基类Alex Martelli 的警告：不要自己定义抽象基类，除非你要构建允许 用户扩展的框架。日常使用中，我们与抽象基类的联系应 该是创建现有抽象基类的子类，或者使用现有的抽象基类注册。 声明抽象基类最简单的方式是继承 abc.ABC 或其他抽象基类 abc.ABC 是 Python 3.4 新增的类，如果你使用的是旧版 Python，那么无法继承现有的抽象基类。此时，必须在 class 语句中使用 metaclass= 关键字，把值设为 abc.ABCMeta（不是 abc.ABC） 1234&gt; # 这是Python &lt; 3.4&gt; class Tombola(metaclass=abc.ABCMeta):&gt; ...&gt; 在 Python 2 中必须使用 __metaclass__ 类 属性： 1234&gt; # 这是Python 2 ！！！ &gt; class Tombola(object): &gt; __metaclass__ = abc.ABCMeta&gt; 抽象方法使用 @abstractmethod 装饰器标记，而且定义体中通常只有文档字符串 除了 @abstractmethod 之外，abc 模块还定义了 @abstractclassmethod、@abstractstaticmethod 和 @abstractproperty 三个装饰器。然而，后三个装饰器从 Python 3.3 起废弃了，因为装饰器可以在 @abstractmethod 上堆叠，abstractmethod() 应该放在最里层，声明抽象类方法的推荐方式是： 12345class MyABC(abc.ABC): @classmethod @abc.abstractmethod def an_abstract_classmethod(cls, ...): pass 继承抽象基类具体子类必须实现全部的抽象方法 12class B(Abstract): '''实现全部抽象函数''' 虚拟子类注册虚拟子类的方式是在抽象基类上调用 register 方法。这么做之后，注册的类会变成 抽象基类的虚拟子类，而且 issubclass 和 isinstance 等函数都能识别，但是注册的类 不会从抽象基类中继承任何方法或属性。 register 方法通常作为普通的函数调用（参见 11.9 节），不过也可以作为装饰器使用。 123456@Tombola.register # Tombola是抽象基类class TomboList(list): pass# Python 3.3 或之前的版本，不能把 .register 当作类装饰器使用，必须使用标准的调用句法。Tombola.register(TomboList) 虚拟子类不会继承注册的抽象基类，而且任何时候都不会检查它是否符合抽 象基类的接口，即便在实例化时也不会检查。为了避免运行时错误，虚拟子类要实现 所需的全部方法。(不明白)TODO 异常python异常之间的层次结构：Exception hierarchy 元类编程类工厂函数通常，我们把 type 视作函数，因为我们像函数那样使用它，例如，调用 type(obj) 获取对象所属的类——作用与 obj.__class__ 相同。然而，type 是一个类。当成类使用时，传入三个参数可以新建一个类： 1MyClass = type('MyClass', (MySuperClass, MyMixin), &#123;'x': 42, 'x2': lambda self: self.x * 2&#125;) type 的三个参数分别是 name、bases 和 dict。最后一个参数是一个映射，指定新类的属性名和值。上述代码的作用与下述代码相同： 12345class MyClass(MySuperClass, MyMixin): x = 42 def x2(self): return self.x * 2 因此尝试创建一个类似于 namedtuple 的类工厂 12345678910111213141516171819202122232425262728def record_factory(cls_name, field_names): try: field_names = field_names.replace(',', ' ').split() except AttributeError: # 不能调用.replace或.split方法 pass # 假定field_names本就是标识符组成的序列 field_names = tuple(field_names) ➋ # 下面3个定义的函数是给新类的引用 def __init__(self, *args, **kwargs): # ➌ attrs = dict(zip(self.__slots__, args)) # 位置参数 依次对应 到 slots 中的属性 attrs.update(kwargs) # 关键字参数直接加入 attrs 中,关键字必须在 slots 中 for name, value in attrs.items(): setattr(self, name, value) def __iter__(self): # ➍ for name in self.__slots__: yield getattr(self, name) def __repr__(self): # ➎ values = ', '.join('&#123;&#125;=&#123;!r&#125;'.format(*i) for i in zip(self.__slots__, self)) return '&#123;&#125;(&#123;&#125;)'.format(self.__class__.__name__, values) # 组建类属性 cls_attrs = dict(__slots__=field_names, __init__=__init__, __iter__=__iter__, __repr__=__repr__) # 创建新的类 return type(cls_name, (object,), cls_attrs) record_factory 函数创建的类，其实例有个局限——不能序列化，如果想了解完整的方案，请分析 collections.nameduple 函数的源码（https://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py#l236），搜索“pickling”这个词。 定制描述符的类装饰器一旦组建好整个类，而且把描述符绑定到类属性上之后，我们就可以审查类，并为描述符设置合理的储存属性名称。因此我们要在创建类时设置储存属性的名称，使用类装饰器或元类可以做到这一点。我们首先使用较简单的方式。 类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类 123456789101112131415161718192021def entity(cls): #➊ cls 是类对象 for key, attr in cls.__dict__.items(): # ➋ 遍历类属性 if isinstance(attr, Validated): # ➌ 对 Validated 描述符的实例处理 desc = attr # 对描述符进行处理 type_name = type(desc).__name__ desc.storage_name = '_&#123;&#125;#&#123;&#125;'.format(type_name, key) return cls@entity class LineItem: description = NonBlank() weight = Quantity() price = Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price 类装饰器有个重大缺点：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承 也可能不继承装饰器所做的改动，具体情况视改动的方式而定。 因此需要元类。 导入时与运行时在导入时，解释器会从上到下一次性解析完 .py 模块的源码，然后生成用于执行的字节码。如果句法有错误，就在此时报告。如果本地的 __pycache__ 文件夹中有最新的 .pyc 文件，解释器会跳过上述步骤。 import 语句，它不只是声明，在进程中首次导入模块时，还会运行所导入模块中的全部顶层代码——以后导入相同的模块则使用缓存，只做名称绑定 顶层代码可以做任何事，包括通常在“运行时”做的事，如：连接数据库 解释器会编译函数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是显然解释器 不会执行函数的定义体 解释器会执行每个类的定义体，甚至会执行嵌套类的定义体，说明类的定义体属于”顶层代码” 接下来分析一下实际的import 与运行的情况 1234567891011121314151617181920212223242526# evalsupport.pyprint('&lt;[100]&gt; evalsupport module start')def deco_alpha(cls): print('&lt;[200]&gt; deco_alpha') def inner_1(self): print('&lt;[300]&gt; deco_alpha:inner_1') cls.method_y = inner_1 return clsclass MetaAleph(type): print('&lt;[400]&gt; MetaAleph body') def __init__(cls, name, bases, dic): print('&lt;[500]&gt; MetaAleph.__init__') def inner_2(self): print('&lt;[600]&gt; MetaAleph.__init__:inner_2') cls.method_z = inner_2print('&lt;[700]&gt; evalsupport module end') 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# evaltime.pyfrom evalsupport import deco_alphaprint('&lt;[1]&gt; evaltime module start')class ClassOne(): print('&lt;[2]&gt; ClassOne body') def __init__(self): print('&lt;[3]&gt; ClassOne.__init__') def __del__(self): print('&lt;[4]&gt; ClassOne.__del__') def method_x(self): print('&lt;[5]&gt; ClassOne.method_x') class ClassTwo(object): print('&lt;[6]&gt; ClassTwo body')@deco_alphaclass ClassThree(): print('&lt;[7]&gt; ClassThree body') def method_y(self): print('&lt;[8]&gt; ClassThree.method_y')class ClassFour(ClassThree): print('&lt;[9]&gt; ClassFour body') def method_y(self): print('&lt;[10]&gt; ClassFour.method_y')if __name__ == '__main__': print('&lt;[11]&gt; ClassOne tests', 30 * '.') one = ClassOne() one.method_x() print('&lt;[12]&gt; ClassThree tests', 30 * '.') three = ClassThree() three.method_y() print('&lt;[13]&gt; ClassFour tests', 30 * '.') four = ClassFour() four.method_y()print('&lt;[14]&gt; evaltime module end') 导入时代码的运行结果 1234567891011&gt;&gt;&gt; import evaltime&lt;[100]&gt; evalsupport module start&lt;[400]&gt; MetaAleph body&lt;[700]&gt; evalsupport module end&lt;[1]&gt; evaltime module start&lt;[2]&gt; ClassOne body # 每个类的定义体都执行了&lt;[6]&gt; ClassTwo body # 包括嵌套的类&lt;[7]&gt; ClassThree body&lt;[200]&gt; deco_alpha # 解释器先计算类3的定义体，然后调用依附在类上的装饰器函数&lt;[9]&gt; ClassFour body&lt;[14]&gt; evaltime module end 运行时的运行结果，顺序与 import 时一样，只不过是增加了 main 函数中的执行结果 123456789101112131415161718$ python3 evaltime.py&lt;[100]&gt; evalsupport module start&lt;[400]&gt; MetaAleph body&lt;[700]&gt; evalsupport module end&lt;[1]&gt; evaltime module start&lt;[2]&gt; ClassOne body&lt;[6]&gt; ClassTwo body&lt;[7]&gt; ClassThree body&lt;[200]&gt; deco_alpha&lt;[9]&gt; ClassFour body&lt;[11]&gt; ClassOne tests ..............................&lt;[3]&gt; ClassOne.__init__&lt;[5]&gt; ClassOne.method_x&lt;[12]&gt; ClassThree tests ..............................&lt;[300]&gt; deco_alpha:inner_1&lt;[13]&gt; ClassFour tests ..............................&lt;[10]&gt; ClassFour.method_y&lt;[14]&gt; evaltime module end 元类如果想定制整个类层次结构，而不是一次只定制一个类，使用元类更高效 元类是制造类的工厂，不过不是函数，而是类。元类是生产机器的机器。 根据 Python 对象模型，类是对象，因此类肯定是另外某个类的实例。默认情况下，Python 中的类是 type 类的实例，为了避免无限回溯，type 是其自身的实例 object 类和 type 类之间的关系很独特：object类 是 type 的实例，而 type 是 object 的子类。这种关系很“神奇”，无法使用 Python 代码表述，因为定义其中一个之前另一个必须存在。type 是自身的实例这一点也很神奇。 所有类（包括元类）都直接或间接地是 type 的实例， 不过只有元类同时也是 type 的子类。若想理解元类，一定要知道这种关系：元类（如 ABCMeta）从 type 类继承了构建类的能力。 元类的入口： init方法就元类本身而言，它们其实是很简单的： 1) 拦截类的创建 2) 修改类(在元类的__init__中) 3) 返回修改之后的类 在使用元类时，只要通过关键字metaclass=元类，那么在类对象cls加载（创建）完后，就会调用元类的__init__方法，对cls进行改造，而类装饰器是通过将 cls 直接传给函数，然后在函数中进行修改。 元类可以通过实现 __init__ 方法定制实例， __init__ 方法可以做到类装饰器能做的任何事情，但是作用更大。 __init__ 方法有四个参数，后面3个参数元 type 的一样： cls 要修改操作的类对象引用 name 类的名字 bases 类的超类 dic 类的属性字典 元类支持继承：ClassSix 类没有直接引用 MetaAleph 类，但是却受到了影响，因为它是 ClassFive 的子类，进而也是 MetaAleph 类的实例，所以由 MetaAleph.__init__ 方法初始化。 1234567891011121314151617181920212223242526# evalsupport.pyprint('&lt;[100]&gt; evalsupport module start')def deco_alpha(cls): print('&lt;[200]&gt; deco_alpha') def inner_1(self): print('&lt;[300]&gt; deco_alpha:inner_1') cls.method_y = inner_1 return clsclass MetaAleph(type): print('&lt;[400]&gt; MetaAleph body') def __init__(cls, name, bases, dic): print('&lt;[500]&gt; MetaAleph.__init__') def inner_2(self): print('&lt;[600]&gt; MetaAleph.__init__:inner_2') cls.method_z = inner_2print('&lt;[700]&gt; evalsupport module end') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# evaltime_meta.pytfrom evalsupport import deco_alphafrom evalsupport import MetaAlephprint('&lt;[1]&gt; evaltime_meta module start')@deco_alphaclass ClassThree(): print('&lt;[2]&gt; ClassThree body') def method_y(self): print('&lt;[3]&gt; ClassThree.method_y')class ClassFour(ClassThree): print('&lt;[4]&gt; ClassFour body') def method_y(self): print('&lt;[5]&gt; ClassFour.method_y')class ClassFive(metaclass=MetaAleph): print('&lt;[6]&gt; ClassFive body') def __init__(self): print('&lt;[7]&gt; ClassFive.__init__') def method_z(self): print('&lt;[8]&gt; ClassFive.method_z')class ClassSix(ClassFive): print('&lt;[9]&gt; ClassSix body') def method_z(self): print('&lt;[10]&gt; ClassSix.method_z')if __name__ == '__main__': print('&lt;[11]&gt; ClassThree tests', 30 * '.') three = ClassThree() three.method_y() print('&lt;[12]&gt; ClassFour tests', 30 * '.') four = ClassFour() four.method_y() print('&lt;[13]&gt; ClassFive tests', 30 * '.') five = ClassFive() five.method_z() print('&lt;[14]&gt; ClassSix tests', 30 * '.') six = ClassSix() six.method_z()print('&lt;[15]&gt; evaltime_meta module end') 1234567891011121314151617181920212223$python3 evaltime_meta.py&lt;[100]&gt; evalsupport module start&lt;[400]&gt; MetaAleph body&lt;[700]&gt; evalsupport module end&lt;[1]&gt; evaltime_meta module start&lt;[2]&gt; ClassThree body&lt;[200]&gt; deco_alpha&lt;[4]&gt; ClassFour body&lt;[6]&gt; ClassFive body&lt;[500]&gt; MetaAleph.__init__ # 创建 ClassFive 时调用了 MetaAleph.__init__ &lt;[9]&gt; ClassSix body&lt;[500]&gt; MetaAleph.__init__ # 创建 ClassSix 时也调用了 MetaAleph.__init__&lt;[11]&gt; ClassThree tests ..............................&lt;[300]&gt; deco_alpha:inner_1&lt;[12]&gt; ClassFour tests ..............................&lt;[5]&gt; ClassFour.method_y&lt;[13]&gt; ClassFive tests ..............................&lt;[7]&gt; ClassFive.__init__&lt;[600]&gt; MetaAleph.__init__:inner_2&lt;[14]&gt; ClassSix tests ..............................&lt;[7]&gt; ClassFive.__init__&lt;[600]&gt; MetaAleph.__init__:inner_2&lt;[15]&gt; evaltime_meta module end 注意，ClassSix 类没有直接引用 MetaAleph 类，但是却受到了影响，因为它是 ClassFive 的子类，进而也是 MetaAleph 类的实例，所以由 MetaAleph.init 方法初始化。 定制描述符的元类如果用户完全不用知道描述符或元类，直接继承库提供的类就能满足需求，那该多好 1234567891011121314class EntityMeta(type): \"\"\"元类，用于创建带有验证字段的业务实体\"\"\" def __init__(cls, name, bases, attr_dict): super().__init__(name, bases, attr_dict) for key, attr in cls.__dict__.items(): # ➋ 遍历类属性 if isinstance(attr, Validated): # ➌ 对 Validated 描述符的实例处理 desc = attr # 对描述符进行处理 type_name = type(desc).__name__ desc.storage_name = '_&#123;&#125;#&#123;&#125;'.format(type_name, key)class Entity(metaclass=EntityMeta): \"\"\"带有验证字段的业务实体\"\"\" 这样，用户直接继承 Entity 类即可，完全不需要考虑复杂的处理，甚至不用知道元类的存在 123456789101112class LineItem(Entity): description = NonBlank() weight = Quantity() price = Quantity() def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price __prepare__方法 这个特殊方法只在元类中有用，而且必须声明为类方法 在某些应用中，可能需要知道类的属性定义的顺序。在默认情况下，名称到属性的映射是无序字典dict；元类或类装饰器获得映射时，属性在类定义体中的顺序已经丢失了。 If the metaclass has no __prepare__ attribute, then the class namespace is initialised as an empty ordered mapping.(官网：默认是有序的了嘛?) 解决办法：Python 3 引入了特殊方法 __prepare__ （用 @classmethod 装饰器定义），返回一个 OrderedDict 对象，用于储存名称到属性的映射。这样就保留了要构建的类在定义体中绑定属性的顺序。 在调用 __new__ 和__init__方法之前，由解释器调用 __prepare__ 方法获得 OrderedDict 对象，将其传给元类的 __new__ 和 __init__ 方法的 attr_dict 特殊属性dir(...) 函数不会列出本节提到的任何一个属性 参见标准库参考中“Built-in Types”一章的“4.13. Special Attributes”一节。 其中三个属性在本书中已经见过多次：__mro__、__class__ 和 __name__。此外，还有以下属性。 cls.__bases__：由类的基类组成的元组。 cls.__qualname__：Python 3.3 新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类的点分路径。例如，ClassOne的内部类 ClassTwo 的 __qualname__ 属性，其值是字符串 ‘ClassOne.ClassTwo‘，而 __name__ 属性的值是 ‘ClassTwo’ cls.__subclasses__()：这个方法返回一个列表，列表中是内存里现存的子类，包含类的直接子类。这个方法的实现使用弱引用，防止在超类和子类（子类在 __bases__ 属性中储存指向超类的强引用）之间出现循环引用。 cls.mro()：构建类时，如果需要获取储存在类属性 __mro__ 中的超类元组，解释器会调用这个方法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。 类的创建过程默认情况下，类通过type()函数创建，类的定义体在一个新的命名空间中执行，类名被绑定为\u0005type(name, bases, namespace)的结果 当类的定义代码被执行了以后，会进行以下步骤： MRO entries are resolved; the appropriate metaclass is determined; the class namespace is prepared; the class body is executed; the class object is created. 想要自定义 类的创建过程，可以在定义类时，通过 metaclass参数指定元类，或者继承自有 metalclass 参数的父类，如下：MyClass 和 MySubclass 都是 元类 Meta 的实例 123456789# both MyClass and MySubclass are instances of Meta:class Meta(type): passclass MyClass(metaclass=Meta): passclass MySubclass(MyClass): pass 1.处理 MRO 名单 Resolving MRO entries 不明白 If a base that appears in class definition is not an instance of type, then an __mro_entries__ method is searched on it. If found, it is called with the original bases tuple. This method must return a tuple of classes that will be used instead of this base. The tuple may be empty, in such case the original base is ignored. 2.确定合适的元类 没有基类和指定的元类，那么就是默认的 type 元类 有指定元类，并且不是 type()的实例，那么直接用它作为元类 type()的实例被指定为元类，或者指定了基类，那么使用the most derived metaclass most derived metaclass 是从显示指定的元类(if any)和所有基类的元类中选出来的。most derived metaclass 是这些候选元类的子类型(subtype)，如果不满足该条件，抛出TypeError 3.准备类的命名空间 合适元类决定下来后，就开始准备命名空间。 如果元类有__prepare__()属性（方法），那么命名空间就由该函数的返回值确定，namespace =metaclass.__prepare__(name, bases, **kwds) kwds 是来自类定义时的参数(if any) 如果没有__prepare__()属性（方法），那么命名空间就初始化为空的有序字典(empty ordered mapping) 4.执行类的定义体 类定义体 会以exec(body, globals(), namespace)的方式执行，与普通调用exec()的关键不同是：当类的定义是在函数中时，lexical scoping 允许类定义体引用当前范围与外部范围的名字(不是很明白) 5.创建出类对象 执行类主体填充类命名空间后，通过调用metaclass(name, bases, namespace, **kwds)来创建 类对象，也就会调用 metaclass .__init__()。 类对象会被super()所引用，在类中，如果有方法使用了__class__ 或super，__class__就会成为一个隐式的闭包。 当使用默认的元类type，或者最终调用type.__new__的其他元类，在创建类对象后，下面这些额外可自定义的步骤会被调用 first, type.__new__ collects all of the descriptors in the class namespace that define a __set_name__() method; second, all of these __set_name__ methods are called with the class being defined and the assigned name of that particular descriptor; finally, the __init_subclass__() hook is called on the immediate parent of the new class in its method resolution order. 在类对象创建完成后，如果有类装饰器的话，就会被传到其中，返回的新的类对象才会被绑定到本地的命名空间中，成为定义的类 类属性访问的优先级参考：http://www.betterprogramming.com/object-attribute-lookup-in-python.html Class “C” 是 Metaclass “M”的实例 , 调用 C.name 会进行下面的步骤： 获取类的Metaclass (Get the Metaclass from Class) 调用Metaclass的特殊方法 __getattribute__ __getattribute__的内部逻辑： 123456789101112131415161718192021222324252627282930def __getattribute__(): meta_attr= None # 元类属性 for meta_parent in Metaclass.__mor__: if meta_parent.__dict__['name'] is not None: meta_attr = meta_parent.__dict__['name'] if meta_attr is data descriptor: return meta_attr.__get__() # 返回元类的数据描述符的值 break # 在继承链中查找，只要找到就返回， for class_parent in Class.__mro__: if class_parent.__dict__['name'] is not None: cls_attr = class_parent.__dict__['name'] if cls_attr is data/non-data descriptor: return cls_attr.__get__() # 获取描述符的值 return cls_attr #返回普通的值 # 返回元类的属性 if meta_attr is not None: if meta_attr is non-data descriptor: return meta_attr.__get__() return meta_attr raise an AttributeError # 都没有找到，抛出异常if MetaClass has the special method __getattr__: return MetaClass.__getattr__() 结语元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类： 1） Monkey patching 2) class decorators 当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 重载Python 施加了一些限制，做好了灵活性、可用性和安全性方面的平衡： 不能重载内置类型的运算符 不能新建运算符，只能重载现有的 某些运算符不能重载——is、and、or 和 not（不过位运算符 &amp;、| 和 ~ 可以） 一元运算符只需实现相应的特殊方法。这些特殊方法只有一个参数：self，始终返回一个新对象，也就是说，不能修改self -（__neg__）：一元取负算术运算符。如果 x 是 -2，那么 -x == 2。 +（__pos__）：一元取正算术运算符。通常，x == +x，但也有一些例外。如果好奇，请阅读“x 和 +x 何时不相等”附注栏。 ~（__invert__）：对整数按位取反，定义为 ~x == -(x+1)。如果 x 是 2，那么 ~x == -3。 12345678def __abs__(self): return math.sqrt(sum(x * x for x in self))def __neg__(self): return Vector(-x for x in self)def __pos__(self): return Vector(self) x 和 +x 何时不相等 第一例与 decimal.Decimal 类有关， x 是 Decimal 实例，在算术运算的上下文中创建，然后在不同的上下文中计算 +x，那么 x != +x 123456789101112131415import decimalctx = decimal.getcontext()ctx.prec = 40 # 设置上下文精度one_third = decimal.Decimal('1') / decimal.Decimal('3')# Decimal('0.3333333333333333333333333333333333333333')one_third == +one_third ➎# Truectx.prec = 28 # 修改精度，不同上下文one_third == +one_third ➐# False+one_third# Decimal('0.3333333333333333333333333333') 第二例与 collections.Counter 类有关 Counter 相加时，负值和零值计数会从结果中剔除。而一元运算符 + 等同于加上一个空 Counter，因此它产生一个新的 Counter 且仅保留大于零的计数器 1234567891011ct = Counter('abracadabra')# Counter(&#123;'a': 5, 'r': 2, 'b': 2, 'd': 1, 'c': 1&#125;)ct['r'] = -3ct['d'] = 0ct# Counter(&#123;'a': 5, 'b': 2, 'c': 1, 'd': 0, 'r': -3&#125;)+ct # Counter(&#123;'a': 5, 'b': 2, 'c': 1&#125;) 二元运算符实现一元运算符和中缀运算符的特殊方法一定不能修改操作数，__add__返回一个新 Vector 实例，而没有影响 self 或 other。 二元运算的反向(不同类型之间的运算)为了支持不同类型之间的运算，Python 为中缀运算符特殊方法提供了特殊的分派机制： 对表达式 a + b 来说，解释器会执行以下几步操作（见图） 如果 a 有__add__ 方法，而且返回值不是 NotImplemented，调用 a.__add__(b)， 然后返回结果。 如果 a 没有__add__方法，或者调用 __add__ 方法返回 NotImplemented，检查 b 有没有__radd 方法，如果有，而且没有返回 NotImplemented，调用 `b.radd__(a)`，然后返回结果。 __radd__ 是 __add__ 的反向”（reversed）版本或者“反射”（reflected）版本 如果 b 没有 __radd__ 方法，或者调用 __radd__ 方法返回 NotImplemented，抛出 TypeError，解释器会在错误消息中指明操作数类型不支持：TypeError: unsupported operand type(s) for +: &#39;Class1&#39; and &#39;Class2&#39; 别把 NotImplemented 和 NotImplementedError 搞混了。 前者是特殊的单例值，如果中缀运算符特殊方法不能处理给定的操作数，那么要把它return给解释器，让解释器尝试对调操作数，调用运算符的反向特殊方法（如__radd__ ）。 而 NotImplementedError 是一种异常，抽象类中的占位方法把它抛出（raise），提醒子类必须覆盖 反向方法一般只需委托正向的方法即可。 如果中缀运算符的正向方法（如 __mul__）只处理与 self 属于同 一类型的操作数，那就无需实现对应的反向方法（如__rmul__），因为按照定义， 反向方法是为了处理类型不同的操作数。 操作数类型不同时的异常处理考虑一下可能发生的错误（Vector 代表向量）： 如果提供的对象不可迭代（Vector([1,2]) + 1），那么 __add__ 就无法处理，而且提供的错误消息不是很有用。 如果操作数是可迭代对象（Vector([1,2]) + &#39;ABC&#39;），但是它的元素不能与 Vector 中的浮点数元素相加，给出的消息也没什么用 如果操作数的类型不同，我们要检测出不能处理的操作数。两种方式可以处理这个问题： 鸭子类型，直接尝试执行运算，如果有问题，捕获 TypeError 异常； 另一种是显式使用 isinstance 测试，__mul__ 方法就是这么做的。 这两种方式各有优缺点：鸭子类型更灵活，但是显式检查更能预知结果。如果选择使用isinstance，要小心，不能测试具体类，而要测试抽象基类，比如：numbers.Real 方法1：为了遵守鸭子类型精神，我们不能测试 other 操作数的类型，或者它的元素的类型，我们要捕获异常，然后返回 NotImplemented 12345678910# 最终版本def __add__(self, other): try: pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs) except TypeError: return NotImplementeddef __radd__(self, other): return self + other 方法2：白鹅类型。我们将使用 isinstance() 检查 scalar 的类型，但是不硬编码具体的类型，而是检查 numbers.Real 抽象基类。 1234567891011# 最终版本import numbersdef __mul__(self, scalar): if isinstance(scalar, numbers.Real): return Vector(n * scalar for n in self) else: return NotImplementeddef __rmul__(self, scalar): return self * scalar 比较运算符号 正向方法返回NotImplemented的话， 调用反向方法 参数对调：对 == 来说，正向和反向调用都是__eq__方法，只是把参数对调了；正向的 __gt__ 方法调用的是反向的 __lt__方法，并把参数对调 后备机制：对 == 和!= 来说，如果反向调用失败，Python有后备机制， 会比较对象的 ID，而不抛出 TypeError != 运算符我们不用实现它：因为从 object 继承的 __ne__ 方法的后备行为满 足了我们的需求：定义了 __eq__ 方法，而且它不返回 NotImplemented，__ne__ 会对__eq__返回的结果取反。 注意类型检查 对操作数过度宽容可能导致令人惊讶的结果，因此，我们要保守一点，做些类型检查。 1234567def __eq__(self, other): # 如果other操作数是Vector实例或子类的实例，那就像之前那样比较。 if isinstance(other, Vector): return (len(self) == len(other) and all(a == b for a, b in zip(self, other))) else: return NotImplemented 增量赋值运算符(就地方法) 就地运算符(+=,*=)用于增量赋值 如果一个类没有实现表中列出的就地运算符，增量赋值运算符只是语法糖：a += b 的 作用与 a = a + b 完全一样。对不可变类型来说，这是预期的行为，而且，如果定义了 __add__ 方法的话，不用编写额外的代码，+= 就能使用。 增量赋值不会修改不可变类型，而是新建实例，然后重新绑定 可变类型实现了就地运算符方法，会就地修改左操作数，而不会创建新对象作为结果，必须返回 self。 例子 1234567891011121314151617181920212223242526import itertoolsfrom tombola import Tombolafrom bingo import BingoCageclass AddableBingoCage(BingoCage): def __add__(self, other): if isinstance(other, Tombola): return AddableBingoCage(self.inspect() + other.inspect()) else: return NotImplemented def __iadd__(self, other): # 是否同类型 if isinstance(other, Tombola): other_iterable = other.inspect() # 尝试迭代 other else: try: other_iterable = iter(other) except TypeError: self_cls = type(self).__name__ msg = \"right operand in += must be &#123;!r&#125; or an iterable\" raise TypeError(msg.format(self_cls)) self.load(other_iterable) return self 在实现的过程中，我们得知在可接受的类型方面，+ 应该比 += 严格。对序列类型来说，+ 通常要求两个操作数属于同一类型，而 += 的右操作数往往可以是任何可迭代对象。 上下文管理器和 else 块else不过与if/else差别很大，使用then关键字更好理解 总结：如果异常或者 return、break 或 continue 语句导致控制权跳到了复合语句的主块之外，else 子句也会被跳过。 for：仅当 for 循环运行完毕时（即 for 循环没有被 break 语句中止）才运行 else 块。 while：仅当 while 循环因为条件为假值而退出时（即 while 循环没有被 break 语句中止） 才运行 else 块。 try :仅当 try 块中没有异常抛出时才运行 else 块。官方文档还指出：“else 子句抛出的异常不会由前面的 except 子句处理。” 12345for item in my_list: if item.flavor == 'banana': break else: raise ValueError('No banana flavor found!') 下面有个疑问：有必要用 else吗？(TODO)，直接写 after_call()可以吗？ 123456try: dangerous_call()except OSError: log('OSError...')else: after_call() with与上下文管理器 上下文管理器协议包含 __enter__ 和 __exit__ 两个方法。 在定义类时，含有__enter__和__exit__方法的对象就是上下文管理器。 with语句的目的是简化try/finally模式。当with遇到上下文管理器，就会在执行语句体之前，先执行上下文管理器的__enter__方法，然后再执行语句体，执行完语句体后，最后执行__exit__方法，以此扮演 finally子句的角色 这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、return语句或sys.exit()调用而中止，也会执行指定的操作。 12345678910111213141516171819202122class ContextManager(object): def __init__(self): print('实例化一个对象') def __enter__(self): print('进入') # return self def __exit__(self, exc_type, exc_val, exc_tb): print('退出') # return True# with 上下文管理器：# 语句体obj = ContextManager()with obj: print('正在执行')# 实例化一个对象# 进入# 正在执行# 退出 与函数和模块不同，with 块没有定义新的作用域，退出后变量还可以使用。 enter 与 exit 细节 12with 上下文管理器 as target: 代码语句体 参数 解释器调用 __enter__ 方法时，除了隐式的 self 之外，不会传入任何参数。 传给 __exit__ 方法的三个参数列举如下: exc_type：异常类（例如 ZeroDivisionError） exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用 exc_value.args 获取。 traceback：traceback 对象 如果一切正常，Python 调用 __exit__ 方法时传入的参数是 None, None, None；如果抛出了异常，这三个参数是异常数据 返回值 如果使用了as，则是把上下文管理器的 __enter__() 方法的返回值赋值给 target，target 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”），__enter__ 方法除了返回上下文管理器之外，还可能返回其他对象。 出现异常时，__exit__ 返回 False（默认不写返回值时，即为False），则会重新抛出异常，让with之外的语句逻辑来处理异常，这也是通用做法；如果返回True，则忽略异常，不再对异常进行处理 请看下面的具体例子： 1234567891011121314151617181920212223242526272829class LookingGlass: def __enter__(self): import sys self.original_write = sys.stdout.write sys.stdout.write = self.reverse_write # 替换标准输出 return 'JABBERWOCKY' def reverse_write(self, text): self.original_write(text[::-1]) def __exit__(self, exc_type, exc_value, traceback): import sys sys.stdout.write = self.original_write # 恢复标准输出 if exc_type is ZeroDivisionError: print('Please DO NOT divide by zero!') return Truewith LookingGlass() as what: print('Alice, Kitty and Snowdrop') print(what)# pordwonS dna yttiK ,ecilA# YKCOWREBBAJ# with 块已经执行完毕。输出不再是反向的了。可以看出，__enter__ 方法返回的值——即存储在 what 变量中的值——是字符串'JABBERWOCKY'。print(what) print('Back to normal.')# 'JABBERWOCKY'# Back to normal. 上下文管理器对象存在的目的是管理with语句，就像迭代器的存在是为了管理for语句一样。 使用@contextmanager @contextmanager装饰器优雅且实用，把三个不同的 Python 特性结合到了一起：函数装 饰器、生成器和 with 语句。 用法形式 在使用 @contextmanager 装饰的生成器中，yield 语句的作用是把函数的定义体分成两部分： yield 语句前面的所有代码在 with 块开始时（即解释器调用 __enter__ 方法时）执行 yield 语句后面的代码在 with 块结束时（即调用 __exit__ 方法时）执行 在 @contextmanager 装饰器装饰的生成器中，yield 与迭代没有任何关系 原理 其实，contextlib.contextmanager 装饰器会把函数包装成实现 __enter__ 和 __exit__ 方法的类。 类的名称是 _GeneratorContextManager。具体的工作方式，可以阅读 Python 3.4 发行版中 Lib/contextlib.py。 这个类的 __enter__ 方法有如下作用： 调用生成器函数，保存生成器对象（这里把它称为 gen） 调用 next(gen)，执行到 yield 关键字所在的位置 返回 next(gen) 产出的值，以便把产出的值绑定到 with/as 语句中的目标变量上。 with 块终止时，__exit__ 方法会做以下几件事： 检查with有没有发生异常，有没有把异常传给 exc_type；如果有，调用 gen.throw(exception)，在生成器函数定义体中包含 yield 关键字的那一行抛出异常，但是，如果那里没有处理错误的代码，可能出现无法避免的错误(具体见下面的例子) 否则，调用 next(gen)，继续执行生成器函数定义体中 yield 语句之后的代码。 12345678910111213141516171819202122232425262728293031323334import contextlib@contextlib.contextmanagerdef looking_glass(): import sys original_write = sys.stdout.write def reverse_write(text): original_write(text[::-1]) sys.stdout.write = reverse_write msg = '' # 使用 try 的原因如下面的解释： try: yield 'JABBERWOCKY' except ZeroDivisionError: msg = 'Please DO NOT divide by zero!' finally: sys.stdout.write = original_write if msg: print(msg) '''测试'''with looking_glass() as what: print('Alice, Kitty and Snowdrop') print(what) raise ZeroDivisionError # 模拟在 with 块中抛出异常# pordwonS dna yttiK ,ecilA# YKCOWREBBAJprint(what)# 'JABBERWOCKY' 如果在 with 块中抛出了异常，Python 解释器会将其捕获， 然后在 looking_glass 函数的 yield 表达式里再次抛出。但是，如果那里没有处理错误的代码， looking_glass 函数会中止，永远无法恢复成原来的 sys.stdout.write 方法，导致系统处于无效状态。 默认返回值 使用 @contextmanager 装饰器时，默认的行为是返回 True，与上下文管理器默认返回False不同：装饰器提供的 __exit__方法假定发给生成器的所有异常都得到处理了，因此应该压制异常。 如果不想让 @contextmanager 压制异常，必须在被装饰的函数中显式重新抛出异常。 有意思的两个例子上下文管理器有两种写法，下面一种是使用装饰器的方式，实现了一个计时器。 要点： 使用contextmanager装饰器 在函数中使用yield进入with语句块 12345678910111213141516171819202122232425262728from time import timefrom contextlib import contextmanager@contextmanagerdef timer(): print(\"进入'with'语句块 之前，进行初始化工作...\") start = time() print(f'start:&#123;start&#125;') print(\"马上就进入'with'语句块...\") yield # 进入 with 语句块，执行其内容 print(\"退出 'with' 语句块 之后，进行收尾工作...\") print(f'end:&#123;time()&#125;, cost time: &#123;time() - start&#125;') def do_something(): xx = [] for i in range(10000): for j in range(10000): xx.append(j) xx.clear()if __name__ == '__main__': with timer() as t: do_something() 再来一个通过实现接口定义类的方式，实现了一个文本缩进。 要点： 实现__enter__,__exit__ 方法 可以重复使用同一个上下文 12345678910111213141516171819202122class Indeter: def __init__(self): self.level = -1 def __enter__(self): self.level += 1 return self def __exit__(self, exc_type, exc_val, exc_tb): self.level -= 1 def print(self, text): print(\"\\t\"*self.level+text) if __name__==\"__main__\": with Indeter() as idt: idt.print('第一章') with idt: idt.print('第一节') with idt: idt.print('第一段') 协程协同程序，协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。 从句法上看，协程与生成器类似，都是定义体中包含 yield 关键字的函数。 但是在协程中，yield 通常出现在表达式的右边（例如，datum = yield data），可以产出值，也可以不产出——如果 yield 关键字后面没有表达式，那么生成器产出 None。 协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是 .send(datum) 方法，而不是 next(…) 函数。通常，调用方会把值推送给协程。 123456789101112131415161718192021def simple_coroutine(): print('-&gt; coroutine started') x = yield # 需要调用 next 后，才会停在这里 print('-&gt; coroutine received:', x)my_coro = simple_coroutine()print(my_coro)# ➌ &lt;generator object simple_coroutine at 0x100c2be10&gt;#预先激活next(my_coro) # -&gt; coroutine started#发送数据my_coro.send(42) ## -&gt; coroutine received: 42# 运行到结束，抛出 stopIteration# Traceback (most recent call last):# ...# StopIteration 协程状态协程可以身处四个状态中的一个。当前状态可以使用 inspect.getgeneratorstate(...) 函数确定： ‘GEN_CREATED’：等待开始执行，通过对其调用next()进入下一个状态 ‘GEN_RUNNING’ ：解释器正在执行 只有在多线程应用中才能看到这个状态。此外，生成器对象在自己身上调用 getgeneratorstate 函数也行，不过这样做没什么用。 ‘GEN_SUSPENDED’ ：在 yield 表达式处暂停 ‘GEN_CLOSED’ ：执行结束 协程在 yield 关键字所在的位置暂停执行，在赋值语句中，= 右边的代码在赋值之前执行。因此，对于 b = yield a 这行代码来说，等到客户端代码 再激活协程时才会设定 b 的值。具体看下面的图示： 1234567891011121314151617181920212223242526272829303132def simple_coro2(a): print('-&gt; Started: a =', a) b = yield a print('-&gt; Received: b =', b) c = yield a + b print('-&gt; Received: c =', c)from inspect import getgeneratorstatemy_coro2 = simple_coro2(14)print(getgeneratorstate(my_coro2))# 'GEN_CREATED'print(next(my_coro2)) #预激，进入下一个状态# -&gt; Started: a = 14# 14print(getgeneratorstate(my_coro2))# 'GEN_SUSPENDED'my_coro2.send(28)# -&gt; Received: b = 2842my_coro2.send(99)# -&gt; Received: c = 99# Traceback (most recent call last):# File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;# StopIterationprint(getgeneratorstate(my_coro2))# 'GEN_CLOSED' 预激协程的装饰器12345678910111213141516171819def averager(): total = 0.0 count = 0 average = None while True: term = yield average #➊ total += term count += 1 average = total/count coro_avg = averager()next(coro_avg)# 需要通过next()进行预激，让代码运行到➊处print(coro_avg.send(10))# 10.0print(coro_avg.send(30))# 20.0print(coro_avg.send(5))# 15.0 使用协程之前必须预激，可是这一步容易忘记。为了避免忘记，可以在协程上使用一个特殊的装饰器 123456789101112131415161718192021222324252627282930313233343536from functools import wrapsdef coroutine(func): \"\"\"装饰器：向前执行到第一个`yield`表达式，预激`func`\"\"\" @wraps(func) def primer(*args,**kwargs): gen = func(*args,**kwargs) next(gen) # 预激 return gen return primer @coroutinedef averager(): total = 0.0 count = 0 average = None while True: term = yield average total += term count += 1 average = total/count'''测试'''from inspect import getgeneratorstatecoro_avg = averager()getgeneratorstate(coro_avg)# 'GEN_SUSPENDED'coro_avg.send(10)# 10.0coro_avg.send(30)# 20.0coro_avg.send(5)# 15.0 终止协程和异常处理协程中未处理的异常会向上冒泡，传给 next 函数或 send 方法的调用方（即触发协程的对象） 在协程内没有处理异常，协程会终止。如果试图重新激活协程，会抛出 StopIteration 异常。 从 Python 2.5 开始，客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。 generator.throw(exc_type[, exc_value[, traceback]]) 致使生成器在【暂停的 yield 表达式处】抛出指定的异常。 如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为throw 方法的返回值。 如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。 generator.close() 致使生成器在【暂停的 yield 表达式处】抛出 GeneratorExit 异常，协程正常关闭 如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会报错。 收到 GeneratorExit 异常后，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。生成器抛出的其他异常会向上冒泡，传给调用方。 1234567891011121314151617181920212223242526272829303132333435363738394041class DemoException(Exception): \"\"\"为这次演示定义的异常类型。\"\"\" passdef demo_exc_handling(): print('-&gt; coroutine started') while True: try: x = yield except DemoException: print('*** DemoException handled. Continuing...') else: print('-&gt; coroutine received: &#123;!r&#125;'.format(x)) raise RuntimeError('This line should never run.')exc_coro = demo_exc_handling()next(exc_coro)# -&gt; coroutine startedexc_coro.send(11)# -&gt; coroutine received: 11from inspect import getgeneratorstate# 1. 正常 closeexc_coro.close()print(getgeneratorstate(exc_coro))# 'GEN_CLOSED'# 2. 抛出可处理的异常，协程继续exc_coro.throw(DemoException)# *** DemoException handled. Continuing...print(getgeneratorstate(exc_coro))# GEN_SUSPENDED# 3. 抛出不可处理的异常，协程关闭，异常冒泡exc_coro.throw(ZeroDivisionError)# Traceback (most recent call last):# ZeroDivisionErrorprint(getgeneratorstate(exc_coro))# 'GEN_CLOSED' 协程的返回值在 Python 3.3 之前，如果生成器返回值，解释器会报句法错误。 return 表达式的值会传给调用方，赋值给 StopIteration 异常的一个属 性。这样做有点不合常理，但是能保留生成器对象的常规行为——耗尽时抛出 StopIteration 异常。 123456789101112131415161718192021222324252627282930from collections import namedtupleResult = namedtuple('Result', 'count average')def averager(): total = 0.0 count = 0 average = None while True: term = yield # 取消了term = yield average 形式 if term is None: break # 通过传入 None 跳出并返回 Result total += term count += 1 average = total/count return Result(count, average) coro_avg = averager()next(coro_avg) # 预激coro_avg.send(10)coro_avg.send(30)coro_avg.send(6.5)# 获取返回值try: coro_avg.send(None)except StopIteration as exc: result = exc.valueprint(result)# Result(count=3, average=15.5) yield from概念与功能使用 yield from 句法调用协程时，会自动预激 yield from x 表达式对 x 对象所做的第一件事是，调用 iter(x)，从中获取迭代器。因此，x 可以是任何可迭代的对象。(替代产出值的嵌套 for 循环) yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。 术语概念 委派生成器在 yield from 表达式处暂停时， 调用方可以直接把数据发给子 生成器， 子生成器再把产出的值发给调用方。 子生成器返回之后， 解释器会抛出 StopIteration 异常， 并把返回值附加到异常对象上， 此时委派生成器会恢复 委派生成器：包含 yield from &lt;iterable&gt; 表达式的生成器函数。 子生成器：从 yield from 表达式中 &lt;iterable&gt; 部分获取的生成器。 这就是 PEP 380 的标题 （“Syntax for Delegating to a Subgenerator”）中所说的“子生成器”（subgenerator）。 调用方 ：PEP 380 指代调用委派生成器的客户端代码。 在不同的语境中，我会使用“客户端”代替“调用方”，以此与委派生成器（也是调用方，因为它调用了子生成器）区分开。 在生成器 gen 中使用 yield from subgen() 时，子生成器 subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直接控制 subgen。与此同时，gen 会阻塞，等待 subgen终止返回 subgen 返回的值会成为 yield from 表达式的值：yield from 会处理解释器会抛出 StopIteration 异常，获取附加到异常对象上的返回值， 此时委派生成器会恢复 子生成器 subgen 可能是简单的迭代器，只实现了 __next__ 方法，yield from 也能处理这种子生成器。不过，引入 yield from 结构的目的是为了支持实现了 __next__、send、close 和 throw 方法的生成器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from collections import namedtupleResult = namedtuple('Result', 'count average')# 子生成器def averager(): total = 0.0 count = 0 average = None while True: term = yield if term is None: break total += term count += 1 average = total / count return Result(count, average) # 返回的值会成为 yield from 表达式的值# 委派生成器def grouper(results, key): # 这是个协程，运行结束后会抛出 StopIteration，因此 True 是让它永不结束，然后在➊处覆盖实例，让解释器垃圾回收即可，不用担心无限循环，后面有个不用 True 的版本 while True: results[key] = yield from averager() # yield from 会处理 解释器会抛出 StopIteration 异常，获取附加到异常对象上的返回值， 此时委派生成器会恢复# 客户端代码，即调用方def main(data): results = &#123;&#125; for key, values in data.items(): group = grouper(results, key) # ➊ group 是个生成器 next(group) for value in values: group.send(value) group.send(None) # 重要！ # print(results) # 如果要调试，去掉注释 report(results)# 输出报告def report(results): for key, result in sorted(results.items()): group, unit = key.split(';') print('&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'.format(result.count, group, result.average, unit))data = &#123; 'girls;kg': [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5], 'girls;m': [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43], 'boys;kg': [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3], 'boys;m': [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],&#125;if __name__ == '__main__': main(data) 不用 True 的版本 12345678910111213141516171819202122232425# 委派生成器def grouper(results, key): # while True: # print(\"start\") # results[key] = yield from averager() # print(\"end\") # print(results) results[key] = yield from averager() # 收到 None 后，委托生成器恢复运行 print(\"end\") # 然后该协程会抛出 StopIteration# 客户端代码，即调用方def main(data): results = &#123;&#125; for key, values in data.items(): group = grouper(results, key) next(group) for value in values: group.send(value) try: group.send(None) # 重要！ except StopIteration: # 处理委托生成器的异常 pass yield from 的行为 子生成器产出的值都直接传给委派生成器的调用方（即客户端代码）。 调用方使用 send() 方法发给委派生成器的值都直接传给子生成器。如果发送的值是 None，那么会调用子生成器的 __next__() 方法。如果发送的值不是 None，那么会调用子生成器的 send() 方法。如果调用的方法抛出 StopIteration 异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。 生成器退出时，生成器（或子生成器）中的 return expr 表达式会触发 StopIteration(expr) 异常抛出。 yield from 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数。 yield from 结构的另外两个特性与异常和终止有关。 传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的 throw() 方法。如果调用 throw() 方法时抛出 StopIteration 异常，委派生成器恢复运 行。StopIteration 之外的异常会向上冒泡，传给委派生成器。 如果把 GeneratorExit 异常传入委派生成器，或者在委派生成器上调用 close() 方 法，那么在子生成器上调用 close() 方法，如果它有的话。如果调用 close() 方法 导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 GeneratorExit 异常。 伪代码模拟yield from 的行为伪代码，等效于委派生成器中的 RESULT = yield from EXPR 语句 123456789101112131415161718192021222324252627282930313233343536373839404142_i = iter(EXPR) # ➊ EXPR 可以是任何可迭代的对象try: _y = next(_i) # ➋ 预激子生成器except StopIteration as _e: _r = _e.value # ➌else: while True: # ➍ try: _s = yield _y # ➎ # ➏ 这一部分用于关闭委派生成器和子生成器。 except GeneratorExit as _e: # 因为子生成器可以是任何可迭代的对象， 所以可能没有 close 方法。 try: _m = _i.close except AttributeError: pass else: _m() raise _e # 这一部分处理调用方通过 .throw(...) 方法传入的异常 except BaseException as _e: _x = sys.exc_info() try: _m = _i.throw except AttributeError: # ➐如果子生成器可以是迭代器，从而没有 throw 方法可调用 raise _e else: # ➑ 如果子生成器有 throw 方法，调用它并传入调用方发来的异常。 try: _y = _m(*_x) except StopIteration as _e: _r = _e.value break else: # ➒ 如果产出值时没有异常 try: # ➓ 尝试让子生成器向前执行 if _s is None: # ⓫ _y = next(_i) else: _y = _i.send(_s) except StopIteration as _e: # ⓬ 子生成器抛出 StopIteration 异常，获取 value 属性的值，赋值给 _r，然后退 出循环，让委派生成器恢复运行。 _r = _e.value breakRESULT = _r 内建模块collectionsnamedtuple1234Point = namedtuple('Point', ['x', 'y'])&gt;&gt;&gt; p = Point(1, 2)&gt;&gt;&gt; p.x1 namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。 dequedeque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。 defaultdict如果希望key不存在时，返回一个默认值，就可以用defaultdict ，dd = defaultdict(lambda: &#39;N/A&#39;) 默认值是调用函数返回的，而函数在创建defaultdict对象时传入。 OrderedDictOrderedDict的Key会按照插入的顺序排列，不是Key本身排序 ChainMapChainMap可以把多个dict组成一个逻辑上的dict。ChainMap本身也是一个dict，但是查找的时候，会按照顺序在内部的dict依次查找。 12345678910111213141516171819202122232425# 举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。# 我们可以用ChainMap实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。from collections import ChainMapimport os, argparse# 构造缺省参数:defaults = &#123; 'color': 'red', 'user': 'guest'&#125;# 构造命令行参数:parser = argparse.ArgumentParser()parser.add_argument('-u', '--user')parser.add_argument('-c', '--color')namespace = parser.parse_args()command_line_args = &#123; k: v for k, v in vars(namespace).items() if v &#125;# 组合成ChainMap: 依次从这3个字典里查找是否有指定的字段，优先级依次递减combined = ChainMap(command_line_args, os.environ, defaults)# 打印参数:print('color=%s' % combined['color'])print('user=%s' % combined['user']) Counter常用的就是items()k-v对, keys()键, values()值 ,elements()打印全部的 k(出现几次就重复几次) 123456789101112131415from collections import Counters=['asdf','asd','asdf','sdf']c=Counter(s)print(c)for k,v in c.items(): print(k,v)print(\"-----\")for i in c.elements(): print(i)print(\"-----\")for i in c.keys(): print(i)print(\"-----\")for i in c.values(): print(i) https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000 itertools可以参考流畅的 python14.9中的标准函数库，里面有详细的介绍 reducereduce 函数时最好提供第三个参数，reduce(function, iterable, initializer)，这样能避免这个异常：TypeError: reduce() of empty sequence with no initial value（这个错误消息很棒，说明了问题，还提供了解决方法）。如果序列为空，initializer 是返回的结果； zipzip 函数的名字取自拉链系结物（zipper fastener），因为这个物品用于把 两个拉链边的链牙咬合在一起，与文件压缩没有关系。 itertools.zip_longest 函数的行为有所不同：使用可选的 fillvalue（默认 值为 None）填充缺失的值，因此可以继续产出，直到最长的可迭代对象耗尽。 all如果所有分量对的比较结果都是 True，那么结果就是 True。只要有一次比较的结果是 False，all 函数就返回 False。 return len(self) == len(other) and all(a == b for a, b in zip(self, other)) 可迭代的归约函数 表中的函数都接受一个可迭代的对象(iterable)，然后返回单个结果。这些函数叫“归约”函数（“合拢”函数或“累加”函数） 这里列出的每个内置函数都可以使用 functools.reduce 函数实现 但是对 all 和 any 函数来说，有一项重要的优化措施是 reduce 函数做不到的：这两个函数会短路（一旦确定了结果就立即停止使用迭代器） 123456# 短路现象g = (n for n in [0, 0.0, 7, 8])any(g) # Truenext(g) # 8 sorted 和这些归约函数只能处理最终会停止的可迭代对象 contextlib自己定义上下文管理器类之前，先看一下 Python 标准库文档中的“29.6 contextlib Utilities for with-statement contexts“。contextlib 模块中有一些类和其他函数，使用范围广泛。 奇淫巧技长度为1的切片，是一个元素还是一个列表？s[0] == s[:1] 只对 str 这个序列类 型成立。不过，str 类型的这个行为十分罕见。对其他各个序列类型来说，s[i]返 回一个元素，而 s[i:i+1] 返回一个相同类型的序列，里面是 s[i] 元素。 True False测试默认情况，一个对象都会被认为是 true ，除非定义的 __bool__() 返回 False 或者 __len__() 返回 0 , 下面是常见的内建对象返回 False 的情况: constants defined to be false: None and False. zero of any numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1) empty sequences and collections: &#39;&#39;, (), [], {}, set(), range(0) 在 Python 中，很多情况下类和函数可以互换这不仅是因为 Python 没有 new 运算符，还因为有特殊的 __new__ 方法，可以把类变成工厂方法，生成不同类型的对象，或者返回事先构建好的实例，而不是每次都创建一个新实例。 命名我编写的每个类都使用驼峰式名称 其他语言类型强类型和弱类型语言 如果一门语言很少隐式转换类型，说明它是强类型语言；如果经常这么做，说明 它是弱类型语言。Java、C++ 和 Python 是强类型语言。PHP、JavaScript 和 Perl 是弱类型语言。 Python 不会自动在字符串和数字之间强制转换 静态类型和动态类型在编译时检查类型的语言是静态类型语言，在运行时检查类型的语言是动态类型语言。静态类型需要声明类型（有些现代语言使用类型推导避免部分类型声明）。 静态类型使得一些工具（编译器和 IDE）便于分析代码、找出错误和提供其他服务 （优化、重构，等等）。动态类型便于代码重用，代码行数更少，而且能让接口自然 成为协议而不提早实行。 综上，Python 是动态强类型语言。 必须使用 self 访问实例属性也备受批评。 我自己并不介意输入 self 限定符，这样便于把局部变量和属性区分开","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python进阶","slug":"python进阶","permalink":"https://jizx.vip/tags/python进阶/"},{"name":"python高级","slug":"python高级","permalink":"https://jizx.vip/tags/python高级/"},{"name":"流畅的python","slug":"流畅的python","permalink":"https://jizx.vip/tags/流畅的python/"},{"name":"协议","slug":"协议","permalink":"https://jizx.vip/tags/协议/"}]},{"title":"attention图解","slug":"attention图解","date":"2020-02-04T12:15:44.000Z","updated":"2020-02-04T12:16:30.710Z","comments":true,"path":"2020/02/04/attention图解/","link":"","permalink":"https://jizx.vip/2020/02/04/attention图解/","excerpt":"","text":"回顾自注意力机制语言离不开语境，比如这个第二定律： 12机器人第二定律机器人必须服从人给予它的命令，当命令与第一定律冲突时例外。 笔者已强调了句子中有三处单词与其他单词有联系。如果不结合语境是无法理解或者处理单词的，所以在模型处理这句话时，了解语境是必要的： · 这句话是讲机器人的 · 这样的命令是定律早期的一部分，也即“人类发出的指令” · 第一定律就是指整个第一定律 自注意力层的流程就是这样。如同烘培一样，它会在加工特定文字之前对其关联词进行预处理（再传递给神经网络层）。其方式就是对每个单词在语段中的相关度进行评分，然后把结果向量加起来。 例如，顶部的transformer模块的自注意力层在处理“it”时，将重点放在了“robot”上。那么传递给神经网络层的向量将是三个单词中每个单词的向量乘以其分数的总和。 自注意力机制处理自注意力机制会贯穿于语段中每个词的处理路径。其中重要的组件是三个向量： · Query(查询)：展示了当前的单词，该单词会使用键给其他单词评分。我们只需要注意目前正在处理的词的查询。 · Key（键）：键向量就像段中所有单词的标签，是搜索相关词汇时的匹配项。 · Value（值）：值向量是实际单词的体现，给每个单词的相关度评过分后，加起来的值就会用来表示当前的单词。 该过程可大致理解为在文件柜里进行搜索。查询就如同写有搜索主题的便利贴，键是里面的文件夹名称。对着便利贴寻找标签时，会提取文件夹中的内容，这些内容就是值向量。如果所找值不是一个，而是无数文件夹中的各个值，就要另当别论了。 将查询向量乘以每个键向量，得到的值即为每个文件夹对应的分数（从专业角度讲：乘指的是向量点乘，乘积会通过 softmax 函数处理）。 将值与其分数相乘，再求总和——得出自注意力层结果。 该加权向量值的结果，会让模型将50%的注意力都放在词语“robot”上，30%的注意力放在“a”上，还有19%会在“it”上。 英文原版：https://jalammar.github.io/illustrated-gpt2/","categories":[],"tags":[]},{"title":"keras","slug":"keras","date":"2020-02-04T12:14:08.000Z","updated":"2020-02-17T03:26:31.488Z","comments":true,"path":"2020/02/04/keras/","link":"","permalink":"https://jizx.vip/2020/02/04/keras/","excerpt":"","text":"下载mnist数据集，网络失败的问题Keras file is located into a new path in Google Cloud Storage (Before it was in AWS S3)： 1https://storage.googleapis.com/tensorflow/tf-keras-datasets/mnist.npz When using: 1tf.keras.datasets.mnist.load_data() You can pass a path parameter. load_data() will call get_file() which takes as parameter fname, if path is a full path and file exists, it will not be downloaded. Example: 1234567# gsutil cp gs://tensorflow/tf-keras-datasets/mnist.npz /tmp/data/mnist.npz# python3&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; path = '/tmp/data/mnist.npz'&gt;&gt;&gt; (train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data(path)&gt;&gt;&gt; len(train_images)&gt;&gt;&gt; 60000","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://jizx.vip/categories/深度学习/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jizx.vip/tags/深度学习/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jizx.vip/tags/tensorflow/"}]},{"title":"python数据分析库","slug":"数据分析库","date":"2020-02-04T12:12:54.000Z","updated":"2020-07-14T14:43:01.205Z","comments":true,"path":"2020/02/04/数据分析库/","link":"","permalink":"https://jizx.vip/2020/02/04/数据分析库/","excerpt":"","text":"numpy函数argpartitionnumpy.argpartition：是将第k大的数字，放在第k个位置。类似于快排找第k大的数，对其它数不做排序，比较省计算。 参考https://zhuanlan.zhihu.com/p/35325758 pandasTODOhttps://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html#grouping 基本类型panda 对象、索引都有 name 属性 series，可以认为它是一个长度固定且有序的字典 索引index，可以指定字符串数组为索引，根据此数组顺序进行排序，索引对象是不可变的，无法修改索引对象。 1index[1]=&apos;d&apos; # TypeError 值 value dataframe，表示矩阵的数据表，行列索引都用，列索引一般由你指定，行索引可以自动生成，可以嵌套 dataframe 当你将列表或者数组赋值给列时，长度必须与 DataFrame 匹配 列是 series？同一列有相同的信息（数据类型）。行是 dataframe？ 索引Frame[&quot;colunm&quot;]可以获取列，frame.colunm 也可以，但是必须是有效的 Python 值，不存在键时会报错 Frame[&quot;colunm&quot;]=arrange(6)可以创建新的列，但是Frame.colunm=arrange(6)不可以 索引像数组一样，但是方法像集合 reindex1df2=df.reindex(index=['a','b','c'],columns=['f','d','w']) method=’ffile’，向前填充，’bfill’向后填充 fill_value=0 这是填充值 drop删除 指定行、列，并返回新的对象，如果要修改原对象，可以设置 inplace=True 123data.drop([\"row1\"])data.drop([\"col1\"],axis=1)data.drop([\"col1\"],axis=1,inplace=True) 数值切片时与 Python 一致不含之后一列，但是字符串切片时，是包含最后的。 loc 与 ilocloc 轴标签，iloc 整数标签 123data.loc[[1,2],[3,0,1]]loc[:1] # 包含 1iloc[:1] # 不包含1 ，有点坑 排序sort_index(axis=)，对索引进行排序 sort_values(by=[&#39;a&#39;,&#39;b&#39;])，对值进行排序 缺失值na : not available 1234dropna 过滤掉 na (how=&apos;all&apos;, axis=1，thresh=2)全部是 na 时才是删除，并指定为列，thresh 表示只删除第2列或者行fillna 替换 naisnull 判断是否为 nanotnull 创建对象series1s = pd.Series([1, 3, 5, np.nan, 6, 8]) dataFrame传递数组123456789101112131415dates = pd.date_range('20130101', periods=6) # 创建时间列表，作为下面的索引\"\"\"DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04','2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D')\"\"\"df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list('ABCD')) # index是行索引，columns 是列索引\"\"\" A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-03 -0.861849 -2.104569 -0.494929 1.0718042013-01-04 0.721555 -0.706771 -1.039575 0.2718602013-01-05 -0.424972 0.567020 0.276232 -1.0874012013-01-06 -0.673690 0.113648 -1.478427 0.524988\"\"\" 传递字典1234567891011121314df2 = pd.DataFrame(&#123;'A': 1., 'B': pd.Timestamp('20130102'), 'C': pd.Series(1, index=list(range(4)), dtype='float32'), 'D': np.array([3] * 4, dtype='int32'), 'E': pd.Categorical([\"test\", \"train\", \"test\", \"train\"]), 'F': 'foo'&#125;)\"\"\" A B C D E F0 1.0 2013-01-02 1.0 3 test foo1 1.0 2013-01-02 1.0 3 train foo2 1.0 2013-01-02 1.0 3 test foo3 1.0 2013-01-02 1.0 3 train foo\"\"\" 查看查看部分内容12df.head()df.tail(3) 查看索引12df.index # 行索引df.columns # 列索引 转为 numpy12345678df.to_numpy()Out[17]: array([[ 0.4691, -0.2829, -1.5091, -1.1356], [ 1.2121, -0.1732, 0.1192, -1.0442], [-0.8618, -2.1046, -0.4949, 1.0718], [ 0.7216, -0.7068, -1.0396, 0.2719], [-0.425 , 0.567 , 0.2762, -1.0874], [-0.6737, 0.1136, -1.4784, 0.525 ]]) 使用DataFrame.to_numpy()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy) 有时代价会非常大，特别是当每列数据类型不同的时候，这是pandas 与 NumPy本质的不同造成的: 整个NumPy数组只有一种数据类型 ,而 pandas 的每一列都可以是不同的数据类型. 当你使用DataFrame.to_numpy(), pandas 要选择一种能覆盖 DataFrame 中所有数据的 NumPy dtype ，最终往往是object, 这就需要将每个值都转为 Python object类型。 查看数值类型的列的统计信息1234567891011df.describe()”“”count 6.000000 6.000000 6.000000 6.000000mean 0.073711 -0.431125 -0.687758 -0.233103std 0.843157 0.922818 0.779887 0.973118min -0.861849 -2.104569 -1.509059 -1.13563225% -0.611510 -0.600794 -1.368714 -1.07661050% 0.022070 -0.228039 -0.767252 -0.38618875% 0.658444 0.041933 -0.034326 0.461706max 1.212112 0.567020 0.276232 1.071804“”“ 转置1df.T 排序索引排序默认是对行索引排序，axis=1 时对列索引排序 12345678910df.sort_index(axis=1, ascending=False) # 列索引逆序\"\"\" D C B A2013-01-01 -1.135632 -1.509059 -0.282863 0.4691122013-01-02 -1.044236 0.119209 -0.173215 1.2121122013-01-03 1.071804 -0.494929 -2.104569 -0.8618492013-01-04 0.271860 -1.039575 -0.706771 0.7215552013-01-05 -1.087401 0.276232 0.567020 -0.4249722013-01-06 0.524988 -1.478427 0.113648 -0.673690\"\"\" 内容排序12345678910df.sort_values(by='B')\"\"\" A B C D2013-01-03 -0.861849 -2.104569 -0.494929 1.0718042013-01-04 0.721555 -0.706771 -1.039575 0.2718602013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-06 -0.673690 0.113648 -1.478427 0.5249882013-01-05 -0.424972 0.567020 0.276232 -1.087401\"\"\" 选择某行、某列列选择：df[&#39;A&#39;]等价于 df.A 行切片：df[0:3] 一大片loc：通过 label通过 label 选择，指定哪些行，哪些列 123456In [28]: df.loc[&apos;20130102&apos;:&apos;20130104&apos;, [&apos;A&apos;, &apos;B&apos;]]Out[28]: A B2013-01-02 1.212112 -0.1732152013-01-03 -0.861849 -2.1045692013-01-04 0.721555 -0.706771 at快速定位一个值 (等价于上面的方法): 12In [31]: df.at[dates[0], &apos;A&apos;]Out[31]: 0.4691122999071863 iloc：通过下标指定行 1234567In [32]: df.iloc[3]Out[32]: A 0.721555B -0.706771C -1.039575D 0.271860Name: 2013-01-04 00:00:00, dtype: float64 指定连续的行与列 12345In [33]: df.iloc[3:5, 0:2]Out[33]: A B2013-01-04 0.721555 -0.7067712013-01-05 -0.424972 0.567020 指定某些行与列 123456In [34]: df.iloc[[1, 2, 4], [0, 2]]Out[34]: A C2013-01-02 1.212112 0.1192092013-01-03 -0.861849 -0.4949292013-01-05 -0.424972 0.276232 iat：快速获得一个值 123456In [38]: df.iat[1, 1]Out[38]: -0.17321464905330858# 等价于In [37]: df.iloc[1, 1]Out[37]: -0.17321464905330858 boolean基本形式：df[条件表达式] 所有满足条件的 12345678910df[df &gt; 0]\"\"\" A B C D2013-01-01 0.469112 NaN NaN NaN2013-01-02 1.212112 NaN 0.119209 NaN2013-01-03 NaN NaN NaN 1.0718042013-01-04 0.721555 NaN NaN 0.2718602013-01-05 NaN 0.567020 0.276232 NaN2013-01-06 NaN 0.113648 NaN 0.524988\"\"\" 某一列满足条件的 1234567df[df.A &gt; 0]\"\"\" A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-04 0.721555 -0.706771 -1.039575 0.271860\"\"\" isin()辅助过滤 123456789101112131415161718df2 = df.copy()df2['E'] = ['one', 'one', 'two', 'three', 'four', 'three']\"\"\" A B C D E2013-01-01 0.469112 -0.282863 -1.509059 -1.135632 one2013-01-02 1.212112 -0.173215 0.119209 -1.044236 one2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 two2013-01-04 0.721555 -0.706771 -1.039575 0.271860 three2013-01-05 -0.424972 0.567020 0.276232 -1.087401 four2013-01-06 -0.673690 0.113648 -1.478427 0.524988 three\"\"\"df2[df2['E'].isin(['two', 'four'])]\"\"\" A B C D E2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 two2013-01-05 -0.424972 0.567020 0.276232 -1.087401 four\"\"\" 赋值新增一列12345# 通过 series 新增s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range(&apos;20130102&apos;, periods=6))# 通过 numpy 新增df.loc[:, &apos;D&apos;] = np.array([5] * len(df)) 通过 label 定位来赋值1In [48]: df.at[dates[0], &apos;A&apos;] = 0 通过下标 position 定位来赋值1In [49]: df.iat[0, 1] = 0 经过上面 3 次操作后： 123456789In [51]: dfOut[51]: A B C D F2013-01-01 0.000000 0.000000 -1.509059 5 NaN2013-01-02 1.212112 -0.173215 0.119209 5 1.02013-01-03 -0.861849 -2.104569 -0.494929 5 2.02013-01-04 0.721555 -0.706771 -1.039575 5 3.02013-01-05 -0.424972 0.567020 0.276232 5 4.02013-01-06 -0.673690 0.113648 -1.478427 5 5.0 通过条件筛选赋值12345678910111213In [52]: df2 = df.copy()In [53]: df2[df2 &gt; 0] = -df2In [54]: df2Out[54]: A B C D F2013-01-01 0.000000 0.000000 -1.509059 -5 NaN2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.02013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.02013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.02013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.02013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0 缺失值处理默认 nan 不参与计算 判断 nan1234567In [60]: pd.isna(df1)Out[60]: A B C D F E2013-01-01 False False False False True False2013-01-02 False False False False False False2013-01-03 False False False False False True2013-01-04 False False False False False True 删除含有 NaN 的行1234In [58]: df1.dropna(how=&apos;any&apos;)Out[58]: A B C D F E2013-01-02 1.212112 -0.173215 0.119209 5 1.0 1.0 填充NaN1234567In [59]: df1.fillna(value=5)Out[59]: A B C D F E2013-01-01 0.000000 0.000000 -1.509059 5 5.0 1.02013-01-02 1.212112 -0.173215 0.119209 5 1.0 1.02013-01-03 -0.861849 -2.104569 -0.494929 5 2.0 5.02013-01-04 0.721555 -0.706771 -1.039575 5 3.0 5.0 操作统计123456# 平均值df.mean()# 频率计算(series 方法)s = pd.Series(np.random.randint(0, 7, size=10))s.value_counts() mapmap()是Series对象的一个函数，DataFrame中没有map()，map()的功能是将一个自定义函数作用于Series对象的每个元素。 aplayapply()函数的功能是将一个自定义函数作用于DataFrame的行或者列 1234567891011121314151617181920df.apply(np.cumsum)&quot;&quot;&quot; A B C D F2013-01-01 0.000000 0.000000 -1.509059 5 NaN2013-01-02 1.212112 -0.173215 -1.389850 10 1.02013-01-03 0.350263 -2.277784 -1.884779 15 3.02013-01-04 1.071818 -2.984555 -2.924354 20 6.02013-01-05 0.646846 -2.417535 -2.648122 25 10.02013-01-06 -0.026844 -2.303886 -4.126549 30 15.0&quot;&quot;&quot;df.apply(lambda x: x.max() - x.min())&quot;&quot;&quot;A 2.073961B 2.671590C 1.785291D 0.000000F 4.000000dtype: float64&quot;&quot;&quot; applymapapplymap()函数的功能是将自定义函数作用于DataFrame的所有元素 字符串方法Note that pattern-matching in str generally uses regular expressions by default. str 是通过正则匹配到的 12s = pd.Series([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;Aaba&apos;, &apos;Baca&apos;, np.nan, &apos;CABA&apos;, &apos;dog&apos;, &apos;cat&apos;])s.str.lower() 合并数据append添加一行 123df = pd.DataFrame(np.random.randn(8, 4), columns=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;])s = df.iloc[3] # 选择原表中的第 4 行df.append(s, ignore_index=True) # 添加一行到表的最后 concat多行拼接 1234567891011121314151617181920212223242526272829303132df = pd.DataFrame(np.random.randn(10, 4))In [74]: dfOut[74]: 0 1 2 30 -0.548702 1.467327 -1.015962 -0.4830751 1.637550 -1.217659 -0.291519 -1.7455052 -0.263952 0.991460 -0.919069 0.2660463 -0.709661 1.669052 1.037882 -1.7057754 -0.919854 -0.042379 1.247642 -0.0099205 0.290213 0.495767 0.362949 1.5481066 -1.131345 -0.089329 0.337863 -0.9458677 -0.932132 1.956030 0.017587 -0.0166928 -0.575247 0.254161 -1.143704 0.2158979 1.193555 -0.077118 -0.408530 -0.862495# break it into piecesIn [75]: pieces = [df[:3], df[3:7], df[7:]] # 从第4 、8行拆开，分成 3 份，然后再进行拼接，还原会原表In [76]: pd.concat(pieces)Out[76]: 0 1 2 30 -0.548702 1.467327 -1.015962 -0.4830751 1.637550 -1.217659 -0.291519 -1.7455052 -0.263952 0.991460 -0.919069 0.2660463 -0.709661 1.669052 1.037882 -1.7057754 -0.919854 -0.042379 1.247642 -0.0099205 0.290213 0.495767 0.362949 1.5481066 -1.131345 -0.089329 0.337863 -0.9458677 -0.932132 1.956030 0.017587 -0.0166928 -0.575247 0.254161 -1.143704 0.2158979 1.193555 -0.077118 -0.408530 -0.862495 joinSql 风格的合并 1234567891011121314151617181920In [82]: left = pd.DataFrame(&#123;'key': ['foo', 'bar'], 'lval': [1, 2]&#125;)In [83]: right = pd.DataFrame(&#123;'key': ['foo', 'bar'], 'rval': [4, 5]&#125;)In [84]: leftOut[84]: key lval0 foo 11 bar 2In [85]: rightOut[85]: key rval0 foo 41 bar 5In [86]: pd.merge(left, right, on='key')Out[86]: key lval rval0 foo 1 41 bar 2 5 分组类似于数据库的 group by，会有以下步骤 根据条件来分组 对每个组应用指定的方法function 将结果汇总到数据类型中（serie或者 dataframe） 12345678910111213141516171819In [91]: df = pd.DataFrame(&#123;'A': ['foo', 'bar', 'foo', 'bar', ....: 'foo', 'bar', 'foo', 'foo'], ....: 'B': ['one', 'one', 'two', 'three', ....: 'two', 'two', 'one', 'three'], ....: 'C': np.random.randn(8), ....: 'D': np.random.randn(8)&#125;) ....: In [92]: dfOut[92]: A B C D0 foo one -1.202872 -0.0552241 bar one -1.814470 2.3959852 foo two 1.018601 1.5528253 bar three -0.595447 0.1665994 foo two 1.395433 0.0476095 bar two -0.392670 -0.1364736 foo one 0.007207 -0.5617577 foo three 1.928123 -1.623033 根据一列分组 123456In [93]: df.groupby('A').sum()Out[93]: C DA bar -2.802588 2.42611foo 3.146492 -0.63958 根据 多列分组 12345678910In [94]: df.groupby(['A', 'B']).sum()Out[94]: C DA B bar one -1.814470 2.395985 three -0.595447 0.166599 two -0.392670 -0.136473foo one -1.195665 -0.616981 three 1.928123 -1.623033 two 2.414034 1.600434 时间处理时间 序列生成12rng = pd.date_range('3/6/2012 00:00', periods=5, freq='D') #起始时间点，数据量，跨度（D：day,M:minute,S：second） Reshaping TODOTODO","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://jizx.vip/tags/pandas/"},{"name":"numpy","slug":"numpy","permalink":"https://jizx.vip/tags/numpy/"}]},{"title":"sklearn","slug":"sklearn","date":"2020-02-04T09:59:01.000Z","updated":"2020-02-04T12:10:56.316Z","comments":true,"path":"2020/02/04/sklearn/","link":"","permalink":"https://jizx.vip/2020/02/04/sklearn/","excerpt":"","text":"模型保存与加载pickle 1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; s = pickle.dumps(clf) # clf是模型对象&gt;&gt;&gt; clf2 = pickle.loads(s)&gt;&gt;&gt; clf2.predict(X[0:1]) joblib 在某些情况，可以使用joblib来代替pickle,，特别是对一些大的数据 123&gt;&gt;&gt; from joblib import dump, load&gt;&gt;&gt; dump(clf, &apos;filename.joblib&apos;) &gt;&gt;&gt; clf = load(&apos;filename.joblib&apos;) 设置超参123clf = SVC() #实例化clf.set_params(kernel=&apos;linear&apos;).fit(X, y) # 实例化后，可以修改超参，进行训练clf.set_params(kernel=&apos;rbf&apos;, gamma=&apos;scale&apos;).fit(X, y) # 训练后可以再修改超参，然后再进行训练 标签处理 fit训练时使用的是哪种类型的标签，预测就会使用对应的类型输出标签。 预测时模型可能输出全为0的结果，表示该样本不属于任何类别 情况1：多类别 标签 one-hot 化：LabelBinarizer 12345678910111213from sklearn.preprocessing import LabelBinarizery = [0, 0, 1, 3, 1, 2]y = LabelBinarizer().fit_transform(y)print y###################################[[1 0 0 0] [1 0 0 0] [0 1 0 0] [0 0 0 1] [0 1 0 0] [0 0 1 0]] 情况2：多标签 ，每个样本属于多个类别的请情况，使用MultiLabelBinarizer 12345678910111213141516171819from sklearn.preprocessing import MultiLabelBinarizery = [[0, 1], [0, 2], [1, 3], [0, 2, 3], [2, 4]] # 每个样本的标签可能有2-3个y = MultiLabelBinarizer().fit_transform(y)print yclassif.fit(X, y).predict(X)###################################[[1 1 0 0 0] [1 0 1 0 0] [0 1 0 1 0] [1 0 1 1 0] [0 0 1 0 1]] array([[1, 1, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 1, 0, 0], [1, 0, 1, 0, 0]]) 获取超参1234567&gt;&gt;&gt; estimator = Estimator(param1=1, param2=2)&gt;&gt;&gt; estimator.param11Estimated parameters: When data is fitted with an estimator, parameters are estimated from the data at hand. 所有的 estimated parameters 都是模型的属性，并以下划线结尾:&gt;&gt;&gt; estimator.estimated_param_ https://blog.csdn.net/10km/article/details/51906821 https://my.oschina.net/leejun2005/blog/150662 网格搜索TODO https://blog.csdn.net/u012897374/article/details/74999940","categories":[],"tags":[]},{"title":"python 多线程与多进程","slug":"python-多线程","date":"2019-12-07T15:39:40.000Z","updated":"2020-02-17T03:24:38.928Z","comments":true,"path":"2019/12/07/python-多线程/","link":"","permalink":"https://jizx.vip/2019/12/07/python-多线程/","excerpt":"","text":"概述与线程相关的标准库模块 线程实现方式一，定义线程函数，实例化Thread类（简单） 12345678910111213# Code to execute in an independent threadimport timedef countdown(n): while n &gt; 0: print('T-minus', n) n -= 1 time.sleep(5)# Create and launch a threadfrom threading import Threadt = Thread(target=countdown, args=(10,))# t = Thread(target=countdown, args=(10,), daemon=True) #守护进程t.start() 方式二，定义线程类，可实现复杂需求（推荐） 123456789101112131415161718192021class CountdownTask: def __init__(self): self._running = True # 其他辅助方法 def terminate(self): self._running = False # 线程执行的内容 def run(self, n): while self._running and n &gt; 0: print('T-minus', n) n -= 1 time.sleep(5)c = CountdownTask()t = Thread(target=c.run, args=(10,))# t = Thread(target=countdown, args=(10,), daemon=True) #守护进程t.start()c.terminate() # 终止信号t.join() # Wait for actual termination (if needed) 方式三，继承 Thread 函数 12345678910111213141516from threading import Threadclass CountdownThread(Thread): def __init__(self, n): super().__init__() self.n = n def run(self): while self.n &gt; 0: print('T-minus', self.n) self.n -= 1 time.sleep(5)c = CountdownThread(5)c.start() 尽管这样也可以工作，但这使得你的代码依赖于 threading 库，所以你的这些代码只能在线程上下文中使用。 而方式二的代码可以被用在其他的上下文中，可能与线程有关，也可能与线程无关。比如，你可以通过 multiprocessing 模块在一个单独的进程中执行你的代码： 1234import multiprocessingc = CountdownTask(5)p = multiprocessing.Process(target=c.run)p.start() 守护线程守护线程一般是一个等待客户端请求服务的服务器。 如果没有客户端请求， 守护线程就是空闲的。 如果把一个线程设置为守护线程，就表示这个线程是不重要的，主线程准备退出时，不需要等待这个子线程执行完成。启动线程之前执行如下赋值语句： thread.daemon = True（调用 thread.setDaemon(True)的旧方法已经弃用了）。 线程同步event 对象TODO event 对象最好单次使用，就是说，你创建一个 event 对象，让某个线程等待这个对象，一旦这个对象被设置为真，你就应该丢弃它。尽管可以通过 clear() 方法来重置 event 对象，但是很难确保安全地清理 event 对象并对它重新赋值。很可能会发生错过事件、死锁或者其他问题（特别是，你无法保证重置 event 对象的代码会在线程再次等待这个 event 对象之前执行）。如果一个线程需要不停地重复使用 event 对象，你最好使用 Condition 对象来代替。 Condition 对象TODO event对象的一个重要特点是当它被设置为真时会唤醒所有等待它的线程。如果你只想唤醒单个线程，最好是使用信号量或者 Condition 对象来替代 锁I/O 和访问相同的数据结构都属于临界区，因此需要用锁来防止多个线程同时进入临界区。为了加锁，需要添加一行代码来引入Lock（或RLock），然后创建一个锁对象。当情况更加复杂，你可能需要一个更强大的同步原语来代替锁。 Lock 对象和 with 语句块一起使用可以保证互斥执行，每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。相当于lock.acquire()；... lock.release()。相比于这种显式调用的方法，with 语句更加优雅，也更不容易出错，特别是程序员可能会忘记调用 release() 方法或者程序在获得锁之后产生异常这两种情况（使用 with 语句可以保证在这两种情况下仍能正确释放锁）。 Lock的最佳实践1234567891011121314151617181920212223import threadingclass SharedCounter: ''' 利用这个类，将需要共享的数据、锁都封装起来，暴露给线程的只有方法，是一种非常好的实现方法。 ''' def __init__(self, initial_value = 0): self._value = initial_value self._value_lock = threading.Lock() def incr(self,delta=1): ''' Increment the counter with locking ''' with self._value_lock: self._value += delta def decr(self,delta=1): ''' Decrement the counter with locking ''' with self._value_lock: self._value -= delta RLock可重入锁一个 RLock （可重入锁）可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下，当锁被持有时，只有一个线程可以使用完整的函数或者类中的方法。 与一个标准的锁不同的是，已经持有这个锁的方法在调用同样使用这个锁的方法时，无需再次获取锁。比如 下面的decr 方法。 这种实现方式的一个特点是，无论这个类有多少个实例都只用一个锁。因此在需要大量使用计数器的情况下内存效率更高。不过这样做也有缺点，就是在程序中使用大量线程并频繁更新计数器时会有争用锁的问题。 1234567891011121314151617181920212223import threadingclass SharedCounter: ''' A counter object that can be shared by multiple threads. ''' _lock = threading.RLock() # 所有类的实例共享的一个类级锁 def __init__(self, initial_value = 0): self._value = initial_value def incr(self,delta=1): ''' Increment the counter with locking ''' with SharedCounter._lock: self._value += delta def decr(self,delta=1): ''' Decrement the counter with locking ''' with SharedCounter._lock: self.incr(-delta) 信号量threading 模块包括两种信号量类：Semaphore 和 BoundedSemaphore。如你所知，信号量实际上就是计数器，它们从固定数量的有限资源起始。 相对于简单地作为锁使用，信号量更适用于那些需要在线程之间引入信号或者限制的程序。比如，你需要限制一段代码的并发访问量，你就可以像下面这样使用信号量完成： 123456789from threading import Semaphoreimport urllib.request# 运行 5 个线程并发_fetch_url_sema = Semaphore(5)def fetch_url(url): with _fetch_url_sema: return urllib.request.urlopen(url) 线程通信从一个线程向另一个线程发送数据最安全的方式可能就是使用 queue 库中的队列了。创建一个被多个线程共享的 Queue 对象，这些线程通过使用 put() 和 get() 操作来向队列中添加或者删除元素。 Queue 模块使用 Queue 模块（Python 2.x 版本，在Python 3.x版本中重命名为queue）来提供线程间通信的机制，Queue 对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。通过使用 put() 和 get() 操作来向队列中添加或者删除元素。 生产者和消费者 关于消费者的关闭问题解决方法是在队列中放置一个特殊的值，当消费者读到这个值的时候，终止执行。 1234567891011121314151617181920212223242526272829from queue import Queuefrom threading import Thread# Object that signals shutdown_sentinel = object()# A thread that produces datadef producer(out_q): while running: # Produce some data ... out_q.put(data) # Put the sentinel on the queue to indicate completion out_q.put(_sentinel)# A thread that consumes datadef consumer(in_q): while True: # Get some data data = in_q.get() # Check for termination if data is _sentinel: in_q.put(_sentinel) # 将这个标注放回队列，然后结束当前进程 break # Process the data ... 队列流量控制与非阻塞在创建 Queue 对象时提供可选的 size 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，为队列中的元素数量添加上限是有意义的。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。 get() 和 put() 方法都支持非阻塞方式和设定超时，这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况。 123456789101112131415161718import queueq = queue.Queue()try: data = q.get(block=False) # 非阻塞式except queue.Empty: ...try: data = q.get(timeout=5.0) # 超时except queue.Empty: ... try: q.put(item, block=False) # 非阻塞except queue.Full: log.warning('queued item %r discarded!', item) ... 不安全的一些方法你最好不要在你的代码中使用这些不是线程安全的方法： q.qsize() ， q.full() ， q.empty() 获取一个队列的当前大小和状态。因为可能你对一个队列使用 empty() 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。 Condition自定义线程安全的数据结构尽管队列是最常见的线程间通信机制，但是仍然可以自己通过创建自己的数据结构并添加所需的锁和同步机制来实现线程间通信。最常见的方法是使用 Condition 变量来包装你的数据结构 123456789101112131415161718192021import threadingclass PriorityQueue: \"\"\" 自定义的优先级队列 \"\"\" def __init__(self): self._queue = [] self._count = 0 self._cv = threading.Condition() def put(self, item, priority): with self._cv: heapq.heappush(self._queue, (-priority, self._count, item)) self._count += 1 self._cv.notify() def get(self): with self._cv: while len(self._queue) == 0: self._cv.wait() return heapq.heappop(self._queue)[-1] 双向通信使用队列来进行线程间通信是一个单向、不确定的过程。通常情况下，你没有办法知道接收数据的线程是什么时候接收到的数据并开始工作的。下面提供 2 种解决办法 方式一：队列对象提供一些基本完成的特性 123456789101112131415161718192021222324252627282930from queue import Queuefrom threading import Thread# A thread that produces datadef producer(out_q): while running: # Produce some data ... out_q.put(data)# A thread that consumes datadef consumer(in_q): while True: # Get some data data = in_q.get() # Process the data ... # 提示队列，消费者数据处理完成 in_q.task_done()# Create the shared queue and launch both threadsq = Queue()t1 = Thread(target=consumer, args=(q,))t2 = Thread(target=producer, args=(q,))t1.start()t2.start()# Wait for all produced items to be consumedq.join() 方式二： 123456789101112131415161718192021222324from queue import Queuefrom threading import Thread, Event# A thread that produces datadef producer(out_q): while running: # Produce some data ... # 将 (data, event) 元组放入队列中 evt = Event() out_q.put((data, evt)) ... # 等待消费者通知 evt.wait()# A thread that consumes datadef consumer(in_q): while True: # 获取到数据和 Event 对象 data, evt = in_q.get() # Process the data ... # 通知消费者数据处理完成 evt.set() 数据深拷贝使用线程队列有一个要注意的问题是，向队列中添加数据项时并不会复制此数据项，线程间通信实际上是在线程间传递对象引用。如果你担心对象的共享状态，那你最好只传递1）不可修改的数据结构（如：整型、字符串或者元组）或者2）一个对象的深拷贝。 使用 copy 模块进行深拷贝 1234567891011121314151617from queue import Queuefrom threading import Threadimport copy # 使用 copy 模块# A thread that produces datadef producer(out_q): while True: # Produce some data ... out_q.put(copy.deepcopy(data)) # 深拷贝# A thread that consumes datadef consumer(in_q): while True: # Get some data data = in_q.get() # Process the data 死锁问题TODOhttps://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p05_locking_with_deadlock_avoidance.html 线程本地存储对象 TODOhttps://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p06_storing_thread_specific_state.html 线程池concurrent.futures 函数库有一个 ThreadPoolExecutor 类可以被用来完成这个任务。通常应该避免编写线程数量可以无限制增长的程序。 1234567891011121314151617181920212223242526272829from socket import AF_INET, SOCK_STREAM, socketfrom concurrent.futures import ThreadPoolExecutordef echo_client(sock, client_addr): ''' Handle a client connection ''' print('Got connection from', client_addr) while True: msg = sock.recv(65536) if not msg: break sock.sendall(msg) print('Client closed connection') sock.close()def echo_server(addr): \"\"\" 服务器线程 \"\"\" pool = ThreadPoolExecutor(128) # 定义线程池大小 sock = socket(AF_INET, SOCK_STREAM) sock.bind(addr) sock.listen(5) while True: client_sock, client_addr = sock.accept() pool.submit(echo_client, client_sock, client_addr)echo_server(('',15000)) 对比手动实现线程池，如果你想手动创建你自己的线程池， 通常可以使用一个Queue来轻松实现。 123456789101112131415161718192021222324252627282930313233343536from socket import socket, AF_INET, SOCK_STREAMfrom threading import Threadfrom queue import Queuedef echo_client(q): ''' Handle a client connection ''' sock, client_addr = q.get() # 阻塞性等待 print('Got connection from', client_addr) while True: msg = sock.recv(65536) if not msg: break sock.sendall(msg) print('Client closed connection') sock.close()def echo_server(addr, nworkers): # Launch the client workers，区别的地方 q = Queue() for n in range(nworkers): t = Thread(target=echo_client, args=(q,)) t.daemon = True t.start() # Run the server sock = socket(AF_INET, SOCK_STREAM) sock.bind(addr) sock.listen(5) while True: client_sock, client_addr = sock.accept() q.put((client_sock, client_addr)) # 区别的地方echo_server(('',15000), 128) 使用 ThreadPoolExecutor 相对于手动实现的一个好处在于它使得 任务提交者更方便的从被调用函数中获取返回值。 12345678910111213141516from concurrent.futures import ThreadPoolExecutorimport urllib.requestdef fetch_url(url): u = urllib.request.urlopen(url) data = u.read() return datapool = ThreadPoolExecutor(10)# Submit work to the poola = pool.submit(fetch_url, 'http://www.python.org')b = pool.submit(fetch_url, 'http://www.pypy.org')# Get the results backx = a.result()y = b.result() 例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。 特别的，a.result() 操作会阻塞进程直到对应的函数执行完成并返回一个结果。 多进程由于 Python 的 GIL 的限制，多线程更适合于 I/O 密集型应用（I/O 释放了 GIL，可以允 许更多的并发），而不是计算密集型应用。对于后一种情况而言，为了实现更好的并行性，我们有两种策略来解决GIL的缺点。 方法一：如果你完全工作于Python环境中，你可以使用 multiprocessing 模块来创建一个进程池， 并像协同处理器一样的使用它 12345678910111213141516171819# Processing pool (see below for initiazation)pool = None# CPU 密集性的任务def some_work(args): ... return result# 在线程中调用进程池def some_thread(): while True: ... r = pool.apply(some_work, (args)) ...# Initiaze the poolif __name__ == '__main__': import multiprocessing pool = multiprocessing.Pool() 这个通过使用一个技巧利用进程池解决了GIL的问题。 当一个线程想要执行CPU密集型工作时，会将任务发给进程池。 然后进程池会在另外一个进程中启动一个单独的Python解释器来工作。 当线程等待结果的时候会释放GIL。 并且，由于计算任务在单独解释器中执行，那么就不会受限于GIL了。 在一个多核系统上面，你会发现这个技术可以让你很好的利用多CPU的优势。 方法二：另外一个解决GIL的策略是使用C扩展编程技术。这里不做讨论。 如果你准备使用一个进程池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，不能是lambda、闭包可调用实例等， 并且函数参数和返回值必须要兼容pickle。 同样，要执行的任务量必须足够大以弥补额外的通信开销。 jupyter 的 bugjupyter的setDeamon有bug，setDaemon(True)在jupyter中会主进程会等待子进程结束。这是有问题的。 setDaemon() ： 设置此线程是否被主线程守护回收，需要在 start 方法前调用。 默认False不回收，也就是主进程运行到最后一行后，会等待子进程结束； 设为True相当于向主线程中注册守护，主线程结束时会将其一并回收，子进程不论是否运行完成 1234567891011121314151617import threadingimport timeclass MyThread(threading.Thread): def __init__(self,id): threading.Thread.__init__(self) self.id=id def run(self): for _ in range(5): time.sleep(2) print(\"this is \" + str(self.id)+ self.getName()) if __name__ == \"__main__\": t1 = MyThread(999) t1.setDaemon(False) t1.setDaemon(True) t1.start() print(\"I am the father thread\") join()： 设置主线程是否同步阻塞自己来待此子线程执行完毕 没有t.join()时，主进程启动子进程后会继续执行后续代码，然后等待子进程结束（如果没有设置t1.setDaemon(True)） join时，主进程会被阻塞，等待调用了t.join()的子进程t结束。 123456789101112131415161718192021import threadingimport timeclass MyThread(threading.Thread): def __init__(self, id): threading.Thread.__init__(self) self.id = id def run(self): for _ in range(5): time.sleep(1) print(\"this is \" + str(self.id) + self.getName())if __name__ == \"__main__\": ts=[] for i in range(5): ts.append(MyThread(i)) for t in ts: t.start() # 启动了第1个子进程，之后调用join，主进程就被阻塞，无法启动下一个子进程 t.join() # 主进程会卡在这里，一直等待第1个子进程运行结束，才进入下一次循环，启动下一个进程 print(\"I am the father thread\") 这才是比较正确的做法 1234567891011121314151617181920212223import threadingimport timeclass MyThread(threading.Thread): def __init__(self, id): threading.Thread.__init__(self) self.id = id def run(self): for _ in range(5): time.sleep(1) print(\"this is \" + str(self.id) + self.getName())if __name__ == \"__main__\": ts=[] for i in range(5): ts.append(MyThread(i)) for t in ts: t.start() # 启动所有子进程，子进程在后台，主进程继续后面的代码，不会阻塞 for t in ts: print \"start\"+t.getName() t.join() # 这时候进行join，使得主进程在这里被第一个子进程t阻塞，但是所有子进程都在运行。第一个进程结束后，主进程恢复运行，执行第二个子进程的join，这时的第二个子进程是有可能已经结束了的 print(\"I am the father thread\") 所以 setDeamon(True)与join共用时应该是没有效果的（我的观点）","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"多线程","slug":"多线程","permalink":"https://jizx.vip/tags/多线程/"},{"name":"多进程","slug":"多进程","permalink":"https://jizx.vip/tags/多进程/"}]},{"title":"python cookbook","slug":"python-cookbook","date":"2019-12-01T14:52:58.000Z","updated":"2019-12-08T14:53:00.072Z","comments":true,"path":"2019/12/01/python-cookbook/","link":"","permalink":"https://jizx.vip/2019/12/01/python-cookbook/","excerpt":"python cookbook的阅读笔记，对内容进行了简练。将常用的知识点记录下来。","text":"python cookbook的阅读笔记，对内容进行了简练。将常用的知识点记录下来。 数据结构字典字典的构造方式1234567# a,b,c是常用的方式a = dict(one=1, two=2, three=3) # 注意 one、two、three表示字符串，不用加引号b = &#123;'one': 1, 'two': 2, 'three': 3&#125;c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))d = dict([('two', 2), ('one', 1), ('three', 3)])e = dict(&#123;'three': 3, 'one': 1, 'two': 2&#125;)a == b == c == d == e # True 字典键值的获取12345one = a['four'] # 键不存在时，会报错KeyError，因此推荐get方法，设置默认值one = a.get('four')# Noneone=a.get('four',4) # get(key [,default])# 4 字典键值的添加123a['key'] = valuea.setdefault(\"key\"[,default]) # 不要被这个名字给骗了，注意不会使用default修改原来的值# 如果key在字典中，返回他的value. If not, 插入该键，设置为default 并返回 default。default 默认是 None。注意不会使用default修改原来的值。 个人觉得与get的差别只有 不存在给定的键时会不会在字典中添加该键。 例子 123456strings = ('puppy', 'kitten', 'puppy', 'puppy','weasel', 'puppy', 'kitten', 'puppy')counts = &#123;&#125;for kw in strings: # counts[kw] += 1 会抛出KeyError异常 counts[kw] = counts.setdefault(kw, 0) + 1 # counts[kw] = counts.get(kw, 0) + 1 效果相同 设置默认值有没有一种字典它本身提供了默认值的功能呢？答案是肯定的，那就是 collections.defaultdict 。 定义：defaultdict([default_factory[, …]]) default_factory：必须是callable类型，因此可以是类型（如int、list）、函数。在 __missing__() 方法中会使用default_factory ; default_factory使用第一个参数初始化，否则为None。 __missing__：在调用 __getitem__() 方法或者dict[key]未找到key时，会调用__missing__(key)方法。 如果default_factory 是 None，则抛出异常。如果不是None，则为给定键提供默认值，插入到字典中，并返回。 注意：这种形式的默认值只有在通过 dict[key]或者 dict.__getitem__(key) 访问的时候才有效。 default_factory：类型 12345678from collections import defaultdicts = 'mississippi'd = defaultdict(int) # 默认为0for k in s: d[k] += 1sorted(d.items())# [('i', 4), ('m', 1), ('p', 2), ('s', 4)] 12345678from collections import defaultdicts = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]d = defaultdict(list)for k, v in s: d[k].append(v)sorted(d.items())[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])] default_factory：函数、lambda 函数 123456789# 提供函数from collections import defaultdictdef constant_factory(value): return lambda: valued = defaultdict(constant_factory('&lt;missing&gt;')) # d.update(name='John', action='ran')print('%(name)s %(action)s to %(object)s' % d)# 'John ran to &lt;missing&gt;' 123456789# 提供lambda 函数from collections import defaultdicts = 'mississippi'd = defaultdict(lambda : 0) # 默认为0for k in s: d[k] += 1sorted(d.items())# [('i', 4), ('m', 1), ('p', 2), ('s', 4)] 队列与堆deque队列 在队列两端插入或删除元素时间复杂度都是 O(1) ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 O(N) 。 12345678from collections import deque&gt;&gt;&gt; q = deque()&gt;&gt;&gt; q.append(1)&gt;&gt;&gt; q.append(2)&gt;&gt;&gt; q.append(3)&gt;&gt;&gt; qdeque([1, 2, 3])&gt;&gt;&gt; q.appendleft(4) 使用 deque(maxlen=N) 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。 123456789101112&gt;&gt;&gt; q = deque(maxlen=3)&gt;&gt;&gt; q.append(1)&gt;&gt;&gt; q.append(2)&gt;&gt;&gt; q.append(3)&gt;&gt;&gt; qdeque([1, 2, 3], maxlen=3)&gt;&gt;&gt; q.append(4)&gt;&gt;&gt; qdeque([2, 3, 4], maxlen=3)&gt;&gt;&gt; q.append(5)&gt;&gt;&gt; qdeque([3, 4, 5], maxlen=3) heapq堆(TODO )在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中 解压赋值、星号表达式解压赋值给多个变量 任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。 唯一的前提就是变量的数量必须跟序列元素的数量是一样的。 解压赋值可以用在任何可迭代对象上面，而不仅仅是列表或者元组。 包括字符串，文件对象，迭代器和生成器。 12s = &apos;Hello&apos;a, b, c, d, e = s 你可能只想解压一部分，丢弃其他的值。可以使用任意变量名去占位，到时候丢掉这些变量就行了，最常用的占位符就_。 12data = [ &apos;ACME&apos;, 50, 91.1, (2012, 12, 21) ]_, shares, price, _ = data 变量与星号扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。 你可以像下面这样分解这些记录： 123456# 可以解压元组record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')name, email, *phone_numbers = recordprint(name) #'Dave'print(email) #'dave@example.com'print(phone_numbers) # ['773-555-1212', '847-555-1212'] 你有一个公司前 8 个月销售数据的序列， 但是你想看下最近一个月数据和前面 7 个月的平均值的对比。 12345# 可以解压列表*trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]print(trailing) # [10, 8, 7, 1, 9, 5, 10]print(current) `# 3trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs) 在学期末的时候， 统计家庭作业的平均成绩，但是排除掉第一个和最后一个分数。 12first, *middle, last = gradesavg(middle) 星号*解压出的变量永远都是list列表类型 ，不管解压的数量是多少(包括 0 个)。试着理解下面这些容易让人困惑的点： *elements = iterable 会让 elements 变为 list 类型； 但是 elements = *iterable, 会让 elements 变成 tuple类型 因为这等价于elements= e1,e2...en,(e是iterable对象中的元素)，e1,e2...en,就是tuple类型，试试这个a=1,，a就成了一个tuple对象，等价于a=(1,) 理解上面的以后，下面的就能理解了吧。 first, *elements = *iterable, ，elements是list类型 *elements, = *iterabl, ，elements是list类型。 注意：*elements = *iterabl, SyntaxError: starred assignment target must be in a list or tuple 报错提示：星号赋值的目标element必须在list、tuple中，因此像上面的写法（加个逗号）才是对的。 函数与星号一、函数定义中的星号 函数定义中的星号，def func(a,*b) 表示接受可变参数，分配给位置参数后剩下的参数(关键字参数、**解压的字典参数除外)会被封装为tuple。 整体的参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 在一个函数的接收参数中，同时出现”非关键字参数（位置参数）”和”关键字参数”时，可以使用一个单星号来分隔这两种参数，这种叫做命名关键字参数。命名关键字参数可以有默认值，例子如下： 1234567891011def mix(a,b,*,x,y=4): \"\"\"位置参数与命名关键字参数混合\"\"\" return a,b,x,y# 星号前面的a和b是位置参数，星号后面的x和y是关键字参数，并且 x 有默认值# 调用mix()函数并传入参数时，关键字参数一定要使用\"变量名=值\"的形式传入数据，如果同位置参数一样传入数据，就会引发一个TypeError异常print(mix(1,2,x=3,y=4))print(mix(1,2,x=3))# print(mix(1,2,3,4)) # Error, mix() takes 2 positional arguments but 4 were given 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了（func2中的 b 是命名关键字参数，不是默认参数），但是调用时必须显示指明给命名参数的赋值，否则会被可变参数全部接收，无法改变默认值。出现你意料之外的问题，如下例子： 12345678910111213141516# 位置参数，默认参数，可变参数def func1(a,b=3,*c): print(vars())func1(1,2,3,4) # 2会赋值给默认参数b# 位置参数，可变参数，命名关键字参数def func2(a,*c,b=3): print(vars())func2(1,2,3,4) # 2，3，4全部被可变参数接收，默认参数b不会被改变func2(1,2,3,b=4) # 除非显示指定要改变默认参数 # &#123;'c': (3, 4), 'b': 2, 'a': 1&#125; # &#123;'c': (2, 3, 4), 'b': 3, 'a': 1&#125; # &#123;'c': (2, 3), 'b': 4, 'a': 1&#125; 综合的例子： 12345678# a,b 是位置参数，c 是默认参数，d 是可变参数，e,f 是命名关键字参数，并且 e 有默认值，kw 是关键字参数def func(a,b,c=1,*d,e=1,f,**kw): print(vars()) d=&#123;'m':4&#125;func(*(1,2),3,*(4,5),6, e=2,f=3,**d,**&#123;'x': 2&#125;, y=3,**&#123;'z': 3&#125;,g=5)# 等价于如下：func(1,2,3,4,5,6,e=2,f=3,**&#123;'m':4,'x':2,'y':3,'z':3,'g':5&#125;) 关键字参数和命名关键字参数的区别在于：前者可以传递任何名字的参数，而后者只能传递*后面名字的参数。 二、函数调用时的星号 在调用函数时，func(1,*[2,3,4,5])， *操作符会将 iterable对象（如 list、 tuple）中的元素提取出来，就像他们是另外的位置参数，替换了原本iterable对象的位置，因此相当于func(1,2,3,4,5)，对于字典对象的解压也是一样的。 在 version 3.5之前，只能接收一个* 和 ** unpackings，之后( PEP 448) 发生了一些改变： 函数调用时，允许接受任意多个 * 和 ** unpackings。 因此在理解调用函数时出现的*与**，将他们替换为”位置参数”和”关键字参数”即可。因此在调用时，位置参数 与 * 表达式参数 没有位置顺序的限制 ，关键字参数 与**表达式参数也没有位置顺序的限制。 参数顺序问题： 函数调用也是遵循参数定义的顺序规则，关键字参数 必须在 位置参数 之后， ** 表达式参数 在 * 表达式参数之后。 123456789# 例子def func(a,b,c=1,*d,e=1,**kw): print(vars()) d=&#123;'m':4&#125;# 调用时的顺序，以及任意多个 unpacking 参数func(*(1,2),3,*(4,5),6, e=2, **d,**&#123;'x': 2&#125;, y=3,**&#123;'z': 3&#125;,f=5)# 等价于 func(1,2,3,4,5,6,e=2,&#123;'m':4,'x':2,'y':3,'z':3,'f':5&#125;) 记住诀窍：将*与**替换为\"位置参数\"和\"关键字参数\"即可 虽然“*表达式参数“可以出现在”关键字参数”后面，但是 它会比“关键字参数”（**表达式）优先处理 ，相当于python 帮你提前了。(在这里那个替换诀窍暂时不能用。)12345678910def f(a, b): print(a, b)f(1, *(2,))# 1 2f(b=1, *(2,))# 2 1f(a=1, *(2,)) # 2先被赋值给 a，因此 a=1 会导致重复赋值# TypeError: f() got multiple values for keyword argument 'a' 重复键问题： 字典与Function 对待重复键是不同的，字典允许重复键，但函数会引发error。比如如果一个位置参数def func(a) 通过 位置、关键字这两种方法提供了值func(1,a=3)就会引发错误；使用 ** unpackings引起得出重复，比如 f(**{&#39;x&#39;: 2},**{&#39;x&#39;: 3})，也会引发错误。 zip与星号(*)zip 方法在 Python 2 和 Python 3 中的不同： 在 Python 3 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。 在python3中（有个大坑），处于优化内存的考虑，只能访问一次(操作一次），内存就会释放 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同 1234567a = [1,2,3]b = [4,5,6]c = [7,8,9,10,11] lis=list(zip(a,b,c)) print(lis)# [(1, 4, 7), (2, 5, 8), (3, 6, 9)] 星号*进行解压，解压的效果：提取iterable对象内的元素 1234567a = [1,2,3]b = [4,5,6]zipped_list = list(zip(a,b))print(zipped_list) print(*zipped_list)# [(1, 4), (2, 5), (3, 6)]# (1, 4) (2, 5) (3, 6) zip 与 *zip 进行逆操作 1234567a = [1,2,3]b = [4,5,6]lis = zip(a,b) # [(1, 4), (2, 5), (3, 6)]result = zip(*lis) # 等价于 zip( (1, 4), (2, 5), (3, 6) )aa,bb = list(result)print(aa,bb)# (1, 2, 3), (4, 5, 6) 又获得原来的a、b 字符串处理用Shell通配符匹配字符串fnmatch 模块提供了两个函数—— fnmatch() 和 fnmatchcase() ，可以用 Unix Shell 中常用的通配符(比如 *.py , Dat[0-9]*.csv 等)去匹配文本字符串。 fnmatch() 函数匹配能力介于简单的字符串方法和强大的正则表达式之间。 如果在数据处理操作中只需要简单的通配符就能完成的时候，这通常是一个比较合理的方案。 如果你的代码需要做文件名的匹配，最好使用 glob 模块。参考5.13小节。 1234567891011from fnmatch import fnmatch, fnmatchcaseprint(fnmatch('foo.txt', '*.txt'))print(fnmatch('foo.txt', '?oo.txt'))print(fnmatch('Dat45.csv', 'Dat[0-9]*'))names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py'][name for name in names if fnmatch(name, 'Dat*.csv')]# True# True# True# ['Dat1.csv', 'Dat2.csv'] fnmatch() 函数使用底层操作系统的大小写敏感规则(不同的系统是不一样的)来匹配模式。比如： 123456# On OS X (Mac)fnmatch(&apos;foo.txt&apos;, &apos;*.TXT&apos;)# False# On Windowsfnmatch(&apos;foo.txt&apos;, &apos;*.TXT&apos;)# True 如果你对这个区别很在意，可以使用 fnmatchcase() 来代替。它完全使用你的模式大小写匹配。比如： 12fnmatchcase(&apos;foo.txt&apos;, &apos;*.TXT&apos;)# False 正则表达式匹配字符串如果你想匹配的是字面字符串，那么你通常只需要调用基本字符串方法就行， 比如 str.find() , str.endswith() , str.startswith() 或者类似的方法。 对于复杂的匹配需要使用正则表达式和 re 模块， 核心步骤就是先使用 re.compile() 编译正则表达式字符串， 然后使用 match() , search(),findall() 或者 finditer() 等方法。 需要注意的是 match() 方法仅仅检查字符串的从头开始部分，出现在字符串中间的子串不会匹配到。它的匹配结果有可能并不是你期望的那样。 如果你仅仅是做一次简单的文本匹配/搜索操作的话，可以略过编译部分，直接使用 re 模块级别的函数。如果你打算做大量的匹配和搜索操作的话，最好先编译正则表达式，然后再重复使用它。 模块级别的函数会将最近编译过的模式缓存起来，因此并不会消耗太多的性能， 但是如果使用预编译模式的话，你将会进一步减少查找和一些额外的处理损耗。 当写正则式字符串的时候，相对普遍的做法是使用原始字符串比如 r&#39;(\\d+)/(\\d+)/(\\d+)&#39; 。 这种字符串将不去解析反斜杠，这在正则表达式中是很有用的。 如果不这样做的话，你必须使用两个反斜杠，类似 &#39;(\\\\d+)/(\\\\d+)/(\\\\d+)&#39; 。 字符串搜索和替换对于简单的字面模式，直接使用 str.replace() 方法即可，对于复杂的模式，请使用 re 模块中的 sub() 函数。如将形式为 11/27/2012 的日期字符串改成 2012-11-27 。示例如下： 1234import retext = 'Today is 11/27/2012. PyCon starts 3/13/2013.'re.sub(r'(\\d+)/\\d+)/(\\d+)', r'\\3-\\1-\\2', text)# 'Today is 2012-11-27. PyCon starts 2013-3-13.' sub() 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \\3 指向前面模式的捕获组号。 sub() 函数除了接受替换字符串外，还能接受一个回调函数。 123456789101112131415161718192021222324import retext = 'UPPER PYTHON, lower python, Mixed Python're.findall('python', text, flags=re.IGNORECASE)# ['PYTHON', 'python', 'Python']re.sub('python', 'snake', text, flags=re.IGNORECASE) # 替换为字符串# 'UPPER snake, lower snake, Mixed snake'def matchcase(word): # 定义 处理不同match时替换为不同的字符串 的函数 def replace(m): text = m.group() if text.isupper(): return word.upper() elif text.islower(): return word.lower() elif text[0].isupper(): return word.capitalize() else: return word return replacere.sub('python', matchcase('snake'), text, flags=re.IGNORECASE) # 使用回调函数# 'UPPER SNAKE, lower snake, Mixed Snake' 多行匹配模式123456789101112import recomment = re.compile(r'/\\*(.*?)\\*/')text1 = '/* this is a comment */'text2 = '''/* this is amultiline comment */'''comment.findall(text1)# [' this is a comment ']comment.findall(text2)# []re.compile(r'/\\*(.|\\n)*?\\*/') 将Unicode文本标准化(统一unicode文本)处理Unicode字符串，需要确保所有字符串在底层有相同的表示。 因为在Unicode中，某些字符能够用多个合法的编码表示。为了说明，考虑下面的这个例子： 123456789101112s1 = 'Spicy Jalape\\u00f1o's2 = 'Spicy Jalapen\\u0303o'print(s1)# 'Spicy Jalapeño'print(s1)# 'Spicy Jalapeño's1 == s2# Falselen(s1)# 14len(s2)# 15 为了修正这个问题，你可以使用unicodedata模块先将文本标准化： 12345678910111213import unicodedatat1 = unicodedata.normalize('NFC', s1)t2 = unicodedata.normalize('NFC', s2)print(t1 == t2)# Trueprint(ascii(t1))'Spicy Jalape\\xf1o't3 = unicodedata.normalize('NFD', s1)t4 = unicodedata.normalize('NFD', s2)print(t3 == t4)# Trueprint(ascii(t3))# 'Spicy Jalapen\\u0303o' 标准化的标准normalize() 第一个参数指定字符串标准化的方式。 NFC表示字符应该是整体组成(比如可能的话就使用单一编码，会把’eu0301’2个字节压缩到1个字节’é’。)，而NFD表示字符应该分解为多个组合字符表示。 python同样支持扩展的标准化形式NFKC和NFKD，它们在处理某些字符的时候增加了额外的兼容特性。比如： 123456789s = '\\ufb01' # 一个单字节的字符'ﬁ'unicodedata.normalize('NFD', s)'ﬁ'# 注意组合的字符如何被分解unicodedata.normalize('NFKD', s)'fi'unicodedata.normalize('NFKC', s)'fi' 处理和音字符（TODO 2.12还没看）在清理和过滤文本的时候字符的标准化也是很重要的。 比如，假设你想清除掉一些文本上面的变音符的时候(可能是为了搜索和匹配)： 123t1 = unicodedata.normalize('NFD', s1)''.join(c for c in t1 if not unicodedata.combining(c))'Spicy Jalapeno' 最后一个例子展示了 unicodedata 模块的另一个重要方面，也就是测试字符类的工具函数。combining() 函数可以测试一个字符是否为和音字符。 正则中匹配unicode字符如果你想在模式中包含指定的Unicode字符，你可以使用Unicode字符对应的转义序列(比如 \\uFFF或者 \\UFFFFFFF )。 下面是一个匹配几个不同阿拉伯编码页面中所有字符的正则表达式： 1&gt;&gt;&gt; arabic = re.compile('[\\u0600-\\u06ff\\u0750-\\u077f\\u08a0-\\u08ff]+') 注意大小写转换问题当执行匹配和搜索操作的时候，最好是先标准化并且清理所有文本为标准化格式。 但是同样也应该注意一些特殊情况，比如在忽略大小写匹配和大小写转换时的行为。 1234567pat = re.compile('stra\\u00dfe', re.IGNORECASE)s = 'straße'pat.match(s) # 匹配成功# &lt;_sre.SRE_Match object at 0x10069d370&gt;pat.match(s.upper()) # 匹配失败s.upper() # Case folds# 'STRASSE' 删除字符串中空白字符（不需要的字符）开始、结束的字符用于删除开始或结尾的字符，默认情况下，strip、lstrip、rstrip方法会去除空白字符，但是你也可以指定其他字符，注意strip()指定其他字符的使用，只要在开始或者结尾位置的字符符合指定的字符之一，就会被删除。 123456789t = '---=-hello===-='t.lstrip('-')# '=-hello===-='t.rstrip('=')# '---=-hello==-'t.strip('-=') #注意该情况# 'hello' 中间的字符如果你想处理中间的空格，那么你需要求助其他技术。比如使用 replace() 方法或者是用正则表达式替换。示例如下： 12345s.replace(' ', '')# 'helloworld'import rere.sub('\\s+', ' ', s)# 'hello world' strip与生成器通常情况下你想将字符串 strip 操作和其他迭代操作相结合，比如从文件中读取多行数据。 如果是这样的话，那么生成器表达式就可以大显身手了。比如： 1234with open(filename) as f: lines = (line.strip() for line in f) for line in lines: print(line) 在这里，表达式 lines = (line.strip() for line in f) 执行数据转换操作。 这种方式非常高效，因为它不需要预先读取所有数据放到一个临时的列表中去。 它仅仅只是创建一个生成器，并且每次返回行之前会先执行 strip 操作。 字符串对齐结论：优先选择 format() 函数或者方法。 format() 要比 % 操作符的功能更为强大。 format() 也比使用 ljust() , rjust() 或 center() 方法更通用(使用 &lt;,&gt; 或者 ^ 字符后面紧跟一个指定的宽度)， 因为它可以用来格式化任意对象，而不仅仅是字符串。 123456789101112131415text = 'Hello World'# 用空格对齐format(text, '&lt;20') # 等价于 text.ljust(20) # 'Hello World 'format(text, '&gt;20') # 等价于 text.rjust(20)# ' Hello World'format(text, '^20') # 等价于 text.center(20)# ' Hello World '# 用指定字符对齐format(text, '=&gt;20') # 等价于 text.rjust(20,'=')# '=========Hello World'format(text, '*^20') # 等价于 text.center(20,'*')# '****Hello World*****' 当格式化多个值的时候，这些格式代码也可以被用在 format() 方法中。比如： 12'&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;'.format('Hello', 'World')# ' Hello World' 合并拼接字符串推荐使用 join如果你仅仅只是合并少数几个字符串，使用加号(+)通常已经足够了。 如果你想要合并的字符串是在一个序列或者 iterable 中，那么最快的方式就是使用 join() 方法。 123parts = ['Is', 'Chicago', 'Not', 'Chicago?']' '.join(parts)# 'Is Chicago Not Chicago?' 初看起来，这种语法看上去会比较怪，但是 join() 被指定为字符串的一个方法。 这样做的部分原因是你想去连接的对象可能来自各种不同的数据序列(比如列表，元组，字典，文件，集合或生成器等)， 如果在所有这些对象上都定义一个 join()方法明显是冗余的。 一个相对比较聪明的技巧是利用生成器表达式转换数据为字符串的同时合并字符串，比如： 123data = ['ACME', 50, 91.1]','.join(str(d) for d in data)# 'ACME,50,91.1' 避免不必要的拼接比如在打印的时候： 123print(a + ':' + b + ':' + c) # Uglyprint(':'.join([a, b, c])) # Still uglyprint(a, b, c, sep=':') # 推荐 当混合使用I/O操作和字符串连接操作的时候，有时候需要仔细研究你的程序。 比如，考虑下面的两端代码片段： 123456# Version 1 (string concatenation)f.write(chunk1 + chunk2)# Version 2 (separate I/O operations)f.write(chunk1)f.write(chunk2) 如果两个字符串很小，那么第一个版本性能会更好些，因为I/O系统调用天生就慢。 另外一方面，如果两个字符串很大，那么第二个版本可能会更加高效， 因为它避免了创建一个很大的临时结果并且要复制大量的内存块数据。 以指定列宽 格式化字符串使用 textwrap 模块来格式化字符串的输出 12345678910111213141516171819202122232425s = \"Look into my eyes, look into my eyes, the eyes, the eyes, the eyes, not around the eyes, don't look around the eyes, look into my eyes, you're under.\"import textwrapprint(textwrap.fill(s, 70))# Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,# not around the eyes, don't look around the eyes, look into my eyes,# you're under.print(textwrap.fill(s, 40))# Look into my eyes, look into my eyes,# the eyes, the eyes, the eyes, not around# the eyes, don't look around the eyes,# look into my eyes, you're under.print(textwrap.fill(s, 40, initial_indent=' '))# Look into my eyes, look into my# eyes, the eyes, the eyes, the eyes, not# around the eyes, don't look around the# eyes, look into my eyes, you're under.print(textwrap.fill(s, 40, subsequent_indent=' '))# Look into my eyes, look into my eyes,# the eyes, the eyes, the eyes, not# around the eyes, don't look around# the eyes, look into my eyes, you're# under. 当你希望输出自动匹配终端大小的时候。 你可以使用 os.get_terminal_size() 方法来获取终端的大小尺寸。比如： 12import osos.get_terminal_size().columns fill() 方法接受一些其他可选参数来控制tab，语句结尾等。 参阅 textwrap.TextWrapper文档 获取更多内容。 在字符串中处理html和xml(TODO 未看)https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p17_handle_html_xml_in_text.html#htmlxml 字符串令牌解析(TODO 未看)https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p18_tokenizing_text.html 数字日期和时间数字的四舍五入简单的四舍五入使用内置的 round(value, ndigits) 函数即可。 一、关于保留的位数 传给 round() 函数的 ndigits 参数可以是负数，这种情况下， 舍入运算会作用在十位、百位、千位等上面。比如： 1234&gt;&gt;&gt; a = 1627731&gt;&gt;&gt; round(a, -1)1627730&gt;&gt;&gt; round(a, -2) 二、关于四舍五入 1234567## python2 ##round(0.5)1.0## python3 ##round(0.5)0 在python2.7的doc中，round()的最后写着保留值将保留到离上一位更近的一端（四舍六入），如果距离两端一样远，则保留到离0远的一边。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。 Values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done away from 0 但是到了python3.5的doc中，文档变成了如果距离两边一样远，会保留到偶数的一边。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。 values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice 三、关于精度问题 12round(2.675, 2)2.67 round(2.675, 2)的结果，不论我们从python2还是3来看，结果都应该是2.68的，结果它偏偏是2.67，为什么？这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串1和0后可能是无限位数的，机器已经做出了截断处理。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离2.67要更近一点点，所以保留两位小数时就近似到了2.67。 总结 以上。除非对精确度没什么要求，否则尽量避开用round()函数。近似计算我们还有其他的选择： 使用math模块中的一些函数，比如math.ceiling（天花板除法）。 python自带整除，python2中是/，3中是//，还有div函数。 字符串格式化可以做截断使用，例如 &quot;%.2f&quot; % value（保留两位小数并变成字符串，如果还想用浮点数请披上float()的外衣）。 当然，对浮点数精度要求如果很高的话，请用decimal模块。 参考 https://www.cnblogs.com/anpengapple/p/6507271.html 数值格式化指令定宽度和精度的一般形式是 &#39;[&lt;&gt;^]?width[,]?(.digits)?&#39; ， 其中 width 和 digits 为整数，？代表可选部分。 同样的格式也被用在字符串的 format() 方法中。比如： 12&gt;&gt;&gt; &apos;The value is &#123;:0,.2f&#125;&apos;.format(x)&apos;The value is 1,234.57&apos; 进制10 进制—&gt;其他带前缀的 使用 bin() , oct() 或 hex() 函数 12345678&gt;&gt;&gt; x = 1234&gt;&gt;&gt; bin(x)&apos;0b10011010010&apos;&gt;&gt;&gt; oct(x)&apos;0o2322&apos;&gt;&gt;&gt; hex(x)&apos;0x4d2&apos;&gt;&gt;&gt; 没有前缀的 如果不想输出 0b , 0o 或者 0x 的前缀的话，可以使用 format() 函数 1234567&gt;&gt;&gt; format(x, &apos;b&apos;)&apos;10011010010&apos;&gt;&gt;&gt; format(x, &apos;o&apos;)&apos;2322&apos;&gt;&gt;&gt; format(x, &apos;x&apos;)&apos;4d2&apos;&gt;&gt;&gt; 其他—&gt;10 进制其他的进制转换整数，简单的使用带有进制的 int() 函数即可： 1234&gt;&gt;&gt; int('4d2', 16)1234&gt;&gt;&gt; int('10011010010', 2)1234 字节到大整数的打包与解包 https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p05_pack_unpack_large_int_from_bytes.html 无穷大与 NaN定义 123&gt;&gt;&gt; a = float(&apos;inf&apos;)&gt;&gt;&gt; b = float(&apos;-inf&apos;)&gt;&gt;&gt; c = float(&apos;nan&apos;) 检测 测试是否为这些值，使用 math.isinf() 和 math.isnan() 函数。比如： 12345&gt;&gt;&gt; math.isinf(a)True&gt;&gt;&gt; math.isnan(c)True&gt;&gt;&gt; 传播 无穷大数在执行数学计算的时候会传播 NaN值会在所有操作中传播，而不会产生异常 NaN值的一个特别的地方时它们之间的比较操作总是返回False。因此唯一安全的方法就是使用 math.isnan() 分数运算https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p08_calculating_with_fractions.html 随机随机小数random.random()方法用于生成一个0到1的随机浮点数：0&lt;=n&lt;1.0 random.uniform() 计算均匀分布随机数,0&lt;=n&lt;1.0 随机整数random.randint(a,b)：用于生成一个指定范围内的整数。其中生成的随机数n：a&lt;=n&lt;=b random.randrange([start],stop[, step])：从指定范围内，按指定基数递增的集合中获取一个随机数。如：random.randrange(10,100,2)，结果相当于从[10,12,14,16,…,96,98]序列中获取一个随机数。random.randrange(10,100,2)在结果上与random.choice(range(10,100,2))等效。 随机选择数组中的1个12&gt;&gt;&gt; print random.choice([\"JGood\",\"is\",\"a\",\"handsome\",\"body\"])is 随机选择数组中的 N个random.sample(sequence,k)：从指定序列中随机获取指定长度的片段，sample函数不会修改原有序列。 123&gt;&gt;&gt; list=[1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; print random.sample(list,5) #从list中随机获取5个元素，作为一个片段返回[1, 6, 10, 8, 3] https://www.cnblogs.com/chamie/p/4917820.html 时间处理datetime 模块datetime 模块，可以进行常规的加减计算。 12345from datetime import datetimea = datetime(2012, 9, 23)b = datetime(2012, 9, 20)print(a - b)# 3 days, 0:00:00 为了表示一个时间段，可以创建一个 timedelta 实例，就像下面这样： 12345678910from datetime import timedeltaa = timedelta(days=2, hours=6)b = timedelta(hours=4.5)c = a + b&gt;&gt;&gt; c.days2&gt;&gt;&gt; c.seconds37800&gt;&gt;&gt; c.total_seconds() / 360058.5 在计算的时候，需要注意的是 datetime 会自动处理闰年。 高级库 如果你需要执行更加复杂的日期操作，比如处理时区，模糊时间范围，节假日计算等等， 可以考虑使用 dateutil模块 循环时间123456&gt;&gt;&gt; for d in date_range(datetime(2012, 9, 1), datetime(2012,10,1), timedelta(hours=6)):... print(d)...2012-09-01 00:00:002012-09-01 06:00:00 这种实现之所以这么简单，还得归功于Python中的日期和时间能够使用标准的数学和比较操作符来进行运算。 字符串与时间对象字符串—&gt;时间：strptime 1234567&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; text = '2012-09-20'&gt;&gt;&gt; y = datetime.strptime(text, '%Y-%m-%d')&gt;&gt;&gt; z = datetime.now()&gt;&gt;&gt; diff = z - y&gt;&gt;&gt; diffdatetime.timedelta(3, 77824, 177393) 时间—&gt;字符串：strftime 12345&gt;&gt;&gt; zdatetime.datetime(2012, 9, 23, 21, 37, 4, 177393)&gt;&gt;&gt; nice_z = datetime.strftime(z, '%A %B %d, %Y')&gt;&gt;&gt; nice_z'Sunday September 23, 2012' 时区https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p16_manipulate_dates_involving_timezone.html 迭代器与生成器next函数一、默认会抛出异常 StopIteration 用来指示迭代的结尾。 1234567with open('/etc/passwd') as f: try: while True: line = next(f) print(line, end='') except StopIteration: pass 二、通过返回一个指定值来标记结尾 123456with open('/etc/passwd') as f: while True: line = next(f, None) # 设置为不抛出异常，返回 None 的方式 if line is None: break print(line, end='') 文件与 IOTODO 5.4，5.6， 5.8，5.9，5.10，5.18, 5.20(略)读写文本文件rt,wt,at模式使用带t的模式，文件的读写操作默认使用系统编码，可以通过调用 sys.getdefaultencoding() 来得到。 在大多数机器上面都是utf-8编码。 12345678with open('somefile.txt', 'rt') as f: for line in f: # process line ...with open('somefile.txt', 'wt') as f: f.write(text1) f.write(text2) x模式，文件不存在才能写入 x模式是一个Python3对 open() 函数特有的扩展。 在Python的旧版本或者是Python实现的底层C函数库中都是没有这个模式的。 可以在 open() 函数中使用 x 模式来代替 w 模式的方法来解决这个问题。比如： 12345678910&gt;&gt;&gt; with open(&apos;somefile&apos;, &apos;wt&apos;) as f:... f.write(&apos;Hello\\n&apos;)...&gt;&gt;&gt; with open(&apos;somefile&apos;, &apos;xt&apos;) as f:... f.write(&apos;Hello\\n&apos;)...Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileExistsError: [Errno 17] File exists: &apos;somefile&apos;&gt;&gt;&gt; 如果文件是二进制的，使用 xb 来代替 xt 文件对象的属性12345with open(\"1.txt\",'rt') as f: print(f.name) # 读取的文件名 print(f.mode) # 读取模式 print(f.encoding) # 读取编码 print(f.errors) # 编码错误时的处理方式，默认是‘strict’ python3 中的newline默认情况下，Python会以统一模式处理换行符，识别所有的普通换行符并将其转换为单个 \\n 字符。 如果你不想要这种默认的处理方式，可以给 open() 函数传入参数 newline=&#39;&#39;，注意，这不是清除换行符的作用 123456789&gt;&gt;&gt; # 启用 Newline 转换&gt;&gt;&gt; f = open('hello.txt', 'rt')&gt;&gt;&gt; f.read()'hello world!\\n'&gt;&gt;&gt; # 禁用 Newline 转换 &gt;&gt;&gt; g = open('hello.txt', 'rt', newline='')&gt;&gt;&gt; g.read()'hello world!\\r\\n' 打印到文件中,参数file在 print() 函数中指定 file 关键字参数，像下面这样，文件必须是以文本模式打开。 12with open('d:/work/test.txt', 'wt') as f: print('Hello World!', file=f) 指定打印分隔符或行终止符可以使用在 print() 函数中使用 sep 和 end 关键字参数，以你想要的方式输出。 123456&gt;&gt;&gt; print('ACME', 50, 91.5)ACME 50 91.5&gt;&gt;&gt; print('ACME', 50, 91.5, sep=',')ACME,50,91.5&gt;&gt;&gt; print('ACME', 50, 91.5, sep=',', end='!!\\n')ACME,50,91.5!! 有时候你会看到一些程序员会使用 str.join() 来完成同样的事情。比如： 12&gt;&gt;&gt; print(','.join(('ACME','50','91.5')))ACME,50,91.5 str.join() 的问题在于它仅仅适用于字符串，如果列表中有数值，就需要另外的转换。 你当然可以不用那么麻烦，只需要像下面这样写： 12&gt;&gt;&gt; print(*row, sep=',')ACME,50,91.5 读写压缩文件如下，所有的I/O操作都使用文本模式并执行Unicode的编码/解码。 类似的，如果你想操作二进制数据，使用 rb 或者 wb 文件模式即可。 123456789# gzip compressionimport gzipwith gzip.open('somefile.gz', 'rt') as f: text = f.read()# bz2 compressionimport bz2with bz2.open('somefile.bz2', 'rt') as f: text = f.read() 如果你不指定模式，那么默认的就是二进制模式。 参数 gzip.open() 和 bz2.open() 接受跟内置的 open() 函数一样的参数， 包括 encoding，errors，newline 等等。 当写入压缩数据时，可以使用 compresslevel 这个可选的关键字参数来指定一个压缩级别。比如： 12with gzip.open('somefile.gz', 'wt', compresslevel=5) as f: f.write(text) 默认的等级是9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。 特性 最后一点， 它们可以作用在一个已存在并以二进制模式打开的文件上。比如，下面代码是可行的： 1234import gzipf = open('somefile.gz', 'rb')with gzip.open(f, 'rt') as g: text = g.read() 这样就允许 gzip 和 bz2 模块可以工作在许多类文件对象上，比如套接字，管道和内存中文件等。 文件、路径操作路径名操作请看 Python 小模块的 os.path 测试文件请看 Python 小模块的 os.path 文件列表列出指定目录下的全部文件和目录，非递归获取。 函数 os.listdir() 返回的实体列表会根据系统默认的文件名编码来解码。 但是有时候也会碰到一些不能正常解码的文件名，请参考下一节 1234567891011import os.pathnames = os.listdir('somedir')# 获取文件filenames = [name for name in names if os.path.isfile(os.path.join('somedir', name))]# 获取目录dirnames = [name for name in names if os.path.isdir(os.path.join('somedir', name))] 获取某类文件 1234567891011121314# 方法 1：字符串简单匹配import osnames = os.listdir('somedir')pyfiles = [name for name in os.listdir('somedir') if name.endswith('.py')]# 方法 2：fnmatch 模块from fnmatch import fnmatchpyfiles = [name for name in os.listdir('somedir') if fnmatch(name, '*.py')]# 方法 3：glob 模块 推荐import globpyfiles = glob.glob('somedir/*.py') 文件名编码通常来讲，你不需要担心文件名的编码和解码，普通的文件名操作应该就没问题了。 字符串表示文件名（默认情况） 默认情况下，所有的文件名都会根据 sys.getfilesystemencoding() 返回的文本编码来编码或解码 原始字节字符串表示文件名 如果因为某种原因你想忽略这种编码，可以使用一个原始字节字符串来指定一个文件名即可。 12345678910111213141516171819&gt;&gt;&gt; # 创建一个unicode编码的文件&gt;&gt;&gt; with open('jalape\\xf1o.txt', 'w') as f:... f.write('Spicy!')...6&gt;&gt;&gt; # 打印目录 (默认进行解码ecoded)&gt;&gt;&gt; import os&gt;&gt;&gt; os.listdir('.')['jalapeño.txt']&gt;&gt;&gt; # 打印目录 (使用原始字节字符串)&gt;&gt;&gt; os.listdir(b'.') # 通过传递 字节字符串 来提示 Python 不要解码[b'jalapen\\xcc\\x83o.txt']&gt;&gt;&gt; # Open file with raw filename&gt;&gt;&gt; with open(b'jalapen\\xcc\\x83o.txt') as f:... print(f.read())...Spicy! 打印不合法的文件名默认情况下，Python假定所有文件名都已经根据 sys.getfilesystemencoding() 的值编码过了。 但是，有一些文件系统并没有强制要求这样做，因此允许创建文件名没有正确编码的文件。 操作不合法的文件名或者将文件名传递给 open() 这样的函数时，一切都能正常工作。 只有当你想要输出文件名时才会碰到些麻烦(比如打印输出到屏幕或日志文件等)。 12345678910111213&gt;&gt;&gt; import os&gt;&gt;&gt; files = os.listdir('.')&gt;&gt;&gt; files['spam.py', 'b\\udce4d.txt', 'foo.txt']&gt;&gt;&gt; for name in files:... print(name)...spam.pyTraceback (most recent call last): File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;UnicodeEncodeError: 'utf-8' codec can't encode character '\\udce4' inposition 1: surrogates not allowed&gt;&gt;&gt; 解决方法 123456789101112131415161718# 方法 1，简单处理def bad_filename(filename): return repr(filename)[1:-1]# 方法 2，以正确的编码进行解码def bad_filename(filename): # filename 是 unicode 码，因此先进行编码，最后再解码 temp = filename.encode(sys.getfilesystemencoding(), errors='surrogateescape') return temp.decode('latin-1')for name in files: try: print(name) except UnicodeEncodeError: print(bad_filename(name))spam.pybäd.txtfoo.txt surrogateescape: 这种是Python在绝大部分面向OS的API中所使用的错误处理器， 它能以一种优雅的方式处理由操作系统提供的数据的编码问题。 在解码出错时会将出错字节存储到一个很少被使用到的Unicode编码范围内。 在编码时将那些隐藏值又还原回原先解码失败的字节序列。 它不仅对于OS API非常有用，也能很容易的处理其他情况下的编码错误。 文件对象的层次结构I/O系统由一系列的层次构建而成。你可以试着运行下面这个操作一个文本文件的例子来查看这种层次： 1234567&gt;&gt;&gt; f = open('sample.txt','w')&gt;&gt;&gt; f&lt;_io.TextIOWrapper name='sample.txt' mode='w' encoding='UTF-8'&gt;&gt;&gt;&gt; f.buffer&lt;_io.BufferedWriter name='sample.txt'&gt;&gt;&gt;&gt; f.buffer.raw&lt;_io.FileIO name='sample.txt' mode='wb'&gt; io.TextIOWrapper 是一个编码和解码Unicode的文本处理层，增加或改变文本编码会涉及这一层。 io.BufferedWriter 是一个处理二进制数据的带缓冲的I/O层。 io.FileIO 是一个表示操作系统底层文件描述符的原始文件。 如果你想修改一个已经打开的文本模式的文件的编码方式(暂时不知道有什么用途)，可以先使用 detach() 方法移除掉已存在的文本编码层， 并使用新的编码方式代替。detach() 方法会断开文件的最顶层并返回第二层，之后最顶层就没什么用了。 1234567891011f = open('sample.txt', 'w')# &lt;_io.TextIOWrapper name='sample.txt' mode='w' encoding='UTF-8'&gt;b = f.detach() # 返回的第2层# &lt;_io.BufferedWriter name='sample.txt'&gt;f.write('hello')# Traceback (most recent call last):# File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;# ValueError: underlying buffer has been detached f = io.TextIOWrapper(b, encoding='latin-1')# &lt;_io.TextIOWrapper name='sample.txt' encoding='latin-1'&gt; 将字节写入文本文件如果你想在文本模式打开的文件中写入原始的字节数据，可以将字节数据直接写入文件的缓冲区即可，例如： 12345678&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.stdout.write(b'Hello\\n')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: must be str, not bytes&gt;&gt;&gt; sys.stdout.buffer.write(b'Hello\\n')Hello5 类似的，能够通过读取文本文件的 buffer 属性来读取二进制数据。 原理：I/O系统以层级结构的形式构建而成。 文本文件是通过在一个拥有缓冲的二进制模式文件上增加一个Unicode编码/解码层来创建。 buffer 属性指向对应的底层文件。如果你直接访问它的话就会绕过文本编码/解码层。 创建临时文件和文件夹tempfile 模块中有很多的函数可以完成这任务。 临时文件：tempfile.TemporaryFile 12345678910with TemporaryFile('w+t'，encoding='utf-8', errors='ignore') as f: # Read/write to the file f.write('Hello World\\n') f.write('Testing\\n') # Seek back to beginning and read the data f.seek(0) data = f.read()# Temporary file is destroyed 通常来讲文本模式使用 w+t ，二进制模式使用 w+b 。 这个模式同时支持读和写操作，在这里是很有用的 结果文件关闭时会被自动删除掉。 如果你不想这么做，传递关键字参数 delete=False 所有和临时文件相关的函数都允许通过使用关键字参数 prefix 、suffix 和 dir 来自定义目录以及命名规则 带名字的临时文件：tempfile.NamedTemporaryFile 123with NamedTemporaryFile('w+t', delete=False, prefix='mytemp', suffix='.txt', dir='/tmp') as f: print('filename is:', f.name)# '/tmp/mytemp8ee899.txt' 临时目录： tempfile.TemporaryDirectory() 1234567from tempfile import TemporaryDirectorywith TemporaryDirectory() as dirname: print('dirname is:', dirname) # Use the directory ...# Directory and all contents destroyed 多线程12.10~12.14 TODO","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"ing","slug":"ing","permalink":"https://jizx.vip/tags/ing/"},{"name":"time","slug":"time","permalink":"https://jizx.vip/tags/time/"}]},{"title":"推荐网站","slug":"推荐网站","date":"2019-10-28T12:30:07.000Z","updated":"2020-02-03T08:51:06.562Z","comments":true,"path":"2019/10/28/推荐网站/","link":"","permalink":"https://jizx.vip/2019/10/28/推荐网站/","excerpt":"推荐一些发现的高质量学习网站","text":"推荐一些发现的高质量学习网站 python python 3.6 入门指南 python cookbook 非常多的实践经验 Python 3 标准库实例教程 pandas 10 分钟快速入门（官方文档） 机器学习 PyTorch版《动手学深度学习》 |相关代码 TensorFlow2.0版《动手学深度学习》 神经网络与深度学习-邱锡鹏 Neural Networks and Deep Learning-入门 Hands-on Machine Learning with Scikit-Learn, Keras and TensorFlow 源码 linux 骏马金龙的Shell系列文章 骏马金龙的Shell脚本、bash特性系列 Bash Reference Manual — gnu 官方英文 数据结构与算法数学 交互式线性代数 沉浸式线性代数 其他算法 python shell 网站 http://ddrv.cn/","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://jizx.vip/tags/深度学习/"},{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://jizx.vip/tags/机器学习/"},{"name":"shell","slug":"shell","permalink":"https://jizx.vip/tags/shell/"}]},{"title":"python技巧","slug":"python技巧","date":"2019-10-25T06:36:26.000Z","updated":"2020-02-04T12:10:06.048Z","comments":true,"path":"2019/10/25/python技巧/","link":"","permalink":"https://jizx.vip/2019/10/25/python技巧/","excerpt":"","text":"数据结构字典排序1res = sorted(a.iteritems(), key = lambda kv:(kv[1], kv[0]),reverse=True) 多字段排序其实就是将要排序的字段组成一个元组 12L = [(12, 12), (34, 13), (32, 15), (12, 24), (32, 64), (32, 11)]L.sort(key=lambda x: (x[0], -x[1])) Operator 模块功能允许多级排序。 例如，按 grade 排序，然后按 age 排序： 1234567891011121314151617181920212223242526from operator import itemgetter, attrgetter# 元组、字典类型，使用itemgetterstudent_tuples = [ ('dave', 'B', 10), ('john', 'A', 15), ('jane', 'B', 12)] # 元组类型student_dicts = [&#123;'name':'dave','grade':'B','age':10&#125;,&#123;'name':'john','grade':'A','age':15&#125;,&#123;'name':'jane','grade':'B','age':12&#125;] # 字典类型sorted(student_tuples, key=itemgetter(1,2))sorted(student_tuples, key=itemgetter('grade', 'age'))# [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]# 考虑 Student 对象，使用attrgetterclass Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def __repr__(self): return repr((self.name, self.grade, self.age))student_objects = [ Student('jane', 'B', 12), Student('john', 'A', 12), Student('dave', 'B', 10),]sorted(student_objects, key=attrgetter('grade', 'age'))# [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)] 显示字符串原始内容，不进行转义123s=[\"s\\nsdf\\r\",\"s\\n\",\"d\\r\\n\",\"sdf\\n\\r\"]for i in s: print repr(i) 默认字典 带数据的初始化1d = defaultdict(lambda: 0, &#123;\"1\":1 , \"0\":0 &#125;) python从后向前遍历12for i in range(len(arr)-1, -1, -1): print(arr[i]) 最后个-1表示逆向，从len(arr)-1也就是数组最后一位开始，到0，因为 range 是开始区间，因此为了取到 0，用-1表示结束位置。 字符串操作删除特定的字符问题： 过滤用户输入中前后多余的空白字符：++++abc123--- 过滤某windows下编辑文本中的\\r：hello world \\r\\n 去掉文本中unicode组合字符、音调：Zhào Qián Sūn Lǐ Zhōu Wú Zhèng Wáng 解决方案： 去掉两端字符串： strip(), rstrip(), lstrip() 123456789101112s = ' -----abc123++++ ' # 删除两边空字符print(s.strip())# 删除左边空字符print(s.rstrip())# 删除右边空字符print(s.lstrip())# 删除两边 - + 和空字符print(s.strip().strip('-+')) print(\"北门吹雪:http://www.cnblogs.com/2bjiujiu/\") 删除单个固定位置字符： 切片 + 拼接 1234s = 'abc:123'# 字符串拼接方式去除冒号new_s = s[:3] + s[4:]print(new_s) 删除任意位置字符同时删除多种不同字符：replace(), re.sub() 12345678910# 去除字符串中相同的字符s = '\\tabc\\t123\\tisk'print(s.replace('\\t', '')) print(\"北门吹雪: http://www.cnblogs.com/2bjiujiu/\") import re# 去除\\r\\n\\t字符s = '\\r\\nabc\\t123\\nxyz'print(re.sub('[\\r\\n\\t]', '', s)) 多种不同字符映射转换：translate() 12345s = 'abc123xyz'# a _&gt; x, b_&gt; y, c_&gt; z，字符映射加密print(str.maketrans('abcxyz', 'xyzabc'))# translate把其转换成字符串print(s.translate(str.maketrans('abcxyz', 'xyzabc'))) 去掉unicode字符中音调 12345678910111213141516171819202122232425#!/usr/bin/python3 import sysimport unicodedatas = \"Zhào Qián Sūn Lǐ Zhōu Wú Zhèng Wáng\"remap = &#123; # ord返回ascii值 ord('\\t'): '', ord('\\f'): '', ord('\\r'): None &#125;# 去除\\t, \\f, \\ra = s.translate(remap)''' 通过使用dict.fromkeys() 方法构造一个字典，每个Unicode 和音符作为键，对于的值全部为None 然后使用unicodedata.normalize() 将原始输入标准化为分解形式字符 sys.maxunicode : 给出最大Unicode代码点的值的整数，即1114111（十六进制的0x10FFFF）。 unicodedata.combining:将分配给字符chr的规范组合类作为整数返回。 如果未定义组合类，则返回0。'''cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode) if unicodedata.combining(chr(c))) #此部分建议拆分开来理解b = unicodedata.normalize('NFD', a)''' 调用translate 函数删除所有重音符'''print(b.translate(cmb_chrs)) https://www.cnblogs.com/2bjiujiu/p/7257744.html 文件读写读取多个文件12345with open('file1') as f1, open('file2') as f2, open('file3') as f3: for i in f1: j = f2.readline() k = f3.readline() print(i,j,k) 还有一种优雅一点的写法（已过时）： 1234567from contextlib import nestedwith nested(open('file1'), open('file2'), open('file3')) as (f1,f2,f3): for i in f1: j = f2.readline() k = f3.readline() print(i,j,k) readline报错 Unicode errorThe default for errors is ‘strict’, meaning that encoding errors raise a UnicodeError. Other possible values are ‘ignore’, ‘replace’, ‘xmlcharrefreplace’, ‘backslashreplace’ and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings. In Python 3, pass an appropriate errors= value (such as errors=ignore or errors=replace) on creating your file object (presuming it to be a subclass of io.TextIOWrapper – and if it isn’t, consider wrapping it in one!); also, consider passing a more likely encoding than charmap (when you aren’t sure, utf-8 is always a good place to start). For instance: 1f = open('misc-notes.txt', encoding='utf-8', errors='ignore') In Python 2, the read() operation simply returns bytes; the trick, then, is decoding them to get them into a string (if you do, in fact, want characters as opposed to bytes). If you don’t have a better guess for their real encoding: 1your_string.decode('utf-8', 'replace') …to replace unhandled characters, or 1your_string.decode('utf-8', 'ignore') to simply ignore them. 遍历文件夹12345source -- dir -- 文件3.txt -- 文件1.txt -- 文件2.txt listdir：罗列出指定目录下的一级文件以及目录，不递归进入子文件夹 12345678import osimport sysfilesystemencoding = sys.getfilesystemencoding() # 获取文件系统的编码files = os.listdir(\"source/\")for file in files: file = file.decode(filesystemencoding).encode(\"utf-8\") print file walk：罗列出指定目录下全部的文件、文件夹 12345678import osimport sysfilesystemencoding = sys.getfilesystemencoding()for pwd, dirs, files in os.walk(\"source/\"): for f in files: f = f.decode(filesystemencoding).encode(\"utf-8\") print f 写入文件头部123456new_data = \"ssss\"with open(\"1.txt\", 'r+') as fw: old_data = fw.read() # 读取全部文本内容，此时指针会到文件尾部 fw.seek(0) # 通过seek回到文件头部 fw.write(new_data) fw.write(old_data) https://blog.csdn.net/junbujianwpl/article/details/73194846 打印显示在一行内显示进度Python3版本 1234567import sysimport timefor i in range(0, 100): time.sleep(0.1) print(\"\\r\" + \"#\" * i, end=\"\") sys.stdout.flush() python2版本，逗号是重点 1234567import sysimport timefor i in range(100): time.sleep(0.1) print \"\\r\"+\"#\"*i, # 重点是这个逗号 sys.stdout.flush() format 函数的格式化语言12345678format_spec ::= [[fill]align][sign][#][0][width][grouping_option][.precision][type]fill ::= &lt;any character&gt;align ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;sign ::= &quot;+&quot; | &quot;-&quot; | &quot; &quot;width ::= digit+grouping_option ::= &quot;_&quot; | &quot;,&quot;precision ::= digit+type ::= &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot; 其他python 查看所有模块12345python&gt;&gt;&gt; help()Welcome to Python 3.7's help utility!...........help&gt; modules 使用其他目录的模块123PROJECT_PATH = path.dirname(path.dirname(path.abspath(__file__))) # 当前文件所在目录的前两级目录sys.path.append(PROJECT_PATH) # 添加在环境变量中from conf import config # 就可以使用conf目录中的config.py文件了 sys.exit 与 exit、quit 的区别exit和quit函数 这两个函数的作用，就是直接退出程序，可以带一个参数作为程序的返回码，如果不带参数，默认就是返回0. 12345678910111213141516xinlin@ubuntu:~/test$ python3 -q&gt;&gt;&gt; exit(111)xinlin@ubuntu:~/test$ echo $?111xinlin@ubuntu:~/test$ python3 -q&gt;&gt;&gt; quit(222)xinlin@ubuntu:~/test$ echo $?222xinlin@ubuntu:~/test$ python3 -q&gt;&gt;&gt; exit()xinlin@ubuntu:~/test$ echo $?0xinlin@ubuntu:~/test$ python3 -q&gt;&gt;&gt; quit()xinlin@ubuntu:~/test$ echo $?0 sys.exit()函数 sys.exit()函数会抛出一个SystemExit异常，Python代码可以捕获这个异常来进行一些程序退出前的清理工作。sys.exit函数同样可以带一个参数来作为程序的退出码，默认是0. 实践中，完整的使用sys.exit函数的逻辑应该是如下这样的代码： 1234567891011121314import sysdef main(): # do something sys.exit(123) returnif __name__ == '__main__': try: main() except SystemExit as e: if str(e) == '123': print('---123---') exit(123) 使用sys.exit函数退出程序，可以有个异常捕获机制来做清理扫尾的工作，程序会更加灵活健壮。","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"}]},{"title":"开发环境搭建与效率技巧","slug":"开发环境搭建与效率技巧","date":"2019-10-25T06:27:11.000Z","updated":"2020-09-10T14:51:41.709Z","comments":true,"path":"2019/10/25/开发环境搭建与效率技巧/","link":"","permalink":"https://jizx.vip/2019/10/25/开发环境搭建与效率技巧/","excerpt":"Mac、linux、window这 3 大系统的开发环境搭建推荐、遇到的相关问题的解决方案记录","text":"Mac、linux、window这 3 大系统的开发环境搭建推荐、遇到的相关问题的解决方案记录 通用环境Python 环境macOS安装 anaconda 更多请查看 anaconda与jupyter使用与设置 清华镜像站下载 或者清华镜像站anaconda首页 或者anaconda官网(比较慢)，这样这个环境中默认的python就是最新的。 根据提示完成安装，这时命令行中conda --version 无法执行， for anaconda 3 : 1export PATH=~/anaconda3/bin:$PATH 然后通过conda --version 确认 export PATH=~/anaconda3/bin:$PATH 有效时间为这次终端结束，因此应该通过 123sudo nano ~/.bashrc # bash或者sudo nano ~/.zshrc # zsh 修改配置文件，将命令复制保存在文件中，最后通过source .bashrc加载新的配置信息，使得配置立即生效。 在pycharm设置中搜索 interpreter，添加解释器，选择conda 环境，如果想让新项目默认使用该解释器，勾选【 make available to all projects】 卸载官方安装包不建议自己安装 官网的Python，因为这是典型的安装容易，删除麻烦。提供了安装器，但没有卸载器 我们首先要知道其具体都安装了什么，实际上，在安装 Python 时，其自动生成: Python framework，即 Python 框架; Python 应用目录; 指向 Python 的连接。 对于 Mac 自带的 Python，其框架目录为：/System/Library/Frameworks/Python.framework 而我们安装的 Python，其(默认)框架目录为：/Library/Frameworks/Python.framework 接下来，我们就分别(在 Mac 终端进行)删除上面所提到的三部分，其中x.x为 Python 的版本号。 删除框架:sudo rm -rf /Library/Frameworks/Python.framework/Versions/x.x 删除应用目录:sudo rm -rf &quot;/Applications/Python x.x&quot; 删除指向 Python 的连接:ls -l /usr/local/bin | grep &#39;../Library/Frameworks/Python.framework/Versions/x.x&#39; | awk &#39;{print $9}&#39; | tr -d @ | xargs rm 删除环境变量$PATH window 下载最新python版本对应的anaconda，这样这个环境中默认的python就是最新的 右键我的电脑—属性—高级系统设置—-高级选项里面有一个环境变量，点击环境变量——系统变量里面 找path——双击path，添加路径，路径间用;隔开，需要添加的路径有三个：F:\\Anaconda3;F:\\Anaconda3\\Scripts;F:\\Anaconda3\\Library\\bin anaconda的使用请看anaconda与jupyter使用与设置 pip的使用pipi清华镜像设置 临时使用 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 永久使用 方法1：命令设置 1pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 方法2：手动修改 linux下，修改 ~/.pip/pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple IDE 配置pycharm快捷键编辑Shift + Enter：在下方新建行并移到新行行首Ctrl + /：注释(取消注释)选择的行Ctrl + Alt + L：格式化代码(与QQ锁定热键冲突，关闭QQ的热键) 查找alt+F7 查找变量、函数、方法在项目中被使用的位置Ctrl + Shift + F：高级查找 设置打开设置，Editor-&gt;Code Style 可以看到，默认是System-Dependent，修改为\\n VSCode设置成中文菜单vscode默认的语言是英文，简单几步教大家如何将vscode设置成中文。 按快捷键“Ctrl+Shift+P”。 在“vscode”顶部会出现一个搜索框。 输入“configure language”，然后回车。 “vscode”里面就会打开一个语言配置文件。 将“en-us”修改成“zh-cn”。 按“Ctrl+S”保存设置。 关闭“vscode”，再次打开就可以看到中文界面了。 当前文件显示完整路径信息 File-&gt;Preferences-&gt;Settings 搜索window.title 修改 activeEditorShort =&gt; activeEditorLong 推荐扩展扩展 TODO Highlight 高亮TODO提示 Rainbow Brackets 高亮括号 indent-rainbow 突出显示缩进 python Python运行插件，默认按F5后进入DEBUG模式，需要再按一次F5程序才会运行 flake8 python语法提示（1.打开终端，输入 pip install flake8 安装flake8；2.在settings.json文件中输入”python.linting.flake8Enabled”: true） Yapf 自动格式化代码 Yapf是谷歌开源的一个用于格式化Python代码的工具，可以一键美化代码。支持两种规范：PEP8和Google Style. 打开终端 输入 “pip install yapf” 安装yapf 在settings.json文件中输入”python.formatting.provider”: “yapf” 用一个看看， 按下快捷键 Alt+Shift+F 即可自动格式化代码。 Python Docstring Generator 生成注释格式 主题 Snazzy Operator 字体 operator-mono 图标 Material Icon Theme Material Theme Icons https://zhuanlan.zhihu.com/p/112431369 终端字体在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。 123下载安装字体$cd /Library/Fonts$sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git 在vscode中设置字体： 1&quot;terminal.integrated.fontFamily&quot;: &quot;Menlo for Powerline&quot; SecureCRT自动验证堡垒机、登录到开发机 个人PC连接开发机都需要先ssh跳板机（堡垒机），再ssh开发机。如果有多台开发机，或者想开多个开发机的窗口，就需要重复地通过跳板机验证，再重复地输入开发机密码。按照以下步骤即可一键登录各个开发机，获得懒癌晚期勋章。 以下是在MAC环境测试通过，window请自行踩坑。 零. 准备工作1、开启mac的远程登录【必选】，默认情况mac是关闭远程登录功能的 做法：在设置中搜索“远程登录”，就可以快速找到开关。 2、下载SecureCRT 密码:4ekd 有些同学的Secure无法记住密码，可能是因为软件权限不够，无法保存到mac的“钥匙串访问” 中，然后又不提示，莫名地每次都要密码，可以试一下覆盖安装这个软件包。 一.连接跳板机新建一个本地连接，使用个人PC的账号和密码进行ssh连接，选择记住账号和密码。 可以看到ssh的信息 然后在Logon Actions中添加自动脚本，用于自动ssh连接跳板机，并自动输入密码。 二.设置共享ssh会话【功能】：使用跳板机时，我们需要登录到跳板机，才能登录到开发机，为了每天只需要第一次输入token密码，以后再登录共享第一次的会话（隐含意思就是不要关闭第一个ssh窗口，否则需要重新输入密码） 【实现】：执行命令vim ~/.ssh/config，加入以下内容 123Host * ControlMaster auto ControlPath ~/.ssh/master-%r@%h:%p 【验证】：打开一个标签页执行ssh xxx@跳板机.com，输入token，然后按Command+T新建一个窗口，再次执行ssh xxx@跳板机.com，不需要输入密码即可登录跳板机。 【锁住跳板机】：为了避免不小心关掉了跳板机的标签页（一旦关掉，其他标签页的连接将全部断开），secureCRT非常nice地支持锁定标签页，对标签页右键选择Lock Session，设置密码，出现小黄锁就OK啦。 三.登录开发机与登录跳板机的操作类似，首先新建一个本地连接，session名称设定为开发机名称。 然后设置自动登录脚本： ssh连接跳板机； 第二步不再需要跳板机密码，已经共享了ssh，直接ssh目标开发机； 输入开发机密码； cd 到指定的目录、、、等其他操作。 Git换行符问题 Git 的换行符转换策略配置需要与项目同步，不能仅仅是依靠团队规范来约束； 文件是否需要做换行符转换处理，是由文件本身的属性决定的，需要对每个文件分别对待； Windows 批处理 bat 文件最好使用 CRLF 作为换行符； bash 脚本文件应当使用 LF 作为换行符； 这个问题与git-config里面的相关设置有关，主要涉及到三个参数： core.autocrlf core.safecrlf core.eol core.autocrlf设置是否进行自动转换 12345678# 当添加到暂存区时，自动将CRLF转换成LF；反之，当检出时，自动将LF转换成CRLFgit config --global core.autocrlf true # 提交时转换为LF，检出时不转换git config --global core.autocrlf input # 提交检出均不转换git config --global core.autocrlf false core.safecrlf 设置是否检查换行符 12345678# 拒绝提交包含混合换行符的文件git config --global core.safecrlf true # 允许提交包含混合换行符的文件git config --global core.safecrlf false # 提交包含混合换行符的文件时给出警告git config --global core.safecrlf warn core.eol 当core.autocrlf是false时，设置行结束符的类型，可以是 lf crlf native三种，其中native是指平台默认的行结束符。默认的类型是native 个人建议方案第一种123git config --global core.autocrlf falsegit config --global core.safecrlf true # 并且把所有文件转换为Linux编码（即LF\\n），开启safecrlf检查 也就是让代码仓库使用统一的换行符(LF)，如果代码中包含 CRLF 类型的文件时将无法提交，需要用 dos2unix 或者其他工具手动转换文件类型。 第二种使用 .gitattributes 就完美解决了以上两个问题： .gitattributes 具有最高的优先级，无论你是否设置相关的换行符风格转化属性，你都可以和团队保持一致； 使用 * text=auto 可以定义开启全局的换行符转换； 使用 *.bat text eol=crlf 就可以保证 Windows 的批处理文件在 checkout 至工作区时，始终被转换为 CRLF 风格的换行符； 使用 *.sh text eol=lf 就可以保证 Bash 脚本无论在哪个平台上，只要被 checkout 至工作区，始终被保持 LF 风格的换行符； 使用 *.jpg -text 可以禁止 Git 将 jpg 文件识别为文本文件，从而避免由于换行符转换引入的数据损坏； 首先要在项目里添加.gitattributes文件，可以参考Github help-Dealing with line endings和gitattributes 推荐的现成模板gitattributes 例子： 123456789101112131415161718# 设置默认行为, in case people don't have core.autocrlf set.* text=auto# 显示声明想要进行规范化的文本类型。Explicitly declare text files you want to always be normalized and converted to native line endings on checkout.#*.c text#*.h text*.md text*.js text*.json text*.wxss text*.wxml text# 保持CRLF的文件。Declare files that will always have CRLF line endings on checkout.#*.sln text eol=crlf# 指定哪些文件是二进制文件，禁止转换。Denote all files that are truly binary and should not be modified.*.png binary*.jpg binary 关于 .gitattributes 的详细使用方法，可以参考Git Documentation:gitattributes。 参考： https://www.jianshu.com/p/2a46dfd3705a https://www.jianshu.com/p/fa4d5963b6c8 http://kuanghy.github.io/2017/03/19/git-lf-or-crlf windowcmd的乱码打开设置——&gt; Startup-Environment——&gt; 添加 set LANG=zh_CN.UTF-8 macmac 与 samba连接反应慢问题SMB 的支持有问题，请用 CIFS。具体方法是在 Finder 里摁 cmd ＋k，然后把 SMB 那个地址前缀替换成 cifs。比如原来是 smb://YYY/XXX, 改完后为 cifs://YYY/XXX。 Linux推荐配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 效率命令alias ..='cd ..'alias ...='cd ../../'alias grep=\"grep --color=auto\"alias qe=\"qe_biz_bh --sessionconf engine=wing\"alias vi=\"vim\"alias ls=\"ls --color=auto -F --time-style '+%Y-%m-%d %H:%M:%S'\"alias l=\"ls -l\"alias ll=\"l -h\"alias lt=\"l -t\"alias la=\"l -a\"cd_ll()&#123; # 使用‘\\’可以调用原始命令命 if [[ ! $1 ]];then ll else \\cd $1 ll fi &#125;alias cd='cd_ll'alias h=\"head -n 50\"alias hd=\"hadoopbh fs\"alias hdj=\"hadoopbh job\"alias awkt=\"awk -F'\\t'\"alias sortt=\"sort -t $'\\t'\"alias wc=\"wc -l\"bind \"\\C-f\":vi-fword # Ctrl+f:向前移动一个词(以空格划分)bind \"\\C-b\":vi-bword # Ctrl+b:向后移动一个词alias gits=\"git status\"alias gita=\"git add\"alias gitc=\"git commit -m\"alias gitpush=\"git push origin master:refs/for/master\"# 命令行提示符COLOR_GRAY='\\[\\033[1;30m\\]'COLOR_RED='\\[\\033[1;31m\\]'COLOR_GREEN='\\[\\033[1;32m\\]'COLOR_YELLOW='\\[\\033[1;33m\\]'COLOR_BLUE='\\[\\033[1;34m\\]'COLOR_MAGENTA='\\[\\033[1;35m\\]'COLOR_CYAN='\\[\\033[1;36m\\]'COLOR_WHITE='\\[\\033[1;37m\\]'COLOR_NONE='\\[\\033[m\\]'PS1_USER=\"\\u\"PS1_HOST=\"\\H\"PS1_PWD=\"$&#123;COLOR_BLUE&#125;\\w$&#123;COLOR_NONE&#125; $&#123;COLOR_GREEN&#125;\\\\t$&#123;COLOR_NONE&#125;\"export PS1=\"$&#123;PS1_PWD&#125;\\n$&#123;PS1_USER&#125;@$&#123;PS1_HOST&#125;\\\\\\$ \" bash高效快捷键bash高效快捷键 30个高效alias临时取消alias 123/usr/bin/clear ## 命令完整路径\\c ## call alias 前添加\\command ls ## 或使用command 删除别名 12unalias aliasnameunalias foo 参考 系统设置设置sudo文件排除某些命令12visudo # 之后找到如下，修改为如下work ALL=ALL,!/bin/chown,!/bin/chgrp,!/sbin/,!/usr/sbin/visudo sudo免密让普通用户work具有所有超级用户的权限而又不用输入密码，同时排除一些命令 12[root@test ~]# visudowork ALL=（ALL)NOPASSWD:ALL, !/usr/bin/reboot, !/sbin/reboot, !/sbin/ifconfig, !/sbin/shutdown, !/sbin/route, !/sbin/ip","categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://jizx.vip/tags/效率/"},{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"},{"name":"环境","slug":"环境","permalink":"https://jizx.vip/tags/环境/"},{"name":"window","slug":"window","permalink":"https://jizx.vip/tags/window/"}]},{"title":"hive","slug":"hive","date":"2019-10-11T16:40:39.000Z","updated":"2020-02-04T12:09:25.393Z","comments":true,"path":"2019/10/12/hive/","link":"","permalink":"https://jizx.vip/2019/10/12/hive/","excerpt":"hive 的读书笔记，ing","text":"hive 的读书笔记，ing TODO 第 3 章 第 4 章 4.4.2 自定义表的存储格式 4.6.7 第 5 章 第 6 章 6.9.2 分桶表的输入裁剪 第 7 章 视图 第 8 章 粗略看了 第 9 章 9.5 头部寻址 Hadoop 每次指定的文件输入和输出路径都是文件夹 hive 变量空间 命名空间 使用权限 详细描述 hivevar rw 用户自定义变量（v0.8.0+） hiveconf rw hive相关配置属性 system rw java定义的配置属性 env r Shell环境属性 通常我们可以使用hive -e查看有关hivevar与hiveconf的描述： 2、hivevar与hiveconf的作用域 之前项目中涉及两个hive作业同时执行并需要传入相同key的参数，因此顾虑不清楚是否是线程安全。 结论先行：hivevar与hiveconf作用域都是会话级别的，言外之意就是如果两个并发同时跑的作业同时传入一个相同key但是value不相同的值的参数，不会发生线程安全问题。 3、对于hivevar与hiveconf的使用 hiveconf 变量取值必须要使用hiveconf作为前缀参数，具体格式如下:${hiveconf:key} 但是对于hivevar取值可以不使用前缀hivevar，具体格式如下： 使用前缀: ${hivevar:key} 不使用前缀:${key} CLI注意：cli中 tab 会进行自动补全，而且输入流后面的字符会被认为是对提示的回复，因此会导致执行失败 !， 不用退出 hive CLI 即可使用shell 命令，在命令前加上感叹号即可：! pwd ; 注意：不支持交互式命令、管道命令、文件名模糊匹配功能，如! ls *.hql，查找的是*.hql文件而不是以.hql结尾的所有文件。 hive 中使用 hadoop 命令，只需要去掉hadoop这个关键字即可。而且更加高效，因此 hive 会在同一进程中执行这些命令，而不需要重新启动一个 JVM 实例。 以--开头的字符串是注释。 数据类型与定义hive 数据类型 分类 类型 描述 字面量示例 原始类型 BOOLEAN true/false TRUE TINYINT 1字节的有符号整数 -128~127 1Y SMALLINT 2个字节的有符号整数，-32768~32767 1S INT 4个字节的带符号整数 1 BIGINT 8字节带符号整数 1L FLOAT 4字节单精度浮点数1.0 DOUBLE 8字节双精度浮点数 1.0 DEICIMAL 任意精度的带符号小数 1.0 STRING 字符串，变长 “a”，’b’ VARCHAR 变长字符串 “a”，’b’ CHAR 固定长度字符串 “a”，’b’ BINARY 字节数组（v0.8.0+） TIMESTAMP 时间戳，纳秒精度（v0.8.0+） 122327493795 DATE 日期 ‘2016-03-29’ 复杂类型 ARRAY 有序的的同类型的集合 array(1,2) MAP key-value,key必须为原始类型，value可以任意类型 map(‘a’,1,’b’,2) STRUCT 字段集合,类型可以不同 struct(‘1’,1,1.0), named_stract(‘col1’,’1’,’col2’,1,’clo3’,1.0) UNION 在有限取值范围内的一个值 create_union(1,’a’,63) 不存在最大长度限制的“字符串”，hive 支持无限长度的字符串 进行比较时，hive 会隐式地将类型转为较大的，因此是同类型间的比较 集合类型的问题可能会增大数据冗余的风险，也可能导致数据不一致，当数据发生改变时，冗余的拷贝数据可能无法进行相应的同步。优点是提升更高的吞吐量的数据。 文本文件的保存形式分隔符在HIVE中的用途 分隔符 描述 \\n 对于文本文件来说，每行都是一条记录，因此换行符可以分隔记录 ^A(Ctrl+A) 用于分隔字段(列)。在CREATE TABLE语句中可以使用八进制编码\\001表示 ^B(Ctrl+B) 用于分隔ARRAY或者STRUCT中的元素，或用于MAP中键-值对之间的分隔。在CREATE TABLE语句中可以使用八进制编码\\002表示 ^C(Ctrl+C) 用于MAP中键和值之间的分隔。在CREATE TABLE语句中可以使用八进制编码\\003表示 Hive 中没有定义专门的数据格式，数据格式可以由用户指定，用户定义数据格式需要指定三个属性：列分隔符（通常为空格、”\\t”、”\\x001″）、行分隔符（”\\n”）以及读取文件数据的方法。由于在加载数据的过程中，不需要从用户数据格式到 Hive 定义的数据格式的转换，因此，Hive 在加载的过程中不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的 HDFS 目录中。 在创建 table 的时候，table 加载文件的时候就会按照下面格式匹配 123456row format delimited fields terminated by &apos;\\001&apos; collection items terminated by &apos;\\002&apos; map keys terminated by &apos;\\003&apos;lines terminated by &apos;\\n&apos; stored as textfile; row format delimited必须写在其他子句（不包括lines terminated by与stored as textfile）之前。 其实，line terminated by目前只支持\\n，stored as textfile也很少用到。 数据校验传统数据库是写时模式，即 数据在写入数据库的时候对模式（数据格式）进行检查 hive 不会在 数据加载时进行验证，而是在查询时进行，也就是读时模式 如果模式和文件内容不匹配，hive 容忍性非常好。 如果每行记录中字段个数少于对应的模式中定义的字段个数的话，缺失的字段以 null 填充 如果字段是数值型，但 hive 读取时发现存在非数值类型的字符串值的话，那些字段将会返回 null 值 HiveQL基本语句hive 不支持行级插入、更新、删除操作，也不支持事务。 hive 数据库的概念本质上只是表的一个目录或者命名空间。这样可以避免表名冲突。 如果没有显指定数据库，默认使用 default 数据库 数据库123show databases;show databases like &apos;h.*&apos;; # 支持正则create database name LOCATION ‘/my/dir/’; # 指定数据库目录 数据库可以的内容很少，只有DBPROPERTIES可以设置键值对属性，来描述这个数据库的属性信息，其他都是不可改的。 1alert database name SET DBPROPERTIES (&apos;edited-by&apos;=&apos;jizx&apos;); 数据定义分区表通过载入数据的方式创建分区。将$HOME/california-employees 目录下的文件拷贝到分区目录下。 123load data local inpath &apos;$&#123;env:HOME&#125;/california-employees&apos;into table emplyeespartition (country = &apos;US&apos;, state = &apos;CA&apos;) 也可以t通过 insert 的方法，也可以通过 alert table...add partition的方法 查看分区123show partitions table_name;describe extended table_name; # 更详细的表信息describe extended table_name PARTITION (year=2019,month=1,day=2); # 更详细的分区信息，可以看到 location 信息 外部分区表（最常见）使用的目录组织习惯完全由我们自己定义。 12alert table name ADD PARTITION(year=2019,month=9,day=2)LOCATITION &apos;hdfs://master_server/data/log_messages/2012/01/02&apos;; 这种灵活性的优点是：我们可以用像 amazon s3 这样的廉价存储设备存储旧的数据，在 HDFS 中存储较新的数据。 删除表1drop table if exists table_name; 对于管理表，表的元数据和表内的数据都会被删除。 回收站功能 /user/$USER/.Trash目录下 1fs.trash.interval= 检查点的时间间隔，单位是分钟。 如果不小心删除了管理表的话，先重建表，然后重建所需要的分区，再从.Trash目录中将误删的文件移动到正确的文件目录下。 修改表会修改元数据，但不会修改数据本身 重命名1alert table log_messages RENAME TO logmsgs; 分区操作添加 1234alert table log_messages ADD IF NOT EXISTSPARTITION (year=2019,month=1,day=1) LOCATITION &apos;/logs/2019/09/01&apos;PARTITION (year=2019,month=1,day=2) LOCATITION &apos;/logs/2019/09/02&apos;PARTITION (year=2019,month=1,day=3) LOCATITION &apos;/logs/2019/09/03&apos; 0.8.0以上的 hive 可以在一个查询内同时增加多个分区 修改 12alert table log_messages PARTITION (year=2019,month=1,day=3)SET LOCATION &apos;s3n://ourbucket/logs/2011/01/02&apos; 删除 1alert table log_messages DROP IF EXISTs PARTITION (year=2019,month=1,day=3); 列操作修改列 1234alert table logCHANGE COLUMN hms new_hms INTCOMMENT &apos;注释&apos;AFTER other_column; 想放在第一列的话，使用FIRTST代替AFTER other_column即可 添加 1234alert table log ADD COLUMN ( app_name STRING COMMENT &apos;注释&apos;, session STRING COMMENT &apos;注释&apos;); 删除或替换列 其实就是将原本的全部的列信息删除掉，然后重新定义列信息。 1234alert table log REPLACE COLUMN ( app_name STRING COMMENT &apos;注释&apos;, session STRING COMMENT &apos;注释&apos;); 修改表属性 可以修改或添加，但是无法删除 123alert table log SET TBLPROPERTIES( &apos;note&apos; = &apos;笔记内容&apos;); 查看表详细信息 desc formatted test_table; 优化limit在CLI 中非常经常用到，为了避免执行整个查询语句，有一个配置属性可开启，对原数据进行抽样。 123hive.limit.optimize.enable=truehive.limit.row.max.size=1000000 # how much size we need to gurantee each row to have at leasthive.limit.optimize.limit.file=10 # 最多采样的文件数 缺点：有可能输入中有用的数据永远不会被处理到。 创建分区表12345678910# 建表&gt; create table supply(id int, part string, quantity int) &gt; partitioned by (int day);# 添加分区&gt; alert table supply add partiton (day=20190909);# 通过 where 选择分区&gt; select part,quantity from supply&gt; where day&gt;=20190909 and quantity &lt; 4; 多分区 12&gt; ...&gt; partition by (day int, state string, city string); 理想的分区方案不应该导致产生太多的分区和文件夹目录。 一个分区对应着包含多个文件的文件夹。因此如果存在数百个分区，每天就会创建好几万个文件。默认情况下，MapReduce 会将每个 job转为多个 task，每个 task 都是一个新的 JVM 实例，每个文件都会对应一个 task，因此 JVM 的开启和销毁可能会比实际处理数据的时间还要久。 好的分区方案应该保证分区数量的增长是均匀的。 分桶表TODO为表增加列SerDe 非常宽松，通过指定的分隔符从左向右将行分解成列 如果字段数比预期少，那么缺失的字段将返回 null 如果字段数比预期多，那么多出的字段将会被忽略 1alert table student add columns (score string); 通过这种方法，无法在已有字段的开始或者中间增加字段 使用列存储表 TODO以下两种情况适合列存储表 重复数据，如 age，省市多列Map join以下几种情况无法使用map join 123456Union Followed by a MapJoinLateral View Followed by a MapJoinReduce Sink (Group By/Join/Sort By/Cluster By/Distribute By) Followed by MapJoinMapJoin Followed by UnionMapJoin Followed by JoinMapJoin Followed by MapJoin 相关配置 12345678--是否自动转换为mapjoinset hive.auto.convert.join = true;--小表的最大文件大小，默认为25000000，即25Mset hive.mapjoin.smalltable.filesize = 25000000;--是否将多个mapjoin合并为一个set hive.auto.convert.join.noconditionaltask = true;--多个mapjoin转换为1个时，所有小表的文件大小总和的最大值。set hive.auto.convert.join.noconditionaltask.size = 10000000; 确保多张小表使用 mapjoin123456select /*+MAPJOIN(smallTableTwo)*/ idOne, idTwo, value FROM ( select /*+MAPJOIN(smallTableOne)*/ idOne, idTwo, value FROM bigTable JOIN smallTableOne on (bigTable.idOne = smallTableOne.idOne) ) firstjoin JOIN smallTableTwo ON (firstjoin.idTwo = smallTableTwo.idTwo) 除了添加 mapjoin提示，还需要设置两个参数 hive.auto.convert.join.noconditionaltask=true 如果启用此参数，并且n向连接的表/分区的n-1个大小的总和&lt;指定的大小，则该连接将直接转换为mapjoin（没有条件任务）。 hive.auto.convert.join.noconditionaltask.size=1000000 如果n路联接的n个表/分区的n-1个大小的总和小于此大小，该连表将直接转换为mapjoin（没有条件任务）。 默认值为10MB。 https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins 导入导出数据动态分区插入可以基于查询参数推断出需要创建的分区名称。SELECT 语句中的最后 2 列会对应到 PARTITION 中的分区名。 1234INSERT OVERWRITE TSBLE employeesPARTITION(country, state)SELECT ..., se.cnty,se.stFROM staged_employees se; 动静结合 12345INSERT OVERWRITE TSBLE employeesPARTITION(country = &apos;US&apos;, state) # 静态分区键必须出现在动态分区键之前SELECT ..., se.cnty,se.stFROM staged_employees seWHERE se.cnty = &apos;US&apos;; 单个查询语句中创建表并加装数据这个功能不能用于外部表。 1234CREATE TABLE ca_employeesAS SELECT name, salary, addressFROM employeesWHERE se.state = &apos;CA&apos;; 导出数据1234INSERT OVERWRITE LOCAL DIRECTORY &apos;/tmp/employees&apos;select namefrom employeewhere se.state = &apos;CA&apos; 查询selectselect sub[0] from table_name; 查询数组类型的字段的第一个元素 select ded[“state taxes”] from table_name; 查询map类型的字段 select address.city from table_name; 查询struct类型的字段 使用正则表达式来指定列，所有以 price 开头的列 1select `price.*` from stocks; 不允许使用多个 DISTINCT 函数 1select count(DISTINCT ymd),count (DISTINCT volume) from stocks; 存在的 bug count(DISTINCT col)同时 col 是分区列时，会出现 bug 表生成函数 123SELECT name, sub FROM udtf_testLATERAL VIEW explode(subordinates) subView AS sub; 在这里LATERAL VIEW 是将 explode结果转换成一个视图subView,在视图中的单列列名定义为sub，然后在查询的时候引用这个列名就能够查到。 与时间相关的函数 ，输入可以是整数或者字符串类型。对于 0.8.0，可以接受 TIMESTAMP 类型的参数。 列别名 SELECT col as new_col FROM table_name 对列的进一步处理，进行条件判断 123456Select CASE WHEN salary &gt; 7 AND salary &lt;10 THEN &apos;high&apos; ELSE &apos;very high&apos; END AS bracket FROM employees 最好将下面的设置添加到 hiverc 中，避免不必要的 MapReduce 1set hive.exec.mode.local.auto=true wherewhere 语句使用谓词表达式，谓词表达式结果为 true 时，相应的行将被保留和输出。 where 语句中并不能使用 select 语句中的别名，解决办法是使用嵌套 select 语句 1234SELECT e.* FROM ( select salary*(1- ded[&quot;Taxes&quot;]) as new_salary FROM employees) eWHERE round(e.new_salary) &gt; 7000 关于浮点数比较的陷阱hive无法精确的表示 0.2，如果转为 float，实际数值是：0.2000001。如果转为 double，实际数值是：0.200000000001。 sql 语句中的浮点数，默认是 Double 类型的，比如下面的0.2 1select * from name wheren high&gt; 0.2 如果表的字段定义时是 Float 类型，就会出现比较上的问题。输出中会有=0.2 的。 Float字段会隐式转为 Double 类型，变成：0.20000001000000，因此会比 0.2 的double 类型0.200000000001大。 因此会出现 &gt;0.2的效果与&gt;=0.2相同。 解决办法： 将字段类型保存为 double，缺点是查询时内存消耗增多 sql 中的数字显示指定类型WHERE high &gt; cast(0.2 AS FLOAT) 与钱相关的都避免使用浮点数 GROUP BY 语句having 语句用于聚合后再进行的条件过滤，避免了子查询 1234select avg(salary) From stockswhere ...GROUP BY year(ymd)HAVING avg(salary) &gt; 50.0 # 对上面的聚合后的内容进行过滤 join 语句 join on 只支持等值连接，也就是a.col=b.col ，不支持a.col&lt; b.col 不支持在 on 子句中的谓词使用 OR hive 假定从左到右边表依次变大，也可以在 SELECT 中添加/*+STREAMTABLE(s)*/ 12SELECT /*+STREAMTABLE(s)*/ s.ymd,s.symbolFROM stocks s JOIN dividends d ON ... ON语句中的分区过滤条件在 OUTER JOIN 中是无效的，在 INNER JOIN 中是有效的 TODO（不太明白） full outer join 将会返回所有表中符合 WHERE 语句条件的所有记录。如果任一张表的指定字段没有符合条件的值的话，那么就是用 NULL 值代替。 LEFT SEMI-JOIN左半开连接会返回左边表的记录，前提是其记录对于满足 ON 语句中的判定条件。 map join0.7之前的需要在 SELECT 中添加标记来进行触发，如下面的内连接 123SELECT /*+MAPJOIN(d)*/ s.ymd, s.symbol, d.dividend FROM stocks s JOIN dividends d ON s.ymd=d.ymdWHERE s.symbol = &apos;AAPL&apos; 0.7之后的版本，废弃这种标记，不过添加后同样是有效的。如果没有该标记，需要用户设置属性hive.auto.convert.JOIN=true，也可以配置小表的大小hive.mapjoin.smalltable.filesize=25000000 单位是字节 ORDER BY 和 SORT BYsort by 是局部的，order by 是全局的，比较费时。 DISTRIBUTE BY与 CLUSTER BYDistribute by 用来保证相同指定列的记录会分发到同一个 reducer 中。 如果DISTRIBUTE 与 SORT 语句中都涉及到相同的列，而且采用的是升序排序方式，那么这时 CLUSTER BY 等价于前面的两个语句。 CLUSTER BY 剥夺了 SORT BY 的并行性，但是这样可以实现输出的数据是全局排序的。 抽样查询方式1 1select * from numbers TABLESAMPLE(BUCKET 1 OUT OF 2 ON col1) s; 2表示将数据分散成几桶，1 表示选择第几桶 方式 2 1select * from numbersflat TABLESAMPLE(0.1 PERCENT) s; 基于行数的，按照输入路径下的数据块百分比进行抽样。 不一定适合所有文件格式 抽样最小单元是一个 HDFS 数据块，如果标的数据大小 &lt; 普通的块大小 128MB 的话，将返回所有行 UNION ALLhive中比较低的版本没有 union，只有 union all 视图 将复杂的多层子嵌套进行封装，类似于使用函数一样。 安全机制，不直接给用户访问敏感数据的原始表，而是提供给用户通过 where 限制了的视图。（目前 hive 并不支持，用户必须具有原始表的权限，视图才能工作） 可以理解为：hive 会先解析视图，然后使用解析结果来解析整个查询语句，不过查询优化器可能会将视图和查询语句合并成一个单一的实际查询语句。如果视图中包含 ORDER BY 或者 LIMIT，则会先解析视图。 通过 show tables 来查询视图，没有 show views 这样的语句 describe 和describe extended 可以显示视图的元数据信息 索引其他数据的导入与导出1）加载到普通表 加载本地文本文件内容（要与hive表字段分隔符顺序都要一致） load data local inpath &apos;/home/hadoop/orders.csv&apos; overwrite into table orders; 如果数据源在HDFS上， 1load data inpath &apos;hdfs://master:9000/user/orders&apos; overwrite into table orders; 数据源在HDFS上 2) 加载到分区表 1load data local inpath &apos;/home/hadoop/test.txt&apos; overwrite into table test partition (dt=&apos;2017-09-09&apos;); partition 是指定这批数据放入分区2017-09-09中； 3）加载分桶表先创建普通临时表 1234567create table orders_tmp(user_id int,user_name string,create_time string)row format delimited fields terminated by ',' stored as textfile; 数据载入临时表 load data local inpath &apos;/home/hadoop/lead.txt&apos; overwrite into table orders_tmp; 导入分桶表 12set hive.enforce.bucketing = true;insert overwrite table orders select * from orders_tmp; 4) 导出数据 将hive表中的数据导出到本地文件中； 1insert overwrite local directory &apos;/home/hadoop/orders.bak2017-12-28&apos; select * from orders; 【去掉local关键字，也可以导出到HDFS上】 JOIN ON中的 and 与 where 子句HiveQL与标准SQL的区别： 陷阱1： 12345SELECT *FROM first_table t1JOIN second_table t2ON t1.id = t2.id where t1.date = \"2016-06-01\" 在hive里面，没有SQL优化器，则这样些的后果是，直接将t1表与t2表全量连接，产生大量的MapReduce操作再进行过滤 正确写法： 12345SELECT *FROM( SELECT * FROM first_table WHERE date = \"2016-06-01\") t1JOIN second_table t2ON t1.id = t2.id; 其实上面的语句还不是最好的,因为hive通常处理的都是大数据表,上亿至少小case。hive sql里不推荐用嵌套子查询语句，就是为了减小查询负担。 更优的写法是join…on 后面，用and代替where。为什么？用and的话，查询是先过滤条件，得到一个较小的表，然后再跟其他表联合。这样，无形中，就能节省下不小的运算量，自然就更快了！ 更优的写法： 12345SELECT *FROM first_table t1JOIN second_table t2ON t1.id = t2.idand t1.date = \"2016-06-01\"; https://www.jianshu.com/p/ad64b953dc67 合并小文件1hadoop fs -cat hdfs://cdh5/tmp/lxw1234/*.txt | hadoop fs -appendToFile - hdfs://cdh5/tmp/hdfs_largefile.txt 这种处理方法在数据量非常大的情况下不适合，最好使用MapReduce来合并。","categories":[{"name":"hive","slug":"hive","permalink":"https://jizx.vip/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://jizx.vip/tags/hive/"},{"name":"ing","slug":"ing","permalink":"https://jizx.vip/tags/ing/"}]},{"title":"linux知识点","slug":"linux知识点","date":"2019-10-11T12:17:35.000Z","updated":"2019-10-28T15:50:52.172Z","comments":true,"path":"2019/10/11/linux知识点/","link":"","permalink":"https://jizx.vip/2019/10/11/linux知识点/","excerpt":"","text":"内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间（swap space）。 系统的运行级别运行级为1时，只启动基本的系统进程以及一个控制台终端进程。我们称之为单用户模式。 标准的启动运行级是3。在这个运行级上，大多数应用软件，比如网络支持程序，都会启动。 另一个Linux中常见的运行级是5。在这个运行级上系统会启动图形化的X Window系统，允许用 户通过图形化桌面窗口登录系统。 man每个内容区域都分配了一个数字， 从1开始，一直到9，如表所示。 区号 所涵盖的内容 1 可执行程序或shell命令 2 系统调用 3 库调用 4 特殊文件 5 文件格式与约定 6 游戏 7 概览、约定及杂项 8 超级用户和系统管理员命令 9 内核例程 工具通常提供的是命令所对应的最低编号的内容。 常见Linux目录名称 目 录 用处 / 虚拟目录的根目录。通常不会在这里存储文件 /bin 二进制目录，存放许多用户级的GNU工具 /boot 启动目录，存放启动文件 /dev 设备目录， Linux在这里创建设备节点 /etc 系统配置文件目录 /home 主目录， Linux在这里创建用户目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录，存放现有硬件及当前进程的相关信息 /root root用户的主目录 /sbin 系统二进制目录，存放许多GNU管理员级工具 /run 运行目录，存放系统运作时的运行时数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建和删除临时工作文件 /usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里 /var 可变目录，用以存放经常变化的文件，比如日志文件 常见的目录名均基于文件系统层级标准（filesystem hierarchy standard，FHS）。http://www.pathname.com/fhs。 虚拟目录与挂载点Linux虚拟目录中比较复杂的部分是它如何协调管理各个存储设备。在Linux PC上安装的第一块硬盘称为根驱动器。根驱动器包含了虚拟目录的核心，其他目录都是从那里开始构建的。Linux会在根驱动器上创建一些特别的目录，我们称之为挂载点（mountpoint）。挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上它们却存储在另外一个驱动器中。 通常系统文件会存储在根驱动器中，而用户文件则存储在另一驱动器中。 glob 模式匹配 问号（?）代表一个字符； 星号（*）代表零个或多个字符。 问号可用于过滤器字符串中替代任意位置的单个字符。 使用中括号[ai]pt，字母范围[a – i]，感叹号[!a]将不需要的内容排除在外。 符号链接 软链接(符号链接)：类似window 的快捷方式，ln -s选项来创建符号链接。软链接sl_data_file仅仅只是指向data_file而已。它们的内容并不相同，是两个完全不同的文件。 硬链接：ln，硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件（带有硬链接的文件共享inode编号）。引用硬链接文件等同于引用了源文件。 只能对处于同一存储媒体的文件创建硬链接。要想在不同存储媒体的文件之间创建链接， 只能使用符号链接。 用不着复制链接文件，可以创建原始文件的另一个链接。 千万别创建软链接文件的软链接。 shell配置文件加载顺序http://ddrv.cn/a/173848/ 通配符（Wildcard）在 Shell 中命令中，通常会使用通配符表达式来匹配一些文件，如以下命令可以查找当前目录下所有后缀为 .xml 的文件 1find . -name &quot;*.xml&quot; Shell 中可以使用的通配符如下： 通配符 含义 实例 * 匹配 0 或多个字符 a*b，a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如 aabcb, axyzb, a012b, ab ? 匹配任意单个字符 a?b，a与b之间有且只有一个字符, 可以是任意字符, 如 aab, abb, acb, a0b [list] 匹配 list 中的任意单个字符 a[xyz]b，a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如 axb, ayb, azb。 [!list] 匹配除 list 中的任意单一字符 a[!0-9]b，a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如 axb, aab, a-b。 [c1-c2] 匹配 c1-c2 中的任意单一字符 a[0-9]b，匹配0与9之间其中一个字符，如 a0b, a1b… a9b {s1,s2,…} 匹配 s1 或 s2 (或更多)中的一个字符串 a{abc,xyz,123}b，a与b之间只能是abc或xyz或123这三个字符串之一 转义字符有的时候，我们匹配的内容里面会存在 *，?，[等通配符中的符号。为了表示他们原来的意思，我们需要使用转义字符 \\，如 a\\[ac\\]c 表示匹配 a[a]c 或 a[c]c。\\ 本身用 \\\\ 表示。 分清楚通配符表达式和正则表达式通配符看起来和正则表达式很像，但他们并不是同一种东西。正则表达式中的那些量词的匹配规则和这里提到的几个通配符的匹配规则并不相同。如正则表达式中 * 表示重复前一个字符任意次，ab* 表示的是那些 a 后面跟 0 个或多个 b 的字符串， 而通配符表达式中 * 表示 0 或多个任意字符， ab* 表示的是那些 ab 后面跟任意个字符的字符串。 而且正则表达式一般是部分匹配的，用来匹配内容中的一部分，如用正则表达式 a 去匹配 bac 这段字符串时，匹配是成功的，匹配到的内容是 a。但是通配符表达式的话是全部匹配的，表达式要匹配整个字符串才算匹配成功，如用通配符表达式 a 取匹配 bac 这段字符串时，匹配是失败的。 在 Shell 命令中，通常用通配符表达式来匹配文件名，而用正则表达式来匹配一段文本内容。以 grep 命令为例，grep 命令可以在指定的文件中，挑选出和表达式匹配的那些行，其中指定文件是用的通配符表达式，而文本内容的匹配用的是正则表达式。 今天使用 grep 时，就因为没分清楚他们，忙活了半天。情况是这样的，我想看一个 jar 包里是不是有 pom 相关的文件，所以就输入了下面命令 1jar tf maven-model-builder-3.5.3.jar | grep &apos;pom*&apos; # 这里是正则表达式，匹配有po、pom、pom+子串的字符串 结果输入了一堆文件，而且很多文件都没有 pom 这串字符串的。输出内容是这样的： 123456...org/apache/maven/model/composition/org/apache/maven/model/interpolation/org/apache/maven/model/superpom/org/apache/maven/model/composition/DependencyManagementImporter.class... 这就是因为我把通配符表达式和正则表达式搞混了，后来知道原因后，用下面的命令才得到想要的内容。 1jar tf maven-model-builder-3.5.3.jar | grep &apos;pom.*&apos; 使用 Shell 命令时，要分清楚哪里用的是通配符表达式，哪里用的是正则表达式。 链接：https://www.jianshu.com/p/25f3d0cd5fdc 其他文本命令行界面（command line interface，CLI）","categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"}]},{"title":"vim技巧","slug":"vim技巧","date":"2019-10-10T06:32:24.000Z","updated":"2019-10-28T15:15:49.738Z","comments":true,"path":"2019/10/10/vim技巧/","link":"","permalink":"https://jizx.vip/2019/10/10/vim技巧/","excerpt":"","text":"行尾添加字符串123&lt;C-v&gt;G$ &quot; 全选A; &quot; 进入插入模式，添加;&lt;Esc&gt; &quot; 完成插入 或者使用替换命令 1%s/$/;/g 统计当前模式的匹配个数方法一、使用 substitute 123➾ /\\&lt;buttons\\&gt; ➾ :%s///gn 《 5 matches on 4 lines 方法二、使用 vimgrep 可以知道当前匹配文本所处的位置，例如共5个匹配，当前 是第3个。 123➾ /\\&lt;buttons\\&gt; ➾ :vimgrep //g % 《(1 of 5) var buttons = viewport.buttons; 该命令会把当前文件中所有找到的匹配放进quickfix列表。用 :cnext和 :cprev命令可以正向和反向遍历quickfix列表。","categories":[{"name":"vim","slug":"vim","permalink":"https://jizx.vip/categories/vim/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"},{"name":"vim","slug":"vim","permalink":"https://jizx.vip/tags/vim/"}]},{"title":"bash命令提示符个性化","slug":"bash命令提示符个性化","date":"2019-09-04T13:54:45.000Z","updated":"2019-10-30T07:38:35.768Z","comments":true,"path":"2019/09/04/bash命令提示符个性化/","link":"","permalink":"https://jizx.vip/2019/09/04/bash命令提示符个性化/","excerpt":"详细介绍了如何配置 bashrc，使得命令行的提示符更美观，包括当前路径、时间、用户、服务器名称等","text":"详细介绍了如何配置 bashrc，使得命令行的提示符更美观，包括当前路径、时间、用户、服务器名称等 常用显示参数\\d：代表日期，格式为weekday month date，例如：”Mon Aug 1”\\H：完整的主机名称\\h：仅取主机的第一个名字\\t ：显示时间为24小时格式，如：HH：MM：SS\\T：显示时间为12小时格式\\A ：显示时间为24小时格式：HH：MM\\u ：当前用户的账号名称\\v ：BASH的版本信息\\w：完整的工作目录名称\\W ：利用basename取得工作目录名称，所以只会列出最后一个目录\\# ：下达的第几个命令\\$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$\\n ：换行符 可以在 bash 的 man 手册 PROMPTING 章节中查阅 颜色PS1中设置字符颜色的格式为：\\[\\e[F;Bm\\]，其中“F“为字体颜色，编号为30到37，“B”为背景颜色，编号为40到47。可以只设置前景色或背景色。颜色表如下： F B 颜色 30 40 黑色 31 41 红色 32 42 绿色 33 43 黄色 34 44 蓝色 35 45 紫红色 36 46 青蓝色 37 47 白色 颜色格式后面跟着的就是\\u、\\w这样的显示参数，颜色格式后面的字符串都将使用该颜色，为了实现不同字段不同颜色，建议使用指定的颜色 显示参数 None颜色 这样进行划分。见下例 123456789101112131415COLOR_GRAY='\\[\\e[1;30m\\]' 还有一种写法是将\\e写成\\033COLOR_RED='\\[\\e[1;31m\\]'COLOR_GREEN='\\[\\e[1;32m\\]'COLOR_YELLOW='\\[\\e[1;33m\\]'COLOR_BLUE='\\[\\e[1;34m\\]'COLOR_MAGENTA='\\[\\e[1;35m\\]'COLOR_CYAN='\\[\\e[1;36m\\]'COLOR_WHITE='\\[\\e[1;37m\\]'COLOR_NONE='\\[\\e[m\\]'PS1_USER=\"$&#123;COLOR_MAGENTA&#125;\\u$&#123;COLOR_NONE&#125;\"PS1_HOST=\"$&#123;COLOR_CYAN&#125;\\h$&#123;COLOR_NONE&#125;\"PS1_PWD=\"$&#123;COLOR_YELLOW&#125;\\w$&#123;COLOR_NONE&#125;\"export PS1=\"$&#123;PS1_USER&#125;@$&#123;PS1_HOST&#125;:$&#123;PS1_PWD&#125;\\\\\\$ \" 在颜色定制文本(例如： COLOR_GRAY=&#39;\\[\\033[1;30m\\]&#39;)中，开始的\\[和结尾的\\]是必须的，否则当输入的命令很长的时候，就会回车但不换行,于是覆盖了行首的有颜色的字符串 通过Bash编程在Terminal上输出彩色的字符串，是不能添加\\[和\\]的。 例如： 123456789101112131415161718function print &#123; printf -- \"$*\\n\"; &#125;function _isatty&#123; typeset -l isatty=$&#123;ISATTY:-\"auto\"&#125; [[ $isatty == \"yes\" ]] &amp;&amp; return 0 # yes [[ $isatty == \"no\" ]] &amp;&amp; return 1 # no [[ -t 1 &amp;&amp; -t 2 ]] &amp;&amp; return 0 || return 1 # auto&#125;function str2gray &#123; _isatty &amp;&amp; print \"\\e[1;30m$@\\033[m\" || print \"$@\"; &#125;function str2red &#123; _isatty &amp;&amp; print \"\\e[1;31m$@\\033[m\" || print \"$@\"; &#125;function str2green &#123; _isatty &amp;&amp; print \"\\e[1;32m$@\\033[m\" || print \"$@\"; &#125;function str2yellow &#123; _isatty &amp;&amp; print \"\\e[1;33m$@\\033[m\" || print \"$@\"; &#125;function str2blue &#123; _isatty &amp;&amp; print \"\\e[1;34m$@\\033[m\" || print \"$@\"; &#125;function str2magenta &#123; _isatty &amp;&amp; print \"\\e[1;35m$@\\033[m\" || print \"$@\"; &#125;function str2cyan &#123; _isatty &amp;&amp; print \"\\e[1;36m$@\\033[m\" || print \"$@\"; &#125;function str2white &#123; _isatty &amp;&amp; print \"\\e[1;37m$@\\033[m\" || print \"$@\"; &#125; 在线网站更多颜色参数，请参考：https://misc.flogisoft.com/bash/tip_colors_and_formatting 如果上面的方法觉得麻烦，可以使用推荐的在线制作网站：http://ezprompt.net/ 参考： https://www.jianshu.com/p/426d0eeee671 https://www.cnblogs.com/idorax/p/8270025.html","categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"}]},{"title":"awk","slug":"awk","date":"2019-09-02T04:05:24.000Z","updated":"2020-02-24T15:39:41.931Z","comments":true,"path":"2019/09/02/awk/","link":"","permalink":"https://jizx.vip/2019/09/02/awk/","excerpt":"linux 三剑客之一 awk 的详细介绍","text":"linux 三剑客之一 awk 的详细介绍 awk英文文档https://www.gnu.org/software/gawk/manual/gawk.html 基本组成基本组成形式 123awk options program file1 awk options program file1 file2awk options program # 进入交互模式，直到ctrl+d结束输入 由于gawk命令行假定脚本是单个文本字符串，你必须将脚本放到单引号中。 1awk 'BEGIN&#123; print \"start\";command2 &#125; pattern &#123; command1;command2 &#125; END&#123; print \"end\";command2 &#125;' file 一个命令就是一个以新行或者分号分隔的语句序列。 由于模式和命令两者任一都是可选的，所以需要使用大括号包围动作以区分于其他模式。 多条语句之间用;分隔1awk 'BEGIN &#123;FS=\":\"&#125; &#123; \"grep root /etc/passwd\" | getline; print $1,$6 &#125;' 运行流程 awk以逐行的形式处理文件 BEGIN之后的命令会先于公共语句块执行 BEGIN语句块在awk开始从输入流中读取行之前被执行（除非调用了 getline）。这是一个可选的语句块，诸如变量初始化、打印输出表格的表头等语句通常都可以放在BEGIN语句块中。 对于匹配PATTERN的行，awk会对其执行PATTERN之后的命令 这个语句块是可选的。如果不提供，则默认执行{ print }，即打印所读取到的每一行。 如果提供，则每个pattern依次测试每个输入行。对于匹配到行的模式，其对应的命令（也许包含多步）得到执行，然后读取下一行并继续匹配，直到所有的输入读取完毕。 最后，在处理完整个文件之后，awk会执行END之后的命令 END语句块和BEGIN语句块类，也是可选的语句块。它在awk读取完输入流中所有的行之后被执行。像打印所有行的分析结果这种常见任务都是在END语句块中实现的。 输出print输出print接受的变量之间以逗号分隔，在输出时会以空格作为变量之间的分隔符。 1awk &apos;&#123;print $3,$4&#125;&apos; marks.txt print之间的空格不会影响输出格式 12awk '&#123;print $3 \"\\t\" $4&#125;' marks.txt # $3与\\t之间的空格不会显示在输出中awk '&#123;print $3 , $4&#125;' marks.txt # 逗号表示最终会以空格分分隔两个字段 字符串拼接 在awk的print语句中，双引号被当作拼接操作符（concatenation operator）使用。 1234echo | awk '&#123; var1=\"v1\"; var2=\"v2\"; var3=\"v3\"; \\print var1 \"-\" var2 \"-\" var3 ; &#125;'# v1-v2-v3 省略print 如果没有主体块——默认的动作是输出行。因此比如搜索字符串Tom可以使用下面简略方式实现： 1awk '/Tom/' marks.txt 打印一行 123&#123; print &#125;# 或者，由于 $0 表示整行,&#123; print $0 &#125; 打印特定列 使用一个 print 语句可以在同一行中输出不止一个字段. 下面的程序输出了每 行输入中的第一和第三个字段 1&#123; print $1, $3 &#125; NF 列总数 该变量表示一共有多少列 1&#123; print NF, $1, $NF &#125; # 打印第一列 和最后一列 计算和打印 你也可以对字段的值进行计算后再打印出来. 下面的程序 1&#123; print $1, $2 * $3 &#125; NR 打印行号 存储当前已经读取了多少行的计数。给每一行加上行号: 1&#123; print NR, $0 &#125; 在输出中添加内容 双引号内的文字将会在字段和计算的值中插入输出. 1&#123; print &quot;total pay for&quot;, $1, &quot;is&quot;, $2 * $3 &#125; 排序输出 最简单的方式是使用awk将每位员工的总薪酬置于其记录之前，然后利用sort命令来处理awk的输出。Unix上，命令行如下: 1awk &apos;&#123; printf(&quot;%6.2f %s\\n&quot;, $2 * $3, $0) &#125;&apos; emp.data | sort 打印表头，表尾 BEGIN 用于匹配第一个输入文件的第一行之前的位置， END 则用于匹配处理过的最后一个文件的最后一行之后的位置 1awk &apos;BEGIN &#123;print &quot;Name Rate Hour&quot;;print &quot;=========&quot;&#125; &#123;print $0&#125;&apos; file 字符串拼接 在命令中使用空格进行变量拼接 在print语句块中使用双引号拼接123# 将names变量与当前行的的$1以及空格进行拼接，赋值给names &#123; names = names $1 &quot; &quot;&#125;END &#123; print names &#125; 只打印最后一行 打印最后一个输入行 虽然在 END 动作中 NR 还保留着它的值，但 $0 没有。程序是打印最后一个输入行的一种方式 12 &#123; last = $0 &#125;END &#123; print last &#125; printf高级输出基本用法printf 语句的形式如下： 1printf(format, value1, value2, ..., valuen) 其中 format 是字符串，包含要逐字打印的文本，穿插着 format 之后的每个值该如何打印的规格(specification)。一个规格是一个 % 符，后面跟着一些字符，用来控制一个 value 的格式。第一个规格说明如何打印 value1 ，第二个说明如何打印 value2 ，… 。因此，有多少 value 要打印，在 format 中就要有多少个 % 规格。（与C语言很像） 这里有个程序使用 printf 打印每位员工的总薪酬：: 1&#123; printf(&quot;total pay for %s is $%.2f\\n&quot;, $1, $2 * $3) &#125; 转义序列退格符\\b 换页符\\f 换行符\\n ，进入下一行 回车符\\r ，光标移动到第一列 这与以前的打字机相关，以前的打字机达打完一行后，机械上需要2步，先将指针移动到下一行（换行），然后将指针回到行首（回车） 我们在每个域输出后输出一个回车符\\r，随后输出的域会覆盖之前输出的内容。也就是说，我们只能看到最后输出的 Field 4。 12awk 'BEGIN &#123; printf \"Field 1\\rField 2\\rField 3\\rField 4\\n\" &#125;'# Field 4 垂直制表符 如下示例，使用垂直制表符输出不同域： 123456awk 'BEGIN &#123; printf \"Sr No\\vName\\vSub\\vMarks\\n\" &#125;'# 执行上面的命令可以得到如下的结果Sr No Name Sub Marks 格式说明符% 符号 说明 %c 输出单个字符。如果参数是个数值，那么数值也会被当作字符然后输出。如果参数是字符串，那么只会输出第一个字符。 %d 与 %i 输出十进制数的整数部分。 %f 输出浮点数，以 [-]ddd.dddddd 的格式 %e 与 %E 输出浮点数，以 [-]d.dddddde[+-]dd 的格式。区别就是输出8.066000e+01与8.066000E+01的e的大小写 %g 与 %G 输出浮点数，使用 %e 或 %E 转换。但它们会删除那些对数值无影响的 0。（推荐） %o 无符号八进制输出。 %u 无符号十进制数输出。 %x 与 %X 输出十六进制无符号数。%X 中使用大写字母，%x 使用小写字母。 %% 输出百分号（%），不需要输入参数。 格式说明符% 的可选参数列宽 %8d表示用空格填充占8列，如果紧接在 % 后是以0开头的数字%08d，表示输出应该使用0填充而不是空格字符。 对齐 默认是右边对齐，在 % 之后数字之前使用减号（-）即可指定输出左对齐 符号前缀 但是+不是表示右对齐，是表示输出数值的符号，正号也输出。 1awk 'BEGIN &#123; num = -10; printf \"Num = %-+10d\\n\", num &#125;' | cat -vte 哈希# 将#放在%后， 可以为 %o 的结果前添加0，为 %x 或 %X 输出的结果前添加 0x 或 0X （结果不为零时），为 %e，%E，%f，%F添加小数点；对于 %g 或 %G，使用哈希可以保留尾部的零 1awk &apos;BEGIN &#123; printf &quot;Octal representation = %#o\\nHexadecimal representaion = %#X\\n&quot;, 10, 10&#125;&apos; 重定向、管道、双向管道重定向AWK 重定向操作符重定向数据到文件 message.txt 中。 12awk 'BEGIN &#123; print \"Hello, World !!!\" &gt; \"/tmp/message.txt\" &#125;'cat /tmp/message.txt 管道下面的例子中我们使用 tr 命令将小写字母转换成大写。 12awk 'BEGIN &#123; print \"hello, world !!!\" | \"tr [a-z] [A-Z]\" &#125;'# HELLO, WORLD !!！ 双向通信通道（TODO 还不知道怎么用） AWK 允许使用 |&amp; 与一个外部进程通信，并且可以双向通信。下面的例子中，使用 tr 命令将字母转换为大写字母。 12345678BEGIN &#123; cmd = \"tr [a-z] [A-Z]\" print \"hello, world !!!\" |&amp; cmd close(cmd, \"to\") cmd |&amp; getline out print out; close(cmd);&#125; 执行上面的命令可以得到如下的结果： 1HELLO, WORLD !!! 脚本的内容看上去很神秘吗？让我们一步一步揭开它神秘的面纱。 第一条语句 cmd = “tr [a-z][A-Z]” 在AWK 中建立了一个双向的通信通道。 第二条语句 print 为 tr 命令提供输入。&amp;| 表示双向通信。 第三条语句 close(cmd, “to”) 执行后关闭 to 进程。 第四条语句 cmd |&amp; getline out 使用 getline 函数将输出存储到 out 变量中。 接下来的输出语句打印输出的内容，最后 close 函数关闭 cmd。 保存到不同文件中跳过表头，第6列是文件名，因此这样就可以将每一行分别保存在不同的文件中，进行了分类 1awk 'NR!=1&#123;print $4,$5 &gt; $6&#125;' netstat.txt 常用参数 参数 说明 标准参数 -F fs fs是分隔符，默认是空白符（空格、制表符），fs可以是字符串或正则表达式。如-F: 表示冒号为分隔符；如果想指定空格为分隔符，请看下面例子。 -v var=value 赋值一个用户定义变量，将外部变量传递给awk -f scripfile 从脚本文件中读取awk命令 -p[file] 用于格式化 awk 脚本文件。默认输出文件是 awkprof.out。 gawk 参数 -mf N 指定要处理的数据文件中的最大字段数 -mr N 指定数据文件中的最大数据行数 在BEGIN语句块中可以用OFS=”delimiter”设置输出字段分隔符。awk &#39;BEGIN { FS=&quot;:&quot; }{ print } 指定空格为分隔符 12echo -e \"a\\tb\\nc d\"|awk -F' ' '&#123;print $2&#125;' # 无效，还是会将\\t进行分割echo -e \"a\\tb\\nc d\"|awk -F'[ ]' '&#123;print $2&#125;' # 推荐 同时使用多个分隔符 123 # 使用多个分隔符, 遇到\";\"或者\",\"就进行分割，因此下面的例子会得到 5 列echo \"1;2,3;4,5\"|awk -F '[;,]' '&#123;print $1,$2,$3,$4,$5&#125;'# 1 2 3 4 5 或者使用| 1awk -F&quot;\\t|,&quot; &apos;&apos; file # 以\\t 或者逗号分隔 参考：https://ipcmen.com/awk 格式化脚本 12[jerry]$ awk --profile 'BEGIN&#123;printf\"---|Header|--\\n\"&#125; &#123;print&#125; END&#123;printf\"---|Footer|---\\n\"&#125;' marks.txt &gt; /dev/null [jerry]$ cat awkprof.out 执行上面的命令可以得到如下的结果： 12345678910111213141516171819\\# gawk profile, created Sun Oct 26 19:50:48 2014 # BEGIN block(s) BEGIN &#123; printf \"---|Header|--\\n\" &#125; # Rule(s) &#123; print $0 &#125; # END block(s) END &#123; printf \"---|Footer|---\\n\" &#125; 模式(pattern)种类BEGIN { 语句 } 在读取任何输入前执行一次语句 END { 语句 } 读取所有输入之后执行一次语句 表达式 { 语句 } 对于表达式为真（即，非零或非空）的行，执行语句 /正则表达式/ { 语句 } 如果输入行包含字符串与正则表达式相匹配，则执行语句 组合模式 { 语句 } 一个 组合模式 通过与（&amp;&amp;），或（||），非（!），以及括弧来组合多个表达式；对于组合模式为真的每个输入行，执行 语句 模式1，模式2 { 语句 } 范围模式(range pattern)匹配从与模式1相匹配的行到与模式2相匹配的行（包含该行）之间的所有行，对于这些输入行，执行语句。 BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。BEGIN和END是仅有的必须搭配动作的模式。 例子： 1234awk &apos;NR &lt; 5&apos; # 行号小于5的行awk &apos;NR==1,NR==4&apos; # 行号在1到5之间的行 awk &apos;/linux/&apos; # 包含模式为linux的行（可以用正则表达式来指定模式）awk &apos;!/linux/&apos; # 不包含模式为linux的行 选择、过滤数值判断 1$2 * $3 &gt; 50 &#123; printf(\"$%.2f for %s\\n\", $2 * $3, $1) &#125; 文本内容选择，支持正则 1234$1 == \"Susie\" &#123; print &#125; # 比较字段是否等于字符串时，要使用双引号包起来$1~/正则内容/ &#123; print $1&#125; # 对某一列进行正则/正则内容/ &#123; print $1&#125; # 对整行进行匹配/条件1/,/条件2/ &#123; print $1&#125; # 对整行进行多条件匹配 匹配中文 12awk '$1 ~/[一-龥]/' 匹配中文awk '$1 ~/[\\u4e00-\\u9fa5]/' 这样反而不行，要不unicode转成对应的中文 多条件组合 逻辑操作符与 &amp;&amp; ， 或 || ， 以及非 ! 对模式进行组合 1$2 &gt;= 4 || $3 &gt;= 20 &#123;print&#125; 注意：!是在括号前的，第1种其实与第2种一模一样，正确的是第3种 12345678awk -F\"\\t\" 'BEGIN&#123;while(\"cat file\"|getline )&#123;dict[c]=1&#125;&#125; ! $2 in dict&#123;print&#125;' some.txt |wc 0 0 0 awk -F\"\\t\" 'BEGIN&#123;while(\"cat file\"|getline c)&#123;dict[c]=1&#125;&#125; (! $2 in dict)&#123;print&#125;' some.txt |wc 0 0 0 awk -F\"\\t\" 'BEGIN&#123;while(\"cat file\"|getline )&#123;dict[c]=1&#125;&#125; !($2in dict)&#123;print&#125;' some.txt |wc1296838 14273901 226060062 多条命令要在命令行上的程序脚本中使用多条命令， 只要在命令之间放个分号即可。 1$ echo \"My name is Rich\" | gawk '&#123;$4=\"Christine\"; print $0&#125;' My name is Christine 也可以用次提示符一次一行地输入程序脚本命令。 123456awk '&#123; \\&gt; $4=\"Christine\"&gt; print $0&#125;' My name is Rich $ My name is Christine 将命令保存在文件中当引号内的程序过长时，可以单独保存在文件中，假设存在文件 progfile ，输入命令行： 1awk -f progfile file 文件中不用引号包起来，但是中括号还是需要的，多条指令在同一行中用分号分分隔，或者以多行形式书写 读取命令的输出awk可以调用命令并读取输出。把命令放入引号中，然后利用管道将命令输出传入getline：&quot;command&quot; | getline output ; 下面的代码从/etc/passwd文件中读入一行，然后显示出用户登录名及其主目录。在BEGIN语 句块中将字段分隔符设置为:，在主语句块中调用了grep。 12awk 'BEGIN &#123;FS=\":\"&#125; &#123; \"grep root /etc/passwd\" | getline; print $1,$6 &#125;' # root /root 变量内置变量 变量 说明 标准 AWK 变量 ARGC 命令行提供的参数的个数 ARGV 存储命令行输入参数的数组。数组的有效索引是从 0 到 ARGC-1。 ARGIND 命令行中当前文件的位置(从0开始算) CONVFMT 数据转换为字符串的格式，其默认值为 %.6g OFMT 数值输出的格式，它的默认值为 %.6g。 OFS 输出域之间的分割符，其默认为空格。 ORS 输出记录（行）之间的分割符，其默认值是换行符。 RS 输入记录的分割符，其默认值为换行符。 NR 表示记录编号，当awk将行作为记录时，该变量相当于当前行号。全局行数（第二个文件的第一行接着第一个文件尾行数顺序计数） FNR 当前文件自身的行数（不考虑前几个输入文件的自身行数及总数。NR 的值依次为：1，2……40，41，42……90。FNR的值依次为：1，2……40， 1， 2……50 NF 表示字段数量，在处理当前记录时，相当于字段数量。默认的字段分隔符是空格。 FS 定义分隔符，可以用在 BEGIN 语句块中，这样你就不用依靠脚本用户在命令行选项中定义字段分隔符了。 $0 该变量包含当前记录的文本内容。 $n 该变量包含第n个字段的文本内容。 ENVIRON 与环境变量相关的关联数组变量，awk &#39;BEGIN { print ENVIRON[&quot;USER&quot;] }&#39; FILENAME 此变量表示当前文件名称 RLENGTH 表示 match 函数匹配的字符串长度 RSTART 表示由 match 函数匹配的字符串的第一个字符的位置 GNU AWK 特定的变量 IGNORECASE GAWK将变得大小写不敏感，awk &#39;BEGIN{IGNORECASE=1} /amit/&#39; marks.txt 自定义变量定义变量变量不用初始化即可使用 数值用作数字的awk变量的默认初始值为0，所以我们不需要初始化 emp 。 这个程序使用一个变量 emp 来统计工作超过15个小时的员工的数目： 12$3 &gt; 15 &#123; emp = emp + 1 &#125;END &#123; print emp, &quot;employees worked more than 15 hours&quot; &#125; 对于第三个字段超过15的每行， emp 的前一个值加1。该程序输出： 13 employees worked more than 15 hours 字符串awk变量可以保存数字也可以保存字符串。这个程序会找出时薪最高的员工： 123# 如果$2大于最大值，则更新为当前行的信息$2 &gt; maxrate &#123; maxrate = $2; maxemp = $1 &#125;END &#123; print &quot;highest hourly rate:&quot;, maxrate, &quot;for&quot;, maxemp &#125; 数组变量awk 中其实并不存在数组类型，所谓的关联数组是一种使用字符串作为索引的字典。因此并不是 [&quot;value1&quot;, &quot;value2&quot;]这样，而是{0: &quot;value1&quot;, 1: &quot;value2&quot;}。在awk中数组之间是无序的，一个数组的key值是数值，例如1，2，3，并不代表该数组元素在数组中的出现的位置。 1234awk 'BEGIN &#123;FS=\":\"&#125; &#123;nam[$1]=$5&#125; END &#123;for （i in nam） &#123;print i,nam[i]&#125;&#125;' /etc/passwd # root root # ftp FTP User # userj Joe User awk没有not in语法 请使用下面的用法 12!($1 in dict) # 通用情况!dict[$1] # 适用于判断在不在字典里进行过滤的情况 http://blog.chinaunix.net/uid-10540984-id-323936.html 判断一个元素是否在数组中 awk 支持in操作，但是in 判断的是键 key，awk 自身是没有判断是否在值value中的方法。 因此为了实现判断是否在数组中，要将value转为key， 123456789BEGIN &#123; split(\"value1 value2\", valuesAsValues) # valuesAsValues = &#123;0: \"value1\", 1: \"value2\"&#125; for (i in valuesAsValues) valuesAsKeys[valuesAsValues[i]] = \"\" # valuesAsKeys = &#123;\"value1\": \"\", \"value2\": \"\"&#125;&#125;# Now you can use `in`($1 in valuesAsKeys) &#123;print&#125; 一行的写法 12echo \"A:B:C:D:E:F\" | tr ':' '\\n' | \\awk 'BEGIN&#123; split(\"A D F\", parts); for (i in parts) dict[parts[i]]=\"\"&#125; $1 in dict' 遍历数组 awk支持列表形式的for循环，是对 key 进行遍历，然后显示出数组的内容： 1for(k in array) &#123; print array[k]; &#125; 数组排序 使用 asort 完成数组元素的排序，或者使用 asorti 实现数组索引的排序等等 12345fruits[\"mango\"]=\"yellow\";fruits[mango]=\"yellow\"; # 这种写法也可以value必须加双引号delete array_name[index] 删除数组元素 1delete arr[key] 例子：按行逆序打印 第一个动作将输入行存为数组 line 的连续元素；即第一行放在 line[1] ，第二行放在 line[2] , 依次继续。 END 动作使用一个 while 语句从后往前打印数组中的输入行： 12345678# 反转 - 按行逆序打印输入 &#123; line[NR] = $0 &#125; # 记下每个输入行END &#123; i = NR # 逆序打印 while (i &gt; 0) &#123; print line[i] i = i - 1 &#125; &#125; 以 emp.data 为输入，输出为 123456Susie 4.25 18Mary 5.50 22Mark 5.00 20Kathy 4.00 10Dan 3.75 0Beth 4.00 0 外部变量方法一（推荐）： 借助选项-v，我们可以将一个外部值（并非来自stdin）传递给awk： 123VAR=10000 echo | awk -v VARIABLE=$VAR &apos;&#123; print VARIABLE &#125;&apos; [filename]# 10000 gawk 程序在引用变量值时并未像shell脚本一样使用美元符。 可以不用加引号 123echo | awk -v name=\"Jerry\" '&#123;print name&#125;'echo | awk -v name=Jerry '&#123;print name&#125;' # 等价 echo | awk -v path=$PATH '&#123;print path&#125;' # 如果是环境变量，需要添加$ 可以将多个外部变量传递给awk。例如： 1234var1=\"Variable1\"var2=\"Variable2\"echo | awk '&#123; print v1,v2 &#125;' v1=$var1 v2=$var2# Variable1 Variable2 在上面的方法中，变量以键值对的形式给出，使用空格分隔（v1=$var1 v2=$var2），作为awk 的命令行参数紧随在BEGIN、{}和END语句块之后。 方法二：用引号括起来直接用，是&quot;&#39;$var&#39;&quot;的形式。 12var=&quot;abc&quot;awk &apos;BEGIN&#123;print &quot;&apos;$var&apos;&quot;&#125;&apos; 方法三：方法二类似，但使用&quot;&#39;&quot;把shell变量包起来，即&quot;&#39;&quot;$var&quot;&#39;&quot; 如果变量的值中包含空格，为了shell不把空格作为分隔符，则应使用方法二。 12var=&quot;this a test&quot;awk &apos;BEGIN&#123;print &quot;&apos;&quot;$var&quot;&apos;&quot;&#125;&apos; 方法四：export变量，然后在awk中使用ENVIRON[&quot;var&quot;]形式(大写)获取环境变量的值 12var=&quot;this a test&quot;; export var;awk &apos;BEGIN&#123;print ENVIRON[&quot;var&quot;]&#125;&apos; 操作符https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html 基本与C语言的操作相同 运算符 描述 = += -= *= /= %= ^= **= 赋值 ?: C条件表达式 \\ \\ 逻辑或 &amp;&amp; 逻辑与 ~ ~! 匹配正则表达式和不匹配正则表达式 &lt; &lt;= &gt; &gt;= != == 关系运算符 空格 拼接字符串 + – 加，减 * / % 乘，除与求余 + – ! 一元加，减和逻辑非 ^ *** 求幂 ++ — 增加或减少，作为前缀或后缀 $ 字段引用 in 字典成员 +=, 等于==，不等于!= 逻辑与运算符为 &amp;&amp;。逻辑或运算符为 ||。逻辑非 ! 。 逻辑非将 expr1 的真值取反。如果 expr1 为真，则返回 0。否则返回 1。下面的示例判断字符串是否为空： 1[jerry]$ awk &apos;BEGIN &#123; name = &quot;&quot;; if (! length(name)) print &quot;name is empty string.&quot; &#125;&apos; 三元运算符 1[jerry]$ awk &apos;BEGIN &#123; a = 10; b = 20; (a &gt; b) ? max = a : max = b; print &quot;Max =&quot;, max&#125;&apos; 字符串连接操作符 空格 (space) 操作符可以完成两个字符串的连接操作。示例如下： 12[jerry]$ awk &apos;BEGIN &#123; str1=&quot;Hello, &quot;; str2=&quot;World&quot;; str3 = str1 str2; print str3 &#125;&apos;Hello, World 数组成员操作符 数组成员操作符为 in。该操作符用于访问数组元素 。下面的示例用于此操作符输出数组中所有元素。 12345[jerry]$ awk &apos;BEGIN &#123; arr[0] = 1; arr[1] = 2; arr[2] = 3; for (i in arr) printf &quot;arr[%d] = %d\\n&quot;, i, arr[i] &#125;&apos;arr[0] = 1arr[1] = 2arr[2] = 3 awk中并没有数组对象，其实是字典，因此i 遍历的是arr的key，而不是value 匹配（Match） 匹配运算符为 ~。不匹配操作符为 !~。 它用于搜索包含匹配模式字符串的域。下面的示例中将输出包括 9 的行： 12[jerry]$ awk &apos;$0 ~ 9&apos; marks.txt # 这种写法只对数字有效，如果是字母，就会失效[jerry]$ awk &apos;$0 ~ /9/&apos; marks.txt # 推荐正则写法 控制语句 仅可以在动作中使用 一定要加{}与其他语言一样的用法，括号内的为同一语句块 if123456789101112if (condition)&#123; action-1 action-1 . . action-n&#125;else if (a == 30) print &quot;a = 30&quot;;else print &quot;a = 30&quot;; 例子：将每隔几行就拼接在一起输出 1echo -e \"cat\\nbat\\nfun\\nfin\\nfan\\nend\" | awk '&#123;str=str $0&#125;;NR %2==0&#123;print str;str=\"\"&#125;' if-else 语句中，if 后的条件会被计算。如果为真，执行第一个 print 语句。否则，执行第二个 print 语句。注意我们可以使用一个逗号将一个长语句截断为多行来书写。 while一个 while 语句有一个条件和一个执行体。条件为真时执行体中的语句会被重复执行。这个程序使用公式 value=amount(1+rate)yearsvalue=amount(1+rate)years 来演示以特定的利率投资一定量的钱，其数值是如何随着年数增长的。 12345678910# interest1 - 计算复利# 输入: 钱数 利率 年数# 输出: 复利值&#123; i = 1 while (i &lt;= $3) &#123; printf(&quot;\\t%.2f\\n&quot;, $1 * (1 + $2) ^ i) i = i + 1 &#125;&#125; 条件是 while 后括弧包围的表达式；循环体是条件后大括号包围的两个表达式。 printf 规格字符串中的 \\t 代表制表符； ^ 是指数操作符。从 # 开始到行尾的文本是注释，会被awk忽略，但能帮助程序的读者理解程序做的事情。 你可以为这程序输入三个一组的数字，看看不一样的钱数、利率、以及年数会产生什么。例如，如下事务演示了1000美元，利率为6%与12%，5年的复利分别是如何增长的：: 12345678910111213$ awk -f interest11000 .06 5 1060.00 1123.60 1191.02 1262.48 1338.231000 .12 5 1120.00 1254.40 1404.93 1573.52 1762.34 do -while1awk &apos;BEGIN &#123;i = 1; do &#123; print i; ++i &#125; while (i &lt; 6) &#125;&apos; for for ，将大多数循环都包含的初始化、测试、以及自增压缩成一行。 1234&#123; for (i = 1; i &lt;= $3; ++i) printf(&quot;\\t%.2f\\n&quot;, $1 * (1 + $2) ^ i)&#125; 初始化 i = 1 只执行一次。接下来，测试条件 i &lt;= $3 ；如果为真，则执行循环体的 printf 语句。循环体执行结束后执行自增 i = i + 1 ，接着由另一次条件测试开始下一个循环迭代。代码更加紧凑，并且由于循环体仅是一条语句，所以不需要大括号来包围它。 跳出循环（break、continue、exit、next）break、continue、exit都支持 next 等价于continue,next 停止处理当前记录，并且进入到下一条记录的处理过程。下面的例子中，当模式串匹配成功后程序并不执行任何操作： 1awk '&#123;if ($0 ~/Shyam/) next; print $0&#125;' marks.txt nextfile nextfile 停止处理当前文件，从下一个文件第一个记录开始处理。 1awk '&#123; if ($0 ~ /file1:str2/) nextfile; print $0 &#125;' file1.txt file2.txt 内置函数更多的函数说明 字符串相关match返回正则表达式在字符串 str 中第一个最长匹配的位置。如果能够找到，返回非0值；否则，返回0。match()有两个相关的特殊变量，分别是RSTART和RLENGTH。变量RSTART包含了匹配内容的起始位置，而变量RLENGTH包含了匹配内容的长度。 12345678$ awk 'BEGIN &#123; str = \"One Two Three\" subs = \"Two\" ret = match(str, subs) printf \"Substring \\\"%s\\\" found at %d location.\\n\", subs, ret&#125;'# Substring \"Two\" found at 5 location. asort 数组排序asort(arr,[, d [,how] ]) asort 函数使用 GAWK 值比较的一般规则排序 arr 中的value，然后用以 1 开始的有序整数替换排序内容的索引。 大写的会排在前面 1234567891011121314151617awk &apos;BEGIN &#123; arr[0] = &quot;Three&quot; arr[1] = &quot;One&quot; arr[2] = &quot;two&quot; print &quot;Array elements before sorting:&quot; for (i in arr) &#123; print arr[i] &#125; asort(arr) print &quot;Array elements after sorting:&quot; for (i in arr) &#123; print arr[i] &#125;&#125;&apos; asorti 数组排序asorti(arr,[, d [,how] ]) asorti 函数的行为与 asort 函数的行为很相似，二者的差别在于 aosrt 对数组的value排序，而 asorti 对数组的index排序。 123456789101112[jerry]$ awk 'BEGIN &#123; arr[\"Two\"] = 1 arr[\"One\"] = 2 arr[\"Three\"] = 3 asorti(arr) print \"Array indices after sorting:\" for (i in arr) &#123; print arr[i] &#125;&#125;' sub、gsub 替换sub 将正则表达式regex匹配到的第一处内容替换成replacment_str。 gsub(regx,sub, string) gsub 是全局替换( global substitution )的缩写。它将出现的子串（sub）替换为 regx。第三个参数 string 是可选的，默认值为 $0，表示在整个输入记录中搜索子串。进行一次替换的有sub(regex,sub,string)函数 123456$ awk 'BEGIN &#123; str = \"Hello, World\" print \"String before replacement = \" str gsub(\"World\", \"Jerry\", str) print \"String after replacement = \" str&#125;' index 判断子串包含index(str,sub) index 函数用于检测字符串 sub 是否是 str 的子串。如果 sub 是 str 的子串，则返回子串 sub 在字符串 str 的开始位置；若不是其子串，则返回 0。str 的字符位置索引从 1 开始计数。 123456$ awk 'BEGIN &#123; str = \"One Two Three\" subs = \"Two\" ret = index(str, subs) printf \"Substring \\\"%s\\\" found at %d location.\\n\", subs, ret&#125;' split 分割字符串split(str, arr, regex) split 函数使用正则表达式 regex 分割字符串 str。分割后的所有结果存储在数组 arr 中。如果没有指定 regex 则使用 FS 切分。 1234567891011[jerry]$ awk &apos;BEGIN &#123; str = &quot;One,Two,Three,Four&quot; split(str, arr, &quot;,&quot;) print &quot;Array contains following values&quot; for (i in arr) &#123; print arr[i] &#125;&#125;&apos; substr 字符串截取substr(str, start, length) substr 函数返回 str 字符串中从第 start 个字符开始长度为 length 的子串。如果没有指定 length 的值，返回 str 从第 start 个字符开始的后缀子串。 1234567$ awk 'BEGIN &#123; str = \"Hello, World !!!\" subs = substr(str, 1, 5) print \"Substring = \" subs&#125;'# Substring = Hello strtonum字符串转数字strtonum(str) strtonum 将字符串 str 转换为数值。 如果字符串以 0 开始，则将其当作八进制数；如果字符串以 0x 或 0X 开始，则将其当作十六进制数；否则，将其当作浮点数。 123456789[jerry]$ awk 'BEGIN &#123; print \"Decimal num = \" strtonum(\"123\") print \"Octal num = \" strtonum(\"0123\") print \"Hexadecimal num = \" strtonum(\"0x123\")&#125;'Decimal num = 123Octal num = 83Hexadecimal num = 291 大小写转换tolower(str)、toupper(str) 将字符串 str 进行大小写字母转换，然后返回。注意，字符串 str 本身不被改变。 getlinegetline：得到行，但是注意，得到的并不是当前行，而是当前行的下一行。原因如下： 从整体上来说，应这么理解它的用法： getline var 读取一行内容给 var，没有变量时等价于 getline $0 当其左右无重定向符 | 或 &lt; 时，getline作用于当前文件，读入当前文件的一行给其后跟的变量 var 或$0（无变量时）；由于awk在处理getline之前已经读入了一行，所以getline得的是下一行（第二行开始）。 当其左右有重定向符 | 或 &lt; 时，getline则作用于定向输入文件（用重定向符从另外一个文件中读取内容、管道符号获得UNIX命令的输出）赋值给$0 或getline后面的变量。由于该文件是刚打开，并没有被awk读入一行，那么getline返回的是该文件的第一行，而不是隔行，并赋值。 getline 会记住重定向的文件读取到哪一行了，并不会重复执行getline var &lt; file 重复读取文件，而是一次读取一行 getline执行后会更新NF，NR，FNR等这些内部变量。 例子： 比较 getline后有无变量的区别 123456789101112131415# 显示奇数$ seq 10 | awk &apos;&#123;getline var; print $0&#125;&apos; # getline var 后，内部变量不变，因此$0仍然是第1行13579# 显示偶数$ seq 10 | awk &apos;&#123;getline; print $0&#125;&apos; # getline 等价于 getline $0 ，处理getline之前$0是第一行，因此$0变为第2行246810 同时读取2个文件，不用担心getline &lt; &quot;b.txt&quot;重复读取文件， 12345678910$ awk &apos;&#123;printf &quot;%s &quot;, $0; getline &lt; &quot;b.txt&quot;; print $0&#125;&apos; a.txt # 记住 getline 等价于 getline $0 ，因此$0变成了 b 文件的内容1 62 73 84 95 10# 交替打印awk &apos;&#123;getline var &lt; &quot;a.txt&quot;;print var;print $0&#125;&apos; b.txt # var 是文件a的行，$0是文件b的内容 获取命令输出 12$ awk &apos;BEGIN &#123;&quot;date&quot; | getline; close(&quot;date&quot;); print $0&#125;&apos;Tue May 10 07:50:51 PDT 2016 注意，使用管道符号时，getline 中这样是无法获取环境变量FILE的 1awk -F&quot;\\t&quot; &apos;BEGIN&#123;while(&quot;cat $FILE&quot;|getline c)&#123;dict[c]=1&#125;&#125; ($2 in dict)&#123;print&#125;&apos; file 自定义函数12345678910function find_min(num1, num2)&#123; if (num1 &lt; num2) return num1 return num2&#125;# Script execution starts hereBEGIN &#123; main(10, 20) # 使用自定义函数&#125; 其他知识点匹配中文12awk '$1 ~/[一-龥]/' 匹配中文awk '$1 ~/[\\u4e00-\\u9fa5]/' 这样反而不行，要不unicode转成对应的中文 awk对换行敏感1awk &apos;BEGIN&#123;while(&quot;cat company.txt&quot;|getline)&#123;dict[$1]=1&#125;&#125; &#123;if($3 in dict)print NR&#125;&apos; target.txt company.txt的文件是\\r\\n结尾时，无法匹配 shell使用awk批量创建变量123eval $(awk &apos;BEGIN&#123;print &quot;v1=&apos;str1&apos;;v2=&apos;str2&apos;&quot;&#125;&apos;) # 相当于执行了 v1=&apos;str1&apos;;v2=&apos;str2&apos;echo &quot;v1=$var1&quot;echo &quot;v2=$var2&quot;","categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"},{"name":"awk","slug":"linux/awk","permalink":"https://jizx.vip/categories/linux/awk/"},{"name":"工具","slug":"linux/awk/工具","permalink":"https://jizx.vip/categories/linux/awk/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://jizx.vip/tags/工具/"},{"name":"awk","slug":"awk","permalink":"https://jizx.vip/tags/awk/"},{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"}]},{"title":"linux shell编程","slug":"linux-shell编程","date":"2019-08-13T03:00:08.000Z","updated":"2020-07-14T01:31:58.684Z","comments":true,"path":"2019/08/13/linux-shell编程/","link":"","permalink":"https://jizx.vip/2019/08/13/linux-shell编程/","excerpt":"","text":"基本知识Shell 进程父子进程在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。 这个shell程序被称为子shell（child shell）。 在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中。这会对包括变量在内的一些东西造成影响。 进程列表可以在一行内指定依次运行的一系列指令，通过命令列表来实现： 1$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls 命令列表要想成为进程列表，这些命令必须包含在括号里。括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令。 进程列表是一种命令分组（command grouping） 。另一种命令分组是将命令放入花括号中， 并在命令列表尾部加上分号（;）。语法为 { command; }但是不会像进程列表那样创建出子shell。 要想知道是否生成了子shell，得借助一个使用了环境变量的命令echo $BASH_SUBSHELL。如果该命令返回0，就表明没有子shell。如果返回 1或者其他更大的数字，就表明存在子shell。 123456789101112131415$ pwd ; echo $BASH_SUBSHELL/Users/admin0$ &#123; pwd ; echo $BASH_SUBSHELL; &#125;/Users/admin0$ (pwd ; echo $BASH_SUBSHELL)/Users/admin1$ ( pwd ; (echo $BASH_SUBSHELL))/Users/admin2 在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢处理速度。 在交互式的CLI shell会话中，子shell同样存在问题。它并非真正的多进程处理，因为终端控制着子shell的I/O。 在CLI中运用子shell的创造性方法之一就是将进程列表置入后台模式。你既可以在子shell中 进行繁重的处理工作，同时也不会让子shell的I/O受制于终端。 高效子进程后台模式12$ sleep 3000&amp; [1] 2396 在命令末尾加上字符&amp;，在shell CLI提示符返回之前，会出现一条信息，代表后台作业（background job）号（1）与后台作业的进程ID（2396）。 可以通过ps -f 或者 jobs -l 来查看 协程协程 协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。 要进行协程处理，得使用coproc命令，还有要在子shell中执行的命令。 12coproc sleep 10coproc My_Job &#123; sleep 10; &#125; # 指定协程名 通过使用扩展语法，协程的名字被设置成My_Job。这里要注意的是，扩展语法写起来有点 麻烦。必须确保在第一个花括号{和命令名之间有一个空格。还必须保证命令以分号;结 尾。另外，分号和闭花括号}之间也得有一个空格。 shell 内建命令外部命令外部命令，是存在于bash shell之外的程序。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。 当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。 当进程必须执行衍生操作时，它需要花费时间和精力来设置新子进程的环境。所以说，外部命令多少还是有代价的。 内建命令内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。比如cd和exit 利用type命令来了解某个命令是否是内建的 12$ type cdcd is a shell builtin 有些命令有多种实现。例如echo和pwd既有内建命令也有外部命令，要查看命令的不同实现，使用type命令的-a选项。 123$ type -a echo echo is a shell builtin echo is /bin/echo 要使用外部命令 pwd ，可以输入/bin/pwd 内建命令之 history设置保存在bash历史记录中的命令数。要想实现这一点，你需要修改名为 HISTSIZE 的环境变量 输入!!可以重新执行上一条命令，!编号即可执行历史列表中的对应编号的命令 bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件~/.bash_history中。 ~/.bash_history文件只有在打开首个终端会话时才会被读取。 可以在退出shell会话之前强制将命令历史记录写入.bash_history文件。要实现强制写入，需要使用history -a 要想强制重新读 取.bash_history文件，更新终端会话的历史记录，可以使用 history -n 命令。 内建命令之 alias要查看当前可用 的别名，使用alias或者alias -p。 使用alias命令创建属于自己的别名。 alias li=&#39;ls -li&#39; shell 配置文件(TODO)http://ddrv.cn/a/173848/ Shell 启动方式（TODO 到底是几种） 交互式登录 交互式非登录 非交互式登录 非交互式非登录 启动bash shell有3种方式： 登录时作为默认登录shell 作为非登录shell的交互式shell 作为运行脚本的非交互shell 交互式：一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动。 非交互式：运行一个 Shell 脚本 文件，让所有命令批量化、一次性地执行。 登录式：需要输入用户名和密码才能使用。 非登录式：直接可以使用。 判断 shell 类型如何判断是否为交互式 Shell? 有两种方式 查看特殊变量 - ，如果值包含 i，则是交互式，否则是非交互式 1echo $- 查看变量 PS1 是否为空，如果不为空，则是交互式，否则为非交互式 1echo $PS1 如何判断是否为登录式 Shell ?执行命令 shopt login_shell，如果 login_shell 的值为 on表示登录式，为 off表示非登录式。 登录 shell当你登录Linux系统时，bash shell会作为登录shell启动。（对于没有图形化界面来说） 登录shell会从5个不同的启动文件里 读取命令： /etc/profile ——&gt;会去读取/etc/profile.d目录下的配置文件 $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile $HOME目录下的启动文件 剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环 境变量。大多数Linux发行版只用这四个启动文件中的1、2个： $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile shell会按照按照下列顺序，运行第一个被找到的文件，忽略其他文件： $HOME/.bash_profile $HOME/.bash_login $HOME/.profile 这个列表中没有$HOME/.bashrc文件是因为该文件通常通过其他文件运行的。比如 .bash_profile会先去检查HOME目录中是不是还有一个叫.bashrc的启动文件。如果有的话，会先执行启动文件里面的命令。因此.bashrc顺序最先，但是并不是优先级最高，因为.bash_profile设置的变量会覆盖 .bashrc 中的变量 123456789# .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH $ 交互式 shell 进程如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那 么你启动的shell叫作交互式shell。 作为交互式shell启动的，就不会访问/etc/profile文件，只会检查用户HOME目录中的.bashrc文件。 123456# .bashrc # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi# User specific aliases and functions .bashrc文件有两个作用： 查看/etc目录下通用的bashrc文件 为用户提供一个定制自 己的命令别名和私有脚本函数的地方。 非交互式 shell系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。 脚本能以不同的方式执行。只有其中的某一些方式能够启动子shell。 bash shell提供了BASH_ENV环境变量。当shell启动一个非交互式shell进 程时，它会检查BASH_ENV来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。 但是 CentoS 与 Ubuntu 都没有该变量，shell脚本到哪里去获得它们的环境变量呢？ 有些 shell脚本是通过启动一个子shell来执行的。子shell可以继承父shell导出过的变量。 对于那些不启动子shell的脚本， 变量已经存在于当前shell中了。 所以就算没有设置 BASH_ENV，也可以使用当前shell的局部变量和全局变量。 配置文件加载顺序参考网站 正常启动 su 切换用户 环境变量全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的 shell可见。 查看环境变量的命令有set、env、printenv 它们的区别： set 命令会显示出全局变量、局部变量以 及用户定义变量。它还会按照字母顺序对结果进行排序。 env 和 printenv 命令不会对变量排序，也不会输出局部变量和用户定义变量。 TODO env 与 printenv 要显示个别环境变量的值，可以使用printenv 或者 echo 12345$ printenv HOME /home/Christine$ echo $HOME /home/Christine 设置局部变量变量名区分大小写。所有的环境变量名均使用大写字母，自己创建的局部变量或是shell脚本，请使用小写字母。 记住，变量名、等号和值之间没有空格：如果在赋值表达式中加上了空格， bash shell就会把值当成一个单独的命令： 12$ my_variable = \"Hello World\" -bash: my_variable: command not found 设置全局变量创建全局环境变量的方法是先创建一个局部环境变量，然后通过export命令把它导出到全局环境中。变量名前面不需要加$。 123$ my_variable=\"I am Global now\" $ my_variable2=\"I am Global now\" $ export my_variable my_variable2 # 可以同时导出多个变量 修改子shell中全局环境变量并不会影响到父shell中该变量的值。这种改变仅在子shell中有效，并不会被反映到父shell中。甚至无法使用export命令改变父shell中全局环境变量的值。 1234567891011121314151617181920212223$ my_variable=\"I am Global now\" $ export my_variable $ $ echo $my_variable I am Global now $ $bash $ $ echo $my_variable I am Global now $ $ my_variable=\"Null\" $ $ export my_variable # 导出变量也没用$ $ echo $my_variableNull $ $ exit exit $ $ echo $my_variable I am Global now $ shell 编程创建脚本在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为： #!/bin/bash 在通常的shell脚本中，井号（#）用作注释行。然而， shell脚本文件的第一行是个例外。 打印默认情况下，不需要使用引号将要显示的文本字符串划定出来 可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在 文本中使用其中一种引号，而用另外一种来将字符串划定起来。 不换行echo -n &quot;The time and date are: &quot; 反斜杠（\\）：使反斜杠后面的一个变量变为单纯的字符串。 单引号（’’）：全局转义，转义其中所有的变量为单纯的字符串。 双引号（””）：保留其中的变量属性，不进行转义处理。 反引号（）：把其中的命令执行后返回结果，等价于$(命令) 别名通常别名定义在 $HOME/.bashrc 或者 $HOME/bash_aliases (在 $HOME/.bashrc被加载). 123if [ -e $HOME/.bash_aliases ]; then source $HOME/.bash_aliasesfi 推荐的别名 1234567891011121314151617181920alias ls='ls -F' # 目录名后面加上/alias ll='ls -lh' # 人类可读的方式显示容量，KB、GBalias gh='history|grep' # 查找历史命令alias count='find . -type f | wc -l' # 计算当前目录下文件总数# 自定义函数最好保存在 bash_functions 文件中if [ -e $HOME/.bash_functions ]; then source $HOME/.bash_functionsfi# 切换目录同时展示目录下的内容function cl() &#123; DIR=\"$*\"; # if no DIR given, go current dir if [ $# -lt 1 ]; then DIR=\".\"; fi; builtin cd \"$&#123;DIR&#125;\" &amp;&amp; \\ # use your preferred ls command ls -F --color=auto&#125; 变量环境变量在 shell 中set命令来显示一份完整的当前环境变量列表 在脚本中，你可以在环境变量名称之前加上美元符$来使用这些环境变量，或者${variable} 形式引用的变量。变量名两侧额外的花括号通常用来帮助识别美元符后的变量名 用户变量 由字母、数字或下划线组成的文本字符串，长度不超过20个 用户变量 区分大小写 使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格 在shell脚本结束时会被删除掉 用户变量可通过美元符引用 只读变量使用 readonly 下面的例子尝试更改只读变量，结果报错： 123#!/bin/bashmyUrl=&quot;http://c.biancheng.net/shell/&quot;readonly myUrl 字符串字符串的3种形式 由单引号&#39; &#39;包围的字符串：任何字符都会原样输出，在其中使用变量是无效的。字符串中不能出现单引号，即使对单引号进行转义也不行。 由双引号&quot; &quot;包围的字符串：如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。字符串中可以出现双引号，只要它被转义了就行。 不被引号包围的字符串不被引号包围的字符串中出现变量时也会被解析，这一点和双引号” “包围的字符串一样。字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。 12345678910111213n=74str1=c.biancheng.net$n str2=\"shell \\\"script\\\" $n\"str3='C语言中文网 $n'echo $str1echo $str2echo $str3运行结果：c.biancheng.net74shell \"script\" 74C语言中文网 $n 变量(字符串)拼接直接将两个变量写在一起就是拼接 12345str1=$name$url #中间不能有空格，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析，str2=\"$name $url\" #如果被双引号包围，那么中间可以有空格str3=$name\": \"$url #中间可以出现别的字符串str4=\"$name: $url\" #这样写也可以str5=\"$&#123;name&#125;Script: $&#123;url&#125;index.html\" #这个时候需要给变量名加上大括号 加&#123; &#125;是为了帮助解释器识别变量的边界 字符串的长度1$&#123;#string_name&#125; 字符串的截取1.#：截取右边字符，删除左边字符 变量 var=http://www.aaa.com/123.htm 单#：echo ${var#*//}，结果：保留 www.aaa.com/123.htm 其中 var 是变量名，#是运算符，*是通配符，*// 表示从左边开始删除第一个 // 号及左其边的所有字符，即删除http://，保留 www.aaa.com/123.htm 双##（贪心地删除）：echo ${var##*/}，结果：保留 123.htm ##*/表示从左边开始删除最后一个/号及左边的所有字符，即删除 http://www.aaa.com/，保留 123.htm 2. %：截取左边字符，删除右边字符 变量 var=http://www.aaa.com/123.htm 单%：echo ${var%/*}，结果：保留http://www.aaa.com %/* 表示从右边开始，删除第一个/号及右边的字符，保留http://www.aaa.com 双%%（贪心地删除）:echo ${var%%/*}，结果：保留http: %%/* 表示从右边开始，删除最后（最左边）一个/号及右边的字符，保留http: 删除变量记住不要使用$ 1unset my_variable 在处理全局环境变量时，如果你是在子进程中删除了一个全局环境变量， 这只对子进程有效。该全局环境变量在父进程中依然可用。 变量默认值参数设置默认值${var:-default} var=${var1:-default} 当var1不存在时，使用default作为默认值 12345serverparm=$1servername=$&#123;serverparm:-\"/home/test/tomcat-server1\"&#125;servernum=$&#123;serverparm:-34&#125; # 默认值是34哦echo $servernameecho $servernum 变量前的 $ 符号记住一点就行了：如果要用到变量，使用$；如果要操作变量，不使用$。这条规则的一个例外就是使用 printenv 显示某个变量的值。 $* 与$@$* 和$@ 都表示传递给函数或脚本的所有参数， 当 $* 和 $@ 不被双引号&quot;&quot;包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。 但是当它们被双引号&quot; &quot;包含时，就会有区别了： &quot;$*&quot;会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。 &quot;$@&quot;仍然将每个参数都看作一份数据，彼此之间是独立的。 比如传递了 5 个参数，那么对于$*来说，这 5 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于$@来说，这 5 个参数是相互独立的，它们是 5 份数据。 12345678910111213141516171819202122232425262728echo \"脚本的名字是：\"$0n=1echo \"使用\\$@的参数列表为：\"$@for temstr in \"$@\"do echo \"第$n个参数是：\" $temstr let n+=1donen=1echo \"使用\\$*的参数列表为：\"$*for temstr in \"$*\"do echo \"第$n个参数是：\" $temstr let n+=1done##### 结果 #####脚本的名字是：test.sh使用$@的参数列表为：1 2 3 4 5第1个参数是： 1第2个参数是： 2第3个参数是： 3第4个参数是： 4第5个参数是： 5使用$*的参数列表为：1 2 3 4 5第1个参数是： 1 2 3 4 5 $0的含义第一种情况：直接命令调用一个shell，比如bash，会打开一个新的bash子shell，这时echo $0显示 shell的名称，比如sh，或者bash 123# bash# echo &apos;$0&apos; is $0# $0 is bash 第二种情况：shell 调用脚本文件，那么在脚本文件中echo $0就是脚本的文件名 12# bash main.sh# $0 is main.sh 环境变量持久化对全局环境变量来说不要将变量、设置放在/etc/profile文件中，因为在你升级了所用的发行版后， 这个文件也会跟着更新，那所有定制过的变量设置可就都没有了。 最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变 量设置放在这个文件中。 在大多数发行版中，存储个人用户永久性bash shell变量的地方是~/.bashrc文件。这一点适用于所有类型的shell进程。 但如果设置了 BASH_ENV 变量， 那么记住， 除非它指向的是~/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方。 命令输出赋给变量、命令替换 反引号字符（`） $()格式 原理：命令替换会创建一个子shell来运行对应的命令。子shell（ subshell）是由运行该脚本的shell 所创建出来的一个独立的子shell（child shell） 。正因如此，由该子shell所执行命令是无法 使用脚本中所创建的变量的。 TODO 没明白 在命令行提示符下使用路径 ./ 运行命令的话，也会创建出子shell；要是运行命令的时候 不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。 在命令行提示符下运行脚本时一定要留心！ 变量截取假设我们定义了一个变量为： 12代码如下:file=/dir1/dir2/dir3/my.file.txt 可以用${ }分别替换得到不同的值： 12345678$&#123;file#*/&#125;：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt$&#123;file##*/&#125;：删掉最后一个 / 及其左边的字符串：my.file.txt$&#123;file#*.&#125;：删掉第一个 . 及其左边的字符串：file.txt$&#123;file##*.&#125;：删掉最后一个 . 及其左边的字符串：txt$&#123;file%/*&#125;：删掉最后一个 / 及其右边的字符串：/dir1/dir2/dir3$&#123;file%%/*&#125;：删掉第一个 / 及其右边的字符串：(空值)$&#123;file%.*&#125;：删掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file$&#123;file%%.*&#125;：删掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my 记忆的方法为： 123456代码如下:# 是 去掉左边（键盘上#在 $ 的左边）%是去掉右边（键盘上% 在$ 的右边）单一符号是最小匹配；两个符号是最大匹配$&#123;file:0:5&#125;：提取最左边的 5 个字节：/dir1$&#123;file:5:5&#125;：提取第 5 个字节右边的连续5个字节：/dir2 也可以对变量值里的字符串作替换： 123456789101112131415161718代码如下:$&#123;file/dir/path&#125;：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt$&#123;file//dir/path&#125;：将全部dir 替换为 path：/path1/path2/path3/my.file.txt利用 $&#123; &#125; 还可针对不同的变数状态赋值(沒设定、空值、非空值)：$&#123;file-my.file.txt&#125; ：假如 $file 沒有设定，則使用 my.file.txt 作传回值。(空值及非空值時不作处理) $&#123;file:-my.file.txt&#125; ：假如 $file 沒有設定或為空值，則使用 my.file.txt 作傳回值。 (非空值時不作处理)$&#123;file+my.file.txt&#125; ：假如 $file 設為空值或非空值，均使用 my.file.txt 作傳回值。(沒設定時不作处理)$&#123;file:+my.file.txt&#125; ：若 $file 為非空值，則使用 my.file.txt 作傳回值。 (沒設定及空值時不作处理)$&#123;file=my.file.txt&#125; ：若 $file 沒設定，則使用 my.file.txt 作傳回值，同時將 $file 賦值為 my.file.txt 。 (空值及非空值時不作处理)$&#123;file:=my.file.txt&#125; ：若 $file 沒設定或為空值，則使用 my.file.txt 作傳回值，同時將 $file 賦值為my.file.txt 。 (非空值時不作处理)$&#123;file?my.file.txt&#125; ：若 $file 沒設定，則將 my.file.txt 輸出至 STDERR。 (空值及非空值時不作处理)$&#123;file:?my.file.txt&#125; ：若 $file 没设定或为空值，则将 my.file.txt 输出至 STDERR。 (非空值時不作处理)$&#123;#var&#125; 可计算出变量值的长度：$&#123;#file&#125; 可得到 27 ，因为/dir1/dir2/dir3/my.file.txt 是27个字节 参考来源 letet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上$来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。 实例： 12345678# !/bin/bashlet no++let no--let no+=10，let no-=20 # 分别等同于 let no=no+10，let no=no-20let a=5+4let b=9-3 echo $a $b 数组变量 Bash Shell 只支持一维数组（不支持多维数组）。 初始化时不需要定义数组大小（与 PHP 类似）。 数组元素的下标由0开始。 数组定义Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下： 1array_name=(value1 value2 … valuen) 例如：my_array=(A B “C” D) 我们也可以使用下标来定义数组： 123array_name[0]=value0array_name[1]=value1array_name[2]=value2 读取数组这样是行不通的 12$ echo $mytest # 打印数组只会显示第一个值one 一般格式是：${array_name[index]} 12345my_array=(A B \"C\" D)echo \"第一个元素为: $&#123;my_array[0]&#125;\"echo \"第二个元素为: $&#123;my_array[1]&#125;\"echo \"第三个元素为: $&#123;my_array[2]&#125;\"echo \"第四个元素为: $&#123;my_array[3]&#125;\" 获取数组中的所有元素 使用@ 或 * 可以获取数组中的所有元素，例如： 12345my_array=(A B \"C\" D)echo \"数组的元素为: $&#123;my_array[*]&#125;\"echo \"数组的元素为: $&#123;my_array[@]&#125;\"# 数组的元素为: A B C D 数组的元素为: A B C D 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如： 12345my_array=(A B \"C\" D)echo \"数组元素个数为: $&#123;#my_array[*]&#125;\"echo \"数组元素个数为: $&#123;#my_array[@]&#125;\"# 数组元素个数为: 4 数组元素个数为: 4 删除某个值unset命令删除数组中的某个值，但是要小心，这可能会有点复杂。看下面的例子。 123456789$ unset mytest[2] $ echo &#123;mytest[*]&#125; # 遍历时会跳过被删除的索引位置one two four five $ echo $&#123;mytest[2]&#125; # 但是该索引位置还占用着$ echo &#123;mytest[3]&#125; four 这个例子用unset命令删除在索引值为2的位置上的值。显示整个数组时，看起来像是索引 里面已经没这个索引了。但当专门显示索引值为2的位置上的值时，就能看到这个位置是空的。 最后，可以在unset命令后跟上数组名来删除整个数组。 12$ unset mytest $ echo &#123;mytest[*]&#125; 数组遍历首先创建一个数组 array=( A B C D 1 2 3 4) 标准的for循环1234for(( i=0;i&lt;$&#123;#array[@]&#125;;i++)) #$&#123;#array[@]&#125;获取数组长度用于循环do echo $&#123;array[i]&#125;done for … in不带数组下标 1234for element in $&#123;array[@]&#125; #也可以写成for element in $&#123;array[*]&#125;do echo $elementdone 带数组下标 1234for i in $&#123;!array[@]&#125; do echo $i $&#123;array[$i]&#125;done while循环法123456i=0 while [ $i -lt $&#123;#array[@]&#125; ] #当变量（下标）小于数组长度时进入循环体do echo $&#123;array[$i]&#125; #按下标打印数组元素 let i++ done shell 展开Bash 有七种扩展格式。本文只介绍其中五种：~ 扩展、算术扩展、路径名称扩展、大括号扩展和命令替换。 {}花括号从一个包含花括号的模式中创建多个文本字符串。 12345678910111213141516# 逗号$ echo Front-&#123;A,B,C&#125;-BackFront-A-Back Front-B-Back Front-C-Back# 序列$ echo Num_&#123;1..5&#125;Num_1 Num_2 Num_3 Num_4 Num_5$ echo Num_&#123;1..10..2&#125; # 间隔Num_1 Num_3 Num_5 Num_7 Num_9$ echo &#123;Z..A&#125; # 倒序Z Y X W V U T S R Q P O N M L K J I H G F E D C B A$ echo a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b #嵌套aA1b aA2b aB3b aB4b ~扩展Bash shell 把这个快捷方式展开成用户的完整的家目录。 12$ echo ~/home/student 路径名称扩展路径名称扩展是展开文件通配模式为匹配该模式的完整路径名称的另一种说法，匹配字符使用 ? 和 * ? — 匹配字符串中特定位置的一个任意字符 * — 匹配字符串中特定位置的 0 个或多个任意字符 $展开‘$’ 符号引入了三种 shell 展开，包括 “参数展开”，“命令替换” 和 “算术表达式”。 参数展开1$ echo $USER 参数展开的基本的形式是 ${PARAMETER}，整体被替换为 PARAMETER 的值。花括号如果 PARAMETER 是位置参数，而且由两个及以上的数字表示，这时必须使用花括号：${10}。另外当 PARAMETER 与其它字符相邻连接时，也必须使用花括号：${Var}lala。 命令替换命令替换是让一个命令的标准输出数据流被当做参数传给另一个命令的扩展形式。 命令替换有两种格式：command 和 $(command)。 12$ echo \"Todays date is $(date)\"Todays date is Sun Apr 7 14:42:59 EDT 2019 算术扩展数字扩展的语法是 $((arithmetic-expression)) ，分别用两个括号来打开和关闭表达式。算术扩展在 shell 程序或脚本中类似命令替换；表达式结算后的结果替换了表达式，用于 shell 后续的计算。 12$ Var1=5 ; Var2=7 ; Var3=$((Var1*Var2)) ; echo \"Var 3 = $Var3\"Var 3 = 35 禁用展开双引号把文本放在双引号中后，shell 使用的特殊字符，除了 $，\\ ，和 `（倒引号）之外， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割、路径名展开、波浪线展开、花括号展开都被禁止，然而参数展开，算术展开，命令替换仍然有效。 1234567# 多余的空格会被压缩$ echo this is a testthis is a test# 双引号关闭了单词分割功能$ echo \"this is a test\"this is a test 案例2 12345678910111213# 1. 没有引用的命令替换导致命令行包含 38 个参数。$ echo $(cal)January 2019 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31# 2. 命令行只有一个参数，参数中包括嵌入的空格和换行符。$ echo \"$(cal)\" January 2019Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 1213 14 15 16 17 18 1920 21 22 23 24 25 2627 28 29 30 31 单引号如果需要禁止所有的展开，需要使用单引号，包括转义符号\\ 转义字符在文件名中可能使用一些对于 shell 来说，有特殊含义的字符。这些字符包括 “$”, “!”, “ “ 等字符。在文件名中包含特殊字符，你可以这样做： 1mv bad\\&amp;filename good_filename 注意在单引号中，反斜杠失去它的特殊含义，它会被看作普通字符。 重定向输出覆盖原本文件 123&gt; 正常信息写入2&gt; 错误信息写入&amp;&gt; 不论是正确还是错误信息，都写入文件中 追加文本文件，多一个&gt; 123&gt;&gt; 正常信息写入2&gt;&gt; 错误信息写入&amp;&gt;&gt; 不论是正确还是错误信息，都写入文件中 输入12&lt; # 输入重定向&lt;&lt; # 内联输入重定向 内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，你必须指定一个文本标记来划分输 入数据的开始和结尾。它的用途请看 数学运算那一章节的 bc 计算器 123456$ wc &lt;&lt; EOF&gt; test string 1&gt; test string 2&gt; test string 3&gt; EOF$ 3 9 42 重定向绑定&gt;&amp;原理：linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令 command 2&gt;&amp;1 这条命令用到了重定向绑定，采用&amp;可以将两个输出绑定在一起，即错误输出将和标准输出共用一个文件描述符。 可以这样记住这条写法（虽然并不完全正确）首先，2&gt;1 会被解释成将stderr 重定向到一个名为 1的文件中。 因此加入&amp;来表示紧跟着的是文件描述符（file descriptor)而不是文件名，因此最终就是这样的形式： 2&gt;&amp;1 理解上面的原理后，就可以明白下面的例子了： 1、标准输出和标准错误重定向到不同log文件中 1sh mr_add_test.sh &gt;log.log 2&gt;log_err.log 2、将标准输出和标准错误重定向到同一log文件 1foo &gt;file 2&gt;&amp;1 解读：&gt;file 将标准输出重定向到文件中，2&gt;&amp;1 将错误绑定到标准输出上，此时标准输出已经重定向到file了 3、输出标准输出和标准错误，同时保存到文件logfile 方法一： &lt;command&gt; 2&gt;&amp;1 | tee &lt;logfile&gt; 管道符号把一个进程的标准输出作为另一个进程的标准输入。2&gt;&amp;1是把标准错误重定向到标准输出的副本一起输出。上面的命令，把标准输出和标准错误都输出作为tee命令的标准输入，tee的作用为把标准输入的内容拷贝到文件，并输出。 方法二：&lt;command&gt; 2&gt; logfile | cat - logfile cat可以带多个文件参数，同时显示多个文件的内容。 -代表标准输入，logfile是管道前保存的标准错误文本。 4、只输标准出错误，并保存错误信息到文件中 1&lt;command&gt; 2&gt;&amp;1 &gt;/dev/null | tee logfile 这条命令其实分为两命令来看： 2&gt;&amp;1 将标准错误重定向到标准输出，注意，此时标准输出还没有被重定向，其输出仍然是屏幕。 /dev/null文件是一个空设备，类似于windows内的回收站，使用&gt;/dev/null将标准输出重定向到/dev/null，即不显示标准输出的内容。所以这时的标准输出就仅变为重定向过来的标准错误了。 相反，如果两者颠倒顺序，那标准输出连同它的副本都会被重定向到/dev/null，这是一个逻辑问题。 1234make 2&gt;&amp;1 &gt;/dev/null # 顺序1，错误还是输出到屏幕make: *** No targets specified and no makefile found. Stop.make &gt;/dev/null 2&gt;&amp;1 # 顺序2，不输出错误 &gt;/dev/null 2&gt;&amp;1 与 &gt;/dev/null 2&gt;/dev/null 1234ls a.txt b.txt &gt;out 2&gt;outcat out# a.txt# txt: No such file or directory out中出现了丢失。采用这种写法，标准输出和错误输出会抢占往out文件的管道，所以可能会导致输出内容的时候出现缺失、覆盖等情况。有时候也有可能出现只有error信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。 而且，由于out文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体IO效率不如&gt;/dev/null 2&gt;&amp;1来得高。 5、&amp;&gt;与2&gt;&amp;1的区别 &amp;&gt;file 意思是把标准输出 和 标准错误输出 都重定向到文件file中 2&gt;&amp;1 意思是把 标准错误输出 重定向到 标准输出，标准输出并不一定输出到文件中哦 Bash’s man page mentions there’s two ways to redirect stderr and stdout: &amp;&gt; file and &gt;&amp; file. Now, notice that it says both stderr and stdout. In case of this &gt;file 2&gt;&amp;1 we are doing redirection of stdout (1) to file, but then also telling stderr(2) to be redirected to the same place as stdout ! So the purpose may be the same, but the idea slightly different. In other words “John, go to school; Suzzie go where John goes”. 在这个&gt; file 2&gt;＆1的情况下，我们正在将stdout（1）重定向到文件，然后还要告诉stderr（2）重定向到与stdout相同的位置！ 因此目的可能是相同的，但想法略有不同。 换句话说，“约翰，去上学；苏奇去约翰去的地方”。 What about preference ? &amp;&gt; is a bash thing. So if you’re porting a script, that won’t do it. But if you’re 100% certain your script will be only working on system with bash - then there’s no preference. “＆&gt;”是专属于“bash”的东西。 因此，如果你有移植脚本的打算，就不会用这种方法。 但是，如果您100％确定您的脚本只在具有bash的系统上运行。那就没有什么问题。 Here’s an example with dash , the Debian Amquist Shell which is Ubuntu’s default. 123456789101112&gt; $ grep &quot;YOLO&quot; * &amp;&gt; /dev/null&gt; $ grep: Desktop: Is a directory&gt; grep: Documents: Is a directory&gt; grep: Downloads: Is a directory&gt; grep: Music: Is a directory&gt; grep: Pictures: Is a directory&gt; grep: Public: Is a directory&gt; grep: Templates: Is a directory&gt; grep: Videos: Is a directory&gt; grep: YOLO: Is a directory&gt; grep: bin: Is a directory&gt; As you can see, stderr is not being redirected。你可以看到标准错误没有被重定向【失败了】 To address your edits in the question, you can use if statement to check $SHELL variable and change redirects accordingly But for most cases &gt; file 2&gt;&amp;1 should work。而&gt; file 2&gt;&amp;1 大多数情况都是OK的 In more technical terms, the form [integer]&gt;&amp;word is called Duplicating Output File Descriptor, and is a feature specified by POSIX Shell Command Language standard, which is supported by most POSIX-compliant and Brourne-like shells. See also What does &amp; mean exactly in output redirection? 来自：What is the differences between &amp;&gt; and 2&gt;&amp;1 数学运算expr (不推荐)标准操作符在expr命令中工作得很好，但在脚本或命令行上使用它们时仍有问题出现。 许多expr命令操作符在shell中另有含义（比如星号）。 12345$ expr 5 * 2 expr: syntax error # 需要进行转义$ expr 5 \\* 2 方括号(只支持整数)用$[ operation ]将数学表达式围起来 123$ var1=$[1 + 5]$ echo $var1 # 6 注意：bash shell数学运算符只支持整数运算。若要进行任何实际的数学计算，这是一个巨大的限制。z shell（zsh）提供了完整的浮点数算术操作。 12345var1=100var2=45var3=$[$var1 / $var2]echo $var3# 2 bc计算器(浮点数计算)命令行 bash计算器支持变量print语句允许你打印 变量和数字，-q 命令行选项可以不显示bash计算器冗长的欢迎信息。 1234567$ bc -qres=12 * 5.4 # 变量print res64.81+res65.8 # 计算结果quit # 退出 浮点运算是由内建变量scale控制的。必须将这个值设置为你希望在计算结果中保留的小数 位数，否则无法得到期望的结果 12345678$ bc -q3.44 / 5 0 scale=43.44 / 5 .6880 quit $ 脚本 基本格式如下： variable=$(echo &quot;options; expression&quot; | bc) options 允许你设置变量。 如果你需要不止一个变量， 可以用分号将其分开 expression参数定义了通过bc执行的数学表达式 1234567$ cat test10 #!/bin/bash var1=100 var2=45 var3=$(echo \"scale=4; $var1 / $var2\" | bc) echo The answer for this is $var3 $ 大量运算 最好的办法是使用内联输入重定向，当然，必须用命令替换符号标识出用来给变量赋值的命令。 12345678910111213141516$ cat test12#!/bin/bashvar1=10.46var2=43.67var3=33.2var4=71var5=$(bc &lt;&lt; EOF scale = 4 a1 = ( $var1 * $var2) b1 = ($var3 * $var4) a1 + b1 EOF )echo The final answer for this mess is $var5 s$ 你可以在bash计算器中赋值给变量。这一点很重要：在bash 计算器中创建的变量只在bash计算器中有效，不能在shell脚本中使用。 圆括号 运算操作符/运算命令 说明 ((a=10+66) ((b=a-15)) ((c=a+b)) 在 (( )) 中使用变量无需加上$前缀，(( )) 会自动解析变量名 a=$((10+66) b=$((a-15)) c=$((a+b)) 使用$获取 (( )) 命令的结果 ((a&gt;7 &amp;&amp; b==c)) (( )) 也可以进行逻辑运算，在 if 语句中常会使用逻辑运算。 echo $((a+10)) 需要立即输出表达式的运算结果时，可以在 (( )) 前面加$符号。 c=$((a=3+5, b=a+10)) 多个表达式之间以逗号,分隔。以最后一个表达式的值作为整个 (( )) 命令的执行结果。 数字高级比较 （双括号） 1(( expression )) 双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。但还是只支持整数 12345678910111213val++ # 后增 val-- # 后减++val # 先增--val # 先减! # 逻辑求反~ # 位求反** # 幂运算&lt;&lt; # 左位移 &gt;&gt; # 右位移&amp; # 位布尔和| # 位布尔或 &amp;&amp; # 逻辑和 || # 逻辑或 注意，不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性。 12345678910#!/bin/bash # using double parenthesis # val1=10 # if (( $val1 ** 2 &gt; 90 )) then (( val2 = $val1 ** 2 )) echo \"The square of $val1 is $val2\" fi letet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上$来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。 实例： 12345678# !/bin/bashlet no++let no--let no+=10，let no-=20 # 分别等同于 let no=no+10，let no=no-20let a=5+4let b=9-3 echo $a $b 退出脚本shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。退出状态码是一个0～255的整数值，在命令结束运行时执行exit code传给shell。 状态码 说明 0 成功结束 1 一般性未知错误 2 不合适的 shell 命令 126 命令不可执行，比如没有权限 127 没有找到命令 128 无效的退出参数 128+x 与 Linux 信号 x 相关的严重错误 130 通过 Ctrl+C 终止的命令 255 正常范围之外的退出状态码 脚本的健壮性要写出健壮性更好的脚本，下面是一些相关的技巧： 使用 -e 参数，如：set -e 或是 #!/bin/sh -e，这样设置会让你的脚本出错就会停止运行，这样一来可以防止你的脚本在出错的情况下还在拼拿地干活停不下来。 使用 -u 参数，如： set -eu，这意味着，如果你代码中有变量没有定义，就会退出。 你可以使用 set -x 来debug输出。 考虑使用 set -o pipefail 来限制错误。还可以使用trap来截获信号（如截获ctrl+c）。 对一些变理，你可以使用默认值。如：${FOO:-&#39;default&#39;} 处理你代码的退出码。这样方便你的脚本跟别的命令行或脚本集成。 尽量使用 &amp;&amp; 来执行多个命令，而不是 ;，这样会在出错的时候停止运行后续的命令。 对于一些字符串变量，使用引号括起，避免其中有空格或是别的什么诡异字符。 如果你的脚有参数，你需要检查脚本运行是否带了你想要的参数，或是，你的脚本可以在没有参数的情况下安全的运行。 为你的脚本设置 -h 和 --help 来显示帮助信息。千万不要把这两个参数用做为的功能。 使用 $() 而不是 “ 来获得命令行的输出，主要原因是易读。 小心不同的平台，尤其是 MacOS 和 Linux 的跨平台。 对于 rm -rf 这样的高危操作，需要检查后面的变量名是否为空，比如：rm -rf $MYDIDR/* 如果 $MYDIR为空，结果是灾难性的。 考虑使用 find/while而不是 for/find。如：for F in $(find . -type f) ; do echo $F; done 写成 find . -type f | while read F ; do echo $F ; done 不但可以容忍空格，而且还更快。 防御式编程，在正式执行命令前，把相关的东西都检查好，比如，文件目录有没有存在。 你还可以使用网站ShellCheck来帮助你检查你的脚本。 转至：https://coolshell.cn/articles/19219.html 流程控制逻辑符号command1 &amp;&amp; command2 ：如果 command1 执行成功，那么接着执行 command2。如果 command1 失败，就跳过 command2。 command1 || command2：如果 command1 失败，执行 command2。隐藏的逻辑是，如果 command1 成功，跳过 command2。 &amp;&amp; 和 || 两种运算符结合起来才能发挥它们的最大功效 1前置 commands ; command1 &amp;&amp; command2 || command3 ; 跟随 commands 语法解释：假如 command1 退出时返回码为零，就执行 command2，否则执行 command3。类似于 if-else的逻辑。 用具体代码试试，在 root 的 home 目录下测试： 1[student@studentvm1 ~]$ Dir=/root/testdir ; mkdir $Dir &amp;&amp; cd $Dir || echo \"$Dir was not created.\"mkdir: cannot create directory '/root/testdir': Permission denied/root/testdir was not created. 现在在你的家目录执行，你将会有权限创建这个目录了： 1[student@studentvm1 ~]$ Dir=~/testdir ; mkdir $Dir &amp;&amp; cd $Dir || echo \"$Dir was not created.\" if else1234if command then commands fi 或者 1234# 推荐if command; then commandsfi 通过把分号放在待求值的命令尾部，就可以将 then 语句放在同一行上了，这样看起来更 像其他编程语言中的 if-then 语句。 bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0，就执行then后的命令。在其他编程语言 中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。 if else 123456if commandthen commands else commands fi if elif 1234567if command1 then commands elif command2then more commands fi 注意：记住， 在 elif 语句中， 紧跟其后的 else 语句属于 elif 代码块。 它们并不属于之前的 if-then 代码块。 test 命令if-then语句是否能测试命令退出状态码之外的条件。答案是不能。 test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立， test命令就会退出并返回退出状态码0。 1234if test condition then commandsfi 推荐写法bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。 1234if [ condition ] then commandsfi 方括号定义了测试条件。注意， 第一个方括号之后和第二个方括号之前必须加上一个空格， 否则就会报错。 括号内的大于号、小于号，需要进行转义，后面的双括号才不需要。 否定写法(感叹号) 1234if [ ! -f $FILE ]; then # !后有空格 echo &quot;source company doesn\\&apos;t exist&quot; exitfi 条件测试test命令可以判断三类条件： 数值比较 字符串比较 文件比较 整数比较我们不能在 test命令中使用浮点值 123456n1 -eq n2 # 检查n1是否=n2 n1 -ge n2 # 检查n1是否&gt;=n2 n1 -gt n2 # 检查n1是否&gt;n2 n1 -le n2 # 检查n1是否&lt;=n2 n1 -lt n2 # 检查n1是否&lt;n2 n1 -ne n2 # 检查n1是否!=n2 test命令只能在比较中使用简单的 算术操作。双括号命令提供了更多的数学符号。请看后面内容。 字符串比较(有坑)123456str1 = str2 # 检查str1是否和str2相同 str1 != str2 # 检查str1是否和str2不同 str1 \\&lt; str2 # 检查str1是否比str2小，注意一定要转义str1 \\&gt; str2 # 检查str1是否比str2大，注意一定要转义-n str1 # 检查str1的长度是否非0-z str1 # 检查str1的长度是否为0，未在shell脚本中定义过，所以它的字符串长度仍然 为0 字符串长度比较 计算字符串的长度没有简单的方法。有很多种方法可以计算，但是我认为使用 expr（求值表达式）命令是相对最简单的一种。 1MyVar=\"How long is this?\" ; expr length \"$MyVar\" # 注意 mac 中并没有 length 这个命令 这里会出现经常困扰shell程序员的问题： 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名； 大于和小于顺序和sort命令所采用的不同 这是因为 比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort 命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺 序中小写字母出现在大写字母前。 未在shell脚本中定义过，-z认为它的字符串长度为0 字符串中有空格的情况处理 有些人从在文件名或者命令行参数中使用空格，你需要在编写脚本时时刻记得这件事。你需要时刻记得用引号包围变量。 if [ $filename = &quot;foo&quot; ]; 当$filename变量包含空格时就会挂掉。可以这样解决： if [ &quot;$filename&quot; = &quot;foo&quot; ]; 使用$@变量时，你也需要使用引号，因为空格隔开的两个参数会被解释成两个独立的部分。 文件比较 操作符 描述 -a filename 如果文件存在，返回真值；文件可以为空也可以有内容，但是只要它存在，就返回真值 -b filename 如果文件存在且是一个块设备，如 /dev/sda 或 /dev/sda1，则返回真值 -c filename 如果文件存在且是一个字符设备，如 /dev/TTY1，则返回真值 -d filename 如果文件存在且是一个目录，返回真值 -e filename 如果文件存在，返回真值；与上面的 -a 相同，可用于文件和目录 -f filename 如果文件存在且是一个一般文件，不是目录、设备文件或链接等的其他的文件，则返回 真值 -g filename 如果文件存在且 SETGID 标记被设置在其上，返回真值 -h filename 如果文件存在且是一个符号链接，则返回真值 -k filename 如果文件存在且粘滞位已设置，则返回真值 -p filename 如果文件存在且是一个命名的管道（FIFO），返回真值 -r filename 如果文件存在且有可读权限（它的可读位被设置），返回真值 -s filename 如果文件存在且大小大于 0，返回真值（存在并非空）；如果一个文件存在但大小为 0，则返回假值 -t fd 如果文件描述符 fd 被打开且被关联到一个终端设备上，返回真值 -u filename 如果文件存在且它的 SETUID 位被设置，返回真值 -w filename 如果文件存在且有可写权限，返回真值 -x filename 如果文件存在且有可执行权限，返回真值 -G filename 如果文件存在且文件的组 ID 与当前用户相同，返回真值 -L filename 如果文件存在且是一个符号链接，返回真值（同 -h） -N filename 如果文件存在且从文件上一次被读取后文件被修改过，返回真值 -O filename 如果文件存在且你是文件的拥有者，返回真值 -S filename 如果文件存在且文件是套接字，返回真值 在你尝试使用ef、-nt或 -ot比较文件之前，必须先确认文件是存在的。 file1 -ef file2 如果文件 file1 和文件 file2 指向同一设备的同一 INODE 号，返回真值（即硬链接） file1 -nt file2 如果文件 file1 比 file2 新（根据修改日期），或 file1 存在而 file2 不存在，返回真值 file1 -ot file2 如果文件 file1 比 file2 旧（根据修改日期），或 file1 不存在而 file2 存在 判断文件存在并不为空的脚本 1234567891011File=\"TestFile1\"echo \"This is $File\" &gt; $Fileif [ -s $File ] then echo \"$File exists and contains data.\"elif [ -e $File ] then echo \"$File exists and is empty.\"else echo \"$File does not exist.\"fi 其他杂项这些杂项操作符展示一个 shell 选项是否被设置，或一个 shell 变量是否有值，但是它不显示变量的值，只显示它是否有值。 操作符 描述 -o optname 如果一个 shell 选项 optname 是启用的（查看内建在 Bash 手册页中的 set -o 选项描述下面的选项列表），则返回真值 -v varname 如果 shell 变量 varname 被设置了值（被赋予了值），则返回真值 -R varname 如果一个 shell 变量 varname 被设置了值且是一个名字引用，则返回真值 https://linux.cn/article-11687-1.html 布尔逻辑123if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：  [ condition1 ] &amp;&amp; [ condition2 ] [ condition1 ] || [ condition2 ] 例子 12345678#!/bin/bash # testing compound comparisons # if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ] then echo \"The file exists and you can write to it\" else echo \"I cannot write to the file\" fi 双括号与双中括号(进阶)数字高级比较 （双括号）1(( expression )) 双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。但还是只支持整数 12345678910111213val++ # 后增 val-- # 后减++val # 先增--val # 先减! # 逻辑求反~ # 位求反** # 幂运算&lt;&lt; # 左位移 &gt;&gt; # 右位移&amp; # 位布尔和| # 位布尔或 &amp;&amp; # 逻辑和 || # 逻辑或 注意，不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性。 12345678910#!/bin/bash # using double parenthesis # val1=10 # if (( $val1 ** 2 &gt; 90 )) then (( val2 = $val1 ** 2 )) echo \"The square of $val1 is $val2\" fi 字符串高级比较（双中括号）1[[ expression ]] 不需要把变量名用双引号&quot;&quot;包围起来，即使变量是空值，也不会出错。 不需要、也不能对 &gt;、&lt; 进行转义，转义后反而会出错。 双方括号在bashshell中工作良好。不过要小心，不是所有的shell都支持双方括号。 逻辑运算对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来，例如： 1[ -z &quot;$str1&quot; ] || [ -z &quot;$str2&quot; ] 你也可以借助选项把多个表达式写在一个 test 命令中，例如： 1[ -z &quot;$str1&quot; -o -z &quot;$str2&quot; ] 但是，这两种写法都有点“别扭”，[[ ]] 支持在括号内直接使用 &amp;&amp;、|| 和 ! 三种逻辑运算符。 使用 [[ ]] 对上面的语句进行改进： 1[[ -z $str1 || -z $str2 ]] 这种写法就比较简洁漂亮了。注意，[[ ]] 剔除了 test 命令的-o和-a选项，你只能使用 || 和 &amp;&amp;。这意味着，你不能写成下面的形式： 1[[ -z $str1 -o -z $str2 ]] × 当然，使用逻辑运算符将多个 [[ ]] 连接起来依然是可以的，因为这是 Shell 本身提供的功能，跟 [[ ]] 或者 test 没有关系，如下所示： 1[[ -z $str1 ]] || [[ -z $str2 ]] [[ ]] 支持正则表达式在 Shell [[ ]] 中，可以使用=~ 12[[ str =~ regex ]]if [[ $tel =~ ^1[0-9]&#123;10&#125;$ ]] 有了 [[ ]]，你还有什么理由使用 test 或者 [ ]，[[ ]] 完全可以替代之，而且更加方便，更加强大。 但是 [[ ]] 对数字的比较仍然不友好，所以我建议，以后大家使用 if 判断条件时，用 (())来处理整型数字，用[[ ]] 来处理字符串或者文件。 swtich case12345678case variable in pattern1 | pattern2) commands1;; pattern3) commands2;; *) default_commands;; esac 例子： 1234567891011case $USER in rich | barbara) echo \"Welcome, $USER\" echo \"Please enjoy your visit\";; testing) echo \"Special testing account\";; jessica) echo \"Do not forget to log off when you're done\";; *) echo \"Sorry, you are not allowed here\";; esac forPython 风格 1234for var in list do $var commands done 或者 123for var in list; do $var commandsdone 类似于 python，执行到 for的时候，已经将数据加载到 list 中了，并不是每次加载一行，然后赋值给变量。list 的内容其实已经全部通过 IFS 分割然后加载进来了。 list是以空格分割的 例子： 1234for test in Alabama Alaska Arizona Arkansas California Colorado do echo \"The next state is $test\" done echo \"The last state we visited was $test\" 使用$var 获取列表中的值，for循环假定每个值都是用空格分割的。 如果有包含空格的数据值，就必须用双引号将这些值圈起来。或者查看【字段分隔符】章节的解决方案 list 中有引号的情况 123456789for test in I don't know if this'll work do echo \"word:$test\" done $ ./badtest1 word:I word:dont know if thisll word:work shell看到了列表值中的单引号并尝试使用它们来定义一个单独的数据值，这真是把事情搞得一团糟。 有两种办法可解决这个问题： 使用转义字符（反斜线）来将单引号转义； 使用双引号来定义用到单引号的值:&quot;this&#39;ll&quot; 1234for test in I don\\'t know if \"this'll\" work do echo \"word:$test\" done list添加 用&quot;进行拼接 12list=&quot;Alabama Alaska Arizona Arkansas Colorado&quot; list=$list&quot; Connecticut&quot; # 拼接 循环命令结果 使用命令替换符号可以对命令的结果进行循环 1for RPM in `rpm -qa | sort | uniq` ; do rpm -qi $RPM ; done 字段分隔符特殊的环境变量IFS，叫作内部字段分隔符（internal field separator）。 IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字 符当作字段分隔符： 空格 制表符 换行符 如果你想修改IFS的值，使其只能识别换行符，那就必须这么做：IFS=$&#39;\\n&#39; 指定多个IFS字符，只要将它们在赋值行串起来就行。IFS=$&#39;\\n&#39;:;&quot; ，这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。 一个可参考的安全实践是在改变 IFS 之前保存原 来的 IFS 值，之后再恢复它。 这种技术可以这样实现： IFS.OLD=$IFS IFS=$&#39;\\n&#39; &lt;在代码中使用新的IFS值&gt; IFS=$IFS.OLD 这就保证了在脚本的后续操作中使用的是 IFS 的默认值。 遍历目录目录名和文件名中包含空格当然是合法的。要适应这种情况，一种方法是将$file变量用双引号圈起来。 12345678910for file in /home/rich/test/* do if [ -d \"$file\" ] then echo \"$file is a directory\" elif [ -f \"$file\" ] then echo \"$file is a file\" fi done 另一种方法是指定IFS 典型的例子是处理/etc/passwd文件中的数据。这要求你逐行遍历/etc/passwd文件，并将IFS 变量的值改成冒号，这样就能分隔开每行中的各个数据段了。 12345678910111213#!/bin/bash # changing the IFS valueIFS.OLD=$IFS IFS=$'\\n' # 指定分隔符为换行for entry in $(cat /etc/passwd) # 这时数据已经通过\\n加载在list中了do echo \"Values in $entry –\" IFS=: # 指定为冒号，后面不用恢复成\\n，原因如上面的注释 for value in $entry do echo \" $value\" done done c语言风格的 for1for (( variable assignment ; condition ; iteration process )) 这与之前的 bash shell 标准有些不同 变量赋值可以有空格； 条件中的变量不以美元符开头； 迭代过程的算式未用expr命令格式； 12345678910111213#!/bin/bash # multiple variablesfor ((i=1; i&lt;=100; i ++))do echo $idonefor (( a=1, b=10; a &lt;= 10 &amp;&amp; b&gt;=5; a++, b-- )) do echo &quot;$a - $b&quot; done while 与 untilwhile命令的格式是： 1234while test_command do other commands done 例子1 12345while [ $var1 -gt 0 ]do echo $var1 var1=$[ $var1 - 1 ] done while命令允许你在while语句行定义多个测试命令： 每个测试命令都出现在单独的一行上。 只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。 在每次迭代中所有的测试命令都会被执行，包括测试命令失败的最后一次迭代。要留心这种用法。 1234567891011#!/bin/bash# multiple variablesvar1=10while echo $var1 echo “minglin2” # 可以有多条命令，但是测试命令只能一行一条 [ $var1 -ge 0 ]do echo \"This is inside the loop\" var1=$[ $var1 - 1 ]done until命令和while命令工作的方式完全相反，只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。其他的与 while 相同 break 与 continue默认 break 只跳出所在的最内层的循环。 有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值： break n其中n指定了要跳出的循环层级。 默认情况下，n为1，表明跳出的是当前的循环。如果你将 n设为2，break命令就会停止下一级的外部循环。 和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环： continue n其中n定义了要继续的循环层级。 默认情况下，n为1，表明当继续执行下一次循环。 例子：当 2&lt;a&lt;4时跳过循环 12345678910111213141516171819202122232425262728for (( a = 1; a &lt;= 5; a++ )) do echo \"Iteration $a:\" for (( b = 1; b &lt; 3; b++ )) do if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ] then continue 2 # 当 2&lt;a&lt;4时跳过循环 fi var3=$[ $a * $b ] echo \" The result of $a * $b is $var3\" donedone$ ./test22 Iteration 1: The result of 1 * 1 is 1 The result of 1 * 2 is 2 Iteration 2: The result of 2 * 1 is 2 The result of 2 * 2 is 4 Iteration 3: # 跳过了第 3 次Iteration 4: The result of 4 * 1 is 4 The result of 4 * 2 is 8 Iteration 5: The result of 5 * 1 is 5 The result of 5 * 2 is 10 循环的重定向你可以对循环的输出使用管道或进行重定向。这可以通过在关键字done之后添加&gt;或 |命令来实现。 重定向到文件 123456789for file in /home/rich/* do if [ -d \"$file\" ] then echo \"$file is a directory\" elif echo \"$file is a file\" fi done &gt; output.txt # 重定向到文件 从\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f文件中循环读取 123456789#!/bin/bash # process new user accountsinput=\"users.csv\" while IFS=',' read -r userid name do echo \"adding $userid\" useradd -c \"$name\" -m $userid done &lt; \"$input\"\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f\u001f ​ 函数所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 12345678# [ ] 中括号表示可选[ function ] funname [()]&#123; action; [return int;]&#125; 调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值 12345678910funWithParam()&#123; echo \"第一个参数为 $1 !\" echo \"第二个参数为 $2 !\" echo \"第十个参数为 $10 !\" echo \"第十个参数为 $&#123;10&#125; !\" echo \"第十一个参数为 $&#123;11&#125; !\" echo \"参数总数有 $# 个!\" echo \"作为一个字符串输出所有参数 $* !\"&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 Tips命令行参数位置参数变量是标准的数字：$0是程序名，$1是第 一个参数，$2是第二个参数，依次类推，直到第九个参数$9。 常用的转义字符4个最常用的转义字符如下所示。 反斜杠（\\）：使反斜杠后面的一个变量变为单纯的字符串。 单引号（’’）：全局转义，转义其中所有的变量为单纯的字符串。 双引号（””）：保留其中的变量属性，不进行转义处理。 反引号（）：把其中的命令执行后返回结果，等价于$(命令) 获取文件的绝对路径误区一 是使用 pwd 命令，print name of current/working directory 你可以试试 bash shell/a.sh，a.sh 内容是 pwd，你会发现，显示的是执行命令的路径 /home/june，并不是a.sh 所在路径：/home/june/shell/a.sh 误区二 $0，这个也是不对的，这个$0是Bash环境下的特殊变量，其真实含义是： 这个$0有可能是好几种值，跟调用的方式有关系： 使用一个文件调用bash，那$0的值，是那个文件的名字(没说是绝对路径噢) 使用-c选项启动bash的话，真正执行的命令会从一个字符串中读取，字符串后面如果还有别的参数的话，使用从$0开始的特殊变量引用(跟路径无关了) 除此以外，$0会被设置成调用bash的那个文件的名字(没说是绝对路径) 正确方法：dirname 配合 readlink dirname ：可以获取所在目录，输出已经去除了尾部的“/”字符部分的名称；如果名称中不包含“/”，则显示“.”(表示当前目录)。 取决于你传递给它的是不是绝对路径 readlink 可以获取文件的完整路径 最终形式： 1echo $(dirname $(readlink -f \"$0\")) 例子 下面对比下正确答案： 12345678910111213141516171819202122Jun@VAIO 192.168.1.216 23:52:54 ~ &gt;cat shell/a.sh#!/bin/bashecho &apos;$0: &apos;$0echo &quot;pwd: &quot;`pwd`echo &quot;=============================&quot;echo &quot;scriptPath1: &quot;$(cd `dirname $0`; pwd)echo &quot;scriptPath2: &quot;$(pwd)echo &quot;scriptPath3: &quot;$(dirname $(readlink -f $0))echo &quot;scriptPath4: &quot;$(cd $(dirname $&#123;BASH_SOURCE:-$0&#125;);pwd)echo -n &quot;scriptPath5: &quot; &amp;&amp; dirname $(readlink -f $&#123;BASH_SOURCE[0]&#125;)Jun@VAIO 192.168.1.216 23:53:17 ~ &gt;bash shell/a.sh$0: shell/a.shpwd: /home/Jun=============================scriptPath1: /home/Jun/shellscriptPath2: /home/JunscriptPath3: /home/Jun/shellscriptPath4: /home/Jun/shellscriptPath5: /home/Jun/shell 在此解释下 scriptPath1 ： dirname $0，取得当前执行的脚本文件的父目录 cd dirname $0，进入这个目录(切换当前工作目录) pwd，显示当前工作目录(cd执行后的) 由此，我们获得了当前正在执行的脚本的存放路径。 检查命令是否存在用 which 吗？最好不要用，因为很多操作系统的 which 命令没有设置退出状态码，这样你不知道是否是有那个命令。 123456789101112131415# POSIX 兼容:command -v [the_command] # bash 环境:hash [the_command]type [the_command] # 示例：gnudate() &#123; if hash gdate 2&gt; /dev/null; then gdate \"$@\" else date \"$@\" fi&#125; 路径中获取文件1234chengdan_file=\"dir/file.txt\"echo $chengdan_filefile_name=$&#123;chengdan_file##*/&#125; # 去除目录file_name=$&#123;file_name%%.*&#125; # 去除后缀 最佳实践1234567891011121314151617181920212223242526#!/usr/bin/env bash# Bash3 Boilerplate. Copyright (c) 2014, kvz.ioset -o errexitset -o pipefailset -o nounset# set -o xtrace# Set magic variables for current file &amp; dir__dir=\"$(cd \"$(dirname \"$&#123;BASH_SOURCE[0]&#125;\")\" &amp;&amp; pwd)\"__file=\"$&#123;__dir&#125;/$(basename \"$&#123;BASH_SOURCE[0]&#125;\")\"__base=\"$(basename $&#123;__file&#125; .sh)\"__root=\"$(cd \"$(dirname \"$&#123;__dir&#125;\")\" &amp;&amp; pwd)\" # &lt;-- change this as it depends on your apparg1=\"$&#123;1:-&#125;\"# 显示执行进展echo -e '##################################【第1步:xxx:开始】###################################################'echo -e '##################################【第1步:xxx:完成】###################################################\\n'# 对于耗时的任务，最好复用本地文件if [[ !-f $&#123;file&#125; ]];then sh xxx.shelse echo \"复用已存在的$&#123;file&#125;\"if 使用长的参数名，以便增加可读写，除非在命令行中简短的参数更快速 (logger --priority vs logger -p). set -o errexit (a.k.a set -e) 让脚本在运行出错时退出，而不会继续执行下去 set -o nounset (a.k.a. set -u)让脚本在使用了未声明变量时退出. set -o xtrace (a.k.a set -x) 用于 debug set -o pipefail 用于捕获管道命令的出错，比如捕获 mysqldump 的在mysqldump |gzip中出现的错误 #!/usr/bin/env bash 比 #!/bin/bash更有兼容性。 用{}括起你的变量 You don’t need two equal signs when checking if [ &quot;${NAME}&quot; = &quot;Kevin&quot; ]. TODO 在脚本的头部定义魔法变量、basename、目录等等。 参考:https://kvz.io/bash-best-practices.html","categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://jizx.vip/tags/shell/"}]},{"title":"python小模块","slug":"python小模块","date":"2019-08-06T09:39:47.000Z","updated":"2020-05-09T14:29:07.521Z","comments":true,"path":"2019/08/06/python小模块/","link":"","permalink":"https://jizx.vip/2019/08/06/python小模块/","excerpt":"记录Python常用的一些标准库，以及第三方库","text":"记录Python常用的一些标准库，以及第三方库 argpaseradd_argument说明 name=&quot;square&quot; 没有-前缀的verbose` 是位置参数 -a短参数，--arg为长参数，是可选参数，短参数与长参数可以放一起 help=&quot;参数说明&quot;， 参数的说明 type=int，指定参数类型 action=&quot;store_true&quot;，如果指定了参数就将True赋值给args.square，否则为False 默认需要提供value，--batch_size 2 store_true，可以不传值：--is_verbose count，当参数出现n次就赋值为n，比如-vvv时，就有v=3 choices=[0, 1, 2]，指定可以赋值的范围，与action=&quot;store_true&quot;不兼容 default=0，指定默认值，否则是None 添加参数位置参数 positional arguments 123456789import argparseparser = argparse.ArgumentParser()parser.add_argument(\"square\", help=\"display a square of a given number\", type=int)args = parser.parse_args()print(args.square**2)##################用法################python3 prog.py 416 可选参数 Optional arguments 123456789import argparseparser = argparse.ArgumentParser()parser.add_argument(\"--verbosity\", help=\"increase output verbosity\")args = parser.parse_args()if args.verbosity: print(\"verbosity turned on\")##################用法################python3 prog.py --verbosity 1verbosity turned on 默认情况，可选参数后面必须跟一个value，--verbosity any， 如果需要只是标志类型的参数，可以设置action=&quot;store_true&quot; 二者选其一参数使用add_mutually_exclusive_group可以实现两个参数只能设置其中一个的效果，比如想要设置打印日志为详细还是静默。 12345678910111213141516171819202122232425262728293031import argparseparser = argparse.ArgumentParser()group = parser.add_mutually_exclusive_group()group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")parser.add_argument(\"x\", type=int, help=\"the base\")parser.add_argument(\"y\", type=int, help=\"the exponent\")args = parser.parse_args()answer = args.x**args.yif args.quiet: print(answer)elif args.verbose: print(\"&#123;&#125; to the power &#123;&#125; equals &#123;&#125;\".format(args.x, args.y, answer))else: print(\"&#123;&#125;^&#123;&#125; == &#123;&#125;\".format(args.x, args.y, answer)) ##################使用###############$ python3 prog.py 4 24^2 == 16$ python3 prog.py 4 2 -q16$ python3 prog.py 4 2 -v4 to the power 2 equals 16$ python3 prog.py 4 2 -vqusage: prog.py [-h] [-v | -q] x yprog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose$ python3 prog.py 4 2 -v --quietusage: prog.py [-h] [-v | -q] x yprog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose 最佳实践1234567891011121314151617181920import argparsedef paser_arg(): \"\"\" 参数解析，以及默认参数设置 :return: \"\"\" parser = argparse.ArgumentParser(description=\"说明该模块的功能\") add = parser.add_argument #将该函数赋值给add，方便后面定义参数 add(\"--verbose\",help=\"是否显示详细日志内容\") return parser.parse_args()if \"__main__\" == __name__: options = paser_arg() if options.verbose: print(\"verbose print\") else: print(\"no verbose print\") 参考：官方argpaser profile 性能分析1234567891011121314151617181920212223242526272829303132from profile import Profilefrom pstats import Statsdef gcd(pair): \"\"\" 计算最大公约数 \"\"\" a, b = pair low = min(a, b) for i in range(low, 0, -1): if a % i == 0 and b % i == 0: return idef main(n): \"\"\" 被测试的函数 \"\"\" i = 0 while i&lt;n: gcd((1963309, 2265973)) i+=1p = Profile()p.runcall(main, 100) # 函数，以及参数# p.print_stats() # 可以直接打印报告# 使用stats可以更加自由的定义打印的报告内容stats = Stats(p)stats.strip_dirs()stats.sort_stats('cumulative')stats.print_stats() stats.print_callers() # 打印每个函数的调用者 12345678910111213141516171819202122&gt; 203 function calls in 22.478 seconds&gt; &gt; Ordered by: standard name&gt; &gt; ncalls tottime percall cumtime percall filename:lineno(function)&gt; 100 0.001 0.000 0.001 0.000 :0(min)&gt; 1 0.000 0.000 0.000 0.000 :0(setprofile)&gt; 1 0.001 0.001 22.477 22.477 &lt;ipython-input-13-1e3e5803ef86&gt;:13(main)&gt; 100 22.476 0.225 22.476 0.225 &lt;ipython-input-13-1e3e5803ef86&gt;:3(gcd)&gt; 1 0.000 0.000 22.478 22.478 profile:0(&lt;function main at 0x107c720d0&gt;)&gt; 0 0.000 0.000 profile:0(profiler)&gt; &gt; Ordered by: cumulative time&gt; &gt; Function was called by...&gt; profile:0(&lt;function main at 0x107dffbf8&gt;) &lt;- profile:0(profiler)(1) 0.000&gt; &lt;ipython-input-21-c6df0a564b27&gt;:13(main) &lt;- profile:0(&lt;function main at 0x107dffbf8&gt;)(1) 22.548&gt; &lt;ipython-input-21-c6df0a564b27&gt;:3(gcd) &lt;- &lt;ipython-input-21-c6df0a564b27&gt;:13(main)(100) 22.547&gt; :0(min) &lt;- &lt;ipython-input-21-c6df0a564b27&gt;:3(gcd)(100) 22.546&gt; :0(setprofile) &lt;- profile:0(&lt;function main at 0x107dffbf8&gt;)(1) 22.548&gt; profile:0(profiler) &lt;- &gt; 报告说明： ncalls：该函数表调用的次数 cumtime：执行该函数的所花的时间，含函数内调用其他函数的时间 tottime：执行该函数的所花的时间，s函数内调用其他函数的时间 percall：平均每次调用消耗的时间 pickleThe pickle module 实现了二进制协议，用于serializing 和 de-serializing Python object structure 并保存到磁盘中，并在需要的时候读取出来，任何对象（lambda除外）都可以执行序列化操作。 Pickle模块中最常用的函数为： 保存为文件 dump(obj, file, [,protocol]) 功能：将obj对象序列化存入已经打开的file中。 obj: 想要序列化的obj对象。 file: file对象 protocol: 序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 123with open('data.pickle', 'wb') as file: # 使用 highest protocol Pickle the 'data' dictionary pickle.dump(data, file, pickle.HIGHEST_PROTOCOL) load(file) 功能：将file中的对象反序列化读出。 123with open('data.pickle', 'rb') as file: # protocol版本会自动检测，不要指定 data = pickle.load(file) 因为pickle是使用二进制保存文件，因此open的读写模式，要使用‘b’ 保存为string dumps(obj [, protocol]) 功能：将obj对象序列化为string形式，而不是存入文件中。 obj：想要序列化的obj对象。 protocol：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 loads(string) 函数的功能：从string中读出序列化前的obj对象。 string：pickle序列化后的字符串对象 123456789101112131415import pickle# dumpsli = [11,22,33]r = pickle.dumps(li)print(r)#(lp0# I11# aI22# aI33# a.# loadsresult = pickle.loads(r)print(result)# [11, 22, 33] 对函数、类、接口序列号pickle 可以序列化函数，类，还有接口，但是结果数据仅仅将它们的名称编码成对应的代码对象。例如： 1234import mathimport pickle.pickle.dumps(math.cos)# b&apos;\\x80\\x03cmath\\ncos\\nq\\x00.&apos; 当数据反序列化回来的时候，会先假定所有的源数据时可用的。 模块、类和函数会自动按需导入进来。对于Python数据被不同机器上的解析器所共享的应用程序而言， 数据的保存可能会有问题，因为所有的机器都必须访问同一个源代码。 安全问题千万不要对不信任的数据使用pickle.load()。pickle在加载时有一个副作用就是它会自动加载相应模块并构造实例对象。但是某个坏人如果知道pickle的工作原理，他就可以创建一个恶意的数据导致Python执行随意指定的系统命令。因此，一定要保证pickle只在相互之间可以认证对方的解析器的内部使用。 rere字符串查找 re.match：查找字符串中是否有”从头开始”匹配的非空子串，返回match对象 re.search：查找字符串中是否有匹配的非空子串，返回第一个匹配成功的match对象 re.finditer：查找字符串中所有满足正则表达式的子串，返回全部match对象的数组 12345678import res=\"she said: \\\"I love you\\\",and he replied 'me,too'\"ms=re.finditer(r\"(?P&lt;quote&gt;['\\\"]).*?(?P=quote)\",s)for m in ms: print(m.group(0))# \"I love you\"# 'me,too' re.fullmatch：判断是否”整个字符串”满足正则表达式 re.findall：查找所有满足正则表达式的子串，返回全部子串的数组 字符串替换 re.sub 函数调用：text = sub(pattern,repl,string,count) pattern ： 正则中的模式字符串 repl ： 替换的字符串，sub() 函数除了接受替换字符串外，还能接受一个回调函数，(参数必须是 match 对象) string：要被查找替换的原始字符串 count ： 模式匹配后替换的最大次数，默认 0 表示替换 全部的匹配 re.subn 函数调用：`newtext, n = re.subn()` ，`n`表示发生了多少次替换 字符串分割re.split字符串分割，返回分割后的数组。注意括号的区别 123456import reres=re.split(\"\\|\" , ' runoob|runoob|runoob.')# [' runoob', 'runoob', 'runoob.']res=re.split(\"(\\|)\" , ' runoob|runoob|runoob.') # 添加括号，会保留分割符# [' runoob', '|', 'runoob', '|', 'runoob.'] pattern为了重复利用正则表达式，将表达式编译好，保存在pattern中，用法与re的方法基本一致。pattern = re.compile(“d”)pattern.search(“dog”) Matchgroup([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group))。 时间注意：datetime 类型是不可变对象 1234567891011121314151617181920212223242526272829303132from datetime import datetime# 构造datetime对象，参数代表：year,month,day,hour,minute,secondt = datetime(2019, 8, 6, 22, 30, 44)# 获取当前时间（日期+时间点）t = datetime.now()print(t)# 获取datetime对象中的日期print(t.date())# 获取datetime对象中的时间print(t.time())# 分别获取datetime对象中的属性print(t.year)print(t.month)print(t.day)# datetime对象 -&gt; 字符串print(t.strftime(\"%Y-%m-%d %H:%M:%S\"))# 字符串 -&gt; datetime对象print(datetime.strptime(\"2019-08-06\", \"%Y-%m-%d\")) # 第2个参数表示如何解析前面的字符串# 字符串 -&gt; 另一格式的字符串time_ = datetime.strptime('20200420', \"%Y%m%d\")print(time_.strftime('%Y-%m-%d %H:%M:%S'))# 修改(产生新对象,因为t不可变)b = t.replace(minute=50, second=30) 获取当前时间注意：datetime 下的 time 与 time 模块不同 123456789101112import timeprint(time.time())# 返回的UTC时间，是从1970.1.1到现在的秒数print(time.ctime(time.time())) # 接收一个以秒为单位的时间，然后转换成本地时间的字符串表示。print(time.strftime(\"%Y-%m-%d %H:%M:%S\"))from datetime import datetimeprint(datetime.now())# 1565268398.010132# Thu Aug 8 20:46:38 2019# 2019-08-08 20:46:38# 2019-08-08 20:46:38.010703 时间的运算datetime 只能相减，得到 tiemdelta 对象：datetime.timedelta(m, n)表示相差m天n秒 tiemdelta可以相加减，也可以与datetime 相加减得到新的 datetime 格式化字符串 %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %F %Y-%m-%d的简写（2019-08-06） %D %m/%d/%y的简写（08/06/19） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %z UTC 时区偏置，格式为+HHMM或-HHMM；如果是简单时区则为空 %Z 当前时区的名称 %% %号本身 tqdmhttps://pypi.org/project/tqdm/#parameters 1tqdm(self, iterable=None, desc=None, total=None, leave=True,file=None, ncols=None, mininterval=0.1,maxinterval=10.0, miniters=None, ascii=None, disable=False,unit='it', unit_scale=False, dynamic_ncols=False,smoothing=0.3, bar_format=None, initial=0, position=None,postfix=None, unit_divisor=1000): desc：progressbar的前缀 leave : 默认True，结束后保留进度条 ascii：默认 False，如果True，进度条将以“123456789#”显示，而不是实线 ncols：整个消息的长度 设置提示消息 1234pbar = tqdm([\"a\", \"b\", \"c\", \"d\"])for char in pbar: time.sleep(0.25) pbar.set_description(\"Processing %s\" % char) 手动控制 1234with tqdm(total=100) as pbar: for i in range(10): time.sleep(0.1) pbar.update(10) # 每次进度增加10 tqdm读取文件 123456789from tqdm import tqdmimport codecs as cswith tqdm(cs.open(\"1.txt\"),desc = \"status: \") as pbar: for i in pbar: b+=1 if b % 1000 == 0: pbar.update(1000)print b 多重进度条 除了 tqdm 构造函数之外，还有下面的构造函数可以用 ​123456789101112131415161718class tqdm(xrange(*args), **kwargs)def trange(*args, **kwargs): \"\"\" A shortcut for tqdm(xrange(*args), **kwargs). On Python3+ range is used instead of xrange. \"\"\"class tqdm_gui(tqdm):def tgrange(*args, **kwargs): \"\"\" Experimental GUI version of trange! \"\"\"def tnrange(*args, **kwargs): class tqdm_notebook(tqdm): \"\"\" Experimental IPython/Jupyter Notebook widget using tqdm! \"\"\" sys用来处理Python运行时配置以及资源，从而可以与前当程序之外的系统环境交互，如：Python解释器。 123456789101112131415161718192021222324252627sys.argv #命令行参数List，第一个元素是程序本身路径 sys.modules.keys() #返回所有已经导入的模块列表 sys.exc_info() #获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息 sys.exit(n) #程序，正常退出时exit(0) sys.hexversion #获取Python解释程序的版本值，16进制格式如：0x020403F0 sys.version #获取Python解释程序的版本信息 sys.maxint #最大的Int值 sys.maxunicode #最大的Unicode值 sys.modules #返回系统导入的模块字段，key是模块名，value是模块 sys.path #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform #返回操作系统平台名称 sys.stdout #标准输出 sys.stdin #标准输入 sys.stderr #错误输出 sys.exc_clear() #用来清除当前线程所出现的当前的或最近的错误信息 sys.exec_prefix #返回平台独立的python文件安装的位置 sys.byteorder #本地字节规则的指示器，big-endian平台的值是&apos;big&apos;,little-endian平台的值是&apos;little&apos; sys.copyright #记录python版权相关的东西 sys.api_version #解释器的C的API版本 sys.version_info #获取Python解释器的版本信息 sys.getwindowsversion #获取Windows的版本sys.getdefaultencoding #返回当前你所用的默认的字符编码格式sys.getfilesystemencoding #返回将Unicode文件名转换成系统文件名的编码的名字sys.setdefaultencoding(name) #用来设置当前默认的字符编码sys.builtin_module_names #Python解释器导入的模块列表 sys.executable #Python解释程序路径 sys.stdin.readline #从标准输入读一行，sys.stdout.write(&quot;a&quot;) 屏幕输出a os文件操作12os.remove() #删除文件 os.rename() #重命名文件 目录操作12345os.chdir() #改变目录 os.mkdir/makedirs() #创建目录/多层目录 os.rmdir/removedirs #删除目录/多层目录 os.listdir() #列出目录下的文件名(不递归)os.walk() #列出目录下的所有文件名(递归) os.mkdir 与os.makedirs的差别在于 os.makedirs 会递归地去建立目录，也就是说连同中继的目录也会一起建立，就类似于 Linux 中的 mkdir -p． 123456&gt;&gt;&gt; import os&gt;&gt;&gt; os.mkdir(&apos;foo/bar&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;OSError: [Errno 2] No such file or directory: &apos;foo/bar&apos;&gt;&gt;&gt; os.makedirs(&apos;foo/bar&apos;) 使用 os.mkdir时，如果你给定的 path 参数是个多层的 path，如果某个中继的目录不存在(比如说上例中的 foo), Python 将会报错． 但如果使用 os.makedirs 则 Python 会连同中间的目录一起建立．但有一点值得注意，当 path 末端的目录已经存在的话，os.makedirs 也是会引发例外． os.pathhttps://docs.python.org/3/library/os.path.html#os.path.dirname os模块包含普遍的操作系统功能。如果你希望你的程序能够与平台无关的话，这个模块是尤为重要的。 路径操作12345678910111213141516171819202122232425262728293031323334os.getcwd() # 取得当前工作目录 os.path.abspath(path) # 获取文件、目录的绝对路径os.path.basename() # 文件名 ，去掉目录路径os.path.dirname() # 目录路径 ，去掉文件名# dirname 与 basename 组成完整的文件路径(绝对、相对路径都可以)os.path.join() # 将分离的各部分组合成一个路径名 os.path.split(path) # 返回(dirname(),basename())元组 # 将路径名*path*分割为(head, tail) ， *tail* 路径名的最后部分，绝对不包含分隔符(/) *head* 是 tail 之前的路径。如果*path* 以(/) 结尾, 那么*tail* 为空 os.path.splitdrive(path)# 返回(盘符、远程地址,路径)元组os.path.splitext(path) # 返回(剩余部分,扩展名)元组os.path.commonpath(paths) #返回公共的父节点路径(有效路径)os.path.commonprefix(list) #返回公共的路径前缀(字符串匹配，不一定是有效路径)# commonprefix(['/usr/lib', '/usr/local/lib'])# '/usr/l'# commonpath(['/usr/lib', '/usr/local/lib'])# '/usr'os.path.realpath(path) #返回真实路径,消除符号链接，类似于abspathos.path.relpath(path, start=os.curdir) #返回相对于指定的start的相对路径，默认是当前目录os.path.exists(path) 如果path存在，返回True；如果path不存在，返回False。os.path.isabs(path) 如果path是绝对路径，返回True。os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False。os.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回False。os.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。os.path.normcase(path) 在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。 os.path.normpath(path) 规范化路径。os.path.expanduser(path)# 将路径中的~转义为真实的home目录地址，否则不做变化os.path.expandvars(path)# 将路径中的环境变量转义为真实的值，否则不做变化 os.path.normcase(path) 返回大小写正常化后的路径名。 对于 Mac、Unix，该操作没有效果（他们对a.txt,A.txt视为同一名称） 对于不区分大小写的文件系统，会将路径转为小写； 对于 window，前向斜杆\\ 会转为后向斜杆/ 文件判断123456789os.path.getatime\\ctime\\mtime # 分别返回最近访问、创建、修改时间 os.path.isfile(path) # 是否为文件os.path.isdir(path) # 是否为目录os.path.getsize() # 返回文件大小 os.path.exists(path) # 是否存在 os.path.isabs() # 是否为绝对路径 os.path.islink() # 判断是否为连接符号，获取真实路径请看上面的realpath函数os.path.samefile(path1, path2) # 是否是同一个文件os.path.sameopenfile(fp1, fp2) # 是否指向同一个文件 configparser12345678910111213141516171819202122232425import configparserimport os#实例化ConfigParsercf = configparser.ConfigParser()#获取当前的绝对路径current_path = os.path.abspath(__file__)#当前文件的目录now_cig = os.path.dirname(current_path)#拼接配置文件路径con_cig = os.path.join(now_cig + &quot;/config/config.ini&quot;)#读取配置文件cf.read(con_cig)#打印配置文件里面section名为&quot;people&quot;里面的optionsprint(cf.options(section=&apos;people&apos;))#打印配置文件里面section里面的某个potions的valueprint(cf.get(&apos;people&apos;,&apos;name&apos;))#加添sectioncf.add_section(&apos;cc&apos;)#设置指定section的key=valuecf.set(&apos;cc&apos;,&apos;aa&apos;,&apos;bb&apos;)print(cf.options(section=&apos;cc&apos;)) shutilhttps://docs.python.org/3/library/shutil.html#shutil.disk_usage 从文件对象拷贝copyfileobj(fsrc, fdst[, length]) 123# with 可以同时 支持 多个上下文管理器with open(\"./1.txt\",encoding='utf8') as f1, open('./2,txt','w',encoding='utf8') as f2: su.copyfileobj(f1,f2) 文件操作复制copyfile(src, dst, *, follow_symlinks=True) 从 src复制的文件内容到 dst 文件中，只复制内容，不包含元数据 dst 必须是目标文件名，而不是目录 copy(src, dst, *, follow_symlinks=True*) 复制文件数据、权限数据；其他的元数据（创建时间、修改时间）没有保留 dst允许是目录，或者文件名 copy2(src, dst, *, follow_symlinks=True) 与 copy 一样，除了会尽量保存文件的元数据 移动(文件/目录)move(src, dst, copy_function=copy2) 将文件或者目录复制到 dst 目录操作复制copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False) 将递归地将整个目录文件复制到 dst，dst 必须不存在 例子：跳过指定的文件 123from shutil import copytree, ignore_patternscopytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*')) 利用 ignore 进行日志记录功能 12345678from shutil import copytreeimport loggingdef _logpath(path, names): logging.info('Working in %s', path) return [] # nothing will be ignoredcopytree(source, destination, ignore=_logpath) 移动参考 move 删除rmtree(path, ignore_errors=False, onerror=None) 删除整个目录，path 必须指向目录 (不可以是指向目录的符号链接). 例子：处理只读的文件，尝试删除 123456789import os, statimport shutildef remove_readonly(func, path, _): \"清除 readonly bit 并重新尝试删除\" os.chmod(path, stat.S_IWRITE) func(path)shutil.rmtree(directory, onerror=remove_readonly) ignore_patternsThis factory function creates a function that can be used as a callable for copytree()’s ignore argument, ignoring files and directories that match one of the glob-style patternsprovided. 文件状态操作复制文件权限copymode(src, dst, *, follow_symlinks=True) 从 src 复制 permission bits 到 dst。文件内容、拥有者、组都不受影响 复制文件状态copystat(src, dst, *, follow_symlinks=True) 从 src 复制 permission bits、 last access time、last modification time、 flags 到 dst. 在 linux 中，还会尝试复制 “extended attributes” 文件内容、拥有者、组都不受影响 chownchown(path, user=None, group=None) 修改 path 的用户或者组 其他磁盘使用情况disk_usage(path) 返回磁盘的使用情况统计结果元组：total, used, free, 单位是 bytes. whichwhich(cmd, mode=os.F_OK | os.X_OK, path=None) 查看命令的执行程序名称 12shutil.which(\"python\")# '/Users/jizhongxian/anaconda3/bin/python' Archiving operations(压缩包操作)用到再看 https://docs.python.org/3/library/shutil.html#archiving-operations globglob 规则：http://www.man7.org/linux/man-pages/man7/glob.7.html 最常用的通配符是 *、?、[] 通配符 描述 例子 匹配 不匹配 * 匹配任意数量的字符包括空字符 Law* Law, Laws, or Lawyer *Law* Law, GrokLaw, or Lawyer. ? 匹配任意一个字符 ?at Cat, cat, Bat or bat at [abc] 匹配任意一个包含的字符 [CB]at Cat or Bat cat or bat [a-z] 匹配任意一个给定范围的字符 Letter[0-9] Letter0, Letter1 etc. Letters or Letter ** 匹配任意的目录(包括当前目录) */\\.js ss.js, a/hh.js, a/b/c.js 在Linux和POSIX系统中[…]的扩展 通配符 描述 例子 匹配 不匹配 [!abc] 不匹配任意一个包含的字符 [!C]at Bat, bat, or cat Cat [!a-z] 不匹配任意一个给定范围的字符 Letter[!3-5] Letter1, Letter2 etc. Letter3, Letter4 or Letter5 与正则的比较： Glob的通配符 等价正则的表达式 ? . * .* 注意事项 Glob尝试匹配整个字符串，而不是片段。S*.DOC将匹配S.DOC和SA.DOC，但不匹配POST.DOC或SURREY.DOCKS，正则只匹配子串除非使用^ 和$。所以S*.DOC的等价正则是^S.*\\.DOC$。 路径分隔符（unix的/，windows的\\）不会被? *匹配。如果要匹配，需要用**匹配任意层级的目录(包括当前目录) **/*.js ==&gt; a/b/c.js [^...]是无效的 .开头的文件被 glob 视为特殊的文件，*匹配不到他，需要显式处理 12345&gt;&gt;&gt; import glob&gt;&gt;&gt; glob.glob('*.gif')['card.gif']&gt;&gt;&gt; glob.glob('.c*') #显式地指定.['.card.gif'] glob1glob.glob(pathname, *, recursive=False) 返回符合 pathname 模式的路径列表，recursive会递归地查找 1234567891011import globglob.glob('./[0-9].*')# ['./1.gif', './2.txt']glob.glob('*.gif')# ['1.gif', 'card.gif']glob.glob('?.gif')# ['1.gif']glob.glob('**/*.txt', recursive=True)# ['2.txt', 'sub/3.txt']glob.glob('./**/', recursive=True)# ['./', './sub/'] iglob1glob.iglob(pathname, *, recursive=False) 与 glob 作用相同，只不过返回的一个迭代器 escape1glob.escape(pathname) 转义所有的字符(&#39;?&#39;, &#39;*&#39; and &#39;[&#39;)。 比如escape(&#39;//?/c:/Quo vadis?.txt&#39;) 返回 &#39;//?/c:/Quovadis[?].txt&#39;. fnmatch Pattern Meaning * matches everything ? matches any single character [seq] matches any character in seq [!seq] matches any character not in seq (&#39;/&#39; on Unix) .开头的文件，不是特殊文件 fnmatch fnmatch.fnmatch(filename, pattern) 测试 filename 是否匹配 pattern 字符串, 参数都是用 os.path.normcase()规范过了。 fnmatchcase() 用于 大小写敏感的比较, 不论那是否是该操作系统的标准 123456import fnmatchimport osfor file in os.listdir('.'): if fnmatch.fnmatch(file, '*.txt'): print(file) fnmatchcase fnmatch.fnmatchcase(filename, pattern)大小写敏感的比较，函数中不使用os.path.normcase(). filter fnmatch.filter(names, pattern)返回列表 names 中符合 pattern 的子列表，等价于 [n for n in namesif fnmatch(n, pattern)], 但内部更进行了高效地实现。 translate fnmatch.translate(pattern)将 shell-风格的 pattern 转为正则表达式 re.match().12345678import fnmatch, reregex = fnmatch.translate('*.txt')print(regex)# '(?s:.*\\\\.txt)\\\\Z'reobj = re.compile(regex)reobj.match('foobar.txt')# &lt;re.Match object; span=(0, 10), match='foobar.txt'&gt;","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"工具","slug":"工具","permalink":"https://jizx.vip/tags/工具/"},{"name":"模块","slug":"模块","permalink":"https://jizx.vip/tags/模块/"}]},{"title":"python模块-logging","slug":"python模块-logging","date":"2019-08-06T06:32:08.000Z","updated":"2020-07-14T01:31:58.683Z","comments":true,"path":"2019/08/06/python模块-logging/","link":"","permalink":"https://jizx.vip/2019/08/06/python模块-logging/","excerpt":"python logging 模块的使用以及详细讲解","text":"python logging 模块的使用以及详细讲解 日志级别logging模块定义了以下几个日志等级，它允许开发人员自定义其他日志级别，但是这是不被推荐的，尤其是在开发供别人使用的库时，因为这会导致日志级别的混乱。 日志等级（level） 描述 DEBUG 最详细的日志信息，典型应用场景是 问题诊断 INFO 信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作 WARNING 当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的 ERROR 由于一个更严重的问题导致某些功能不能正常运行时记录的信息 CRITICAL 当发生严重错误，导致应用程序不能继续运行时记录的信息 默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG）而日志的信息量是依次增多的； 开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试； 简单使用logging模块提供了两种记录日志的方式： 第一种方式是使用logging提供的模块级别的函数 第二种方式是使用Logging日志系统的四大组件 首先来看一下第一种，通过logging提供的模块级别的函数进行日志记录。 logging模块定义的模块级别的常用函数 函数 说明 logging.debug(msg, *args, **kwargs) 创建一条严重级别为DEBUG的日志记录 logging.info(msg, *args, **kwargs) 创建一条严重级别为INFO的日志记录 logging.warning(msg, *args, **kwargs) 创建一条严重级别为WARNING的日志记录 logging.error(msg, *args, **kwargs) 创建一条严重级别为ERROR的日志记录 logging.critical(msg, *args, **kwargs) 创建一条严重级别为CRITICAL的日志记录 logging.log(level, *args, **kwargs) 创建一条严重级别为level的日志记录 logging.basicConfig(**kwargs) 对root logger进行一次性配置 其中logging.basicConfig(**kwargs)函数用于指定“要记录的日志级别”、“日志格式”、“日志输出位置”、“日志文件的打开模式”等信息，其他几个都是用于记录各个级别日志的函数。 具体例子： 1234567891011121314import logginglogging.basicConfig(level=logging.DEBUG,# 控制台打印的日志级别 # filename='new.log', # 注释掉当前行即可打印到控制台 filemode='w',# 写模式：a和w，w就是写模式，a是追加模式，默认是追加模式 format= '%(asctime)s - %(pathname)s[line:%(lineno)d] - %(name)s - %(levelname)s: %(message)s', # 日志格式 datefmt='%Y-%m-%d %H:%M:%S %a ' # 日期格式 )logging.debug(\"info\")logging.info(\"info\")logging.warning(\"warning\")logging.error(\"error\")logging.critical(\"critical\") 自定义屏幕输出的logger。如果想在不同文件中使用不同 logger，就需要创建一个新的 logger。 1234567import logginglogger = logging.getLogger('name') # 创建loggerlogger.setLevel(logging.DEBUG) # 设置等级std_err = logging.StreamHandler() # 创建handlerstd_err.setFormatter(logging.Formatter(\"%(name)s:%(asctime)s-%(levelname)s: %(message)s\")) # handler定义输出格式logger.addHandler(std_err) # 将handler添加到logger 关于 basicConfig 说明主要的配置是通过basicConfig来定制的： 参数 描述 level 指定日志器的日志级别，默认是 WARNING 级别，因此 DEBUG、INFO 都不会输出 filename 指定日志输出目标文件的文件名（可以写文件名也可以写文件的完整的绝对路径，写文件名日志放执行文件目录下，写完整路径按照完整路径生成日志文件），指定该设置项后日志信息就不会被输出到控制台了，如果需要同时显示，请看后面的组件用法。 filemode 指定日志文件的打开模式，默认为a,追加的方式，该选项要在filename指定时才有效 stream 指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常 handlers Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段请看Formater一节 datefmt 指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效 style Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为’%’、’{‘和’$’，默认为’%’ 注意点： logging.basicConfig()函数是一个一次性的简单配置工具使，也就是说只有在第一次调用该函数时会起作用，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作。 日志器（Logger）是有层级关系的，上面调用的logging模块级别的函数所使用的日志器是RootLogger类的实例，其名称为’root’，它是处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的。 如果要记录的日志中包含变量数据，可使用一个格式字符串作为这个事件的描述消息（logging.debug、logging.info等函数的第一个参数），然后将变量数据作为第二个参数*args的值进行传递，如下:12logging.warning('%s is %d years old.', 'Tom', 10)# WARNING:root:Tom is 10 years old. 其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已。这里其实创建了一个 名为root的日志器组件，是一个默认的、单例的 logger 组件。接下来我们看一下第二种。 Logging 组件Logging 组件介绍logging模块就是通过下面这些组件来完成日志处理的，上面所使用的logging模块级别的函数也是通过这些组件对应的类来实现的。 在介绍logging模块的日志处理流程之前，我们先来介绍下logging模块的四大组件： 组件名称 对应类名 功能描述 日志器 Logger 提供了应用程序可一直使用的接口 处理器 Handler 将logger创建的日志记录发送到合适的目的输出 过滤器 Filter 提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录 格式器 Formatter 决定日志记录的最终输出格式 它们之间的合作关系如下： 日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等； 不同的处理器（handler）可以将日志输出到不同的位置； 日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置； 每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志； 每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。 简单点说就是：logger是入口，真正干活儿的是handler，handler还可以通过filter和formatter对要输出的日志内容做过滤和格式化等处理操作。 日志流处理流程 创建一个logger 设置下logger的日志的等级（通过setLevel） 创建合适的Handler(FileHandler要有路径) 设置下每个Handler的日志等级（通过setLevel） 创建下日志的格式Formater 向Handler中添加上面创建的Formater 将上面创建的Handler注册到logger中 打印输出logger.debug\\logger.info\\logger.warning\\logger.error\\logger.critical 为什么会有两个setLevel()方法？logger 的级别决定了消息是否要传递给处理器。每个handler的级别决定了消息是否要分发到指定目标 从“简单使用”一节中我们了解到了logging.debug()、logging.info()等函数分别用以记录不同级别的日志信息 ，logging.basicConfig()用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到 root logger 中。 接下来就按照上面的流程来介绍高级的用法，来满足各种需求。 logger日志器的获取如何获取一个Logger对象呢？ 通过Logger类的实例化方法创建一个Logger类的实例， 但是我们通常都是用第二种方式：logging.getLogger(&#39;name&#39;)方法。 logging.getLogger(&#39;name&#39;)方法有一个可选参数name，该参数表示将要返回的日志器的名称标识， 默认为root。若以相同的name参数值多次调用getLogger()方法，将会返回指向同一个logger对象的引用。 初始的logger是没有handler的，因此无法无法打印日志，需要配置handler后才能使用。 日志器的继承 logger的名称是以.分割的层级结构，每个.后面的logger都是.前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 foo.bar, foo.bar.baz 和 foo.bam都是 foo 的后代。 logger有一个”有效等级（effective level）”的概念。如果一个logger上没有被明确设置一个level，那么该logger就使用它parent的level。如果它的parent也没有明确设置level，则继续向上查找parent的parent的有效level，依次类推，直到找到个一个明确设置了level的祖先为止。需要说明的是，root logger总是会有一个明确的level设置（默认为 WARNING）。当决定是否去处理一个已发生的事件时，logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理。 child loggers在完成对日志消息的处理后，默认会将日志消息传递给与它们的祖先loggers相关的handlers。因此，我们不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。 handlerHandler对象的作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）。Logger对象可以通过addHandler()方法为自己添加0个或者更多个handler对象。比如，一个应用程序可能想要实现以下几个日志需求： 1）把所有日志都发送到一个日志文件中； 2）把所有严重级别大于等于error的日志发送到stdout（标准输出）； 3）把所有严重级别为critical的日志发送到一个email邮件地址。这种场景就需要3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置。 1234fh = logging.FileHandler(\"jizx_log.txt\",encoding=\"utf-8\") # 创建一个文件 handler 用于注册到 logger 中Handler.setLevel(lel):指定被处理的信息级别，低于lel级别的信息将被忽略Handler.setFormatter()：给这个handler选择一个格式Handler.addFilter(filt)、Handler.removeFilter(filt)：新增或删除一个filter对象 应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了素有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些常用的Handler： Handler 描述 logging.StreamHandler([strm]) 将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。默认是sys.stderr logging.FileHandler(filename[,mode]) 将日志消息发送到磁盘文件，默认mode是a,文件大小会无限增长。还可是w logging.handlers.RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]]) 将日志消息发送到磁盘文件，并支持日志文件按大小切割。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。 logging.hanlders.TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]]) 将日志消息发送到磁盘文件，并支持日志文件按时间切割。interval是时间间隔。when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：S 秒、M 分、H 小时、D 天、W 每星期（interval==0时代表星期一）、midnight 每天凌晨 logging.handlers.HTTPHandler 将日志消息以GET或POST的方式发送给一个HTTP服务器 logging.handlers.SMTPHandler 将日志消息发送给一个指定的email地址 logging.NullHandler 该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免’No handlers could be found for logger XXX’信息的出现。 formaterFormater对象用于配置日志信息的最终顺序、结构和内容。与logging.Handler基类不同的是，应用代码可以直接实例化Formatter类。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。 Formatter类的构造方法定义如下： 1logging.Formatter.__init__(fmt=None, datefmt=None, style='%') 该构造方法接收3个可选参数： fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值 datefmt：指定日期格式字符串，如果不指定该参数则默认使用”%Y-%m-%d %H:%M:%S” style：Python 3.2新增的参数，可取值为 ‘%’, ‘{‘和 ‘$’，如果不指定该参数则默认使用’%’ 一般直接用logging.Formatter(fmt, datefmt) format格式字符串说明 字段/属性名称 使用格式 描述 asctime %(asctime)s 将日志的时间构造成可读的形式，默认情况下是‘2016-02-08 12:00:00,123’精确到毫秒 name %(name)s 所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger filename %(filename)s 调用日志输出函数的模块的文件名； pathname的文件名部分，包含文件后缀 funcName %(funcName)s 由哪个function发出的log， 调用日志输出函数的函数名 levelname %(levelname)s 日志的最终等级（被filter修改后的） message %(message)s 日志信息， 日志记录的文本内容 lineno %(lineno)d 当前日志的行号， 调用日志输出函数的语句所在的代码行 levelno %(levelno)s 该日志记录的数字形式的日志级别（10, 20, 30, 40, 50） pathname %(pathname)s 完整路径 ，调用日志输出函数的模块的完整路径名，可能没有 process %(process)s 当前进程， 进程ID。可能没有 processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)s 当前线程， 线程ID。可能没有 threadName %(thread)s 线程名称 module %(module)s 调用日志输出函数的模块名， filename的名称部分，不包含后缀即不包含文件后缀的文件名 created %(created)f 当前时间，用UNIX标准的表示时间的浮点数表示； 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数； 日志事件发生的时间相对于logging模块加载时间的相对毫秒数 msecs %(msecs)d 日志事件发生事件的毫秒部分。logging.basicConfig()中用了参数datefmt，将会去掉asctime中产生的毫秒部分，可以用这个加上 Filter类（暂时了解）Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下： 12class logging.Filter(name='') filter(record) 比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。 filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。 最佳实践标准屏幕日志 123456789101112131415161718192021222324252627282930import loggingdef get_stream_logger(name='LOGGER', level='debug', output_format=None): \"\"\" 获取标准屏幕日志器 :param name: 日志器名称 :param level: 日志级别 :param output_format: 输出格式 :return: \"\"\" \"\"\" \"\"\" if output_format is None: output_format = \"%(name)s:%(asctime)s %(filename)s[line:%(lineno)d]:%(levelname)s:%(message)s\" level_relations = &#123; 'debug': logging.DEBUG, 'info': logging.INFO, 'warning': logging.WARNING, 'error': logging.ERROR, 'critical': logging.CRITICAL &#125; # 日志级别关系映射 logger = logging.getLogger(name) logger.setLevel(level_relations[level]) stream = logging.StreamHandler() stream.setFormatter(logging.Formatter(output_format)) logger.addHandler(stream) return logger 屏幕文件双日志 输出log到控制台，并将日志写入log文件，保存2种类型的log： all.log 保存debug, info, warning, critical 信息 error.log则只保存error信息，同时按照时间自动分割日志文件 123456789101112131415161718192021222324252627282930313233343536373839def get_file_screen_logger(name='LOGGER', filename=None, level='info', when='D', backCount=3, fmt=None): \"\"\" 获取标准屏幕、文件输出日志器 :param name:日志器的名称 :param filename: 保存的文件名 :param level:日志级别 :param when: 日志生成间隔的时间单位，单位有以下几种： # S 秒、M 分、H 小时、、D 天、、W 每星期（interval==0时代表星期一）、midnight 每天凌晨 :param backCount: 备份数量 :param fmt:日志输出格式 :return: \"\"\" level_relations = &#123; 'debug': logging.DEBUG, 'info': logging.INFO, 'warning': logging.WARNING, 'error': logging.ERROR, 'critical': logging.CRITICAL &#125; # 日志级别关系映射 logger = logging.getLogger(name) logger.setLevel(level_relations.get(level)) # 设置日志级别 if fmt is None: fmt = '%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s' format_str = logging.Formatter(fmt) # 设置日志格式 out_screen = logging.StreamHandler() # 往屏幕上输出 out_screen.setFormatter(format_str) # 设置屏幕上显示的格式 logger.addHandler(out_screen) # 把对象加到logger里 if filename is None: raise Exception('未指定日志文件名 ') # 往文件里写入，指定间隔时间自动生成文件的处理器 # interval是时间间隔，backupCount是备份文件的个数，如果超过这个个数，就会自动删除，when是间隔的时间单位，单位有以下几种： # S 秒、M 分、H 小时、、D 天、、W 每星期（interval==0时代表星期一）、midnight 每天凌晨 out_file = handlers.TimedRotatingFileHandler(filename=filename, when=when, backupCount=backCount, encoding='utf-8') out_file.setFormatter(format_str) # 设置文件里写入的格式 logger.addHandler(out_file) return logger 参考:https://www.cnblogs.com/Nicholas0707/p/9021672.html https://www.cnblogs.com/nancyzhu/p/8551506.html 综合案例","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"工具","slug":"工具","permalink":"https://jizx.vip/tags/工具/"},{"name":"logging","slug":"logging","permalink":"https://jizx.vip/tags/logging/"}]},{"title":"anaconda与jupyter的使用和设置","slug":"anaconda与jupyter使用与设置","date":"2019-08-04T13:31:47.000Z","updated":"2020-09-10T14:51:41.711Z","comments":true,"path":"2019/08/04/anaconda与jupyter使用与设置/","link":"","permalink":"https://jizx.vip/2019/08/04/anaconda与jupyter使用与设置/","excerpt":"jupyter 使用介绍、与 anaconda 的虚拟环境结合 、右键打开配置","text":"jupyter 使用介绍、与 anaconda 的虚拟环境结合 、右键打开配置 anaconda安装 清华镜像站下载 或者清华镜像站anaconda首页 或者anaconda官网(比较慢) 下面是每个anaconda对应的Python版本图 对于 windows 安装时，把Anaconda加入环境变量，这涉及到能否直接在cmd中使用conda、jupyter、ipython等命令，推荐打勾。如果没有打钩，可在后续加入下面这些路径（如果目录不同，请修改为对应的安装目录）： 12345C:\\ProgramData\\Anaconda3;C:\\ProgramData\\Anaconda3\\Library\\mingw-w64\\bin;C:\\ProgramData\\Anaconda3\\Library\\usr\\bin;C:\\ProgramData\\Anaconda3\\Library\\bin;C:\\ProgramData\\Anaconda3\\Scripts; 配置镜像地址，否则从官方网站下载、升级文件太慢 1234567conda config --show channels # 列出现有的镜像频道conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ # 为pytorch而加conda config --set show_channel_urls yes # 下载时显示文件来源conda config --remove channels 镜像链接 # 删除指定的镜像conda clean- i # 清除索引缓存 推荐在默认环境下更新所有的包。打开 Anaconda Prompt （或者 Mac 下的终端），键入conda upgrade —all 使用默认有一个base环境，推荐在此基础上，再创建2个环境，分别是：Python3和Python2 12conda create -n py3 python=3.6 # 如果是 python=3 默认安装最新版conda create -n py2 python=2.7 包管理1234567conda install numpy scipy pandas # 安装多个包conda install numpy=1.10 # 指定所需的包版本conda remove package_name # 卸载包conda update package_name # 更新包conda update --all # 更新环境中的所有包（这样做常常很有用）conda list # 列出已安装的包conda search search_term # 如果不知道要找的包的确切名称，可以尝试进行搜索 环境管理123456789101112131415161718192021# 创建、删除环境，记得替换 env_name 为自定义的环境名称conda create -n env_name python=3.4 pandas # 创建环境 ，-n 是指名称，后面可以跟一些想要安装的库conda env remove -n env_name # 删除指定的环境conda create -n new_env --clone old_name # 克隆环境，实现重命名# 激活/退出环境activate my_env # 激活环境 windowdeactivate # 退出环境 windowconda activate my_env # 激活环境 OSX/Linuxconda deactivate # 退出环境 OSX/Linuxsource activate my_env # 激活环境 OSX/Linux(弃用)source deactivate # 退出环境 OSX/Linux(弃用)# 查看环境conda env list # 列出你创建的所有环境conda info -e # 列出你创建的所有环境conda info # 显示当前环境的全部相关信息# 导出环境信息文件，利用文件信息克隆环境conda env export &gt; environment.yaml # 将包保存为YAML，共享此文件，而且其他人能够用于创建和你项目相同的环境conda env create -f environment.yaml # 利用环境文件创建相同环境 对于不使用 conda 的用户，可以使用命令pip freeze&gt; pip_requirements.txt（详情）将一个 pip_requirements.txt 文件导出并包括在其中。 推荐 Mac/linux，在 ~/.bash_profile 中添加别名，方便激活环境 12alias activate=\"source activate\"alias deactivate=\"source deactivate\" 参考：https://www.cnblogs.com/python2webdata/p/10034528.html jupyter/jupyter-lab推荐安装jupyter的升级版jupyter lab： conda install -c conda-forge jupyterlab 激活环境后，输入jupyter-lab或者jupyter notebook就打开了当前环境的 notebook（如果当前环境没有安装jupyter，那么会调用base的）。 如果经常在Python3与Python2之间切换，为了不用每次都先切换环境才能使用 jupyter，可以进行一下配置，实现直接在 jupyter 打开的网页中指定环境。 使用anaconda的虚拟环境 激活虚拟环境 source activate 环境名称 安装 ipykernel，注意：在虚拟环境中安装 ipykernel，conda install ipykernel 写入Jupyter 的 kernel 中，还是在该虚拟环境中，运行命令 python -m ipykernel install --user --name 环境名称 --display-name &quot;Python (环境名称)&quot; 完成，打开Jupyterjupyter-lab或 jupyter notebook windows右键打开Jupyter\\Jupyter-lab注：Jupyter-lab类似 打开 regedit，定位到HKEY_CLASSES_ROOT\\Directory\\Background\\shell 右键新建“项”，输入名称“jupyter”，该名称将出现在右键的菜单上 然后在jupyter目录的右侧，新建一个字符串值Icon，设置为%USERPROFILE%\\AppData\\Local\\Continuum\\anaconda3\\Menu\\jupyter.ico，该图标将出现在右键的菜单上 最后在jupyter目录下新建一个目录 “command”，点击command目录，修改右侧的值为&quot;C:\\Windows\\System32\\cmd.exe&quot; &quot;--working-dir&quot; &quot;%v.&quot; &quot;/k jupyter notebook&quot; cmd /c start dir：会打开一个新窗口后执行dir指令，原窗口会关闭； cmd /k start dir：会打开一个新窗口后执行dir指令，原窗口不会关闭。 参考：https://blog.csdn.net/firing00/article/details/81866878","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"效率","slug":"效率","permalink":"https://jizx.vip/tags/效率/"},{"name":"anaconda","slug":"anaconda","permalink":"https://jizx.vip/tags/anaconda/"},{"name":"jupyter","slug":"jupyter","permalink":"https://jizx.vip/tags/jupyter/"},{"name":"右键","slug":"右键","permalink":"https://jizx.vip/tags/右键/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2019-08-04T11:21:32.000Z","updated":"2020-07-14T01:31:58.681Z","comments":true,"path":"2019/08/04/linux常用命令/","link":"","permalink":"https://jizx.vip/2019/08/04/linux常用命令/","excerpt":"处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）","text":"处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing） 进程ps -f命令也能够表现子shell的嵌套关系 时间date12345678910111213141516171819202122232425-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；date [选项]... [+格式] 或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]Display the current time in the given FORMAT, or set the system date.Mandatory arguments to long options are mandatory for short options too. -d, --date=STRING 显示由STRING 描述指定的时间, 不是默认的&apos;now&apos; -f, --file=DATEFILE like --date once for each line of DATEFILE -I[TIMESPEC], --iso-8601[=TIMESPEC] 使用ISO 8601格式显示 date/time TIMESPEC可以设置为&apos;date&apos;, &apos;hours&apos;, &apos;minutes&apos;, &apos;seconds&apos;, &apos;ns&apos; 来指定显示的精度，默认是date -r, --reference=文件 显示指定文件的最后修改时间 -R, --rfc-2822 以RFC 2822格式输出日期和时间 例如：2006年8月7日，星期一 12:34:56 -0600 --rfc-3339=TIMESPEC output date and time in RFC 3339 format. TIMESPEC=&apos;date&apos;, &apos;seconds&apos;, or &apos;ns&apos; for date and time to the indicated precision. Date and time components are separated by a single space: 2006-08-07 12:34:56-06:00 -s, --set=STRING 用描述时间的字符串 STRING 设置时间 -u, --utc, --universal 显示或设置 Coordinated Universal Time --help 显示此帮助信息并退出 --version 显示版本信息并退出 格式化参数给定的格式FORMAT 控制着输出，解释序列如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 %% 一个% %a 当前locale 的星期名缩写(例如： 日，代表星期日) %A 当前locale 的星期名全称 (如：星期日) %b 当前locale 的月名缩写 (如：一，代表一月) %B 当前locale 的月名全称 (如：一月) %c 当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25) %C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20) %d 按月计的日期(例如：01) %D 按月计的日期；等于%m/%d/%y %e 按月计的日期，添加空格，等于%_d %F 完整日期格式，等价于 %Y-%m-%d %g ISO-8601 格式年份的最后两位 (参见%G) %G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用 %h 等于%b %H 小时(00-23) %I 小时(00-12) %j 按年计的日期(001-366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n 换行 %N 纳秒(000000000-999999999) %p 当前locale 下的&quot;上午&quot;或者&quot;下午&quot;，未知时输出为空 %P 与%p 类似，但是输出小写字母 %r 当前locale 下的 12 小时时钟时间 (如：11:11:04 下午) %R 24 小时时间的时和分，等价于 %H:%M %s 自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数 %S 秒(00-60) %t 输出制表符 Tab %T 时间，等于%H:%M:%S %u 星期，1 代表星期一 %U 一年中的第几周，以周日为每星期第一天(00-53) %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %w 一星期中的第几日(0-6)，0 代表周一 %W 一年中的第几周，以周一为每星期第一天(00-53) %x 当前locale 下的日期描述 (如：12/31/99) %X 当前locale 下的时间描述 (如：23:13:48) %y 年份最后两位数位 (00-99) %Y 年份 %z +hhmm 数字时区(例如，-0400) %:z +hh:mm 数字时区(例如，-04:00) %::z +hh:mm:ss 数字时区(例如，-04:00:00) %:::z 数字时区带有必要的精度 (例如，-04，+05:30) %Z 按字母表排序的时区缩写 (例如，EDT)默认情况下，日期的数字区域以0填充。%后面可以加 下面这些标记： - (hyphen) do not pad the field _ (underscore) pad with spaces 0 (zero) pad with zeros ^ use upper case if possible # use opposite case if possible在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。例子:Convert seconds since the epoch (1970-01-01 UTC) to a date $ date --date=&apos;@2147483647&apos;Show the time on the west coast of the US (use tzselect(1) to find TZ) $ TZ=&apos;America/Los_Angeles&apos; dateShow the local time for 9AM next Friday on the west coast of the US $ date --date=&apos;TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri&apos; 格式化1date +&quot;%Y-%m-%d&quot; 时间游走1.加减操作 1234567date +%Y%m%d //显示前天年月日date -d &quot;+1 day&quot; +%Y%m%d //显示前一天的日期date -d &quot;-1 day&quot; +%Y%m%d //显示后一天的日期date -d &quot;-1 month&quot; +%Y%m%d //显示上一月的日期date -d &quot;+1 month&quot; +%Y%m%d //显示下一月的日期date -d &quot;-1 year&quot; +%Y%m%d //显示前一年的日期date -d &quot;+1 year&quot; +%Y%m%d //显示下一年的日期 2.文字版本 1234date -d &quot;1 day ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot; # 一天前date -d &quot;1 day&quot; +&quot;%Y-%m-%d %H:%M:%S&quot; # 一天后date -d &quot;2009-12-12 1 year ago&quot; +&quot;%Y/%m/%d %H:%M.%S&quot; # 指定时间的一年前date -d &quot;2009-12-12 1 year&quot; +&quot;%Y/%m/%d %H:%M.%S&quot; # 指定时间的一年后 设置时间 1234date -s //设置当前时间，只有root权限才能设置，其他只能查看date -s 20120523 //设置成20120523，这样会把具体时间设置成空00:00:00date -s 01:01:01 //设置具体时间，不会对日期做更改date -s &quot;01:01:01 2012-05-23&quot; //这样可以设置全部时间 文本处理echo-e：输出转义字符 -n：不换行输出 1234567891011RCol='\\e[0m' # Text Reset # Regular Bold Underline High Intensity BoldHigh Intens Background High Intensity BackgroundsBla='\\e[0;30m'; BBla='\\e[1;30m'; UBla='\\e[4;30m'; IBla='\\e[0;90m'; BIBla='\\e[1;90m'; On_Bla='\\e[40m'; On_IBla='\\e[0;100m';Red='\\e[0;31m'; BRed='\\e[1;31m'; URed='\\e[4;31m'; IRed='\\e[0;91m'; BIRed='\\e[1;91m'; On_Red='\\e[41m'; On_IRed='\\e[0;101m';Gre='\\e[0;32m'; BGre='\\e[1;32m'; UGre='\\e[4;32m'; IGre='\\e[0;92m'; BIGre='\\e[1;92m'; On_Gre='\\e[42m'; On_IGre='\\e[0;102m';Yel='\\e[0;33m'; BYel='\\e[1;33m'; UYel='\\e[4;33m'; IYel='\\e[0;93m'; BIYel='\\e[1;93m'; On_Yel='\\e[43m'; On_IYel='\\e[0;103m';Blu='\\e[0;34m'; BBlu='\\e[1;34m'; UBlu='\\e[4;34m'; IBlu='\\e[0;94m'; BIBlu='\\e[1;94m'; On_Blu='\\e[44m'; On_IBlu='\\e[0;104m';Pur='\\e[0;35m'; BPur='\\e[1;35m'; UPur='\\e[4;35m'; IPur='\\e[0;95m'; BIPur='\\e[1;95m'; On_Pur='\\e[45m'; On_IPur='\\e[0;105m';Cya='\\e[0;36m'; BCya='\\e[1;36m'; UCya='\\e[4;36m'; ICya='\\e[0;96m'; BICya='\\e[1;96m'; On_Cya='\\e[46m'; On_ICya='\\e[0;106m';Whi='\\e[0;37m'; BWhi='\\e[1;37m'; UWhi='\\e[4;37m'; IWhi='\\e[0;97m'; BIWhi='\\e[1;97m'; On_Whi='\\e[47m'; On_IWhi='\\e[0;107m'; cat1234cat -A test 显示隐藏字符如^A,^Bcat -n test 所有的行加上行号cat -b test 【有文本的行】 加上行号，【空白行】不算cat -T test 以^I显示制表符 tail1tail -n 2 -f log_file -f 参数是 tail 命令的一个突出特性。它允许你在其他进程使用该文件时查看文件的内容。tail命令会保持活动状态，并不断显示添加到文件中的内容。这是实时监测系统日志的绝妙方式。 uniquniq命令用于报告或忽略文件中的重复行，查重复行的时候，只会检查相邻的行，因此一般与sort命令结合使用，让重复的排在一起。比如下面：aa 统计结果是出现了 2 次，后面又有出现 1 次的 aa 1234567891011# 文本aaaacaa# uniq 后uniq -c 2 aa1 c1 aa 常用参数： 123456789-c或——count： 在每列旁边显示该行重复出现的次数；-u或——unique： 仅显示出一次的行列；-d或--repeated： 仅输出重复出现的行列，且重复的只输出一行；-D, --all-repeated 仅输出重复的行，有几行输出几行 -i, --ignore-case 不区分大小写 -w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt; 指定要比较的前 n 个字符，忽略后面的内容-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt; 忽略前n列（空格分割），-f 1 忽略第一列-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt; 忽略前n个字符 -s 4 忽略前 4 个字符-z 忽略换行(不知道有什么用) 提供的测试文件1234567891011121314this is a test this is a test this is a test i am tank i love tank i love tank this is a test whom have a try WhoM have a try WhoM have a try1you have a try i want to abroad those are good men we are good men 参考：http://blog.51yip.com/shell/1022.html 两个文件的交并集如果你知道怎么用sort/uniq来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已经被uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小） 123cat a b | sort | uniq &gt; c # c is a union b 并集cat a b | sort | uniq -d &gt; c # c is a intersect b 交集cat a b b | sort | uniq -u &gt; c # c is set difference a - b 差集 sort全局选项 选项 解释 -b –ignore-leading-blanks 排序时忽略起始的空白，空格数量不固定时，该选项几乎是必须要使用的。”-n”选项隐含该选项。 -c –check 仅检查输入数据是不是已排序；未排序的话，会输出诊断信息，提示从哪一行开始乱序。 -t –field-separator=SEP 指定分隔符，如果是\\t，需要这样sort -t$&#39;\\t&#39; file。默认的分隔符为空白字符和非空白字符之间的空字符，并非网上众多文章所说的空格或制表符(By default, fields are separated by the empty string between a non-blank character and a blank character)。” foo bar”被分割为：` foo bar（ `视为分割符） -u –unique 在输出行中去除重复行，只识别用-k设定的域，发现都相同的才会删除，只要其中有一级不同都不会轻易删除的。 -n –numeric-sort 指定-n使用数值比较，默认是字符串比较，一遇到不可识别字符就会立即结束该字段的排序行为，无法跨域使用。”n”选项隐含”b”选项。 -g –general-number-sort 按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学 计数法表示的值） -r –reverse 默认从小到大，指定后改为从大到小排序 -f –ignore-case 忽略大小写，未指定情况下，会将大写字母排在前面；在和”-u”选项一起使用时，如果排序字段的比较结果相等，则丢弃小写字母行。 -o –output=file 排序结果输出到指定文件，对于保存到原文件很有用，不然是可以用重定向的 -m –merge 对给定的多个已排序文件进行合并。在合并过程中不做任何排序动作。 -k –key=POS1[,POS2] 指定排序的列，排序从POS1位置开始；如果指定了POS2的话， 到POS2位置结 束 -s –stable 禁用”最终排序”。推荐大文件使用，能确认要排序的列后，不启用可以提高性能 -z –zero-terminated NULL字符作为行尾，而不是用换行符 –debug 查看排序的过程和排序时所使用的列。注意，该选项只有CentOS 7上的sort才有。 知识点私有选项：紧跟在字段后的选项(如”-k3n”的”n”和”-k2r”的”r”)称为私有选项，使用短横线写在字段外的选项(如”-n”、”-r”)为全局选项。当没有为字段分配私有选项时，该排序字段将继承全局选项。当然，只有像”-n”、”-r”这样的排序性的选项才能继承和分配给字段，”-t”这样的选项则无法分配。 除了”b”选项外，其余选项无论是指定在POS1还是POS2中都是等价的，对于”b”选项，指定在POS1则作用于POS1，指定在POS2则作用于POS2。如果继承了全局选项”-b”，则作用于POS1和POS2。 因此，”-n -k3 -k4”、”-n -k3n -k4”和”-k3n -k4n”是等价的，”-r -k3n -k4”和”-k3nr -k4r”是等价的 排序规则：sort命令默认按照字符集的排序规则进行排序，可以指定”-d”选项按照字典顺序排序，指定”-n”按照数值排序，指定”-M”按照字符格式的月份规则排序，指定”-h”按照文件容量大小规则排序。 分隔符 ：sort使用-t选项指定的分隔符对每行进行分割，得到多个字段，分隔符不作为字段的内容，跨域时也没有，注意-n无法跨域，会造成分隔符在其中的错觉。默认的分隔符为空白字符和非空白字符之间的空字符，并非网上众多文章所说的空格或制表符(原文：By default, fields are separated by the empty string between a non-blank character and a blank character.)。 “ foo bar”默认将分隔为两个字段” foo”和” bar”，空格都保留着，可以视为”| foo| bar”，|为分割符。而使用空格作为分隔符时将分隔为三个字段：第一个字段为空，第二个字段和第三个字段为”foo”和”bar”。使用下面三个sort语句可以验证默认的分隔符并非空格。 12345678910111213141516&gt; $ echo -e \" 234 bar\\n 323 aar\" | sort -k2 # 视为 2 列，对（aar,bar）排序&gt; 323 aar&gt; 234 bar&gt; &gt; $ echo -e \" 234 bar\\n 323 aar\" | sort -t' ' -k2 # 视为 3 列，对 (234,323)排序&gt; 234 bar&gt; 323 aar&gt; &gt; $ echo -e \" 234 bar\\n 323 aar\" | sort -b -t' ' -k1 # 视为 2 列，因为全局选项-b 去除了开头的空格&gt; 123 aar&gt; 234 bar&gt; &gt; $ echo -e \" 234 bar\\n 323 aar\" | sort -t' ' -bk3 # 视为 3 列，对（aar, bar）排序，私有选项忽略 bar 前的空格&gt; 323 aar&gt; 234 bar&gt; 分割后字段：分割字段后，分隔符不在排序目标中，跨域时也不包括（-n无法跨域，会造成分隔符在其中的错觉），分割后两个字段A和B是紧靠在一起的。当排序的目标字段包含了B字段，那么sort会从字段左对齐处开始依次对字符排序。 12345678910[root@xuexi ~]# cat sort.txt11:1:21:1:212:1:11:1:0[root@xuexi ~]# sort -t: sort.txt1:1:011:1:21:1:212:1:1 上面排序例子中，为什么”1:1:2”的1会在11和12中间，而”1:1:0”中的1却在11的前面？实际上，真正排序的时候，sort看到的内容是这样的： 123411121121211110 注意：info sort 文档中说跨域时分隔符会保留感觉是错的。通过下面的例子进行测试 1234567$ cat ta aeaa da$ sort -t\" \" -k1,2 t # d &gt; eaa daa ae 最后排序：默认情况下，在命令行中指定的排序行为结束后，sort还会做最后一次排序，这最后一次排序是对整行按照完全默认规则进行排序的，也就是按字符集、升序排序。 考虑这样一种情况：两行在所有key的排序结果上都完全相同，应该如何决定这两行的先后顺序？ 例如： 123[root@xuexi ~]# echo -e &quot;b 100 200\\na 100 300&quot; | sort -t &apos; &apos; -k2na 100 300b 100 200 第一行为”b 100 200”，第二行为”a 100 300”。由于第2字段都是100，所以这两行在该key上的数值排序的结果相同，于是sort采取最后的手段，完全按照默认规则(即按字符集排序规则升序排序)对整行进行一次排序，这次排序称为”最后的排序”(info sort中称为last-resort comparison)。由于最后的排序过程中，第一个字符a&lt;b，所以最终结果将是第二行”a 100 300”在第一行”b 100 200”的前面。 禁止”最后的排序”后，对那些排序key相同的行，将保留被读取时相对顺序。即，先读取的排在前面。 如果上面的例子中，第二字段不采用数值排序，而是默认排序规则排序呢？如下： 123[root@xuexi ~]# echo -e &quot;b 100 200\\na 100 300&quot; | sort -t &apos; &apos; -k2b 100 200a 100 300 由于默认的排序规则是按照字符集排序规则进行排序，它能识别所有的字符，所以-k2等价于-k2,3，对整个key进行排序，由于第三字段的2小于3，所以结果中第一行排在第二行的前面。即使如此，sort还是进行了”最后的排序”，只不过”最后的排序”不影响排序结果。 如果未指定任何排序选项，其本身就是完全默认的，因此没必要再做最后的排序，所以将不会进行”最后的排序”。如果指定的是”-r”选项，由于”-r”是对最终结果进行反转排序，因此会影响这次的”最后的排序”的结果。 排序对象使用”-k”选项指定排序的key。不指定排序key时，整行将成为排序key，即对整行进行排序。 key由字段组成，格式为POS1,[POS2]，表示每行排序的起始和终止位置。也就是说，key才是排序的对象。 POS的格式为F[.C][OPTS]，其中F表示字段的序号，C表示该字段中字符的序号。字段和字符的位置都从1开始计算。如果POS2的字符位置指定为0，则表示POS2字段中的最后一个字符。如果POS1中省略.C，则默认值为1(字段的起始字符)，如果POS2中省略.C，默认值为0(字段的终止字符)。使用”-b”选项忽略前导空白字符时，C从第一个非空白字符开始计算。如果F或C超出了有效范围，则该key为空，例如一行只有3个字段，却指定了”-k4”，或者第2字段只有3个字符，却指定了”-k2.5”。 如果省略POS2，则key将自动扩展到行尾，即等价于”POS1,line_end”。如果不省略POS2，则该key可能会跨越多个字段。无论那种情况，跨越多个字段时，key中都不会保留字段间的分隔符。 OPTS指定的是该key的选项，包括但不限于bfnrhM，它们的作用和全局选项”-b”、”-f”、”-n”、”-r”、”-h”、”-M”相同。默认情况下，如果key中没有指定任何OPTS，则该key会继承全局选项。当key中单独指定了选项时，这些选项是该key的私有排序选项，将覆盖全局选项。除了”b”选项外，其余选项无论是指定在POS1还是POS2中都是等价的，对于”b”选项，指定在POS1则作用于POS1，指定在POS2则作用于POS2。如果继承了全局选项”-b”，则作用于POS1和POS2。-n选项无法跨域。 字段前数量不固定的前导空白字符，将使得字段混乱，因此强烈建议总是忽略前导空白字符。数值排序时(即”n”选项)隐含”b”选项。 可以使用多个”-k”选项指定多个key，排序时将按照key的顺序进行排序。第一个key通常称为主排序key(primary key)。第二个key将在第一个key排序的基础上排序，同理，第三个key将在第二个key的排序基础上进行排序。 以下是几个例子：例子中出现了选项”n”的，描述暂不严谨，但目前只能如此描述，在稍后的(4)中解释。 -k 2： 因为没有指定POS2，所以key扩展到了行尾。因此该key从第2字段第一个字符开始，到行尾结束。 -k 2,3 ：该key从第2字段第一个字符开始到第3字段最后一个字符结束。 -k 2,2： 该key仅拥有第2字段。 -k 2,3n和-k 2n,3和-k 2n,3n：这三者等价，因为除了”b”选项，OPTS指定在POS1或POS2的结果是一样的。 -k 2,3b和-k 2b,3和-k 2b,3b：这三者互不等价。 -k 2n： 该key从第2字段开始直到行尾，都按数值排序。 -k 2.2b,3.2n： 该key从第2字段的第2个非空白字符开始，到第3字段第2字符(可能包含空白字符)结束，且该key按照数值排序。其实此处的b选项是多余的，因为n隐含了b选项。 -k 5b,5 -k 3,3n： 定义了两个排序key，主排序key为第5字段不包含空白字符的部分，副key为第三个字段。主key按照默认规则排序，副key按照数值排序。副key在主key排序后的基础上再排序。 -k 5,5n -k 3b,6b： 主key为第5字段，按照数值排序，副key从第3字段到第六字段，忽略前导空白字符，但是按照默认规则排序。副key在主key排序后的基础上再排序。 建议 任何时候想对单个字段或单个字符排序时，都建议写出POS2，且POS2=POS1，这样能严格排序key的范围只为那个字段或字符。例如，使用-k2,2取代-k2。 想对多个字段或字符排序时，建议使用多个”-k”选项指定多个key，并按需求为每个key分配私有选项。之所以要如此，是防止无意中忽视了扩展到行尾或者范围。例如，想对第2列、第3列按数值排序，应该指定-k2n -k3n，而不应该写成-k2,3n。 应该总是使用-b选项去掉前导空白字符面，防止字段分割时混乱。-n隐含了-b，所以对数值排序时，可以省略-b。 对于大文件，建议写出满足需求的所有排序命令，然后使用-s关闭”最后的排序”。因为”最后的排序”对每个整行进行排序，性能非常低。 多列排序sort按照某列排序，一样的话再按某一列排序 1sort -k2,2 -k5,5 wide_table |grep \"DD4486F320A7F0C112E2757C26609769\" 例子 从公司英文名称的第二个字母开始进行排序： 12345$ sort -t &apos; &apos; -k 1.2 facebook.txtbaidu 100 5000sohu 100 4500google 110 5000guge 50 3000 使用了-k 1.2，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。 按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序 12345$ sort -n -t &apos; &apos; -k 3r -k 2 facebook.txtbaidu 100 5000google 110 5000sohu 100 4500guge 50 3000 在-k 3后面偷偷加上了一个小写字母r。r和-r选项的作用是一样的，就是表示逆序，不过只对当前域有效，表示第三个域（员工平均工资）是按照降序排序。此处你还可以加上n，就表示对这个域进行排序时，要按照数值大小进行排序 12345$ sort -t &apos; &apos; -k 3nr -k 2n facebook.txtbaidu 100 5000google 110 5000sohu 100 4500guge 50 3000 我们去掉了最前面的-n选项，而是将它加入到了每一个-k选项中了。 只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序 12345$ sort -t &apos; &apos; -k 1.2,1.2 -k 3nr facebook.txtbaidu 100 5000google 110 5000sohu 100 4500guge 50 3000 我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。 最诡异的排序（跨域是不行的） 12345$ sort -n -k 2.2,3.1 facebook.txtguge 50 3000baidu 100 5000sohu 100 4500google 110 5000 以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。 第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。 又因为sort认为0小于00小于000小于0000…. 因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢？（你可以自己做实验思考一下。） 答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了。 http://blog.chinaunix.net/uid-10540984-id-313479.html https://www.cnblogs.com/f-ck-need-u/p/7442886.html find1find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression] 任何位于表达式（expression）之前的字符串都将被视为欲查找的目录名。 默认路径为当前目录；默认表达式为-print表达式(expression)可能由下列成份组成：操作符、选项、测试表达式以及动作： find会对每个文件评估从左向右的表达式，直到结果明确为真 或 表达式全部执行结束。 -H，-L和-P选项控制符号链接的处理。后面的命令行参数被视为要检查的文件或目录的名称，直到开始的第一个参数使用’ - ‘或参数’（’或’！’。该参数和任何后续参数被视为描述要搜索内容的表达式。 五个’真正的’选项-H，-L，-P， -D和-O必须出现在第一个路径名之前 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091操作符 (优先级递减；未做任何指定时默认使用 -and): ( EXPR ) ! EXPR -not EXPR EXPR1 -a EXPR2 EXPR1 -and EXPR2 EXPR1 -o EXPR2 EXPR1 -or EXPR2 EXPR1 , EXPR2位置选项 (总是真): -daystart # 从本日开始计算时间；TODO -follow 废弃; 使用-L代替, 排除符号连接； -regextype 普通选项 (总是真，在其它表达式前指定): -depth # 从指定目录下最深层的子目录开始查找，不像默认的一层一层目录往下找，如下： # ./logs/hadoop.kylin.libdfs.log # ./logs -maxdepth LEVELS # 设置最大目录层级; -mindepth LEVELS # 搜索深度距离当前目录至少2个子目录的所有文件 -mount # 此参数的效果和指定“-xdev”相同； -xdev # Don’t descend directories on other filesystems.TODO -ignore_readdir_race -noignore_readdir_race --version --help比较测试 (N 可以是 +N 或 -N 或 N): +N for greater than N, -N for less than N, N for exactly N. -amin N # 查找在指定时间曾被存取过的文件或目录，单位以分钟计算； -mmin N # 查找在指定时间曾被更改过的文件或目录，单位以分钟计算； -cmin N # 查找在指定时间之时被更改过的文件或目录,单位以分钟计算； -atime N # 查找在指定时间曾被存取过的文件或目录，单位以24小时计算； -mtime N # 查找在指定时间曾被更改过的文件或目录，单位以24小时计算; -ctime N # 查找在指定时间之时被更改的文件或目录，单位以24小时计算； -cnewer 文件 # 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录； -anewer 文件 # 查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录； -empty -true # 将find指令的回传值皆设为True; -false # 将find指令的回传值皆设为False； -fstype 类型 # 只寻找该文件系统类型下的文件或目录； -gid N # 查找符合指定之群组识别码的文件或目录； -group 名称 # 查找符合指定之群组名称的文件或目录； -uid N # 查找符合用户uid的文件或目录 -user NAME # 查找符和指定的拥有者名称的文件或目录 # 匹配模式使用的是shell的通配符（除了regex） -name 匹配模式 # *.py 最好配合*使用，精确指定可能得不到想要的结果 -regex 匹配模式 # 需要较多的转义，请看后面的例子 -path 匹配模式 # 与name很像，必须配合*使用，指定字符串作为寻找目录的范本样式，只要目录中包含匹配的模式，就输出 -perm [+-]访问模式 # 查找符合指定的权限数值的文件或目录; -lname 匹配模式 # 查找是符号链接的文件，并且其内容匹配模式 -newer 文件或目录 # 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录; # 忽略字符大小写的差别 -iname 匹配模式 -ipath 匹配模式 -iregex 匹配模式 -ilname 匹配模式 -links N # 查找符合指定的硬连接数目的文件或目录； -inum N # 查找符合指定的inode编号的文件或目录； -nouser -nogroup # 找出不属于本地主机[用户识别码/群组识别码]的文件或目录; -noleaf # 不去考虑目录至少需拥有两个硬连接存在； # 可读写执行 -readable -writable -executable -wholename PATTERN # TODO -size N[bcwkMG] # 查找符合指定的文件大小的文件; -type [bcdpflsD] # 只寻找符合指定的文件类型的文件； -used N # 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算; -xtype [bcdpfls] # 和指定“-type”参数类似，差别在于它针对符号连接检查。动作: -delete -print # 若回传值为Ture，就将符合的文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串; -print0 # 回传值为Ture，就将符合的文件或目录名称列出到标准输出。格式为全部的名称皆在同一行; -printf FORMAT # 回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定; -fprintf FILE FORMAT # 此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件； -fprint0 FILE # 指定“-print0”参数类似，但会把结果保存成指定的列表文件； -fprint FILE # 和指定“-print”参数类似，但会把结果保存成指定的列表文件； -ls # 对符合条件的文件或目录执行ll命令，显示详细信息 -fls FILE # 和指定“-ls”参数类似，但会把结果保存为指定的列表文件； -prune # 不打印符合条的文件或目录 -quit # 执行的命令不支持你自定义的alias -exec COMMAND &#123;&#125; \\; # find指令的回传值为True，就执行该指令; -ok COMMAND &#123;&#125; \\; # 与-exec相似，但是会给出提示，是否执行相应的操作。 -exec COMMAND &#123;&#125; + -ok COMMAND ; # &#123;&#125;是一个占位符，用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名 -execdir COMMAND ; -execdir COMMAND &#123;&#125; + -okdir COMMAND ; 在/home目录下查找以.txt结尾的文件名 1find /home -name &quot;*.txt&quot; 当前目录及子目录下查找所有以.txt和.pdf结尾的文件 1find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; 匹配文件路径或者文件 1find /usr/ -path &quot;*local*&quot; name与path的区别 12345678910111213141516$ find . -ipath &quot;*match*&quot;./bin/match./bin/match/match.py./data/match_result.txt./data/match./data/match/20190910 # 这一行的差别./data/match/20190910/match_result_20190910.txt./data/match_result_20190910.txt$ find . -iname &quot;*match*&quot;./bin/match./bin/match/match.py./data/match_result.txt./data/match./data/match/20190910/match_result_20190910.txt./data/match_result_20190910.txt 基于正则表达式匹配文件路径 1find . -regex &quot;.*\\(\\.txt\\|\\.pdf\\)$&quot; 否定参数 找出/home下不是以.txt结尾的文件 1find /home ! -name &quot;*.txt&quot; 类型参数列表： f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p Fifo UNIX/Linux文件系统每个文件都有三种时间戳： 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。 搜索最近七天内被访问过的所有文件 1find . -type f -atime -7 搜索恰好在七天前被访问过的所有文件 1find . -type f -atime 7 搜索超过七天内被访问过的所有文件 1find . -type f -atime +7 搜索访问时间超过10分钟的所有文件 1find . -type f -amin +10 找出比file.log修改时间更长的所有文件 1find . -type f -newer file.log 根据文件大小进行匹配 1find . -type f -size 文件大小单元 文件大小单元： b —— 块（512字节） c —— 字节 w —— 字（2字节） k —— 千字节 M —— 兆字节 G —— 吉字节 搜索大于10KB的文件 1find . -type f -size +10k 搜索小于10KB的文件 1find . -type f -size -10k 搜索等于10KB的文件 1find . -type f -size 10k 删除匹配文件 删除当前目录下所有.txt文件 1find . -type f -name &quot;*.txt&quot; -delete 根据文件权限/所有权进行匹配 当前目录下搜索出权限为777的文件 1find . -type f -perm 777 找出当前目录下权限不是644的php文件 1find . -type f -name &quot;*.php&quot; ! -perm 644 找出当前目录用户tom拥有的所有文件 1find . -type f -user tom 找出当前目录用户组sunk拥有的所有文件 1find . -type f -group sunk 查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk 1find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print 要列出所有长度为零的文件 1find . -empty 执行命令相关 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中 1find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \\;&gt; all.txt 将30天前的.log文件移动到old目录中 1find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \\; 单行命令中-exec参数中无法使用多个命令，可以将多条命令保存在shell文件中，在-exec执行该文件 1-exec ./text.sh &#123;&#125; \\; grep在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。例如： grep -i &#39;hello world&#39; menu.h main.c 常用参数12grep pattern filename # 默认支持正则grep -e pattern1 -e pattern2 filename 默认情况下，grep命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。 需要注意的是：限定连续字符范围 的{}符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 \\{ 与\\} 来让它失去特殊意义才行。 123456789101112131415161718192021222324252627282930grep --color=auto \" 在输出行中着重标记出匹配到的模式-a # 将 binary 文件以 text 文件的方式搜寻数据-e # 指定字符串做为查找文件内容的样式（非正则）。如果要指定多个匹配模式，可用-e参数来指定每个模式,grep -e t -e f file 输出了含有字符t或字符f的所有行。-E # 将字符串为延伸的正则表达式来使用-o # 只输出匹配到的文本，如果在同一行中，会分开显示-v # 打印出不匹配match_pattern的所有行-c # 统计匹配行的数量，并不是匹配的次数。匹配次数需要与-o配合，请看后面的例子-n # 打印出匹配字符串所在行的行号,以及该行的内容，如果涉及多个文件，该选项也会随输出结果打印出文件名-i # 忽略模式中的大小写-l # 多文件处理时，可以列出匹配模式所在的文件-L # 与-l相反，它会返回一个不匹配的文件列表-q # 静默模式（主要用于脚本中，，在命令行中没什么用），只判断是否匹配成功,不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。0表示匹配成功，非0表示匹配失败。-r # 递归搜索当前目录和子目录-w # 匹配整个英文单词，对中文不管用-x # 匹配整行，比较两个文件不同行时使用-f # 从文件中读取匹配模式，一行一个模式# 显示前后几行-A # after，显示匹配到的行以及之后的 n 行-B # before，显示匹配到的行以及之前的 n 行-C # Center，显示匹配到的行以及前后的 n # 如果匹配到多行，为了区分匹配到的字符串，用\"--\"进行区分，比如：echo -e \"a\\nb\\nc\\na\\nb\\nc\" | grep a -A 1# a 匹配到第1次# b# --# a 匹配到第2次# c 统计匹配项的数量 1echo -e &quot;1 2 3 4\\nhello\\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859正则表达式选择与解释: -E, --extended-regexp PATTERN 是一个可扩展的正则表达式(缩写为 ERE) -F, --fixed-strings PATTERN 是一组由断行符分隔的定长字符串。 -G, --basic-regexp PATTERN 是一个基本正则表达式(缩写为 BRE) -P, --perl-regexp PATTERN 是一个 Perl 正则表达式 -e, --regexp=PATTERN 用 PATTERN 来进行匹配操作 -f, --file=FILE 从 FILE 中取得 PATTERN -i, --ignore-case 忽略大小写 -w, --word-regexp 强制 PATTERN 仅完全匹配字词 -x, --line-regexp 强制 PATTERN 仅完全匹配一行 -z, --null-data 一个 0 字节的数据行，但不是空行杂项: -s, --no-messages 不显示错误信息 -v, --invert-match 选中不匹配的行 -V, --version 显示版本信息并退出 --help 显示此帮助并退出 --mmap 忽略向后兼容性输出控制: -m, --max-count=NUM NUM 次匹配后停止 -b, --byte-offset 输出行的同时打印字节偏移 -n, --line-number 输出行的同时打印行号 --line-buffered 每行输出清空 -H, --with-filename 为每一匹配项打印文件名 -h, --no-filename 输出时不显示文件名前缀 --label=LABEL 标准输入将LABEL 打印为文件名 -o, --only-matching 只显示一行中匹配PATTERN 的部分 -q, --quiet, --silent 不显示所有输出 --binary-files=TYPE 假定二进制文件的TYPE 类型； TYPE 可以是`binary&apos;, `text&apos;, 或`without-match&apos; -a, --text 等同于 --binary-files=text -I 等同于 --binary-files=without-match -d, --directories=ACTION 操作目录的方式； ACTION 可以是`read&apos;, `recurse&apos;,或`skip&apos; -D, --devices=ACTION 操作设备、先入先出队列、套接字的方式； ACTION 可以是`read&apos;或`skip&apos; -r, --recursive 等同于 --directories=recurse -R --dereference-recursive likewise, but follow all symlinks --include=FILE_PATTERN 只查找匹配FILE_PATTERN 的文件 --exclude=FILE_PATTERN 跳过匹配FILE_PATTERN 的文件和目录 --exclude-from=FILE 跳过所有除FILE 以外的文件 --exclude-dir=PATTERN 跳过所有匹配PATTERN 的目录。 -L, --files-without-match 只打印不匹配FILEs 的文件名 -l, --files-with-matches 只打印匹配FILES 的文件名 -c, --count 只打印每个FILE 中的匹配行数目 -T, --initial-tab 行首tabs 分隔（如有必要） -Z, --null 在FILE 文件最后打印空字符文件控制: -B, --before-context=NUM 打印以文本起始的NUM 行 -A, --after-context=NUM 打印以文本结尾的NUM 行 -C, --context=NUM 打印输出文本NUM 行 -NUM 等同于 --context=NUM --color[=WHEN], --colour[=WHEN] 使用标志高亮匹配字串； WHEN 可以是`always&apos;, `never&apos;或`auto&apos; -U, --binary 不要清除行尾的CR 字符(MSDOS 模式) -u, --unix-byte-offsets 当CR 字符不存在，报告字节偏移(MSDOS 模式) 扩展用法egrep命令是grep的一个衍生，支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更 多的可以用来指定匹配模式的字符，增加了额外的正则表达式元字符集。 123grep -E \"[a-z]+\" filename#或egrep \"[a-z]+\" filename 不使用正则表达式12grep -F &apos;str&apos;fgrep &apos;str&apos; fgrep 查询速度比grep命令快，但是不够灵活：它只能找固定的文本，而不是正则表达式。 如果你想在一个文件或者输出中找到包含星号字符的行 123fgrep '*' /etc/profile#或grep -F '*' /etc/profile fgrep则是另外一个版本，支持将匹配模式 指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后 在fgrep命令中用其在一个大型文件中搜索字符串了。 多模式匹配逻辑或命令会打印出匹配任意一种模式的行，每个匹配对应一行输出。例如： 1echo this is a line of text | grep -o -e \"this\" -e \"line\" this 从文件中读取匹配模式可以将多个模式定义在文件中。选项-f可以读取文件并使用其中的模式（一个模式一行，记得最后留一行空白行，不然最后一种模式匹配不到，很诡异） 1234567cat pat_file# ^h.*# co+l# echo hello \\n this is cool | grep -f pat_file # hello # this is cool 逻辑与grep 本身并不支持，所以需要通过管道符号或者与 find 组合使用 常用功能检索文件内容递归搜索目录中的文件内容（不是文件名）-，注意：支持相对路径、绝对路径，但不支持~/work/这样的路径。 1grep &quot;查找内容&quot; 目录 -r -n --include=*.&#123;py,sh&#125; --exclude=*.&#123;log,txt&#125; --exclude-dir=&#123;log,tmp,config&#125; --exclude-from BLACK_LIST --include 指定搜索的文件类型或者某个文件，比如*.sh，*.py，可以使用GLOB写法，如*.{py,sh} --exclude 指定不想搜索的文件类型或者某个文件，比如*.txt，bigdata.txt ,可以使用GLOB写法，如*.{txt,log} --exclude-dir可以排除不想搜索的目录，多个目录时请用{a,b,c} --exclude-from BLACK_LIST从黑名单文件中读取要排除文件列表 例子： 123grep \"TODO\" ./ -r -n --include=*.&#123;sh,py&#125; --exclude-dir=&#123;tmp,logs&#125;# ./src/test.c:16:TODO 添加注释; 等价于find . -type f | xargs grep &quot;test_function()&quot; 0值字节后缀的 xargsxargs命令可以为其他命令提供命令行参数列表。 当文件名作为命令行参数时，建议用0值字节作为文件名终结符，而非空格。因为一些文件名中会包含空格字符，一旦它被误解为终结符， 那么单个文件名就会被视为两个（例如，New file.txt被解析成New和file.txt两个文件名）。 这个问题可以利用0值字节后缀来避免。 grep和find命令可以生成带有0值字节后缀的输出，然后传递 给 xargs，让它产生文件名列表。为了指明输入中的文件名是以0值字节作为终结，需 要在xargs中使用选项-0。 123456789# 创建测试文件：echo \"test\" &gt; file1 echo \"cool\" &gt; file2 echo \"test\" &gt; file3# 找出包含有 test 内容的文件名，并以0值字节作为终结符，然后传递给 xargs，让它生成文件名参数列表，之后传递（不用管道符号）给 rm 命令，删除这些文件grep \"test\" file* -lZ | xargs -0 rm# 选项-l告诉grep只输出有匹配出现的文件名。选项-Z使得grep使用0值字节（\\0）作为文 件名的终结符。这两个选项通常都是配合使用的。xargs的-0选项会使用0值字节作为输入的分隔符 比较两个文件相同内容与不同内容输出file2中不含file1的内容 123grep -Ff file1 file2 # 输出公共的行grep -vFf file1 file2 # 输出不在 file1 的行grep -xvFf file1.txt file2.txt &gt; result.tx -x, --line-regexp 强制 PATTERN 仅完全匹配一行 查找满足条件的文件是否匹配到文字查找包含”hello world”的文件清单，并从这些清单中查找出满足”mailx”的匹配情况 1234567891011121314151617181920#方法1：直接利用管道grep -i \"hello world\" -rl /home/tyrone | xargs grep -i \"mailx\"#输出结果/home/tyrone/test1.txt:mailx#方法2：使用find，适合于需要灵活判断条件的场景。例如查找指定路径下，同时匹配多个模式的txt文件。#注意：本例中“mailx”后面的命令必须加上反引号 ` ，否则会被当作要查询的文件名。grep -i \"mailx\" `find /home/tyrone -type f -name \"*.txt\" -exec grep -l \"hello world\" &#123;&#125; \\;`#输出结果/home/tyrone/test1.txt:mailx#方法3:同2find /home/tyrone -name \"*.txt\" -exec grep -l \"hello world\" &#123;&#125; \\; | xargs grep -i \"mailx\"#输出结果/home/tyrone/test1.txt:mailx tr基本用法tr是translate（转换）的简写，基本功能是将字符从一个字符集合映射到另一个集合中 1tr set1 set2 注意： tr只能通过stdin 接收输入，无法通过命令行参数接收 ，如tr -s &#39;&#39; file，只能转为 stdin 形式，tr -s &#39; &#39;&lt; file.txt 如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1 相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。 1echo &quot;HELLO WHO IS THIS&quot; | tr &apos;A-Z&apos; &apos;a-z&apos; 字符集合（字符组）可以使用“起始字符—终止字符”，如果不是有效的连续字符序列， 那么它就会被视为起始字符、—、终止字符这3个元素的集合。也可以使用像\\t、\\n 这种特殊字符或其他ASCII字符。可以按照需要追加字符或字符类来构造自己的字符组。 字符类 说明 alnum 字母和数字 alpha 字母 cntrl 控制（非打印）字符 digit 数字 graph 图形字符 lower 小写字母 print 可打印字符 punct 标点符号 space 空白字符 upper 大写字母 xdigit 十六进制字符 字符类的使用方法tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; 其他参数12345tr [options] set1 [set2]-d # 删除(delete)set1 中的字符-c # tr会将不在set1中的字符转换成set2中的字符,set2只能是一个字符-d -c # 只保留set1的字符，不需要set2-s # 删除重复字符，只留下一个 例子tr命令可以用来加密。ROT13是一个著名的加密算法。在ROT13算法中，字符会被移动13 个位置，因此文本加密和解密都使用同一个函数： 1echo \"tr came, tr saw, tr conquered.\" | tr 'a-zA-Z' 'n-za-mN-ZA-M' 将制表符转换成单个空格： 1tr '\\t' ' ' &lt; file.txt 删除字符 12echo &quot;Hello 123 world 456&quot; | tr -d &apos;0-9&apos; # Hello world 只保留set1 的字符 12echo hello 1 char 2 next 4 | tr -d -c &apos;0-9 \\n&apos;# 124 压缩空格 1echo &quot;GNU is not UNIX. Recursive GNU is not UNIX. Recursive right ?&quot; | tr -s &apos; &apos; cutcut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、 CSV文件或是由空格分隔的文件。 如果空格的长度不一致，需要使结合tr命令，进行字符串转换 每列被称为一个字段，默认分隔符是制表符\\t 1234567-d&quot;\\t&quot; # 指定分割符为&quot;\\t&quot;，默认就是制表符，因此可以不写-f2,3 # 显示2,3列的内容,f2可以不用空格分开-f2-4 # 显示第2到4列(field)的内容，2-5 的用法看后面表格说明-c2-5 # 显示第2到5个字符(character)，注意不能与-d 组合-b2-5 # 显示第2到5个字节(byte)，注意不能与-d 组合--complement # 与-f 组合使用，显示f没有指定的列，就是取反--output-delimiter 指定输出时的列分隔符 12345cut range_fields.txt -c1-3,6-9 --output-delimiter \",\" # abc,fghi # abc,fghi # abc,fghi # abc,fghi 选取方式 说明 N- 从第N个字节、字符或字段开始到行尾 N-M 从第N个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段 -M 从第1个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段 12cut -c -2 range_fields.txt # 打印前2个字符cut -c2-5 range_fields.txt # 打印第2个到第5个字符 文件分割 split1split [options] filename prefix. 将文件分割成固定大小（bytes）或者固定行数的小文件，原文件不动，小文件为prefix.aa prefix.ab等形式，前缀后面最好要有.，如file. 123456-d 使用数字后缀，file.01 file.02，默认为字符后缀-l 指定每个输出文件多少行内容，最后一个文件可能会小于n-b, --bytes=SIZE 指定每个输出文件的大小，如-b100K,大小可以是 KB、MB，GB-C，--line-bytes=SIZE TODO-a 指定后缀长度，默认是2，不指定时程序会自适应--verbose 显示创建文件的信息 sedsed是stream editor（流编辑器）的缩写。它最常见的用法是进行文本替换。默认不修改原文件，只显示修改后的结果。 123456sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]-e &apos;script1;script2&apos;-f script_file # 从文本中读取大量指令，一行一个，以换行结束-i # 保存到原文件-n或--quiet或--silent # 仅显示script处理后的结果。 要是我们想就地（in place）修改文件内容，可以使用选项-i保存到原文件中。值得推荐的做法是 先使用不带-i选项的sed命令，以确保正则表达式没有问题，如果结果符合要求，再加入-i选项将更改写入文件。 也可以使用sed -i.bak &#39;s/abc/def/&#39; file，这时的sed不仅替换文件内容，还会创建一个名为file.bak的文件，其中包含着原始文件内容的副本。 替换s1234s/old/new/ # 替换每行第1个匹配到的字符串s/old/new/2 # 替换每行第2个匹配到的字符串s/old/new/g # 替换全部s/old/new/2g # 只替换第2次及之后匹配到的字符串 12echo thisthisthisthis | sed 's/this/THIS/2g' # thisTHISTHISTHIS 替换标记1s/pattern/replacement/flags 有4种可用的替换标记： 数字，表明新文本只替换每行第几处模式匹配的地方； g，表明新文本将会替换所有匹配的文本； p，表明原先行的内容要打印出来； w file，将匹配到的行替换的结果写到指定的file中。 p替换标记会打印与替换命令中指定的模式匹配的行替换后的结果。这通常会和sed的-n选项一起使用。-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是 只输出被替换命令修改过的行。 123456$ cat data5.txt This is a test line.This is a different line.$ sed -n 's/test/trial/p' data5.txt This is a trial line. w替换标记会产生与 p 模式同样的输出，不过会将输出保存到指定文件中。 分隔符sed命令会将s之后的字符视为命令分隔符。这允许我们更改默认的分隔符/： 12sed &apos;s:text:replace:g&apos; sed &apos;s|text|replace|g&apos; 如果作为分隔符的字符出现在模式中，必须使用\\对其进行转义 指定行方式1（数字）： 在s前添加行编辑即可 123sed '2s/dog/cat/' data1.txt # 只修改地址指定的第2行的文本sed '2,3s/dog/cat/' data1.txt # 只修改地址指定的第2，3行的文本sed '2,$s/dog/cat/' data1.txt # 修改从某行开始的所有行 方式2（正则）： 1sed '/pattern/s/bash/csh/' /etc/passwd # 使用 pattern 正则表达式过滤 已匹配字符串标记（&amp;） 在sed中，我们可以用&amp;指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹 配的内容： 12echo this is an example | sed &apos;s/\\w+/[&amp;]/g&apos;# [this] [is] [an] [example] 子串匹配标记（\\num） 匹配正则中的子表达式，第1 个是\\1，第 2 个是\\2，以此类推 12echo this is digit 7 in a number | sed &apos;s/digit \\([0-9]\\)/\\1/&apos; # this is 7 in a number 多表达式 12345678sed 'expression; expression'sed 'expression' | sed 'expression'sed -e 'expression' -e 'expression'sed -e 'expression; expression'sed -e '&gt; s/brown/green/&gt; s/fox/elephant/&gt; s/dog/cat/' data1.txt 例子 12345echo abc | sed &apos;s/a/A/;s/c/C/&apos;echo abc | sed &apos;s/a/A/&apos; | sed &apos;s/c/C/&apos;echo abc | sed -e &apos;s/a/A/&apos; -e &apos;s/c/C/&apos;echo abc | sed -e &apos;s/a/A/; s/c/C/&apos;# AbC 单引号与双引号的区别 sed表达式通常用单引号来引用。如果想在sed表达式中使用变量，双引号就能派上用场了。 123text=hello echo hello world | sed &quot;s/$text/HELLO/&quot; # HELLO world 多命令如果需要在匹配到的行上执行多条命令，可以用{}将多条命令组合在一起，同时指定过滤的行号，或者匹配模式。 多条命令之间用;分割，或者分成多行书写。 12345678# 一行内多个命令sed -n '/root/&#123;s/bash/blueshell/;p;q&#125;' /etc/passwd # 分成多行执行多个命令sed '3,$&#123;&gt; s/brown/green/&gt; s/lazy/active/&gt; &#125;' data1.txt 插入a与i12sed '[address]command\\new line' 插入（insert）命令（i）会在指定行前插入文本，（插入的文本要带有换行，否则就直接插入在指定行的头部） 附加（append）命令（a）会在指定行后添加文本，（如果文本没换行，会与下一行在同一行） 可以指定一个行地址，匹配一个数字行号或文本模式 这两条命令的费解之处在于它们的格式。它们不能在一行内使用。你必须先输入i或者a，然后使用\\进行换行，接着输入要插入或者附加的内容。 12345678910111213# 脚本中的写法$ echo \"Test Line 2\" | sed '1i\\ # 在第一行前插入Test Line 1\\ # 换行，否则两行文本会在一同一行' Test Line 1 Test Line 2$ echo \"Test Line 2\" | sed '/Line/a\\ # 在包含Line的一行添加Test Line 1\\' Test Line 2 Test Line 1 插入多行插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后 一行。 12345678910sed '1i\\&gt; This is one line of new text.\\&gt; This is another line of new text.' data6.txt This is one line of new text.This is another line of new text.This is line number 1.This is line number 2.This is line number 3.This is line number 4. 删除行 d删除命令d名副其实，它会删除匹配指定寻址模式的所有行。 支持指定行sed &#39;2,3d&#39; data6.txt 通过特定行区间指定：sed &#39;2,3d&#39; data6.txt 模式匹配特性也适用于删除命令sed &#39;/number 1/d&#39; data6.txt 也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。 sed编辑器会删除两个指定行之间 的所有行（包括指定的行）。如果没有找到停止模式，所以就将数据流中的剩余行全部删除了。 你指定的第1个模式 会“打开”行删除功能，第2个模式会“关闭”行删除功能。之后再遇到第1个模式会再打开删除功能。 1234567891011$ cat data7.txt This is line number 1.This is line number 2.This is line number 3.This is line number 4.This is line number 1 again. # 再次触发删除功能This is text you want to keep. This is the last line in the file. $ sed '/1/,/3/d' data7.txt This is line number 4. 字符转换y转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。 1[address]y/inchars/outchars/ 12345678sed 'y/123/789/' data8.txt This is line number 7.This is line number 8.This is line number 9.This is line number 4.This is line number 7 again.This is yet another line.This is the last line in the file. 转换命令会对inchars和outchars值进行一对一的映射。 如果inchars和outchars的长度不同，则sed编辑器会产生一 条错误消息。 转换命令是一个全局命令，你无法限定只转换在特定地方出现的字符。 打印命令 p命令用来打印文本行； 等号（=）命令用来打印行号； l（小写的L）命令用来列出行。 p 命令123echo \"this is a test\" | sed 'p'this is a testthis is a test 它所做的就是打印已有的数据文本 最常见的用法是与-n配合打印包含匹配文本模式的行。用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。 12345678$ cat data6.txt This is line number 1.This is line number 2.This is line number 3.This is line number 4.$ $ sed -n &apos;/number 3/p&apos; data6.txt This is line number 3. 修改前后对比 123456$ sed -n '/3/&#123;&gt; p&gt; s/line/test/p&gt; &#125;' data6.txt This is line number 3. This is test number 3. $ =等号等号命令会打印行在数据流中的当前行号。 12345sed &apos;=&apos; data1.txt 1 The quick brown fox jumps over the lazy dog.2 The quick brown fox jumps over the lazy dog. 12345$ sed -n '/number 4/&#123;&gt; =&gt; p&gt; &#125;' data6.txt 4 This is line number 4. 显示特殊字符l命令（l）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印 字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\\t，来代表制表符。 制表符的位置使用\\t来显示。行尾的美元符表示换行符。 12345$ cat data10.txt This line contains an escape character.$ sed -n 'l' data10.txt This line contains an escape\\tcharacter. \\a 保存命令ww命令用来向文件写入行。该命令的格式如下： 1[address]w filename filename可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文 件的写权限。 地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。 1234567891011$ cat data11.txt Blum, R Browncoat McGuiness, A AllianceBresnahan, C Browncoat Harken, C Alliance $ sed -n '/Browncoat/w Browncoats.txt' data11.txt $ cat Browncoats.txt Blum, R Browncoat Bresnahan, C Browncoat 读取命令读取（read）命令（r）允许你将另一个文件中的数据插入到数据流中。 1[address]r filename 地址区间只能指定单独一个行号或文本模式地址。sed编辑器会将文件中的所有文本行插入到指定地址后。 12345678910111213141516171819$ cat data12.txt This is an added line.This is the second added line. $ sed '3r data12.txt' data6.txt This is line number 1.This is line number 2.This is line number 3.This is an added line.This is the second added line. This is line number 4.$ sed '/number 2/r data12.txt' data6.txt This is line number 1.This is line number 2.This is an added line.This is the second added line.This is line number 3.This is line number 4. 另一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。 1234567891011121314151617$ cat notice.std Would the following people:LIST please report to the ship's captain. $ sed '/LIST/&#123;&gt; r data11.txt&gt; d&gt; &#125;' notice.std Would the following people:Blum, R Browncoat McGuiness, A Alliance Bresnahan, C Browncoat Harken, C Alliance please report to the ship's captain. $现在占位文本已经被替换成了数据文件中的名单。 Join 字段合并根据指定的字段 拼接两个文件。前提是2个文件中指定的拼接字段是排序过的。 拼接字典默认是第一列，可以通过以下方式修改： -12表示第一个文件使用第2个字段进行拼接。 -22表示第二个文件使用第2个字段进行拼接。 12345678910cat aaaa 111bbb 222cat b555 aaa666 bbb777 cccjoin -1 -2 a b 文本编码转换 iconv对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv 命令（这个命令支持更高级的Unicode编码） 1iconv -f ISO-8859-1 -t UTF-8 file 临时文件 mktemp1mktemp [-qu][文件名参数] 参数： -d 创建临时目录 -q 执行时若发生错误，不会显示任何信息。 -u 暂存文件会在mktemp结束前先行删除，不推荐使用 [文件名参数] 文件名参数必须是以”自订名称.XXXXXX”的格式，XXX 会被替换为随机字符串。 12mktemp jizx.XXX# jizx.ztI 磁盘mount默认情况下，mount命令会输出当前系统上挂载的 设备列表。 12mount -t type device directory # 格式说明mount -t vfat /dev/sdb1 /media/disk umount [directory | device ]，umount命令支持通过设备文件或者挂载点来指定要卸载的设备。 在卸载设备时，系统提示设备繁忙，无法卸载设备，可用lsof命令获得使用它的进程信息，在应用中停止使用该设备或停止该进程。 12lsof /path/to/device/nodelsof /path/to/mount/point df与 du TODOdf命令很容易发现哪个磁盘的存储空间快没了 du TODO du命令可以显示某个特定目录（默认情况下是当前目录）的 磁盘使用情况。 压缩命令压缩命令 linux 命令行与 shell 脚本编程大全 4.33 其他命令file 查看文件类型 seq以指定增量从首数开始打印数字到尾数。 123456seq [选项]... 尾数seq [选项]... 首数 尾数seq [选项]... 首数 增量 尾数-f, --format=格式 使用 printf 样式的浮点格式-s, --separator=字符串使用指定字符串分隔数字(默认使用：\\n)-w, --equal-width 在列前添加0，使得宽度相同 案例： 12345678910111213141516171819202122232425$ seq 512345$ seq 5 85678$ seq 5 2 10579$ seq 5 -1 1 # -1 逆序时-1必须存在54321 xargxargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。 它能够捕获一个命令的输出，然后传递给另外一个命令。 args 一般是和管道一起使用。 1somecommand |xargs -item command 选项： 123456789-d delim # 指定分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。-i 或者-I # 配合占位符使用，将参数替换到命令的占位符上，对每一个参数，命令都会被执行一次。 # 个人理解：因为 xargs 默认将参数放在其他命令的最后，但是像 cp 这种需要在中间的位置时，就可以用-I选项，具体看后面的例子。-t # 打印 xargs 后面那个命令拼上参数后的完整形式，然后再执行，用于debug-s # num 指定 xargs 后面那个命令的最大命令行字符数。-0 # 将 \\0 作为定界符。-p # 当每次执行一个argument的时候询问一次用户。-L num # 从标准输入一次读取 num 行送给 command 命令。-n num # 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。 参数的功能分类： 如何分割（xargs、xargs -d、xargs -0） 分割后如何划批（xargs -n、xargs -L） 参数如何传递（xargs -i）。 另外xargs还提供询问交互式处理（-p选项）和预先打印一遍命令的执行情况（-t选项），传递终止符（-E选项） 实验文件准备123456789101112mkdir tmpcd tmprm -fr *mkdir a b c d test logdir shdirtouch \"one space.log\"touch logdir/&#123;1..10&#125;.logtouch shdir/&#123;1..5&#125;.shecho \"the second sh the second line\" &gt; shdir/2.sh cat &lt;&lt;eof&gt;shdir/1.sh &gt; the first sh&gt; the second line&gt; eof 流程讲解先分割，再分批，然后传递到参数位 预处理管道传递过来的stdin经过xargs处理后的：将所有空格(多个空格)、制表符和分行符都替换为(一个)空格并压缩到一行上显示，这一整行将作为一个整体，这个整体的所有空格属性继承xargs处理前的符号属性. 如果想要保存制表符、空格等特殊符号，需要将它们用单引号或双引号包围起来，但是被xargs处理后，一行的整体中单双引号（和反斜线）都会被去掉。 分割文本意义上的符号和标记意义上的符号 在解释xargs和它的各种选项之前，先介绍一个贯穿xargs命令的符号分类：文本意义上的空格、制表符、反斜线、引号和非文本意义上的符号。我觉得理解它们是理解xargs分割和分批原理的关键。 文本意义上的空格、制表符、反斜线、引号：未经处理就已经存在的符号，例如文本的内容中出现这些符号以及在文件名上出现了这些符号都是文本意义上的。 与之相对的是非文本意义的符号，由于在网上没找到类似的文章和解释，所以我个人称之为标记意义上的符号：处理后出现的符号，例如ls命令的结果中每个文件之间的制表符，它原本是不存在的，只是ls命令处理后的显示方式。还包括每个命令结果的最后的换行符，文件内容的最后一行结尾的换行符。 两种分批可能： 指定-n时按空格分段，然后划批，不管是文本意义的空格还是标记意义的空格，只要是空格都是-n的操作对象 指定-L或者-i时按段划批，文本意义的符号不被处理，比如one space.txt这个文件不会被分割。 123ls | xargs -n 2ls | xargs -L 2ls | xargs -i -p echo &#123;&#125; 如果在一个xargs中使用了多个分批选项，则它们之间必然会冲突，它们的规则是写在后面的生效，前面的分批选项被忽略。 -d 整体执行的过程： 替换：将所有标记符号替换为\\n，完成后所有符号(空格、制表符、换行符)都是文本符号 分段：根据分隔符进行分段、并用空格分开每段。由于分段前所有符号都是文本符号，因此分段后的文本中可能包含空格、制表符、换行符。也就是说除了-d 导致的分段空格，其余的所有符号都是分段中的一部分 输出：最后根据-n、-L、-i指定的分批选项来输出。 -0等价于-d&quot;\\0&quot;，-0可以处理接收的stdin中的null字符（\\0）。如果不使用 -0选项或- -null选项，检测到\\0后会给出警告提醒，并只向命令传递非\\0段。 分批行为分批用于指定每次传递多少个分段。有三种分批选项：-n，-L和-i。 -n 默认以空格分段划分，与-d、-0一起时，按指定的分隔符分段划分 -L 永远是按段划分的 -i 如果不使用-i，则默认是将分割后处理后的结果整体传递到命令的最尾部。但是有时候需要传递到多个位置，不使用-i就不知道传递到哪个位置了。例如重命名备份的时候在每个传递过来的文件名加上后缀.bak，这需要两个参数位。 1ls logdir/ | xargs -i mv ./logdir/&#123;&#125; ./logdir/&#123;&#125;.bak # 将分段传递到多个参数位 分批的典型应用分批选项有时特别有用，例如脚本规定每次只能传输三个参数。有时候rm -rf的文件数量特别多的时候会提示参数列表太长而导致失败，这时就可以分批来按批删除。 假设目前在/tmp/longshuai/下有29W个.log文件，如果直接删除将会提示参数列表过长。 1ls | xargs -n 10000 rm -rf 终止行为之 ：xargs -E -E会将结果空格、制表符、分行符替换为空格并压缩到一行上显示。据我测试，-E似乎只能和独立的xargs使用，和-0、-d配合使用时都会失效。 -E优先于-n、-L和-i执行。如果是分批选项先执行，则下面的第二个结果将压缩在一行上。 指定的终止符必须是完整的，例如想在遇到“xyz.txt”的符号终止时，只能指定完整的xyz.txt符号，不能指定.txt或者txt这样的符号。 分两种情况：如果没指定分批选项或者指定的分批选项是-n或者-L时，则段是以空格为分割符，两个空格之间的段都是完整的。 如果指定的分批选项是-i，则以段为分割符。 1234567891011121314151617181920212223242526272829303132333435lsa b c d logdir one space.log shdir sh.txt test vmware-root x.txtls | xargs -E one #不指定分批选项a b c d logdirls | xargs -n 2 -E one #指定-n，one后面的所有的都终止传递a bc dlogdirls | xargs -L 2 -E\"one\" #同-n 选项a bc dlogdirls | xargs -i -E\"one space.log\" echo &#123;&#125; #和-i配合使用时指定完整的段才可以abcdlogdirls | xargs -i -E\"one\" -p echo &#123;&#125; #非完整段终止失效echo a ?...echo b ?...echo c ?...echo d ?...echo logdir ?...echo one space.log ?...echo shdir ?...echo sh.txt ?...echo test ?...echo vmware-root ?...echo x.txt ?... 总结 分割行为 标记符号处理方式 分段方法 分批方法 xargs 空格、制表符、分行符替换为空格，引号和反斜线删除。处理完后只有空格。如果空格、制表符和分行符使用引号包围则可以保留 结果继承处理前的符号性质（文本符号还是标记符号） -n以分段结果中的每个空格分段，进而分批。不管是文本还是标记意义的空格.-L -i以标记意义上的空格分段，进而分批 xargs -d 不处理文本符号，所有标记符号替换为换行符\\n，将-d指定的分割符替换为标记意义的空格。结果中除了最后的空行和-d指定的分割符位的分段空格，其余全是文本意义上的符号 按照-d指定的符号进行分段，每个段中可包含文本意义上的空格、制表符、换行符。 以标记意义上的符号（即最后的空行和-d指定分隔符位的空格）分段，进而分批。分段结果中保留所有段中的符号，包括制表符和分行符。 xargs -0 不处理文本意义上的符号，将非\\0的标记意义上的符号替换为\\n，将\\0替换为空格。 以替换\\0位的空格分段，每个段中可能包含文本意义上的空格、制表符、换行符。 检测到\\0时，以标记意义上的符号（即最后的空行和\\0位的空格）分段，进而分批。分段结果中保留所有段中的符号，包括制表符和分行符。未检测到\\0时，整个结果作为不可分割整体，使用分批选项是无意义的 多进程只要能分批的选项，都可以使用”-P”，包括”-n”、”-L”和”-i”。 使用xargs的分批行为，除了可以解决一些问题，还可以一次性将多个分批交给不同进程去处理，这些进程可以使用多个cpu执行，效率可谓大幅提高。 “-P N”选项可以指定并行处理的进程数量为N。不指定”-P”时，默认为1个处理进程，也就是串行执行。指定为0时，将尽可能多地开启进程数量。 xargs与文件名由于xargs默认将空格作为分隔符，所以不太适合处理文件名，因为文件名可能包含空格。 find命令有一个特别的参数-print0，指定输出的文件列表以null分隔。然后，xargs命令的-0参数表示用null当作分隔符。 12&gt; $ find /path -type f -print0 | xargs -0 rm&gt; xargs与复杂命令如果xargs要将命令行参数传给多个命令，可以使用-I参数，并配合sh -c 执行命令 -I指定每一项命令行参数的替代字符串。 123456789101112$ cat foo.txtonetwothree$ cat foo.txt | xargs -I file sh -c 'echo file; mkdir file'one twothree$ ls one two three 我们希望对每一项命令行参数，执行两个命令（echo和mkdir），使用-I file表示file是命令行参数的替代字符串。执行命令时，具体的参数会替代掉echo file; mkdir file里面的两个file。 xargs与重定向如果脚本中包含重定向的命令，那么整个命令必须用双引号扩起来，如果双引号里面有$需要用\\来转义，就比如下面的$5 1seq 5 10 |xargs -i sh -c \"awk -F\\$'\\t' '\\$5==&#123;&#125;' file &gt; file_part_&#123;&#125;\" 不过awk本身支持将不同的内容保存到不同的文件中 1awk 'NR!=1&#123;print $4,$5 &gt; $6&#125;' netstat.txt xargs的限制其实是xargs的限制和缺点，但因为通过”-i”选项方便演示，所以此处使用”-i”选项。注意，不是”-i”选项的缺陷。 由于xargs -i传递数据时是在shell执行xargs命令的时候，根据shell解析命令行的流程 ，xargs后的命令如果有依赖于待传递数据的表达式，则无法正确执行。 第一：无法通过xargs传递数值做正确的算术扩展： 12echo 1 | xargs -I &quot;x&quot; echo $((2*x))0 第二：无法将数据传递到命令替换中。 12echo /etc/fstab | xargs -i `cat &#123;&#125;` cat: &#123;&#125;: No such file or directory 参考下图的shell命令行解析过程。 这时要通过xargs正确实现目标，只能改变方法或寻找一些小技巧，例如： 123[root@xuexi ~]# echo 1 | xargs -i expr 2 \\* &#123;&#125; # 感谢楼下评论者提供的expr思路2[root@xuexi ~]# echo /etc/fstab | xargs -i cat $(echo &#123;&#125;) 第三：xargs无法处理bash内置命令。例如： 12[root@xuexi ~]# echo /etc | xargs -i cd &#123;&#125;xargs: cd: No such file or directory 例子复制所有图片文件到 /data/images 目录下： 123ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images# ls 出来的每一行文件名，都会通过 xargs 传递给 cp 命令 统计一个源代码目录中所有 php 文件的行数： 1find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l 删除带空格的文件删除带空格的文件名，思路是让找到的“one space.log”成为一个段，而不是两个段。我给出了常见的两种。 方法一：通过常用的find的-print0选项使用\\0来分隔而不是\\n分隔，再通过xargs -0来配对保证one space.log的整体性。因为-print0后one space.log的前后各有一个\\0，但是文件名中间没有。 1[root@xuexi tmp]# find -name &quot;* *.log&quot; -print0 | xargs -0 rm -rf 当然，能使用-0肯定也能使用-d了。 1[root@xuexi tmp]# find -name &quot;* *.log&quot; -print0 | xargs -d &quot;x&quot; rm -rf #随意指定非文件名中的字符都行，不一定非要\\0 方法二：不在find上处理，在xargs上处理，只要通过配合-i选项，就能宣告它的整体性。 1[root@xuexi tmp]# find -name &quot;* *.log&quot; | xargs -i rm -rf &quot;&#123;&#125;&quot; 相较而言，方法一使用的更广泛更为人所知，但是方法二更具有通用性，对于非find如ls命令也可以进行处理。 还可以使用tr将find的换行符换成其他符号再xargs分割配对也行。 除了find -print0可以输出\\0字符，Linux中还有其他几个命令配合参数也可以实现：locate -0,grep -z或grep -Z,sort -z等。 其他小例子 1234567891011# cat test.txt | xargs -n3a b cd e fg h ij k l# echo \"nameXnameXnameXname\" | xargs -dXname name name name 参考：https://www.cnblogs.com/f-ck-need-u/p/5925923.html#auto_id_4 http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html teetee命令可以把数据重定向到给定文件和屏幕上，相当于分流了 1-a：向文件中重定向时使用追加模式； scpTODO scp 的完整命令 scp免密码 在A中执行命令： 1ssh-keygen -t rsa -P &quot;&quot; 这会在 ~/.ssh 目录下生成两个文件：id_rsa 和 id_rsa.pub 拷贝A的id_rsa.pub到B： 1scp ~/.ssh/id_rsa.pub yliu@192.168.200.1:/home/yliu 登录B，并把id_rsa.pub输入到B的authorized_keys文件中： 1cat /home/yliu/id_rsa.pub &gt;&gt; /home/yliu/.ssh/authorized_keys 最后一步：如果是第一次生成authorized_keys，需要授权：chmod 600 authorized_keys 大功告成！此时在复制文件就无需输入密码了。而且，在A中ssh登录B也无需密码了。 反之亦然，在B中设置A的免密码登录完全一样，在此不做赘述。 其他知识点一行内指令一行内指定依次运行的一系列指令 1$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls 命令行中输入tab我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在sort -t选项后输入字符），你可以先按`Ctrl-V`，然后再按Tab键，就可以输入字符了。当然，你也可以使用$&#39;\\t&#39;。 EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。 参考：https://awk.readthedocs.io/en/latest/chapter-one.html","categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"}],"tags":[{"name":"awk","slug":"awk","permalink":"https://jizx.vip/tags/awk/"},{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"},{"name":"ing","slug":"ing","permalink":"https://jizx.vip/tags/ing/"},{"name":"命令","slug":"命令","permalink":"https://jizx.vip/tags/命令/"}]},{"title":"photoshop曲线原理与应用","slug":"photoshop曲线原理与应用","date":"2018-12-18T08:04:13.000Z","updated":"2018-12-18T08:12:03.336Z","comments":true,"path":"2018/12/18/photoshop曲线原理与应用/","link":"","permalink":"https://jizx.vip/2018/12/18/photoshop曲线原理与应用/","excerpt":"转载poco：photoshop曲线原理与应用，https://www.jb51.net/photoshop/532386.html","text":"转载poco：photoshop曲线原理与应用，https://www.jb51.net/photoshop/532386.html 关键句：可以看到S型曲线中间部分，输入和输出值变化很小。所以S曲线在中间调区域的影响并不大，很好的保护了照片细节最丰富的部分。白色和黑色区域在最两端，S型曲线对这些亮度区域的改变也不大，有效防止了过曝和欠曝溢出。 零、曲线工具原理如果说直方图是摄影师的“X光片”，那么曲线工具一定是摄影师的“手术刀”了。 曲线作为重要的影调和色调调整工具，不仅存在于Photoshop中，在ACR，Lightroom甚至其他很多手机P图软件中都占据着显眼的位置。本篇文章，就将详细谈谈什么是RGB曲线，如何使用提亮压暗、黑白场、对比度，以及局部调整曲线等基本形态，调整一张照片的影调。同时，还会讲解如何把各种基本曲线形态组合起来，达到胶片、漂白、日系等等更复杂的影调效果。 曲线工具在哪? 曲线面板在Lightroom和Adobe Camera Raw工具中，都是紧接着基本面板的第二个面板，足以感受到它的重要性。 在Photoshop中，我们一般会使用曲线调整图层来改变曲线。在PS中图层面板的右下角，第四个图标就是“新建调整图层”选项，点击后选择“曲线”，我们就可以新建一个“曲线调整图层”。 新建调整图层，而不是在原图层上直接改变曲线。优点就是可以让我们方便的撤销/恢复所做的任意调整。曲线是什么? 本文将重点讲解RGB通道曲线，它是由红(R)绿(G)蓝(B)三个通道的曲线叠加而成的，可以“近似的”理解成图片的亮度曲线。 RGB曲线调整的核心其实就是对原图亮度的变换。 曲线的横轴是原图的亮度分布，从左到右依次是0值纯黑，1-254的中间灰色值，以及最右边255的纯白最亮值。横轴上叠加着一个直方图，显示出原图各个亮度上，分别存在着多少像素。 曲线的纵轴是目标图(调整后)的亮度，从下到上任然是0-255的亮度值。当中的那根线就是我们的“曲线”。当我们在曲线上任意取一个点，它的“输入值”就是它横轴对应的值，即原图中的亮度，它的“输出值”就是它纵轴中的数值，也就是调整后它的亮度值。 未调整的情况下，图像的曲线会是一条对角线，也就是横轴(原图)和纵轴(目标图)的亮度值相等。比如我在曲线上取了一个点，它的输入和输出值都是193。 如果我把这个点往上移动，可以看到这个点的输出值变成了232.这意味着原图直方图上那些193亮度的点，都被提亮到了更亮的232。同时我们可以发现曲线的一个特点，当我们变动一个点的时候，旁边的点也会跟着一起变化，离调整点越远的点变化越小。这样使得曲线调整的图片，大多数情况都比较的平滑自然。 通过在曲线上添加控制点(锚点)，我们就可以把曲线变成各种各样的形态，从而达到我们想要的影调效果。接下来我就会通过一些基本的曲线形态，来进一步的解释曲线。 一、提亮压暗曲线提亮和压暗一张图片，并不是我们想象中的对图片中所有点都加大减小同样的亮度值。比如下面这个曲线，就是把图像上所有的点亮度都提高了64。这样造成了2个不好的结果： (1)图片的高光区域直接过曝溢出了 (2)图片的阴影和黑色区域亮度大大提高，使得图片黑场不足，严重发灰。 所以我们一般提亮图片都是用如下的曲线，把锚点放在中间调附近往上提。这样照片主要是中间调的亮度大幅提高。高光区域亮度提高较少，防止了过曝。阴影黑色区域提升也不多，较好的维持了图像的对比反差程度。 同样的，我们要压暗一张图片，也是用描点下拉图片的中间调。保护阴影区域不欠曝，让高光白色区域维持住对比度。 二、黑白场曲线我们把照片上最暗的点叫做黑场，最亮的点叫做白场，黑白场的差值决定了一张照片的反差程度。通过横移和竖移曲线的左右两端，就可以加大和减小照片的黑白场差值。 比如下面这张图片就是一张灰蒙蒙的低反差图片，照片最暗的地方也只是亮度高达50多的深灰色，照片最亮的地方也只是200多的浅灰色。照片的黑色和白色区域完全没有像素。 所以我把曲线最右侧横向左移，此时原来亮度值(输入值)219的像素，全部被提亮到了255(输出值)的纯白色。照片中终于有了亮白的部分。 同样我在曲线最左侧建立一个锚点，横向右拉，此时原来亮度值55的深灰色区域，就全部输出成了亮度为0的纯黑区域。照片中又有了深黑色。通过这两步，我们加大了照片黑白场的差距，照片的反差就大大提高了。 黑白场差值大的图片一般层次丰富，鲜艳锐利。但是照片的黑白场差值并不是越高越好。一个很大的误区就是照片的黑场一定要是0，白场必须为255。实则不然，比如这张照片，照片的黑场是0，照片中有许多深黑区域，显得反差比较大，可能并不是我们想要的效果。 我在曲线最左侧建立一个锚点，纵向上拉。这样输入值为0的纯黑部分，亮度被提高到了38。照片中不再有纯黑，最暗的部分(也就是黑场)也是亮度38的深灰色，这样的照片看起来更加的朦胧淡雅，符合我们想要的气氛。 三、对比度曲线对比度曲线，其实就是摄影里几乎人人皆知的S型曲线和反S型曲线了。 增强对比度曲线(S型曲线)，其实就是在高光处建立锚点并提高，在阴影处建立锚点并降低，拉出一个像英语字母S一样的曲线。 仔细观察S曲线，或许我们就能理解到其背后的原理。前面的教程我们提到过，一张照片按亮度从低到高分为黑色，阴影，中间调(曝光度)，高光和白色5个部分。其中中间调区域的过渡与细节最为细腻。可以看到S型曲线中间部分，输入和输出值变化很小。所以S曲线在中间调区域的影响并不大，很好的保护了照片细节最丰富的部分。白色和黑色区域在最两端，S型曲线对这些亮度区域的改变也不大，有效防止了过曝和欠曝溢出。S曲线主要是提高了原来照片中高光部分的亮度，降低了阴影部分的亮度，让照片的影调更加偏向硬调。因此S曲线在保护黑白色与中间调细节的前提下，有效的提高了照片的对比度，几乎成为了大部分照片必用的一步。 类似的，如果我们降低高光锚点，提高阴影锚点，形成一个反S的形状。就是降低对比度曲线了。 四、曲线的局部调整前面三个曲线形态都是作用在照片的全局。但数码后期的一个核心思路，就是局部调整照片不同的区域，让每个区域在展现出最好效果的同时不要影响到其他区域。比如这张图片，雪山和湖之间的草地一片漆黑，需要提亮。 如果我直接应用提亮曲线，草地倒是变亮了，但雪山(高光部分)和天空(中间调部分)一下子就过曝了。 所以我需要建立两个锚点，把提亮的高光和中间调部分重新拉回来。这样这条曲线就只提高了照片阴影部分的亮度。 在局部调整曲线时，有一个非常有用的工具。就是圆圈中那个手一样的图标，点击它之后再把鼠标移动到图像里面，鼠标就会变成一个吸管，同时在右边曲线面板里，会实时显示吸管所在点对应在曲线里的位置。单击吸管，吸管所在的点，就会对应成一个锚点记录在直方图上，方便我们调整。比如这张图，我想降低深色的山体的亮度，同时又保持住白色雾气的亮度。所以我选择“手”图标后，先在红圈1的山体处点一下，曲线中对应建立了1锚点。再在雾气的红圈2处点一下，曲线中就建立了对应的2锚点。 这样我下压1锚点，同时保持住2锚点，就只降低了阴影的山体区域，而高光的雾气则没有被影响。 在上面讲了RGB曲线是什么。通过提亮压暗曲线，黑白场曲线，对比度曲线三种基本形态，以及对他们的局部应用，就可以快速的调整一张照片的影调了。接下来谈谈如何把这几种基本曲线组合起来，调出复杂的影调效果。 同样的，三种基本曲线虽然看起来都很简单，但当我们把这些基本形态结合起来的时候，却可以创作出丰富多样的复杂效果。 五、暗调效果曲线下图是一张英国七姐妹白崖的照片，如果我们想让它更加的阴沉，仿佛世界尽头一样。应该怎么调整呢? 直接运用我们学过的压暗曲线，可以发现照片的中间调已经达到了我们想要的低沉影调。 但是这样的话暗部几乎一片漆黑，失去了细节。所以我在暗部再增加一个锚点上拉，相当于在暗部又局部的应用了提亮曲线。 这样虽然暗部细节回来了，但是阴影部分发灰严重，乌云已经完全失去了立体感。所以再在暗部建立2个锚点，叠加上一条S型曲线，提高暗部的对比度。可以发现天上的乌云内部的层次对比又展现了出来。 最后在高光区也建立一个锚点上拉，相当于在高光部分叠加了一个局部提亮曲线，重新恢复了高光的亮度。 这张暗调照片的最后曲线=全局压暗曲线+暗部提亮曲线+暗部增加对比度曲线+亮部提亮曲线。看起来很复杂，其实只要理解了原理非常简单，三种基本曲线的一步步的叠加应用而已。 六、胶片效果曲线下图是一张泰国美功铁路市场的照片，如果我们想让它更有胶片味儿。应该怎么调整呢? 最简单的办法就是直接套用PS里的颜色查找表(3D-Lut)工具或者使用各种第三方胶片滤镜了。各种预设好的胶片LUT，可以快速的让图片带上不同类型胶片的影调和色调。不过其实这些效果也是可以通过曲线来完成的。仔细观察下面这张套用 柯达5218胶片 LUT 的成片效果，可以发现它的直方图在保持对比度的同时有一个明显的右移，黑色区域完全没有像素。发灰的暗部给了我们一种照片暗部细节非常丰富的错觉，看起来就像是用高宽容度的胶片拍摄的。 要消除直方图中的黑色像素很简单，使用我们学过的黑白场曲线，(竖直向上)提高照片的黑场锚点即可。 不过这样不仅照片的暗部发灰，中间调和高光也变灰了。所以为了恢复对比度，我再在上面曲线的基础上拉一个S型曲线(增加对比度曲线)。这样这张照片就获得了很多胶片类似的影调，暗部发灰但对比度又很足。 之后我们可以继续应用可选颜色、渐变映射、色相饱和度等等调色工具，给照片加上胶片的色调，这些色彩调整工具会在以后的教程中继续展开。 这里的胶片曲线=提高黑场曲线+增强对比度曲线。我们并不需要记忆这个公式，因为有的胶片效果反而是需要减少对比度的。只要理解了三种基本的曲线形态，各种各样的效果我们都是可以组合出来的。 七、压黑漂白效果曲线 压黑漂白效果很适合运动类，主体硬朗，以及感情强烈的片子。其特点如下图所示，有大量的纯黑或者纯白区域，反差强烈。 下面是这张道路上飞驰的装甲车的原片，反差不够强烈，无法体现出装甲战士带给我们的冲击力。 使用黑白场曲线右移黑场锚点，照片中很暗的部分全部都变成了纯黑。黑色倒是足够了，但黑白场曲线的副作用就是把整个图片都压黑了。 所以在亮部建立锚点，用提亮曲线提高高光和中间调，营造硬朗的反差效果。这种扩大纯黑并提亮亮部的效果就称为压黑(Crushed Black)效果。 与压黑类似的还有漂白效果。顾名思义，漂白效果就是照片整体提亮，白色溢出，同时暗处也变亮并压缩成深灰色，仿佛照片印在纸上再放进漂白水里漂白出来一样。 漂白曲线的前两部跟压黑曲线一样，先是把暗部变成纯黑，同时提亮照片。 漂白效果会进一步让高光也溢出成白色，虽然丢掉细节，但是照片会更有明快动感的气氛。在曲线中可以通过左移白场锚点实现这个效果。 最后我们把黑场的点再上移一段距离，可以理解成刚刚压缩成纯黑的暗部，提亮成了同一种深灰色。 总结可以看到，不管是胶片曲线，暗调曲线，还是压黑漂白曲线，无论多么复杂的效果。其本质任然是提亮压暗，黑白场和对比度这3种基本曲线，在整体和各个局部组合而成的，所以我们并不需要死记硬背这些复杂效果的曲线长什么样。只要理解了三种基本曲线形态的作用，就可以根据需要，组合出自己想要的各种影调效果了。 PS曲线不仅可以调整照片的影调，各个色彩通道的曲线还可以影响照片的色调，这些就只能在未来的教程中继续展开了。","categories":[{"name":"photoshop","slug":"photoshop","permalink":"https://jizx.vip/categories/photoshop/"}],"tags":[{"name":"photoshop","slug":"photoshop","permalink":"https://jizx.vip/tags/photoshop/"},{"name":"曲线","slug":"曲线","permalink":"https://jizx.vip/tags/曲线/"}]},{"title":"正则表达式必知必会","slug":"正则表达式必知必会","date":"2018-12-18T06:48:00.000Z","updated":"2020-09-10T14:51:41.697Z","comments":true,"path":"2018/12/18/正则表达式必知必会/","link":"","permalink":"https://jizx.vip/2018/12/18/正则表达式必知必会/","excerpt":"正则表达式必知必会的笔记","text":"正则表达式必知必会的笔记 元字符表下面介绍的是在正则表达式中有特殊意义的字符，称为元字符 转义符号如果要查找这些字符本身，需要用\\进行转义，比如想匹配点号. 就需要这样写\\. 有个特殊的例子：如果想匹配\\就需要这样\\\\ 匹配单个字符匹配字符中的一个 .： 匹配任意一个字符（除了换行符） []： 匹配多个字符中的一个 自定义字符：[akm]，匹配a、k、m中的一个 字符区间：[ASCII1-ASCII2]，可以是ASCII中的任意字符作为起始字符（ASCII1小于ASCII2），常用的有：[a-z]、[A-Z]、[0-9]、[A-Za-z]（可以有多个字符区间） 取反操作：[^a-z] 表示匹配不是a到z的任意字符，^的作用效果是整个区间，而不仅仅是跟在其后的字符 -是一个元字符，表示区间，不会匹配减号，因此不需要转义 ^是一个元字符，表示在[ ]中表示非匹配，不会匹配到^，因此不需要转义 匹配空白字符也就是不可见的字符 符号 用途 \\f 匹配一个换页符。 \\n 匹配一个换行符。 \\r 匹配一个回车符。 \\t 匹配一个制表符。 \\v 匹配一个垂直制表符。 匹配特定一类的字符不可见字符 符号 用途 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [ ^\\f\\n\\r\\t\\v]。 数字 \\d 等价于[0-9] \\D 等价于[^0-9] 字符匹配大小写字母、数字、下划线 \\w 等价于[a-zA-Z0-9_] \\W 等价于[^a-zA-Z0-9_] 匹配中文需要切换匹配模式为‘u’，表示要匹配的内容为unicode编码内容,汉字的unicode起始编码是：0x4e00—0x9fa5，因此要匹配全部为中文的正则为：$patern = &quot;/[\\x{4e00}-\\x{9fa5}]/u&quot; 或匹配“|”的一个坑正则是从前向后进行匹配的，因此如果文本是餐饮店，而正则是餐|餐饮 或餐饮|餐 ，那就谁在前就先匹配到谁，因此结果分别是：餐、餐饮 但是，如果正则是饮店|店或店|饮店呢，他们的结果都是饮店，原因就是从先向后扫描时，饮店这个字会先触发，完成匹配，而不会再取匹配店了。 重复匹配 符号 用途 + 出现1至多次 * 出现0至多次 ？ 出现0或1次 {n} 精确控制出现n次 {n,m} 区间控制，出现n至m次 {n,} 至少出现n次 贪心匹配+、*、{n,}会贪婪的进行匹配，比如下面的例子： 1&lt;b&gt;text1&lt;/b&gt; &lt;b&gt;text2&lt;/b&gt; &lt;[Bb]&gt;.*&lt;/[Bb]&gt; 会匹配着整体字符串，而不是两个&lt;b&gt;text1&lt;/b&gt; &lt;b&gt;text2&lt;/b&gt; 因此需要懒惰匹配 ： &lt;[Bb]&gt;.*?&lt;/[Bb]&gt; 会匹配到两个&lt;b&gt;text1&lt;/b&gt; &lt;b&gt;text2&lt;/b&gt; 贪婪版 懒惰版 * *？ + +？ {n,} {n,}？ 位置匹配单词边界（boundary）\\b：匹配单词的开始或者结束位置，也就是单词边界：单词和符号之间的边界 单词可以是中文字符,英文字符,数字 符号可以是中文符号,英文符号,空格,制表符,换行 具体来说：\\b匹配的位置是这样的位置，这个位置位于一个能够用来构成单词的字符（\\w）和一个不能用来构成单词的字符（\\W）之间 例子： \\bcat\\b 可以匹配到 the cat catcat 中的第一个cat，因为它前面与后面都有一个单词，因此存在单词分隔符，而不会匹配到后面的catcat 这里有个一开始看不懂的例子： 123456# 为什么cat匹配不到，因为cat是单词，它前面与后面都有一个单词，因此存在单词分隔符&gt;&gt;&gt; re.findall(r&quot;\\Bcat\\B&quot;,&quot;the cat cao&quot;)[]# -却能匹配到，因为-不是单词，所以尽管它前后都有单词，但与-之间不存在单词分割符（除了-，其他\\W也是一样的）&gt;&gt;&gt; re.findall(r&quot;\\B-\\B&quot;,&quot;color - code&quot;)[&apos;-&apos;] 注意：java与python中有个地方不同，一个匹配失败，一个成功 12345678910String str = \" 2 \";String rex = \"\\b2\\b\";Pattern pattern = Pattern.compile(rex);Matcher matcher = pattern.matcher(str);if (matcher.matches()) System.out.println(\"匹配成功\");else System.out.println(\"匹配不成功\"); // 这是结果 1234&gt;&gt;&gt; s=\" 2 \"&gt;&gt;&gt; m=re.search(r'\\b2\\b',s)&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(1, 2), match='2'&gt; 字符串边界 符号 用途 ^ 默认模式下：匹配整个字符串开始位置；在多行模式下：可以匹配换行符后的开始位置 $ 默认模式下：匹配整个字符串结束位置；在多行模式下：可以匹配换行符后的结束位置 子表达式（分组）用()将正则表达式括起来的就是子表达式，子表达式可以嵌套 例子： 年份 1219|20\\d&#123;2&#125; 错误，这会匹配19或者20xx(19|20)\\d&#123;2&#125; 正确 IP 12345678* 任意的1位或2位数字* 任意的以1开头的3位数字* 任意的以2开头，0-4为第二位的3位数字* 以25开头，第3位数字是0-5的3位数字如下，实现了匹配上面的合法的0-255之间的数字(\\d&#123;1,2&#125;) | (1\\d&#123;2&#125;) | (2[0-4]\\d) | (25[0-5]) 因此匹配IP的正则如下：(((\\d&#123;1,2&#125;)|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(25[0-5]))\\.)&#123;3&#125; ((\\d&#123;1,2&#125;)|(1\\d&#123;2&#125;)|(2[0-4]\\d) |(25[0-5])) 子表达式嵌套使用的是深度优先搜索，以下面的例子来解释： group(0)代表整个正则表达式 group(1)代表第1个子表达式，也就是最外层的括号 group(2)代表第2个子表达式 123456789101112131415161718&gt;&gt;&gt; s=&quot;jizx333hhhh&quot;&gt;&gt;&gt; m=re.search(r&quot;((\\w+?)(\\d(\\d(\\d)))(\\w&#123;4&#125;))&quot;,s)&gt;&gt;&gt; m.group(0)&apos;jizx333hhhh&apos;&gt;&gt;&gt; m.group(1) # 上图中的根节点&apos;jizx333hhhh&apos;&gt;&gt;&gt; m.group(2)&apos;jizx&apos;&gt;&gt;&gt; m.group(3)&apos;333&apos;&gt;&gt;&gt; m.group(4)&apos;33&apos;&gt;&gt;&gt; m.group(5)&apos;3&apos;&gt;&gt;&gt; m.group(6)&apos;hhhh&apos;&gt;&gt;&gt; m.group(7)IndexError: no such group 不保存分组?:(:X)在正则中表示所匹配的子组X不作为结果输出，称为非捕获分组，不想被捕获的时候使用，可以提高程序执行速度 正常情况(X)中的X会被作为新增的一个组序号输出，比如(A)(B)，A的序号1，B的序号2如果(?:A)(B)，A将没有序号不输出，B的序号为1 12345678910111213import retext=\"我的电话是1234567890\"pat1=r\"(\\d&#123;3&#125;)(\\d&#123;3&#125;)(\\d&#123;4&#125;)\"pat2=r\"(?:\\d&#123;3&#125;)(\\d&#123;3&#125;)(\\d&#123;4&#125;)\"match=re.search(pat1,s)print(match.groups())match=re.search(pat2,s)print(match.groups())# ('123', '456', '7890')# ('456', '7890') python中的一个坑python中split方法，在匹配部分加上括号 ()之后所切出的结果是不同的，匹配模式加括号表示保留匹配到的分隔子串 123456import reres=re.split(\"\\|\" , ' runoob|runoob|runoob.')# [' runoob', 'runoob', 'runoob.']res=re.split(\"(\\|)\" , ' runoob|runoob|runoob.') # 添加括号，会保留分割符# [' runoob', '|', 'runoob', '|', 'runoob.'] 如果你不想保留分割字符串到结果列表中去，但仍然需要使用到括号来分组正则表达式的话， 确保你的分组是非捕获分组，形如 (?:pattern) 回溯引用回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式。 \\0表示整个正则表达式、\\1表示第一个子表达式、\\2表示第二个子表达式，以此类推 12this is is a apple,and and I like it it.[ ]+(\\w+)[ ]+\\1 匹配重复出现两次的单词，\\1表示的就是(\\w+) 子表达式(分组)命名除了使用上面\\1 、\\2的方式，来引用子表达式，还可以为子表达式命名，然后引用。 为子表达式命名：(?P&lt;name&gt; rexp) 引用子表达式：(?P=name) 例子： 匹配单、双引号包围的字符串 文本： 1she said: &quot;I love you&quot;,and he replied &apos;me,too&apos; 正则表达式：(?P&lt;quote&gt;[&#39;&quot;]).*?(?P=quote) 等价于([&#39;&quot;]).*?\\1 结果： she said: “I love you”,and he replied ‘me,too’ 使用回溯替换将电话格式进行修改： 文本： 我的电话是1234567890 搜索表达式： (\\d{3})(\\d{3})(\\d{4}) 替换表达式： \\1***\\2 结果： 我的电话是123***7890 Javascript 在搜索表达式中使用\\1，在替换表达式中使用$1来获取引用 使用回溯进行大小写不过支持该用法的不多（java不支持） 12345\\E end，表示大小写转换的结束范围\\l low，表示把下一个字符转为小写\\L Low，表示把\\L与\\E之间的字符转为小写\\u up，表示把下一个字符转为大写\\U Up，表示把\\U与\\E之间的字符转为大写 举例： 搜索正则表达式&lt;([Hh][1-6])&gt;(.*?)&lt;/\\1&gt; 替换正则表达式&lt;$1&gt;\\U$2\\E&lt;$1&gt; 注意：字母有大小写之分，文字没有。 前后查找向前查找、向后查找实际上都是子表达式。它们查找满足条件的字符串，但忽略掉其中指定的部分（不消费）。 具体理解是：从字符串开始位置，有一个光标，光标每向前移动一次，就在光标所在的位置之前或之后判断某些字母是否符合条件，如果符合，就把光标所在位置之前的字符串返回，但忽略子表达式匹配到的字符串 区别是： 向前查找：真正需要的是前面部分的字符串( http: )。 向后查找：真正需要的是后面部分的字符串( $400 )。 向前查找模式的长度是可变的，可以包含.和+之类的元字符 向后查找模式只能是固定长度的。（个人理解为：如果不是固定长度的话，可能会把后面需要输出的部分给隐藏起来） 正向向前查找（大部分语言支持）(?=需要匹配但不在结果中的正则表达式) 向前查找指定了一个必须匹配但不在结果中返回的模式，正向是指等于，负向指不等于，后面会讲。 例子1: 例子2: 文本： 123http://www.baidu.comhttps://www.baidu.comftp://ftp.forta.com 正则表达式： .+(?=:) 需要匹配到冒号，但在结果中不需要该冒号 结果： 123httphttpsftp 正向向后查找(?&lt;=需要匹配但不在结果中的正则表达式) 例子1: 例子2: 文本： 123AAA:$23.45BBB:$567.45total items found:2 正则表达式： (?&lt;=\\$)[0-9.]+ 需要匹配到美元$，但在结果中不需要$ 结果： 1223.45567.45 向前向后结合目标：提取出\\标签内的文字 文本： 123&lt;head&gt;&lt;title&gt; ben forta&apos;s homepage &lt;/title&gt;&lt;/head&gt; 正则表达式： (?&lt;=\\&lt;title\\&gt;).*(?=\\&lt;/title\\&gt;) 结果： 1ben forta&apos;s homepage 负向前后查找（对前后查找取非）前面介绍的用法称为 正向前查找 和 正向后查找 ，“正”指的是寻找匹配的事实 前后查找还有一种不太常见的用法：负前后查找，“负”指的是寻找不相匹配的事实 负向前查找：将向前查找 不与给定模式相匹配的文本 负向后查找：将向后查找 不与给定模式相匹配的文本 使用!在进行取非 操作法 说明 (?=) 正向前查找 (?!) 负向前查找 (?&lt;=) 正向后查找 (?&lt;!) 负向后查找 例子： 查找价格 文本： 1I paid $30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order. 正则表达式：(?&lt;=\\$)\\d+ 结果： I paid \\$30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order. 查找数量 文本： 1I paid $30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order. 正则表达式：\\b(?&lt;!\\$)\\d+ 结果： I paid \\$30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order. 注意到这里有个\\b，为什么要这样呢？看下面的结果就知道了 正则表达式：(?&lt;!\\$)\\d+ 结果： I paid \\$30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order. $30中的0也被匹配上了。因为0前面的3不是\\$，完全符合(?&lt;!\\$)\\d+ 嵌入条件并非所有正则表达式实现都支持条件处理 正则表达式里的条件要用(?(condition)true_regx|false_regx)来定义，可以没有false_regx。 之前见过几种非常特殊的条件了： .?、[]?或()?匹配前一个字符或者表达式 (?=……)和(?&lt;=……)匹配前面或后面的文本 回溯引用条件(?(回溯引用的id)true-regx|false-regx) ，当回溯引用存在时，匹配true-regx模式，否则匹配false-regx， 例子：匹配合法的电话 文本： 123456123-456-7890(123)456-7890(123)-456-7890(123-456-78901234567890123 456 7890 正则表达式： (\\()? \\d{3} (?(1)\\)|-) \\d{3}-\\d{4} 结果： 123-456-7890(123)456-7890(123)-456-7890(123-456-78901234567890123 456 7890 其中(?(1)\\)|-)就是回溯引用条件，?(1)表示子表达式1存在时，进行匹配右括号)，否则匹配连字符- 前后查找条件(?(向前向后查找表达式)true-regx|false-regx) 在实际工作中，该方法相当少见，因为有更简单的方法来到达同样的目的。 例子： 文本： 1234111112222233333-44444-4444 正则表达式：\\d{5}(?(?=-)-\\d{4}) 结果： 111112222233333-44444-4444 (?(?=-)-\\d{4}) 中用(?=-)来进行向前匹配，如果条件成立，则-\\d{4}将匹配连字符和随后的4位数字，这样33333- 将被排除在外。 总结元字符可以分为2类： 一种是本身就是元字符，转义后变为普通字符，比如^ $ * ，用\\进行转义恢复成普通字符 另一种是需要\\进行配合，才表示元字符，否则就是普通的字符，比如\\w \\s \\d","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://jizx.vip/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://jizx.vip/tags/正则表达式/"}]},{"title":"window添加右键用atom打开","slug":"window添加右键用atom打开","date":"2018-12-15T02:43:13.000Z","updated":"2018-12-16T09:14:41.128Z","comments":true,"path":"2018/12/15/window添加右键用atom打开/","link":"","permalink":"https://jizx.vip/2018/12/15/window添加右键用atom打开/","excerpt":"window添加右键功能，如用atom打开，用vs code打开，可以方便用指定的编辑器打开文件，或者打开文件夹","text":"window添加右键功能，如用atom打开，用vs code打开，可以方便用指定的编辑器打开文件，或者打开文件夹 使用regedit 打开注册表，找到如下位置，按照图示添加项，即可","categories":[{"name":"windows","slug":"windows","permalink":"https://jizx.vip/categories/windows/"}],"tags":[{"name":"系统优化","slug":"系统优化","permalink":"https://jizx.vip/tags/系统优化/"},{"name":"效率","slug":"效率","permalink":"https://jizx.vip/tags/效率/"},{"name":"atom","slug":"atom","permalink":"https://jizx.vip/tags/atom/"},{"name":"vscode","slug":"vscode","permalink":"https://jizx.vip/tags/vscode/"}]},{"title":"notepad常用插件与设置","slug":"notepad常用插件","date":"2018-12-12T01:40:43.000Z","updated":"2018-12-12T02:48:06.307Z","comments":true,"path":"2018/12/12/notepad常用插件/","link":"","permalink":"https://jizx.vip/2018/12/12/notepad常用插件/","excerpt":"notepad如何安装插件 常用的插件推荐 设置与配置信息备份","text":"notepad如何安装插件 常用的插件推荐 设置与配置信息备份 插件安装点击菜单中的“插件”—&gt;“plugin manager”—&gt;“show plugin manager”的选项 进入到插件的管理列表中，找需要的插件，比如“compare”的选项勾选上，点击“install”的进行按钮 插件列表不显示的情况： 打开plugin manager 最下面的setting，将use development plugin list 勾选上，注意information那一栏，可能会给出关键的信息，如让你创建 allowAppDataPlugins.xml文件 缺少PluginManagerPlugins.xml文件 先在文件资源管理器的查看在隐藏的项目打勾 把PluginManagerPlugins.xml放在这个目录下C:\\Users\\用户\\AppData\\Roaming\\Notepad++ 重新打开软件，看时候可行 可能防火墙禁止Notepad++连接网络 可以从控制面板-&gt;系统与安全-&gt;windows防火墙-&gt;允许应用通过windows防火墙 查看notepad++后面对应的专用和公用是否打勾，如果找不到notepad++可以自行添加，从允许其他应用进去，找到你notepad++的安装目录，然后添加 安装完成会自动重启Notepad++，重启完成之后，在菜单栏的插件中，即可找到新安装的插件 常用的插件推荐 compare 比较两个文件的修改情况 JSON viewer json文件查看、格式化 converter ASCII码与HEX转换 设置与配置信息备份设置好的配置文件在：C:\\Users\\用户\\AppData\\Roaming\\Notepad++目录下，建议将这个文件夹备份，避免重装是又要从头设置 不记住最后打开的文件（标签栏会炸掉的）：备份-&gt;记住最后打开的文件 取消掉 utf8-无BOM：新建-&gt;编码","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://jizx.vip/categories/编辑器/"}],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"https://jizx.vip/tags/编辑器/"},{"name":"notepad++","slug":"notepad","permalink":"https://jizx.vip/tags/notepad/"}]},{"title":"chrome截取整个网页","slug":"chrome截取整个网页","date":"2018-12-04T08:39:59.000Z","updated":"2018-12-16T03:32:05.324Z","comments":true,"path":"2018/12/04/chrome截取整个网页/","link":"","permalink":"https://jizx.vip/2018/12/04/chrome截取整个网页/","excerpt":"浏览器原生功能实现滚动截屏，截取整个页面","text":"浏览器原生功能实现滚动截屏，截取整个页面 在Chrome 浏览器上滚动截屏，不需要插件和任何 app，利用 chrome 浏览器原生功能即可实现。 打开 Chrome 浏览器，进入需要截图的网站页面 打开开发者工具：在页面任何地方点击鼠标右键，在弹出菜单中选择「检查」选项。或者使用快捷键组合：option + command + i。 打开命令行（command palette）：command + shift + p。 在命令行中输入「screen」，这时自动补齐功能会显示出一些包含 「Screen」 关键字的命令。移动方向键到「Capture full size screenshot」并回车，chrome就会自动下载整个页面截屏文件。 原文：https://blog.csdn.net/ianly123/article/details/80565614","categories":[{"name":"Chrome","slug":"Chrome","permalink":"https://jizx.vip/categories/Chrome/"}],"tags":[{"name":"截图","slug":"截图","permalink":"https://jizx.vip/tags/截图/"}]},{"title":"Git教程","slug":"Git教程","date":"2018-11-22T14:21:53.000Z","updated":"2018-12-04T08:53:19.633Z","comments":true,"path":"2018/11/22/Git教程/","link":"","permalink":"https://jizx.vip/2018/11/22/Git教程/","excerpt":"Git 教程","text":"Git 教程 Git本地基本配置全局信息当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改 12git config --global user.name \"Your Name\"git config --global user.email \"email@example.com\" 注意：git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。在那个项目目录下运行没有--global选项的命令来配置。 其他有用的配置 1git config --global core.editor \"notepad\" #commit时的默认编辑器 查看配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 123456789git config--listuser.name=JohnDoeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto... 你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 git config &lt;key&gt;： 来检查 Git 的某一项配置 12$ git config user.nameJizx 创建仓库在现有目录中初始化仓库通过git init命令把这个目录(可以是非空目录)变成Git可以管理的仓库。 如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 git add命令来实现对指定文件的跟踪，然后执行git commit 提交 克隆现有的仓库克隆仓库的命令格式是 git clone [url] 本地仓库名字。可以不定义本地仓库名字，默认适应原仓库名字。比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令： $ git clonehttps://github.com/libgit2/libgit2 mylibgit2 这会在当前目录下创建一个名为 “mylibgit2”的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 提交文件第一步，用命令git add告诉Git，把文件添加到暂存区： git add readme.txt add一个文件之后，如果又对文件进行了修改，需要重新add，不然commit只会保存最后一次git add的文件内容。 第二步，用命令git commit告诉Git，把文件提交到仓库： git commit -m &quot;wrote a readmefile&quot; 或者git commit，将会打开默认的文本编辑器（vim）进行文字输入。若实在不习惯 Vim，也可以设置为其它编辑器： git config --global core.editor &quot;notepad&quot; 其中 notepad 可以替换为更好用的 wordpad、notepad++ 等（不过它们在命令行里无法直接访问，得先设置 PATH 变量）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123git addfile1.txtgit addfile2.txt file3.txtgit commit-m \"add 3 files.\" 快速提交： Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，git commit -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 重新提交有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有--amend 选项的提交命令尝试重新提交，命令执行后将暂存区中的文件提交，因此分为以下2种情况： 修改提交信息： git commit --amend 添加忘记/漏add的文件，同时修改提交信息： 123$ git commit -m 'initial commit' # 错误的提交$ git add forgotten_file$ git commit –amend 查看文件状态要查看哪些文件处于什么状态，可以用 git status 命令。 使用 git status -s 命令或 git status --short命令，你将得到一种更为紧凑的格式输出。 123456$ git status -s M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt ?? 标记：新添加的未跟踪文件 A 标记：新添加到暂存区中的文件 M 标记：修改过的文件 出现在右边的 M表示该文件被修改了但是还没放入暂存区 出现在左边的 M表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区，lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。 Untracked未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件（比如新建的文件）；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。被追踪后处于3种状态：未修改-已修改-已暂存。将暂存的文件commit后就保存在git数据库中，文件就回到未修改状态了。接下来介绍如何对修改的文件进行版本控制。 查看文件修改内容diff 默认查看尚未暂存的文件更新了哪些部分，输入git diff此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。 git diff不加参数即默认比较工作区与暂存区 比较工作区与最新本地版本库 git diff HEAD [&lt;path&gt;...] 如果HEAD指向的是master分支，那么HEAD还可以换成master 比较工作区与指定commit-id的差异 git diff commit-id [&lt;path&gt;...] –cached查看暂存区里将要添加到下次提交里的内容，可以用 git diff --cached命令。也就是查看暂存区里与最新本地版本库的区别（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。） 比较暂存区与指定commit-id的差异 git diff --cached [&lt;commit-id&gt;][...] 比较两个commit-id之间的差异 git diff [&lt;commit-id&gt;][] 打补丁使用git diff打补丁git diff &gt; patch patch的命名是随意的，不加其他参数时作用是当我们希望将我们本仓库工作区的修改拷贝一份到其他机器上使用，但是修改的文件比较多，拷贝量比较大，此时我们可以将修改的代码做成补丁，之后在其他机器上对应目录下使用 git apply patch 将补丁打上即可 git diff --cached &gt; patch //是将我们暂存区与版本库的差异做成补丁 git diff --HEAD &gt; patch//是将工作区与版本库的差异做成补丁 git diff Testfile &gt; patch//将单个文件做成一个单独的补丁 拓展：git apply patch 应用补丁，应用补丁之前我们可以先检验一下补丁能否应用，git apply --check patch 如果没有任何输出，那么表示可以顺利接受这个补丁 另外可以使用git apply --reject patch将能打的补丁先打上，有冲突的会生成.rej文件，此时可以找到这些文件进行手动打补丁 忽略文件（不追踪文件）在Git工作区的根目录下创建一个特殊的.gitignore文件，（window下直接新建不了，最好用命令行创建）使用命令cat .gitignore或者touch .gitignore，然后把要忽略的文件名或者目录填进去，Git就会自动忽略这些文件、文件夹。最后一步就是把.gitignore`也提交到Git，就完成了！ 注意：.gitignore文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。如果要忽略被提交了的文件，请看【删除文件、取消追踪、恢复误删】这节内容 gitignore编写规则 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 以（/）结尾 指定目录，忽略该目录下全部内容。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指shell 所使用的简化了的正则表达式。 星号*匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 问号?只匹配一个任意字符； 如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号** 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。 12345678910111213141516# 忽略任何 以 .a 结尾文件*.a# 但不忽略 lib.a 这个例外!lib.a# 只忽略当前文件夹下的 TODO ，不忽略子文件夹下的 subdir/TODO/TODO# 忽略全部在 build/ 文件夹下的文件build/# 只忽略doc文件夹下的.txt,子目录下的doc/server/arch.txt 不受影响，doc/*.txt # 忽略所有doc文件夹下的 .pdf 文件doc/**/*.pdf GitHub 在 github/gitignore仓库 提供了一个官方推荐的 .gitignore 文件列表，包括各种流行的操作系统、环境、开发语言。 强制添加有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了： 12345$ git add App.classThe following paths are ignored by one of your .gitignore files: App.classUse -f if you really want to add them. 如果你确实想添加该文件，可以用-f强制添加到Git：git add -f App.class当然也可以在.gitignore里使用!排除这个文件。 忽略已经添加到git的文件如果你已经将文件提交到到git中，那么git不会处理你后来添加的gitignore规则。这种情况就需要通过下面的命令先取消追踪文件： 1git rm --cached filename 测试规则或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查： 12$ git check-ignore -v App.class.gitignore:3:*.class App.class Git会告诉我们：.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。 全局忽略可以为你的电脑上每个仓库创建一份全局的忽略文件，这样就不必每个仓库都单独创建一个gitignore文件。 在home目录创建~/.gitignore_global文件 在命令行中执行git config --global core.excludesfile ~/.gitignore_global The Octocat 提供了一个推荐列表 方便添加到全局忽略文件中 a Gist containing some good rules 本地忽略.gitignore 这个文件本身会提交到版本库中去，用来保存的是公共的需要排除的文件。 如果你不想创建一份与他人共享的.gitignore，比如由你的编辑器产生的附属文件，而别人不会产生的情况。可以订制一份本地的忽略规则，这份规则不会提交到git中。 打开仓库中的.git/info/exclude 文件，在这里添加忽略规则即可，这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。 撤销修改、提交取消本地修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时， 使用命令git checkout –– filename。git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 取消add场景2：当你不但改乱了工作区某个已经追踪的文件的内容，还添加到了暂存区时(git add)，想丢弃修改，分两步： 第一步用命令git reset HEAD fileName（取消add到暂存区），就回到了场景1（即文件未暂存到暂存区中，仍为被修改过的状态） 第二步按场景1操作。 如果是新文件（未提交到git中），那么应该使用git rm --cached &lt;file&gt; 来取消add操作。 版本回退场景3：当你不但添加到了暂存区时(git add)，还提交了(git commit)，那就得进行版本回退了 在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 上面的方法仅适合近期恢复，如果忘记应该回退到哪个版本或者要回退到比较久之前的版本，应该通过git log 查看commit id，即可回退到你需要的时间点 123456789101112$ git logcommit c0ce54b1ce75f69259d7f615bf280ff7a07e3eac (HEAD -&gt; master, origin/master, origin/HEAD)Author: jizx &lt;1822980003@qq.com&gt;Date: Sun Nov 18 23:16:49 2018 +0800 git命令行中文乱码解决方法commit 0c0bfca1e3208d83a89366c5be76982d24e03deeAuthor: jizx &lt;1822980003@qq.com&gt;Date: Sun Nov 18 20:52:07 2018 +0800 过滤上根目录的DS_Store 其中commit 后面的一串字符串就是commit id 12$ git reset --hard HEAD^ # 回退到上一个版本$ git reset --hard commit_id # 通过git log 获取的commit id 第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的，Git提供了一个命令git reflog用来记录你的每一次命令，这样就可以找到你全部提交过的commit id。 删除文件、取消追踪、恢复误删 同时删除库中的文件与工作目录的文件： 使用命令git rm fileName删掉，并且git commit –m “someLog” 仅删除库中的文件（取消追踪/恢复未追踪状态）： 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪,可以输入命令：git rm –cached filename/dir 另一种情况是在文件夹里误删了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：git checkout -- test.txt 文件重命名要在 Git 中对文件改名，可以这么做： git mv README.md NewName.md 其实，运行 git mv 就相当于运行了下面三条命令： 123mv README.md NewName.mdgit rm README.mdgit add NewName.md 如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。两者唯一的区别是，git mv 是一条命令而另一种方式需要三条命令，直接用 git mv轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。 版本历史git loggit log 显示从最近到最远的提交日志 git log -p -2 一个常用的选项是 -p，用来显示每次提交的内容差异。你也可以加上 -2 来仅显示最近两次提交git log --decorate 命令查看各个分支当前所指的对象。 git log --pretty=oneline另外一个常用的选项是--pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有short，full 和 fuller可以用（不过不怎么实用）。 git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 最有意思的是format，可以定制要显示的记录格式 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人 图像化展示提交记录 $ git log --graph $ git log --graph --pretty=oneline --abbrev-commit 简洁视图版本 当 oneline 或 format 与另一个 log 选项 –graph 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史。 git log 的常用选项，可以一起使用 选项 说明 -p 按补丁格式显示每个更新之间的差异。 –stat 显示每次更新的文件修改统计信息。 –shortstat 只显示 –stat 中最后的行数修改添加移除统计。 –name-only 仅在提交信息后显示已修改的文件清单。 –name-status 显示新增、修改、删除的文件清单。 –abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 –relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 –graph 显示 ASCII 图形表示的分支合并历史。 –pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 限制git log输出的选项 选项 说明 -(n) 仅显示最近的 n 条提交 –since, –after 仅显示指定时间之后的提交。 –until, –before 仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 –grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 例子：git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; --before=&quot;2008-11-01&quot; git relog$ git reflog //查看全部命令记录，以及HEAD指针 git help 命令提示1git help command # 可以显示某条command的使用方法 Git远程从远程仓库克隆到本地在某个目录下，打开命令行，运行以下命令，就可以把远程的仓库克隆到当前目录 12# 通用命令$ git clone username@host:/path/to/repository 123# 如果远程服务器是github$ git clone git@github.com:你的GitHub用户名/你的某一个仓库名.git# .git可以不用写 默认远程仓库别名为 origin，如果要自定义，可以在克隆时运行命令：git clone -o jizx git@github.com:你的GitHub用户名/你的某一个仓库名.git，那么你默认的远程分支名字将会是 jizx/master注意：克隆后本地只有master分支，如果想要把别的分支如dev克隆下来，需要使用:git checkout -b dev origin/dev也就是说，当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：git checkout -b dev origin/devgit clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支） 本地关联到远程仓库空文件夹新建一个文件夹，进入文件夹后使用git init命令，然后再使用git remote add命令关联一个远程仓库，再使用git pull 命令就可以把管理仓库的所有文件复制到本文件夹中，同样可以修改文件并完成push。 12345# 通用命令$ git remote add remoteName git@server-name:path/仓库名.git# github服务器命令$ git remote add remoteName git@github.com:你的用户名/你的某一个仓库名.git 或者在一个文件夹下直接使用git clone命令，会把远程仓库整个复制到这个文件夹下，然后进入这个文件夹就可以修改文件并完成push。 这时默认远程的url别名为origin 非空仓库(TODO非空文件怎么关联)查看远程库信息用git remote可以查看到默认的远程库：origin 用git remote -v显示更详细的信息： 123$ git remote-vorigin git@github.com:jizxgit/learngit.git (fetch)origin git@github.com:jizxgit/learngit.git (push) remote 详细用法git help remote 即可显示详细命令用法 1234567891011121314git remote [-v | --verbose]git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;git remote rename &lt;old&gt; &lt;new&gt;git remote remove &lt;name&gt;git remote rm &lt;name&gt;git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…git remote get-url [--push] [--all] &lt;name&gt;git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;git remote [-v | --verbose] show [-n] &lt;name&gt;…git remote prune [-n | --dry-run] &lt;name&gt;…git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…] 本地推送到远程仓库第一次更新时： git push -u origin master origin：远程服务器url别名 master：本地仓库的一个分支 加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令 以后更新时： git push origin master 如果要推送本地其他分支，比如dev，就改成：git push origin dev 以上其实做了一定的简化，完整的命令是： 1$ git push origin 本地分支：远程分支 如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 冲突、推送失败当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取pull下来并将其合并进你的工作后才能推送。 相当于是从远程获取最新版本并merge到本地 从远程仓库获取数据$ git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看，它并不会自动合并或修改你当前的工作。 $ git pull [remote-name] 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 如果git pull失败，一般是因为没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 123$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin. 删除远程分支假设你已经通过远程分支做完所有的工作了，也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有--delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令： 1234$ git push origin --delete serverfixTo https://github.com/schacon/simplegit - [deleted] serverfix 基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。 Git 本地高级操作分支操作创建、切换分支创建并切换到新的分支dev $ git branch dev $ git checkout dev 等价于$ git checkout -b dev ​ 复制远程分支到本地 $ git checkout -b dev origin/dev dev是本地新建的分支名字，origin/dev是远程分支 查看所有分支，以及当前所在分支，*表示当前分支 $ git branch 切换分支 $ git checkout dev 切换出去前，要保存好编辑过的文件，用add commit，或者保存现场 保存现场$ git stash 当在一个分支的开发工作未完成，却又要切换到另外一个分支进行开发的时候，并不是不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。除了commit原分支的代码改动的方法外，我觉得保存现场是一个更加便捷的选择，暂时冻结开发现场，等待其他分支完成后继续回来完成。 查看现场 git stash list 恢复现场 git stash apply，默认恢复最新的现场，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 git stash pop，恢复的同时把stash内容也删了 可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：$ git stash apply stash@{0} 删除合并后的分支 $ git branch -d dev 丢弃一个没有被合并过的分支 $ git branch -D dev强行删除。 分支详解当使用git commit 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中这些校验和被保存为树对象。随后，Git 便会创建一个提交对象（98ca9），它除了包含上面提到的那些信息外，还包含指向这个树对象（92ec2）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。 现在，Git 仓库中有五个对象：一个提交对象（包含着指向前述树对象的指针和所有提交信息） 、一个树对象（记录着目录结构和 blob 对象索引）以及三个 blob 对象（保存着文件快照）。 分支合并快速合并：$ git merge dev 关闭快速合并，这样在Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 $ git merge --no-ff -m &quot;merge withno-ff&quot; dev 合并冲突有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。此时 Git 做了部分合并工作，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 例子： master分支和feature1分支各自都分别对同一部分修改并有新的提交，就会产生冲突 Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交，可以直接查看readme.txt的内容： 123456789Git is a distributed version control system.Git is free software distributed under theGPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEADCreating a new branchis quick &amp; simple.=========Creating a new branchis quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt;feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。 为了冲突解决，你可以选择使用由=======分割的两部分中的一个，或者你也可以自行合并这些内容（可以是完全新的内容），并且 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ,======= , 和&gt;&gt;&gt;&gt;&gt;&gt;&gt;这些行要被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决，然后commit保存入仓库。 如果你想使用图形化工具来解决冲突，你可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突： $ git mergetool 查看已合并的分支，从而删除没用的分支 123$ git branch --merged iss53* master 查看未合并的分支 12$ git branch --no-merged testing 总结： Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 跟踪分支从一个远程跟踪分支检出一个本地分支，这个本地分支就叫做“跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 创建跟踪分支：git checkout -b [branch][remotename]/[branch] 例如： 12345$ git checkout -b sf origin/serverfixBranch sf set upto track remote branch serverfix from origin.Switched to a newbranch 'sf' 设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。 123$ git branch -uorigin/serverfixBranch serverfixset up to track remote branch serverfix from origin. 可以使用 git branch -vv 。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。 例如： 123456789$ git branch -vv iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets master 1ae2a45 [origin/master] deploying index fix* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1]this should do it testing 5ea463a trying something new 可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。这些数字的值来自于你从每个服务器上最后一次抓取(fetch)的数据。 这个命令(branch -vv)并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。可以像这样做：git fetch --all; git branch –vv 标签Git 可以给历史中的某一个提交打上标签，以示重要。 Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。 附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；通常建议创建附注标签，这样你可以拥有以上所有信息 标签创建 $ `git tag` 查看标签，注意，标签不是按时间顺序列出，而是按字母排序的。 $ git tagv1.0 标签默认是打在最新提交的commit上的,标签名为v1.0 $ git tag -a v1.0 -m &quot;version 1.0released&quot; commit_id 可以创建带有说明的附注标签，用-a指定标签名，-m指定说明文字。 补打标签 $ git tag v1.0 commit_id 你也可以对过去的提交打标签，指定某个历史打标签，通过$ git log --pretty=oneline --abbrev-commit查找到对应要打标签的commit_id。 $ git show &lt;tagname&gt;可以看到说明文字。 标签推送 默认情况下，git push命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上 $ git push origin &lt;tagname&gt; 推送某个标签到远程。 $ git push origin –-tags 一次性推送全部尚未推送到远程的本地标签. 标签删除 $ git tag -d v1.0如果标签打错了，也可以删除。 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 123$ git tag -d v1.0Deleted tag 'v1.0' (was 6224937) 然后，从远程删除。删除命令也是push，但是格式如下： $ git pushorigin :refs/tags/v1.0//可以删除一个远程标签。 标签切换 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b[branchname][tagname]在特定的标签上创建一个新分支： 123$ git checkout -b version2 v2.0.0Switched to a new branch 'version2' 当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。 大文件更新Update(TODO未看)我们知道 Git 不仅仅是用来做代码版本管理的，很多其他领域的项目也会使用 Git。比如说我公司曾经一个客户的项目涉及到精密零件图纸文档的版本管理，他们也用Git。有一种使用场景是对一些体积庞大的文件进行修改，但是每一次保存 Git 都要计算文件的变化并更新工作区，这在硬盘慢的时候延迟卡顿非常明显。 git update-index –assume-unchanged 的真正用法是这样的： 你正在修改一个巨大的文件，你先对其 git update-index –assume-unchanged，这样 Git 暂时不会理睬你对文件做的修改； 当你的工作告一段落决定可以提交的时候，重置改标识：git update-index –no-assume-unchanged，于是 Git 只需要做一次更新，这是完全可以接受的了； 提交＋推送。 配置命令别名 配置别名有点像C语言里的宏，进行简单的替换。 替换单个词，告诉Git，以后st就表示status $ git config--global alias.st status 当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch： 123$ git config--global alias.co checkout$ git config--global alias.ci commit$ git config --globalalias.br branch 替换多个词（用单引号包含着多个词）； 命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：$ git config --global alias.unstage &#39;reset HEAD&#39; 配置格式化打印log的：（将log--pretty=format:&quot;%h - %an - %ar : %s&quot;定义为linelog）： 1$ git config--global alias.linelog &apos;log --pretty=format:&quot;%h - %an - %ar : %s&quot;&apos; 撤销别名，打开配置文件删除即可，详见【配置文件】章节 配置文件Git的时候，加上–global是针对当前用户（整个软件）起作用的，如果不加，那只针对当前的仓库（当前文件夹）起作用。 当前仓库配置文件：每个仓库的Git配置文件都放在.git/config文件中： 12345678910111213141516$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote \"origin\"] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch \"master\"] remote = origin merge = refs/heads/master[alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 全局配置文件：放在用户主目录（window系统中的用户目录下）下的一个隐藏文件.gitconfig中： 123456789$ cat ~/.gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Nameemail = your@email.com 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 Github参与Github开源项目如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”，将别人的仓库在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：git‍ clone ‍git@github.com:jizxGit/bootstrap.git 一定要从自己的账号下clone仓库，这样你才能推送修改，因为你在github添加了SSH。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。 Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样： 如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。 如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。 小组合作 首先在github上创建一个需要与团队共享的仓库 然后在仓库的Settings中添加队友的github帐户： 添加完成后，对方会收到请求，如下图，需要对方同意请求，才算是加入到这个团队中，拥有push的权限。 流程会像这样： A拥有repository，想要让B也能更新自己的repository，就把B加入collaborators，这样B要一起合作这份code的时候，clone A 的clone repo到本地，然后B就可以在自己的本机尽情修改code (用branch、commit、merge)，最后在push的时候输入B自己的帐密，会更新A的repository(A仍就可以继续更新自己的repository)，但B自己的github账户并不会有一份和A相同的repository(只会有A的repo连结) Git bash 快捷键（window）全屏ATL+ENTER 字体变化CTRL+PLUS/MINUS/ZERO 右键ALT+SPACE","categories":[{"name":"git","slug":"git","permalink":"https://jizx.vip/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://jizx.vip/tags/git/"}]},{"title":"python编码问题","slug":"python编码问题","date":"2018-11-19T08:45:18.000Z","updated":"2019-08-04T13:29:52.072Z","comments":true,"path":"2018/11/19/python编码问题/","link":"","permalink":"https://jizx.vip/2018/11/19/python编码问题/","excerpt":"理清楚 从编写python文件的编码，到运行时的编码，最后print打印显示这一整根流程中的各种编码问题","text":"理清楚 从编写python文件的编码，到运行时的编码，最后print打印显示这一整根流程中的各种编码问题 计算机最早是只有英文ASCII码，但世界上除了英语，还有很多其他语言，因此只有ASCII码编码显然不适合这种情况。 于是后来在中国、日本等其他国家都有了自己的一套编码，但是这样就出现问题了，不同国家之间数据传输，就会出现乱码。 为了让全世界都可以使用计算机，于是有了Unicode编码方式，俗称万国码，可以存储好几万个字符。（unicode专题TODO） 因此计算机内存中，对字符串的编码使用的都是Unicode，作为中间者。 但是又有新的问题出现了，Unicode是定长编码，不适合存储，非常浪费存储空间，这里又有了一种新的编码方式：utf-8。utf-8采用的是不定长编码，大大节约了存储空间。在数据存储和传输方面非常方便。 当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码(或者其他编码)。 pyhton2 中的编码过程123456789# _*_ coding:utf8 _*_s = \"中文\"print(type(s)) # &lt;type 'str'&gt;s2=s.encode('utf8') # unicode解码错误，无法以ASCII解码字节 0xe4，超出了range（128）：UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)s2 = u'中文' # &lt;type 'unicode'&gt;s3=s2.encode('utf8')print(type(s3)) # &lt;type 'str'&gt; 在运行前，python解释器默认以ASCII码解码文件，因此如果文件中有中文就会报错：Non-ASCII character &#39;\\xe9&#39; ，表示出现了超出ASCII码（0-127）以外的字节，因此需要在文件第一行添加：# _*_ coding:utf8 _*_ ，让编译器以指定的字符集进行解码然后编译。 在运行时，Python2 中字符串有2种类型：&lt;type &#39;str&#39;&gt; 和&lt;type &#39;unicode&#39;&gt;，默认是str类型 。变量s 的类型是&lt;type &#39;str&#39;&gt; ，可以理解为保存了“中文”以utf8编码的二进制数据。s.encode(&#39;utf8&#39;)命令实际上过程是这样的： 1234s.decode(defaultencoding).encode('utf8')# 类型的转变过程&lt;type 'str'&gt; ——以defaultencoding解码——&gt; &lt;type 'unicode'&gt; ——以encode方法指定的字符集编码——&gt; &lt;type 'str'&gt; 12import sysprint(sys.getdefaultencoding()) # ascii defaultencoding在python2中默认是ASCII，而s是以utf8编码的，因此在str—&gt;unicode的时候就会出现UnicodeDecodeError 解决办法有2种： 显式进行解码s.decode(&#39;utf8&#39;).encode(&#39;utf8&#39;) 修改系统默认字符集 12345import sysreload(sys)# Python2.5初始化后会删除sys.setdefaultencoding这个方法，因此需要重新载入print(sys.getdefaultencoding()) # asciisys.setdefaultencoding('utf-8')print(sys.getdefaultencoding()) # utf-8 u前缀在python2里面，u表示unicode string，类型是unicode, 没有u表示byte string，类型是 str。 1234567891011121314s1 = '中文' # '\\xe4\\xb8\\xad\\xe6\\x96\\x87'print(type(s1)) # &lt;type 'str'&gt;print(len(s1)) # 6s2 = u'中文' # u'\\u4e2d\\u6587'print(type(s2)) # &lt;type 'unicode'&gt;print(len(s2)) # 2print(s1 == s2) # False (警告 UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal)print(s2 == s1) # False 不会有警告print(s1 is s2) # Falses3=s.encode('utf8')print(type(s3)) 字符串长度问题123456789101112# python2.7import sysreload(sys)sys.setdefaultencoding('utf-8')msg='中文' # '\\xe4\\xb8\\xad\\xe6\\x96\\x87'此时msg被编码为utf-8,而不是ascii ,type(msg) # &lt;type 'str'&gt;len(msg) # 6 因为utf8每个汉字占3个字节umsg=unicode(msg) # u'\\u4e2d\\u6587'type(umsg) # &lt;type 'unicode'&gt;len(umsg) # 2 Python3 中的编码过程123456789101112131415161718s1 = '中文' # '中文'print(type(s1)) # &lt;class 'str'&gt;print(len(s1)) # 3s2 = u'中文' # '中文' 与s1没有区别print(type(s2)) # &lt;class 'str'&gt;print(len(s2)) # 3print(s1 == s2) # Trueprint(s1 is s2) # Trues3=s1.encode(\"utf8\")print(type(s3)) #&lt;class 'bytes'&gt;print(s3) # b'\\xe4\\xb8\\xad\\xe6\\x96\\x87's4=s3.decode(\"utf8\") print(type(s4)) # &lt;class 'str'&gt;print(s4) # 中文 python3的改进： Python3在编译时，文件默认就是以utf-8进行解码然后编译 python3中所有字符串都是以unicode格式(\\uXXXX)保存在内存中，u前缀没有特殊含义了。只有&lt;class str&gt; 类型，对应的就是python2中的 &lt;type &#39;unicode&#39;&gt; 。而&lt;class byte&gt; 类似于python2的&lt;type &#39;str&#39;&gt; 。 encode函数根据参数指定的编码方式，把str类型的字符串转换为bytes类型。而在python3中字符串没有decode函数，byte类型才有。 在python3中，我们将不能直接看到unicode字节串，它会被显示为中文的“中文”；因为python3默认使用unicode编码，unicode字节串将被直接处理为中文显示出来。 获取字符的unicode 根据unicode获取字符 123# chr参数支持10进制、16进制chr(0x4e2d) # '中' chr(20013) # '中' 根据字符获取unicode码 12# 返回值：10进制的unicode码ord(\"中\") # 20013 Python2中的print过程Python2.7中调用print打印var变量时，操作系统会对var做一定的字符处理： 如果var是str类型的变量，则直接将var变量交付给终端进行显示； 如果var变量是unicode类型，则操作系统首先将var编码成str类型的对象（编码格式取决于stdout的编码格式print(sys.stdout.encoding)），然后再交由终端进行显示。 在终端显示时，如果str类型的变量的编码方式和终端设置的编码方式不一致，很可能会出现乱码问题。 Python2 与3 读取文件的编码问题codecs会按照指定的字符集解码文件，然后将字符串转为&lt;type &#39;unicode&#39;&gt; open读取文件后的字符串是&lt;type &#39;str&#39;&gt; 类型，而且a.txt是以utf8编码保存的，与‘分’是同一种编码（# _*_ coding:utf8 _*_），因此可以直接split a.txt中的内容是：中文分国家 12345678910111213141516171819# _*_ coding:utf8 _*_import codecswith codecs.open('a.txt','r','utf-8') as f: line=f.read() print(type(line)) # &lt;type 'unicode'&gt; ss=line.split('分'.decode('utf8')) # 相当于下面2行 # c='分' # &lt;type 'str'&gt; # ss=line.split(c.decode('utf8')) #因为line是unicode，而c是str，因此必须进行decode for s in ss: print(s)with open('a.txt','r') as f: line2=f.readline() print(type(line2)) #&lt;type 'str'&gt; ss=line2.split('分') for s in ss: print(s) python3中都是unicode存储字符串，因此没有上面的问题 12345678910111213141516# python3import codecswith codecs.open('a.txt','r','utf-8') as f: line=f.read() print(type(line)) # &lt;class 'str'&gt; ss=line.split('分') for s in ss: print(s)with open('a.txt','r',encoding='utf-8') as f: line2=f.readline() print(type(line2)) # &lt;class 'str'&gt; ss=line2.split('分') for s in ss: print(s) JSON 保存中文文件使得JSON保存的文件中文可读，必须有ensure_ascii 1print(json.dumps(custs,encoding='UTF-8',ensure_ascii=False))","categories":[{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"编码问题","slug":"编码问题","permalink":"https://jizx.vip/tags/编码问题/"},{"name":"打印","slug":"打印","permalink":"https://jizx.vip/tags/打印/"},{"name":"乱码","slug":"乱码","permalink":"https://jizx.vip/tags/乱码/"}]},{"title":"java方法传参问题","slug":"java方法传参问题","date":"2018-07-04T14:01:40.000Z","updated":"2018-11-18T13:27:37.482Z","comments":true,"path":"2018/07/04/java方法传参问题/","link":"","permalink":"https://jizx.vip/2018/07/04/java方法传参问题/","excerpt":"","text":"一、基本类型 和 引用类型的不同之处12int num = 10;String str = \"hello\"; 首先变量其实是堆栈中的地址索引。然后 基本类型的数据直接保存在堆栈中，而对象是保存在堆中，堆栈中保存的是该对象在堆中的地址，这个地址就是所谓的引用 二、赋值运算符（=）的作用12num = 20;str = \"java\"; 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收） 三、调用方法时发生了什么？参数传递基本上就是赋值操作。12345678num = 20;str = \"java\";func(num,str);public void func(int n,String s)&#123; n=30; s+=\"haha\"; // do something with s&#125; n变为30，num不受影响；s虽然是对象类型，但是由于String是不可变类型，因此并不会影响到原来的str变量。所以结果如下： 如果str是StringBuilder对象的话，就会改变，结果如下： 总结在java中，不管原始参数的类型是什么，参数都是按值传递的。 每当一个方法被执行时，在堆栈中就会为每个参数创建一个拷贝，这个拷贝被传递到方法的内部，这个拷贝分以下2种情况： 如果参数是基本类型，那么在堆栈中复制的就是这个参数的值 如果是对象，那么在堆栈中传递的便是指向真正对象数据的新的引用。这个新的引用被传递到方法内部。 因此关于参数在方法中被修改后，会不会影响到原始变量，根据上面的原理： 修改一个基础类型的参数，不会影响原始数据； 修改一个对象参数(数组、集合、map、类)的引用时，永远不会影响到原始的引用； 修改一个对象参数的属性时，会影响原始对象 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; DuplicatenNum app = new DuplicatenNum(); int a1=5; app.fun1(a1); System.out.println(a1); TreeNode a2=new TreeNode(5); app.fun2(a2); System.out.println(a2); int[] a2_2=&#123;1,2&#125;; app.fun2_2(a2_2); System.out.println(a2_2[0]); List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); list.add(1); app.fun3(list); System.out.println(list); &#125; public void fun1(int a) &#123; a=10; &#125; public void fun2(TreeNode root) &#123; root=new TreeNode(10); &#125; public void fun2_2(int [] arr) &#123; arr = new int[4]; &#125; public void fun3(List&lt;Integer&gt; list)&#123; list.add(2); &#125; 输出： 12345TreeNode&#123;val=5, left=null, right=null&#125;1[1, 2] 参考： Java 到底是值传递还是引用传递？","categories":[{"name":"java","slug":"java","permalink":"https://jizx.vip/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jizx.vip/tags/java/"},{"name":"传参","slug":"传参","permalink":"https://jizx.vip/tags/传参/"},{"name":"方法调用","slug":"方法调用","permalink":"https://jizx.vip/tags/方法调用/"}]},{"title":"剑指offer","slug":"剑指offer","date":"2018-06-17T08:16:41.000Z","updated":"2018-11-18T13:09:31.923Z","comments":true,"path":"2018/06/17/剑指offer/","link":"","permalink":"https://jizx.vip/2018/06/17/剑指offer/","excerpt":"剑指offer题目（持续更新）","text":"剑指offer题目（持续更新） 单例模式单线程1234567891011121314151617181920/** * 线程不安全 */class Singleton1 &#123; private static Singleton1 instance = null; // 构造方法私有化，防止外部使用new创建对象 private Singleton1() &#123; System.out.println(\"单例模式1\"); &#125; // 获取实例的方法 public static Singleton1 getInstance() &#123; if (instance == null) &#123; instance = new Singleton1(); &#125; return instance; &#125;&#125; 多线程有人提出在getInstance()方法上同步锁，但是锁住一整个方法可能粒度过大，不利于效率。既然锁方法不太好，那么锁代码呢？ 1234567891011121314151617class Singleton2 &#123; private static Singleton2 instance = null; // 构造方法私有化，防止外部使用new创建对象 private Singleton2() &#123; System.out.println(\"单例模式2\"); &#125; // 获取实例的方法 public static Singleton2 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton2.class) &#123; instance = new Singleton2(); &#125; &#125; return instance; &#125;&#125; 这样做看似解决了线程安全问题，其实不然。设现有线程A和B，在t1时刻线程A和B均已通过判空语句但都未取得锁资源；t2时刻时，A先取得锁资源进入临界区（被锁的代码块），执行new操作创建实例对象，然后退出临界区，释放锁资源。t3时刻，B取得被A释放的锁资源进入临界区，执行new操作创建实例对象，然后退出临界区，释放锁资源。明显地，Singleton被实例化两次。 改进： 12345678910111213141516171819/** * 线程安全，但是如果instance已经存在不能直接返回，也会被锁住，效率很低下，还可以优化 */class Singleton3 &#123; private static Singleton3 instance = null; private Singleton3() &#123; System.out.println(\"单例模式3\"); &#125; public static Singleton3 getInstance() &#123; synchronized (Singleton3.class) &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; &#125; return instance; &#125;&#125; 双检查锁机制（推荐）12345678910111213141516171819class Singleton4 &#123; //注意此处加上了volatile关键字 private static Singleton4 instance = null; private Singleton4() &#123; System.out.println(\"单例模式4\"); &#125; public static Singleton4 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton4.class) &#123; if (instance == null) &#123; instance = new Singleton4(); &#125; &#125; &#125; return instance; &#125;&#125; 在JDK1.5以前，DCL（双检查锁机制）是不稳定的，有时也可能创建多个实例，在1.5以后开始提供volatile关键字修饰变量来达到稳定效果。 多线程测试入口12345678910public class Test &#123; public static void main(String[] args) &#123; //创建实现了Runnable接口的匿名类 Runnable run = () -&gt; Singleton2.getInstance(); for (int i = 0; i &lt; 50; i++) &#123; Thread thread = new Thread(run); thread.start(); &#125; &#125;&#125; 总结单例是为了保证系统中只有一个实例，其关键点有： 私有构造函数 声明静态单例对象 构造单例对象之前要加锁（lock一个静态的object对象） 需要两次检测单例实例是否已经被构造，分别在锁之前和锁之后 1.为何要检测两次？ 如上面所述，有可能延迟加载或者缓存原因，造成构造多个实例，违反了单例的初衷。 2.构造函数能否公有化？ 不行，单例类的构造函数必须私有化，单例类不能被实例化，单例实例只能静态调用 3.lock住的对象为什么要是object对象，可以是int吗？ 不行，锁住的必须是个引用类型。如果锁值类型，每个不同的线程在声明的时候值类型变量的地址都不一样，那么上个线程锁住的东西下个线程进来会认为根本没锁，相当于每次都锁了不同的门，没有任何卵用。而引用类型的变量地址是相同的，每个线程进来判断锁多想是否被锁的时候都是判断同一个地址，相当于是锁在通一扇门，起到了锁的作用。 数组二维有序数组中查找 思路：用target与数组右上角的值进行比较，小于右上角，则跳过该列，大于右上角，则跳过该行 12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; public static void main(String[] args) &#123; int[][] arr = &#123; &#123;1, 2, 8, 9&#125;, &#123;2, 4, 9, 12&#125;, &#123;4, 7, 10, 13&#125;, &#123;6, 8, 11, 15&#125;, &#125;; int[][] arr2 = &#123; &#123;1, 2, 8, 9&#125;, &#125;; System.out.println(find(arr, 11)); &#125; public static boolean find(int[][] arr, int target) &#123; if (arr.length &lt; 1) return false; int i = 0, j = arr[0].length - 1; // 用target与数组右上角的值进行比较 while (j &gt; 0 &amp;&amp; i &lt; arr.length - 1) &#123; // target小于右上角，则跳过该列 while (target &lt; arr[i][j] &amp;&amp; j &gt; 0) &#123; j--; &#125; // target大于右上角，则跳过该行 while (target &gt; arr[i][j] &amp;&amp; i &lt; arr.length - 1) &#123; i++; &#125; if (target == arr[i][j]) &#123; System.out.println(\"i:\" + (i + 1) + \",j:\" + (j + 1)); return true; &#125; &#125; return false; &#125;&#125; 旋转数组的最小数字 主要考虑三种情况： 正常情况：{7,8,1,2,3,4,5,6} 有序情况：{1, 2, 3, 4, 5, 6} 相等情况：{1, 1, 0, 1, 1, 1, 1, 1} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Test &#123; public static void main(String[] args) &#123; // int[] a = &#123;5,6,7,8,1,2,3,4&#125;; // int[] a = &#123;1, 1, 0, 1, 1, 1, 1, 1&#125;; int[] a = &#123;1, 2, 3, 4, 5, 6&#125;; System.out.println(findMin(a)); &#125; /** * 使用二分法进行查找 */ public static int findMin(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return -1; &#125; int left = 0; int right = arr.length - 1; int mid = left;//初始值原因见下方 /** * 正常情况，左边会大于等于右边，否则就已经是有序的数组，第一个就是最小值，因此mid初始为left */ while (arr[left] &gt;= arr[right]) &#123; if (right - left == 1) &#123; mid = right; break; &#125; mid = (left + right) / 2; // 左边=中间=右边，只能遍历,&#123;1, 1, 0, 1, 1, 1, 1, 1&#125;; if (arr[left] == arr[right] &amp;&amp; arr[right] == arr[mid]) &#123; int min = Integer.MAX_VALUE; for (int i = left; i &lt;= right; i++) &#123; if (min &gt; arr[i]) &#123; min = arr[i]; &#125; &#125; return min; &#125; // 左边&lt;=中间，说明最小值在[mid,right] if (arr[left] &lt;= arr[mid]) &#123; left = mid; &#125; // 右边&gt;=中间，说明最小值在[left,mid] else if (arr[right] &gt;= arr[mid]) &#123; right = mid; &#125; &#125; return arr[mid]; &#125; 调整数组 使奇数在偶数前面 并保证奇数和奇数，偶数和偶数之间的相对位置不变。 基本解法 1234567891011121314151617//基本解法public static void sort(int[] numbers) &#123; if (numbers == null || numbers.length == 0) &#123; return; &#125; int left = 0, right = numbers.length - 1; while (left &lt;= right) &#123; while ((numbers[left] &amp; 0x1) == 1) left++; while ((numbers[right] &amp; 0x1) == 0) right--; if (left &lt;= right) &#123; int tmp = numbers[left]; numbers[left] = numbers[right]; numbers[right] = tmp; &#125; &#125; &#125; 可扩展的实现，解耦，完成各种条件1234567891011121314151617181920212223242526272829303132333435363738394041// 可扩展的实现public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;2, 2, 1, 3, 6, 9, 8, 10, 7, 4, 5&#125;; sort(arr, new Condition() &#123; @Override public boolean check(int a) &#123; if ((a &amp; 0x1) == 1) return false; else &#123; return true; &#125; &#125; &#125;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; &#125; public static void sort(int[] numbers, Condition c) &#123; if (numbers == null || numbers.length == 0) &#123; return; &#125; int left = 0, right = numbers.length - 1; while (left &lt;= right) &#123; while (left &lt;= right &amp;&amp; c.check(numbers[left])) left++; while (left &lt;= right &amp;&amp; !c.check(numbers[right])) right--; if (left &lt;= right) &#123; int tmp = numbers[left]; numbers[left] = numbers[right]; numbers[right] = tmp; &#125; &#125; &#125; private interface Condition &#123; public boolean check(int a); &#125;&#125; 保证顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Solution &#123; //O(n^2) public void reOrderArray(int [] array) &#123; if (array == null || array.length == 0) &#123; return; &#125; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = array.length - 1; j &gt; i; j--) &#123; if (array[j] % 2 == 1 &amp;&amp; array[j - 1] % 2 == 0) &#123; int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; &#125; // O(n),辅助空间 public void reOrderArray2(int [] array) &#123; if (array == null || array.length == 0) &#123; return; &#125; int left = 0; int right = array.length - 1; int[] copy = new int[array.length]; int i = 0; int j = array.length - 1; //从前向后扫描奇数 while (left &lt; array.length ) &#123; if(array[left] % 2 == 1) copy[i++] = array[left]; left++; &#125; //从后向前扫描偶数 while (right &gt;= 0 ) &#123; if(array[right] % 2 == 0) copy[j--] = array[right]; right--; &#125; for(int k=0;k&lt;array.length;k++)&#123; array[k]=copy[k]; &#125; &#125;&#125; 顺时针打印矩阵 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Test &#123; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123;1, 2, 3, 4&#125;, &#123;12, 13, 14, 5&#125;, &#123;11, 16, 15, 6&#125;, // &#123;10,9,8,7&#125;, &#125;; ArrayList&lt;Integer&gt; list = printMatrix(matrix); for (int i : list) &#123; System.out.print(i + \" \"); &#125; &#125; public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return null; &#125; int start = 0;// 因为每次打印都是从对角线[0,0]、[1,1]……的开始，因此只需要一个变量来标记 int row = matrix.length; int col = matrix[0].length; ArrayList&lt;Integer&gt; printList = new ArrayList&lt;&gt;(); while (start * 2 &lt; row &amp;&amp; start * 2 &lt; col) &#123; ArrayList&lt;Integer&gt; result = print(matrix, row, col, start); printList.addAll(result); ++start; &#125; return printList; &#125; public static ArrayList&lt;Integer&gt; print(int[][] matrix, int row, int col, int start) &#123; int endX = col - start - 1; int endY = row - start - 1; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 打印从左到右的上面一行 :第一行肯定要打印的 for (int i = start; i &lt;= endX; i++) &#123; list.add(matrix[start][i]); &#125; // 打印从上到下的右面的一列：第二行能不能打印的条件在循环中了 for (int i = start + 1; i &lt;= endY; i++) &#123; list.add(matrix[i][endX]); &#125; if (start &lt; endX &amp;&amp; start &lt; endY) &#123; for (int i = endX - 1; i &gt;= start; i--) &#123; list.add(matrix[endY][i]); &#125; &#125; if (start &lt; endX &amp;&amp; start &lt; endY - 1) &#123; for (int i = endY - 1; i &gt; start; i--) &#123; list.add(matrix[i][start]); &#125; &#125; return list; &#125;&#125; 数组中超过一半的数字（还有一种解法） 解法1：基于partition的函数的O(n)算法，因为数字超过半数，因此将原数组排序后，中位数一定就是那个数值（如果输入是） 12 解法2：一个数字出现次数超过数组长度的一半，说明他出现的次数比其他所有数字出现的次数还多。因此可以用result，time来分别保存统计的数字，以及出现的次数。遍历时如果相同time+1，不同time-1，当time=0时，result更新为当前数字，time重置为1 1234567891011121314151617181920212223242526272829303132public static int MoreThanHalfNum_Solution(int[] array) &#123; //1.输入合法性验证 if (array == null || array.length == 0) return 0; //2.统计超过半数的数字 int result = array[0]; int time = 1; for (int i = 1; i &lt; array.length; i++) &#123; //当time=0时，result更新为当前数字，time重置为1 if (time == 0) &#123; result = array[i]; time = 1; continue; &#125; //遍历时如果相同time+1，不同time-1 if (result == array[i]) time++; else time--; &#125; //3.是否超过半数验证 time = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (result == array[i]) &#123; time++; &#125; &#125; if (time * 2 &lt;= array.length) result = 0; return result; &#125; 最小的k个数（包含海量数据） 解法1，小数据量：快排方法 O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Test &#123; public static void main(String[] args) &#123; int[] array = &#123;2, 3, 0, 2, 5, 7, 8, 9, 1&#125;; ArrayList&lt;Integer&gt; re = GetLeastNumbers_Solution(array, 10); System.out.println(re); &#125; public static ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //输入检验 if (input == null || input.length == 0 || k &lt;= 0 || k &gt; input.length) return result; int index = parttition(input, 0, input.length - 1); int start = 0; int end = input.length - 1; while (index != k - 1) &#123; if (index &lt; k - 1) &#123; start = index + 1; &#125; else &#123; end = index - 1; &#125; index = parttition(input, start, end); &#125; for (int i = 0; i &lt; k; i++) &#123; result.add(input[i]); &#125; return result; &#125; public static int parttition(int[] input, int low, int high) &#123; int i = low; int j = high; int mid = (low + high) / 2; swap(input, mid, low); int pivot = input[low]; while (i &lt; j) &#123; while (input[j] &gt;= pivot &amp;&amp; i &lt; j) j--; while (input[i] &lt;= pivot &amp;&amp; i &lt; j) i++; swap(input, i, j); &#125; swap(input, i, low); return i; &#125; public static void swap(int[] input, int i, int j) &#123; int temp = input[i]; input[i] = input[j]; input[j] = temp; &#125;&#125; 解法2，海量数据：使用红黑树 O(nlogk)，类似下面介绍的方法5 常见解法思路： 最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求，该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。 第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字与容器内的最小数字相比，如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。 第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。 第四种方法是Hash法。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。 第五种方法采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（n*mlogm），空间复杂度是10000（常数）。 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; int[] array = &#123;2, 3, 0, 2, 5, 7, 8, 9, 1&#125;; ArrayList&lt;Integer&gt; re = GetLeastNumbers_Solution(array, 10); System.out.println(re); &#125; public static ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //输入检验 if (input == null || input.length == 0 || k &lt;= 0 || k &gt; input.length) return result; TreeSet&lt;Integer&gt; topk=new TreeSet(); for (int val : input) &#123; if (topk.size() &lt; k) &#123; topk.add(val); &#125; else &#123; if(topk.last()&gt;val)&#123; topk.pollLast(); topk.add(val); &#125; &#125; &#125; result.addAll(topk); return result; &#125;&#125; 访问次数最多的IP参考：http://yueyemaitian.iteye.com/blog/1180299 算法思想：分而治之+Hash 1、IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 2、可以考虑采用分而治之的思想，按照IP地址的Hash(IP) % 1024值，把海量IP日志分别存储到1024个小文件中，这样，每个小文件最多包含4MB个IP地址； ​ 这里解释一下为什么用Hash(IP) % 1024值，如果不用，而直接分类的话，可能会出现这样一种情况，就是有个IP在每个小文件中都存在，而且这个IP并不一定在那个小文件中是数量最多的，那么最终可能选择的结果会有问题，所以这里用了Hash(IP)%1024值，这样的话，通过计算IP的Hash值，相同IP肯定会放到一个文件中，当然了不同的IP的Hash值也可能相同，就存在一个小文件中。 3、对于每一个小文件，可以构建一个IP为key，出现的次数为value的Hash Map，同时记录当前出现次数最多的那个IP地址； 4、可以得到1024个小文件中的出现次数最多的那个IP，再依据常规的排序算法得出总体上出现次数最多的IP。 连续子数组的最大和 解法1 O(n)，思路如下： 123456789101112131415161718192021222324252627282930313233public class Test &#123; public static void main(String[] args) &#123; int[] array = &#123;1,-2,3,10,-4,7,2,-5&#125;; System.out.println(FindGreatestSumOfSubArray(array)); &#125; public static int FindGreatestSumOfSubArray(int[] array) &#123; if (array == null || array.length == 0) return 0; int start = 0; int end = 0; int max = array[0]; int sum = array[0]; // 初始化为数组中的第一个数 for (int i = 1; i &lt; array.length; i++) &#123; // 如果之前的和&lt;=0，说明从之前某个位置开始的子数组的和 会小于 从当前位置开始的子数组的和 // 因此可以不考虑之前的子数组，Sum重置为当前位置的值 if (sum &lt;= 0) &#123; start = i; end = i; sum = array[i]; &#125;else&#123; sum = sum + array[i]; &#125; // 更新最大和 if (sum &gt; max) &#123; max = sum; end = i; //更新子数组最后的下标 &#125; &#125; System.out.println(\"[\"+start+\",\"+end+\"]\"); return max; &#125;&#125; 解法2：动态规划 123456789101112131415161718192021public static int FindGreatestSumOfSubArray(int[] array) &#123; if (array == null || array.length == 0) return 0; int len = array.length; int[] f = new int[len]; f[0] = array[0]; for (int i = 1; i &lt; len; i++) &#123; // 递归公式 // f[i] = array[i] # i=0 或者 f[i-1]&lt;=0 // f(i) = f[i - 1] + array[i] # f[i-1]&gt;0 f[i] = f[i - 1] &lt;= 0 ? array[i] : f[i - 1] + array[i]; &#125; int max = Integer.MIN_VALUE; for (int i : f) &#123; if (max &lt; i) &#123; max = i; &#125; &#125; return max; &#125; 解法3：分治（未实现） 把数组排成最小的数 12345678910111213141516171819202122232425262728import java.util.*;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; // 输入合法性检测 if (numbers == null || numbers.length == 0) &#123; return \"\"; &#125; // 将数字转为字符串类型 ArrayList&lt;String&gt; nums = new ArrayList&lt;&gt;(); for (int i : numbers) &#123; nums.add(Integer.toString(i)); &#125; // 使用自定义的规则 进行排序 Collections.sort(nums, new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; //为了避免长度问题，将其拼接后再进行字符串比较 return (s1 + s2).compareTo(s2 + s1); &#125; &#125;); // 处理最后的结果 return String.join(\"\",nums); &#125;&#125; 数组中的逆序对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static int InversePairs(int[] array) &#123; if (array == null || array.length &lt;= 0) &#123; return 0; &#125; return countInverse(array, 0, array.length - 1) % 1000000007; &#125; public static int countInverse(int[] array, int low, int high) &#123; if (low &gt;= high) &#123; return 0; &#125; int mid = (low + high) / 2; int leftCount = countInverse(array, low, mid); int rightCount = countInverse(array, mid + 1, high); // 拷贝一份数组的左右部分，用于排序并统计，注意copyOfRange[begin,end)，不包括end位置 int[] leftCopy = Arrays.copyOfRange(array, low, mid + 1); int[] rightCopy = Arrays.copyOfRange(array, mid + 1, high + 1); // 排序并统计逆序对 int i = leftCopy.length - 1; int j = rightCopy.length - 1; int index = high; int count = 0; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (leftCopy[i] &lt;= rightCopy[j]) &#123; array[index--] = rightCopy[j--]; &#125; else &#123; array[index--] = leftCopy[i--]; count += (j + 1); // 避免数据溢出，进行取余 if (count &gt; 1000000007) count %= 1000000007; &#125; &#125; // 将剩余的部分拷贝回原数组 for (; i &gt;= 0; i--) &#123; array[index--] = leftCopy[i]; &#125; for (; j &gt;= 0; j--) &#123; array[index--] = rightCopy[j]; &#125; // 避免数据溢出，进行取余 int result = leftCount + rightCount + count; if (result &gt; 1000000007) result %= 1000000007; return result; &#125; 数字在排序数组中出现的次数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static int GetNumberOfK(int[] array, int k) &#123; int count = 0; if (array != null || array.length &gt; 0) &#123; // 先找到第一个位置 int start = getFirstK(array, k, 0, array.length - 1); if (start == -1) return 0;// 查找不到在则直接返回 // 再找最后出现的位置 int end = getLastK(array, k, 0, array.length - 1); count = end - start + 1; &#125; return count;&#125;public static int getFirstK(int[] array, int k, int low, int high) &#123; if (low &gt; high) &#123; return -1; &#125; int mid = (low + high) / 2; int midData = array[mid]; if (midData == k) &#123; // 如果已经是数组第一个 或者 mid前一个位置小于k，则说明已经找到第一个k的位置了 if (mid == 0 || (mid &gt; 0 &amp;&amp; array[mid - 1] &lt; k)) &#123; return mid; &#125; else &#123; high = high - 1; &#125; &#125; else if (midData &lt; k) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; return getFirstK(array, k, low, high);&#125;public static int getLastK(int[] array, int k, int low, int high) &#123; if (low &gt; high) &#123; return -1; &#125; int mid = (low + high) / 2; int midData = array[mid]; if (midData == k) &#123; // 如果已经是数组最后一个 或者 mid后一个位置大于k，则说明已经找到最后一个k的位置了 if (mid == high || (mid &lt; high &amp;&amp; array[mid + 1] &gt; k)) &#123; return mid; &#125; else &#123; low = mid + 1; &#125; &#125; else if (midData &lt; k) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; return getLastK(array, k, low, high);&#125; 数组中只出现一次的数字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Test &#123; public static void main(String[] args) &#123; int[] array = &#123;2, 4, 3, 6, 3, 2, 5, 5&#125;; int[] num1 = new int[1]; int[] num2 = new int[1]; FindNumsAppearOnce(array, num1, num2); System.out.println(num1[0]); System.out.println(num2[0]); &#125; public static void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123; if (array == null || array.length &lt; 2) return; // 先遍历一遍求出异或的结果 int xorResult = 0; for (int i : array) &#123; xorResult ^= i; &#125; int index = findFirstBit(xorResult); //找到第一个bit为1的下标 // 利用第一个bit为1的下标将数组分割为两部分，每部分index位置的bit相同 int n1 = 0; int n2 = 0; for (int i : array) &#123; if (isSameBit(i, index)) n1 ^= i; else n2 ^= i; &#125; num1[0] = n1; num2[0] = n2; &#125; // 从右往左寻找第一个为1的二进制下标 public static int findFirstBit(int num) &#123; int i = 1; int index = 0; while (index &lt; Integer.SIZE) &#123; if ((i &amp; num) == i) break; i = i &lt;&lt; 1; index++; &#125; return index; &#125; // 判断指定下标的位置的二进制是否为1 public static boolean isSameBit(int num, int leftShift) &#123; int i = 1 &lt;&lt; leftShift; return (num &amp; i) == i; &#125;&#125; 相似题：leetcode：single-number、 single-number-ii 在数组中寻找 和为s的两个数字 思路：分别从最左和最右逼近，如果和小于s，则i++，如果和大于s，则j– 12345678910111213141516171819// 如果有多对数字的和等于S，输出两个数的乘积最小的。 public static ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (array == null || array.length &lt; 2) return result; int i = 0; int j = array.length - 1; while (i &lt; j) &#123; if (array[i] + array[j] == sum) &#123; result.add(array[i]); result.add(array[j]); return result; &#125; else if (array[i] + array[j] &lt; sum) &#123; i++; &#125; else &#123; j--; &#125; &#125; return result; &#125; 寻找和为s的连续序列 12345678910111213141516171819202122232425262728293031323334public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if (sum &lt;= 0) return result; // 初始化将sum分为一大一小的2个数字 int small = sum / 2; int big = sum / 2 + 1; int curSum = small + big; while (small &gt;= 1) &#123; if (curSum == sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = small; i &lt;= big; i++) &#123; list.add(i); &#125; result.add(list); // 通过添加更小的small，获得产生新的序列 small--; curSum += small; &#125; else if (curSum &gt; sum) &#123; // 偏大，则剪去big，加上更小的small small--; curSum = curSum - big + small; big--; &#125; else &#123; // 偏小则再加一个更小的small small--; curSum += small; &#125; &#125; // 序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 result.sort(Comparator.comparingInt(c -&gt; c.get(0))); return result;&#125; 数组中重复的数字在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路： 12345678910111213141516171819202122232425262728public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if (numbers == null || numbers.length &lt;= 1) return false; for (int i = 0; i &lt; length; i++) &#123; while (numbers[i] != i) &#123; int m = numbers[i]; // 如果m和第m个数字相等，则说明m该去的位置被人占了，就找到了第一个重复的数字 if (m == numbers[m]) &#123; duplication[0] = m; return true; &#125; // 否则交换m到对应的第m个位置 numbers[i] = numbers[m]; numbers[m] = m; &#125; &#125; return false; &#125;&#125; 构建乘积数组 先算左边部分A0–Ai，再乘以右边部分Ai-1—An-1 12345678910111213141516171819202122232425262728293031package offer;/** * 构建乘积数组 * * @author jizx * @date 2018/07/24 17:27 */public class Multiply &#123; public int[] multiply(int[] A) &#123; if (A == null || A.length == 0) return null; int len = A.length; int[] B = new int[len]; //自底向上地累乘A[i-1] B[0] = 1; for (int i = 1; i &lt; len; i++) &#123; B[i] = B[i - 1] * A[i - 1]; &#125; //自上向下地在原来基础上，再累成A[i] int temp = 1;//这就是右半部分的乘积 for (int i = len - 1; i &gt;= 0; i--) &#123; B[i] = B[i] * temp; temp = temp * A[i]; &#125; return B; &#125;&#125; 有序数组的交集12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * 有序数组的交集 * * @author jizx * @date 2018/08/19 10:18 */public class Jiaoji &#123; public static void main(String[] args) &#123; int[] a = &#123;1, 3, 8, 10, 11&#125;; int[] b = &#123;1, 3, 9, 10, 12&#125;; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); jiaoji(a, b, result); System.out.println(result); &#125; public static void jiaoji(int[] a, int[] b, List&lt;Integer&gt; result) &#123; if (a == null || b == null || a.length == 0 || b.length == 0) return; int[] min = a; int[] max = b; if (a.length &gt; b.length) &#123; min = b; max = a; &#125; int index = Arrays.binarySearch(max, min[min.length / 2]); if (index &gt;= 0) &#123; result.add(max[index]); // min中去除min[min.length / 2]，max中去除max[index]因为以及找到了 jiaoji(Arrays.copyOfRange(min, 0, min.length / 2), Arrays.copyOfRange(max, 0, index), result); jiaoji(Arrays.copyOfRange(min, min.length / 2 + 1, min.length), Arrays.copyOfRange(max, index + 1, max .length), result); &#125; else &#123; index = -index - 1; jiaoji(Arrays.copyOfRange(min, 0, min.length / 2), Arrays.copyOfRange(max, 0, index), result); jiaoji(Arrays.copyOfRange(min, min.length / 2 + 1, min.length), Arrays.copyOfRange(max, index, max.length), result); &#125; &#125;&#125; 字符串4.字符串替换空格（未实现） 先遍历一次字符串，这样就能统计出字符串中空格的总数 准备两个指针p1，p2,。p1指向原始字符串的末尾，p2指向替换后的字符串的末尾 p1、p2同时移动，先前复制，直到p1遇到空格 p2向前插入‘%20’ p1、p2继续同时先前移动，直到p1与p2相遇 12 35.第一个只出现一次的字符 123456789101112131415161718192021222324import java.util.*;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; // 非法输入检测 if (str == null || \"\".equals(str)) return -1; char[] chars = str.toCharArray(); HashMap&lt;Character, Integer&gt; counter = new HashMap&lt;&gt;(); // 第一遍遍历进行统计 for (char c : chars) &#123; int num = counter.get(c) != null ? counter.get(c) + 1 : 1; counter.put(c, num); &#125; // 第二遍遍历进行搜索 int index = 0; for (char c : chars) &#123; if (counter.get(c) == 1) return index; index++; &#125; return -1; &#125;&#125; 翻转单词顺序 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; System.out.println(ReverseSentence(\"student. a am I\")); &#125; public static String ReverseSentence(String str) &#123; if (str == null || str.length() &lt;= 0) return \"\"; char[] chars = str.toCharArray(); // 先将整个字符串翻转 reverseChars(chars, 0, chars.length); // 通过空格来定位每个单词的位置，然后进行单词的翻转 int start = 0;//指向单词第一个字符 int end = 0;//指向单词后的第一个空格 for (char c : chars) &#123; if (c != ' ') &#123; end++; if (end == chars.length) reverseChars(chars, start, end); &#125; else &#123; // start与end之间是一个单词的情况 if (start != end) &#123; reverseChars(chars, start, end); &#125; end++; start = end;// start移动到end位置 &#125; &#125; return new String(chars); &#125; // start：翻转的开始位置，不包括end位置的字符 public static void reverseChars(char[] str, int start, int end) &#123; int i = start; int j = end - 1; while (i &lt; j) &#123; char c = str[i]; str[i] = str[j]; str[j] = c; i++; j--; &#125; &#125;&#125; 左旋转字符串(循环左移字符串)题目描述（推荐）：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; System.out.println(LeftRotateString(\"abcXYZdef\",3)); &#125; public String LeftRotateString(String str,int n) &#123; if (str == null || str.length() &lt;= 0) return \"\"; char[] chars = str.toCharArray(); // 通过3次翻转即可实现 reverseChars(chars,0,n); reverseChars(chars,n,chars.length); reverseChars(chars,0,chars.length); return new String(chars); &#125; // 字符翻转 public static void reverseChars(char[] str, int start, int end) &#123; int i = start; int j = end - 1; while (i &lt; j) &#123; char c = str[i]; str[i] = str[j]; str[j] = c; i++; j--; &#125; &#125;&#125; 将字符串转换为整数题目描述： 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 1234567891011121314151617181920// 测试用例有:+123,-123,234k234 public static int StrToInt(String str) &#123; if (str == null || str.length() &lt;= 0) return 0; int result = 0; boolean isMinus = false; char[] chars = str.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; // 如果不是数字，则判断是否是在第一位的正负号 if (chars[i] &lt; '0' || chars[i] &gt; '9') &#123; if ((i != 0) || (chars[i] != '+' &amp;&amp; chars[i] != '-')) return 0; else &#123; if (chars[i] == '-') isMinus = true; continue; &#125; &#125; result = result * 10 + chars[i] - '0';// 注意字符要与‘0’进行相减，才是真正对应的数字 &#125; return isMinus ? -1 * result : result; &#125; 字符串判断是否为有效数值1234567891011121314151617181920212223242526272829303132333435363738394041package offer;/** * 判断字符串是否为有效的数值 * * @author jizx * @date 2018/07/24 17:45 */public class IsNumeric &#123; public static void main(String[] args) &#123; IsNumeric app=new IsNumeric(); System.out.println(app.isNumeric(\"-1.e0\".toCharArray())); &#125; public boolean isNumeric(char[] str) &#123; if (str == null || str.length == 0) return false; boolean dot = false; boolean e = false; boolean sign = false; for (int i = 0; i &lt; str.length; i++) &#123; if ((str[i] == '+' || str[i] == '-')) &#123; if (i == 0) sign = true;// 首位 else if (str[i - 1] == 'e' || str[i - 1] == 'E') &#123;&#125; // 紧跟在e后面 else return false; &#125; else if (str[i] == 'e' || str[i] == 'E') &#123; if (e == true) return false;// 已经有e了 else if (i == str.length - 1) return false; // e后面没有数字了 else e = true; &#125; else if (str[i] == '.') &#123; // 在e后面，不能有小数点、或者已经有小数点了 if (e == true || dot == true) return false; else dot = true; &#125; else &#123; if (str[i] &lt; '0' || str[i] &gt; '9') return false; // 其他非法字符 &#125; &#125; return true; &#125;&#125; 字符串的排列 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;import java.util.*;public class Solution &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;(); public ArrayList&lt;String&gt; Permutation(String str) &#123; if (str == null || str.length() == 0) return result; char[] chars = str.toCharArray(); permutation(0, chars); // HashSet&lt;String&gt; set=new HashSet&lt;&gt;(result); result.clear(); result.addAll(set); Collections.sort(result); return result; &#125; public void permutation(int prefix, char[] str) &#123; if (prefix == str.length) &#123; result.add(new String(str)); return; &#125; // [a,b,c]，prefix表示固定的位置，比如a，然后将a与后面的字符依次进行交换 for (int i = prefix; i &lt; str.length; i++) &#123; // 将固定位置的值与数组中的第i个字符交换 char temp = str[i]; str[i] = str[prefix]; str[prefix] = temp; // 递归处理[b,c] permutation(prefix + 1, str); //还原交换 temp = str[i]; str[i] = str[prefix]; str[prefix] = temp; &#125; &#125;&#125; 链表java实现链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * @author jizx * @date 2018/04/20 15:09 */public class Test &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list = new LinkedList(); list.add(\"a\"); list.add(\"c\"); list.add(\"bb\"); list.insert(3, \"1\"); list.printList(); // System.out.println(list.find(\"2\")); System.out.println(list.search(3)); list.printList(); &#125;&#125;class LinkedList&lt;E&gt; &#123; private class Node&lt;E&gt; &#123; private E data; Node next = null; public Node() &#123; data = null; &#125; public Node(E data) &#123; this.data = data; &#125; &#125; private Node head; private Node tail; private int length; public LinkedList() &#123; head = new Node(); tail = head; length = 0; &#125; public void add(E data) &#123; Node newNode = new Node(data); tail.next = newNode; tail = newNode; length++; &#125; public void insert(int position, E data) &#123; if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; int i = 0; Node current = head; while (i &lt; position) &#123; current = current.next; i++; &#125; Node temp = current.next; Node newNode = new Node(data); newNode.next = temp; current.next = newNode; &#125; else &#123; System.out.println(\"超出范围\"); &#125; length++; &#125; public void remove(E data) &#123; Node pre = head; Node current = head.next; while (current != null) &#123; if (current.data.equals(data)) &#123; pre.next = current.next; break; &#125; else &#123; pre = current; current = current.next; &#125; &#125; &#125; public void set(int position, E data) &#123; Node current = head.next; while (current != null) &#123; if (current.data.equals(data)) &#123; break; &#125; else &#123; current = current.next; &#125; &#125; &#125; public int find(E data) &#123; E result = null; Node current = head.next; int position = 0; while (current != null) &#123; if (current.data.equals(data)) &#123; return position; &#125; else &#123; current = current.next; position++; &#125; &#125; return -1; &#125; public E search(int position) &#123; int i = -1; Node current = head; if (position &gt;= 0 &amp;&amp; position &lt; length) &#123; while (i &lt; position) &#123; i++; current = current.next; &#125; return (E) current.data; &#125; else &#123; System.out.println(\"超出范围\"); return null; &#125; &#125; public int length() &#123; return length; &#125; public void printList() &#123; Node current = head.next; while (current != null) &#123; System.out.println(current.data); current = current.next; &#125; &#125;&#125; 从尾到头打印链表 12 O(1)时间删除链表结点(未实现) 12 链表中倒数第k个节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Test &#123; public static void main(String[] args) &#123; ListNode head = new ListNode(1); ListNode cur = head; for (int i = 2; i &lt;= 5; i++) &#123; ListNode node = new ListNode(i); cur.next = node; cur = node; &#125; try &#123; ListNode newHead = findKNode(head, 0); while (newHead != null) &#123; System.out.println(newHead.val); newHead = newHead.next; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static ListNode findKNode(ListNode head, int k) &#123; if (head == null|| k &lt;= 0) &#123; return null; &#125; ListNode ahead = head; ListNode behind = ahead; // 两者相差k-1个位置，因此ahead先走k-1个位置 for (int i = 0; i &lt; k - 1; i++) &#123; if (ahead.next != null) ahead = ahead.next; else return null; &#125; // 然后两者一起移动 while (ahead.next != null) &#123; ahead = ahead.next; behind = behind.next; &#125; return behind; &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 反转链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Test &#123; public static void main(String[] args) &#123; ListNode head = new ListNode(0); ListNode cur=head; for (int i = 1; i &lt;= 10; i++) &#123; ListNode node = new ListNode(i); cur.next = node; cur = node; &#125; try &#123; ListNode newHead = ReverseList(head); while (newHead != null) &#123; System.out.println(newHead.val); newHead = newHead.next; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static ListNode ReverseList(ListNode head) &#123; // 边界处理 if (head == null) return null; if (head.next == null) return head; ListNode remainHead = null; // h:剩余未反转的链表头 ListNode handlingNode = head; // i:正在处理的结点，从head开始，它的next指向原方向，因此正要反转 ListNode reversedHead = null; // j:已经反转的链表头 while (handlingNode != null) &#123; // 原来 reversedHead handlingNode --&gt; remainHead --&gt;k // 反转 reversedHead &lt;-- handlingNode remainHead --&gt;k remainHead = handlingNode.next; handlingNode.next = reversedHead; // 更新结点为下一次要处理的位置 reversedHead = handlingNode; handlingNode = remainHead; &#125; return reversedHead; &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 合并两个有序的链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Test &#123; public static void main(String[] args) &#123; ListNode list1 = new ListNode(1); ListNode list2 = new ListNode(2); ListNode cur1 = list1; ListNode cur2 = list2; for (int i = 3; i &lt;= 10; i++) &#123; ListNode node1 = new ListNode(i); ListNode node2 = new ListNode(++i); cur1.next = node1; cur2.next = node2; cur1 = node1; cur2 = node2; &#125; ListNode newHead = Merge(list1, list2); while (newHead != null) &#123; System.out.print(newHead.val + \" \"); newHead = newHead.next; &#125; &#125; public static ListNode Merge(ListNode list1, ListNode list2) &#123; // 有一个链表为空，直接返回另一个链表 if (list1 == null) return list2; if (list2 == null) return list1; // 新链表的头结点初始化为较小的链表的头结点 ListNode head = list1.val &lt; list2.val ? list1 : list2; ListNode temp; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt; list2.val) &#123; temp = list1.next; list1.next = list2; list1 = temp; &#125; else &#123; temp = list2.next; list2.next = list1; list2 = temp; &#125; &#125; return head; &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 复杂链表的复制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead==null)&#123; return null; &#125; copyChain(pHead); copySibling(pHead); return splitChain(pHead); &#125; /**第一步：复制链表，暂时不考虑random 字段 * A-&gt;B-&gt;C 变为 A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C' * */ public void copyChain(RandomListNode pHead) &#123; RandomListNode cur = pHead; while (cur != null) &#123; RandomListNode n = new RandomListNode(cur.label); n.next = cur.next; cur.next = n; cur = n.next; &#125; &#125; /**第二步：考虑复制sibling字段*/ public void copySibling(RandomListNode pHead) &#123; RandomListNode cur = pHead; while (cur != null) &#123; RandomListNode clone = cur.next; RandomListNode sibling = cur.random; if (sibling != null) &#123; clone.random = sibling.next; &#125; cur = clone.next; &#125; &#125; /**第三步：拆分链表，抽取出copy链表*/ public RandomListNode splitChain(RandomListNode pHead) &#123; RandomListNode copy = pHead.next; RandomListNode cur1 = pHead; RandomListNode cur2 = pHead.next; while (cur1 != null &amp;&amp; cur2 != null) &#123; cur1.next = cur2.next; cur1 = cur1.next; if(cur1!=null)&#123; cur2.next=cur1.next; &#125; cur2=cur2.next; &#125; return copy; &#125;&#125; 查找链表的中间节点（未实现）思路：采用快慢指针的方式查找单链表的中间节点，快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针刚好到达中间节点 12 两个链表的第一个公共结点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.*;public class Test &#123; public static void main(String[] args) &#123; ListNode a1=new ListNode(1); ListNode a2=new ListNode(2); ListNode a3=new ListNode(3); ListNode a4=new ListNode(4); ListNode a5=new ListNode(5); ListNode a6=new ListNode(6); ListNode a7=new ListNode(7); a1.next=a2; a2.next=a3; a3.next=a6; a4.next=a5; a5.next=a6; a6.next=a7; System.out.println(FindFirstCommonNode(a1,a4)); &#125;public static ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if (pHead1 == null || pHead2 == null) return null; // 先遍历一遍找出两个链表的长度 int len1 = getLength(pHead1); int len2 = getLength(pHead2); ListNode longList = pHead1; ListNode shortList = pHead2; int diff = len1 - len2; if (len1 &lt; len2) &#123; longList = pHead2; shortList = pHead1; diff = len2 - len1; &#125; // 然后让长的链表先走多的长度 for (int i = 0; i &lt; diff; i++) &#123; longList = longList.next; &#125; // 最后一起走，第一个相同结点就是公共结点 while (longList != null &amp;&amp; shortList != null) &#123; if (longList == shortList)&#123; return longList; &#125; longList = longList.next; shortList = shortList.next; &#125; return null; &#125; public static int getLength(ListNode list) &#123; int len = 0; ListNode current = list; while (current != null) &#123; current = current.next; len++; &#125; return len; &#125;&#125; 链表中环的入口节点如果一个链表中包含环，如何找出环的入口节点？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.*;/** * 链表中环的入口 * * @author jizx * @date 2018/07/03 18:39 */public class EntryNodeOfLoop &#123; public static void main(String[] args) &#123; EntryNodeOfLoop app = new EntryNodeOfLoop(); ListNode a1=new ListNode(1); ListNode a2=new ListNode(2); ListNode a3=new ListNode(3); ListNode a4=new ListNode(4); ListNode a5=new ListNode(5); ListNode a6=new ListNode(6); a1.next=a2; a2.next=a3; a3.next=a4; a4.next=a5; a5.next=a6; a6.next=a3; System.out.println(app.EntryNodeOfLoop(null)); &#125; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; // 1.判断是否有环,如果有则返回环内的一个节点 ListNode loopNode = meetingNode(pHead); if (loopNode == null) return null; // 2.计数环的长度 int count = 1; ListNode search = loopNode.next; while (loopNode != search) &#123; count++; search = search.next; &#125; // 3.找到入口 ListNode behind = pHead;// 慢指针 ListNode prev = pHead;//快指针 // 让快指针先走count个节点，这样才能保证他们相遇的节点是入口节点 while (count-- &gt; 0) &#123; prev = prev.next; &#125; while(prev!=behind)&#123; prev=prev.next; behind=behind.next; &#125; return prev; &#125; /** * 使用快慢指针，当其相遇时有环，快指针==null时无环 */ private ListNode meetingNode(ListNode head) &#123; if (head == null) return null; ListNode slow = head;// 慢指针 ListNode fast = slow.next;//快指针 while (slow != null &amp;&amp; fast != null) &#123; // 如果快慢指针相遇、快指针的下一个是慢指针，则有环 if (slow == fast || fast.next == slow) &#123; return slow; &#125; // 更新快慢指针位置 slow = slow.next; fast = fast.next; if (fast != null) fast = fast.next; &#125; return null; &#125;&#125; 删除链表中重复的结点在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 删除链表中重复的结点 * * @author jizx * @date 2018/07/06 10:41 */public class DeleteDuplication &#123; public static void main(String[] args) &#123; DeleteDuplication app = new DeleteDuplication(); int[] nums = &#123;1, 1, 2, 3, 3, 4, 5, 5&#125;; ListNode a1 = app.create(nums); a1 = app.deleteDuplication(a1); while (a1 != null) &#123; System.out.print(a1.val + \"--&gt;\"); a1 = a1.next; &#125; &#125; public ListNode deleteDuplication(ListNode pHead) &#123; // null或者只有一个结点时 直接返回 if (pHead == null || pHead.next == null) return pHead; ListNode newHead = new ListNode(0);// 新链表的头结点 newHead.next = pHead; ListNode pre = newHead;// 记录前一个不重复的结点 ListNode cur = pre.next;// 当前结点 while (cur != null &amp;&amp; cur.next != null) &#123; // 当前结点与下一结点相等 if (cur.val == cur.next.val) &#123; do&#123; cur = cur.next; &#125; while (cur.next != null &amp;&amp; cur.next.val == cur.val); cur = cur.next; // 更新到这个暂时不重复的点 pre.next = cur; // pre的next连接到这个暂时不重复的点 &#125; // 当前结点与下一结点不相等 else &#123; pre = cur;// 则pre更新到这个可以确认是不重复的点上 cur = cur.next; // 移动cur &#125; &#125; return newHead.next; &#125; // 保留一个重复结点 public ListNode deleteDuplication2(ListNode pHead) &#123; ListNode p = pHead; while (p != null) &#123; ListNode q = p; while (q.next != null) &#123; if (p.val == q.next.val) &#123; q.next = q.next.next; &#125; else q = q.next; &#125; p = p.next; &#125; return pHead; &#125; public ListNode create(int[] nums) &#123; ListNode cur = new ListNode(0); ListNode head = cur; for (int i = 0; i &lt; nums.length; i++) &#123; cur.next = new ListNode(nums[i]); cur = cur.next; &#125; return head.next; &#125;&#125; 树重建二叉树 12345678910111213141516171819public class Solution &#123; public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if (pre.length == 0 || in.length == 0) &#123; return null; &#125; //先取【先序】的第一个元素，作为根结点 TreeNode root = new TreeNode(pre[0]); //然后遍历【中序】，找到对应的根结点，进行划分数组 for (int i = 0; i &lt; in.length; i++) &#123; if (in[i] == pre[0]) &#123; //注意i对应的是中序的下标，因此是截取pre[1，i+1] root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i)); root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length)); &#125; &#125; return root; &#125;&#125; 层序遍历 1234567891011121314151617public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; result=new ArrayList&lt;&gt;(); if(root==null)&#123; return result; &#125; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node=queue.poll(); result.add(node.val); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); &#125; return result; &#125; 树的子结构 12345678910111213141516171819202122232425262728293031class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean isTree = false; if (root1 != null &amp;&amp; root2 != null) &#123; // 如果当前两个根结点相等，则进行检查 if (root1.val == root2.val) isTree = isSubTree(root1, root2); // 否则递归对root1的左子树判断 if (!isTree) isTree = HasSubtree(root1.left, root2); // 左子树也没有，则递归对root1的右子树判断 if (!isTree) isTree = HasSubtree(root1.right, root2); &#125; return isTree; &#125; public boolean isSubTree(TreeNode root1, TreeNode root2) &#123; if(root2==null) return true; //root2匹配完了，因此true if(root1==null) return false; //root2不为null而root1==null，则不相同 if(root1.val!=root2.val) return false; //当前结点相等，则判断左子树，然后判断右子树 return isSubTree(root1.left, root2.left) &amp;&amp; isSubTree(root1.right, root2.right); &#125;&#125; 二叉树的镜像 12345678910111213141516171819202122232425class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; // 先序遍历的方法 public static void Mirror(TreeNode root) &#123; if (root == null) &#123; return; &#125; // 交换子节点 TreeNode temp = root.left; root.left = root.right; root.right = temp; // 递归处理子节点 Mirror(root.left); Mirror(root.right); &#125;&#125; 二叉搜索树的后序遍历序列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Test &#123; public static void main(String[] args) &#123; int[] a = &#123;5, 7, 6, 9, 11, 10, 8&#125;; int[] b = &#123;6, 8, 7, 5&#125;; int[] c = &#123;4, 8, 6, 12, 16, 14, 10&#125;; int[] d = &#123;&#125;; System.out.println(VerifySquenceOfBST(d)); &#125; public static boolean VerifySquenceOfBST(int[] sequence) &#123; // 为空则false if (sequence == null || sequence.length == 0) &#123; return false; &#125; // 只有一个点，则为true，直接返回不用递归了 if (sequence.length == 1) &#123; return true; &#125; int i = 0; int high = sequence.length - 1; int root = sequence[high]; // 以root判断大小，寻找划分点，i最终会落在第一个大于root的位置 while (sequence[i] &lt; root) &#123; i++; &#125; //判断右子树是否都大于root，否则就不可能是后序遍历 for (int j = i; j &lt; high; j++) &#123; if (root &gt; sequence[j]) return false; &#125; // copyOfRange : [begin,end),不包含end int[] leftTree = Arrays.copyOfRange(sequence, 0, i); int[] rightTree = Arrays.copyOfRange(sequence, i, high); boolean leftResult = true; boolean rightResult = true; if (leftTree.length &gt; 0) &#123; leftResult = VerifySquenceOfBST(leftTree); &#125; if (rightTree.length &gt; 0) &#123; rightResult = VerifySquenceOfBST(rightTree); &#125; return leftResult &amp;&amp; rightResult; &#125;&#125; 二叉树中和为某一值的路径 123456789101112131415161718192021222324252627282930313233343536373839public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allRoad = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if (root != null) &#123; Stack&lt;Integer&gt; road = new Stack&lt;&gt;(); path(root, target, road, 0, allRoad); &#125; return allRoad; &#125; public static void path(TreeNode root, int target, Stack&lt;Integer&gt; road, int currentSum, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allRoad) &#123; currentSum = root.val + currentSum; TreeNode left = root.left; TreeNode right = root.right; // 超过目标值，不必向下继续 if (currentSum &gt; target) &#123; return; &#125; // 叶结点,但值不等于目标值,返回 if (left == null &amp;&amp; right == null &amp;&amp; currentSum != target) &#123; return; &#125; road.push(root.val); // 叶结点，值等于目标值，添加路径 if (left == null &amp;&amp; right == null &amp;&amp; currentSum == target) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for (int i : road) &#123; result.add(i); &#125; allRoad.add(result); &#125; if (left != null) &#123; path(left, target, road, currentSum, allRoad); &#125; if (right != null) &#123; path(right, target, road, currentSum, allRoad); &#125; road.pop(); &#125; 二叉搜索树与双向链表转换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Test &#123; public static void main(String[] args) &#123; TreeNode n1 = new TreeNode(1); TreeNode n2 = new TreeNode(2); TreeNode n3 = new TreeNode(3); TreeNode n4 = new TreeNode(4); TreeNode n5 = new TreeNode(5); TreeNode n6 = new TreeNode(6); TreeNode n7 = new TreeNode(7); //构建树 n4.left = n2; n4.right = n6; n2.left = n1; n2.right = n3; n6.left = n5; n6.right = n7; Convert(n4); &#125; public static TreeNode Convert(TreeNode pRootOfTree) &#123; TreeNode lastVisitNode = null; // 注意，不可以将lastVisitNode直接传入，因为就像传入null，不会赋值给lastVisitNode lastVisitNode = convertNode(pRootOfTree, lastVisitNode); // 完成转换，从lastVisitNode往前遍历，到头结点 TreeNode first = lastVisitNode; while (first != null) &#123; if(first.left==null) break; first = first.left; &#125; return first; &#125; /** * currentNode：当前节点 * lastVisitNode：最后访问的节点，同时也是双向链表的最右节点 */ public static TreeNode convertNode(TreeNode currentNode, TreeNode lastVisitNode) &#123; if (currentNode == null) return null; //先处理左子树，同时获得左子树最右边的点（最大点） if (currentNode.left != null) &#123; lastVisitNode = convertNode(currentNode.left, lastVisitNode); &#125; //互相连接，当前节点的left连接lastVisitNode,同时lastVisitNode的right连接当前节点 currentNode.left = lastVisitNode; if (lastVisitNode != null) lastVisitNode.right = currentNode; lastVisitNode = currentNode; //最后访问的节点更新为当前节点 // 处理右子树 if (currentNode.right != null) &#123; lastVisitNode = convertNode(currentNode.right, lastVisitNode); &#125; return lastVisitNode; &#125;&#125;class TreeNode &#123; int val = 0; TreeNode left = null; // 连接小的结点 TreeNode right = null; // 连接大的结点 public TreeNode(int val) &#123; this.val = val; &#125;&#125; 二叉树的深度,以及是否是平衡二叉树 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; &#125; public static int TreeDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; &#125;&#125;class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Test &#123; public static void main(String[] args) &#123; TreeNode a1 = new TreeNode(1); TreeNode a2 = new TreeNode(2); TreeNode a3 = new TreeNode(3); TreeNode a4 = new TreeNode(4); TreeNode a5 = new TreeNode(5); TreeNode a6 = new TreeNode(6); TreeNode a7 = new TreeNode(7); TreeNode a8 = new TreeNode(8); a1.left=a2; a1.right=a3; a2.left=a4; a2.right=a5; a5.right=a7; a3.left=a8; a3.right=a6; System.out.println(IsBalanced_Solution(a1)); &#125; public static boolean IsBalanced_Solution(TreeNode root) &#123; if (root == null) return true; return isBalanced(root) != -1; &#125; // 返回值 -1：非平衡树，0：null结点，正数：树的深度 public static int isBalanced(TreeNode root) &#123; if (root == null) return 0; int leftDepth = isBalanced(root.left); int rightDepth = isBalanced(root.right); // 如果左右子树都是平衡树，则进行深度比较；如果深度差满足要求，则返回最大深度 if (leftDepth != -1 &amp;&amp; rightDepth != -1) &#123; if (Math.abs(leftDepth - rightDepth) &lt;= 1) &#123; return Math.max(leftDepth, rightDepth) + 1; &#125; &#125; return -1; &#125;&#125;class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 中序遍历二叉树,求某一节点的下一中序节点1234567891011121314151617181920212223242526272829public static TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) return null; // 1.有右结点，则找该右结点的最左结点 if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; /* 2.没有右节点，则向上找父节点 a a b b c c d d c是当前节点。确定c是在某个节点(a)的左子树中，还是(a)的右子树中； 如果在左子树中，则找到的第一个包含c的节点就是下一个中序输出的节点； 否则，就没有下一个节点了 * */ TreeLinkNode parent = pNode.next; while (parent != null) &#123; if (parent.left == pNode) return parent; pNode = parent; parent = parent.next; &#125; return null;&#125; 二叉搜索树的第k个结点给定一颗二叉搜索树，请找出其中的第k小的结点。例如， 5 / \\ 3 7 /\\ /\\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 12 序列化二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; // 序列化 String Serialize(TreeNode root) &#123; if (root == null) return \"\"; String node = Integer.toString(root.val); node += \",\";//父节点后添加逗号 if (root.left == null) node += \"#\"; else node += Serialize(root.left); node += \",\";//左节点后添加逗号 if (root.right == null) node += \"#\"; else node += Serialize(root.right); //右节点后 不添加逗号 return node; &#125; // 反序列化 TreeNode Deserialize(String str) &#123; if (str == null || str.length() &lt;= 0) return null; String[] nodes = str.split(\",\"); return Deserialize2(nodes); &#125; // 正在处理的结点下标 int index=0; TreeNode Deserialize2(String[] nodes) &#123; String node = nodes[index++]; if (\"#\".equals(node)) return null; TreeNode root = new TreeNode(Integer.parseInt(node)); root.left = Deserialize2(nodes); root.right = Deserialize2(nodes); return root; &#125;&#125; 队列与栈两个栈实现队列 123456789101112131415161718192021222324import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; inStack = new Stack&lt;Integer&gt;();// 入队保存的栈 Stack&lt;Integer&gt; outStack = new Stack&lt;Integer&gt;(); // 出队保存的栈 private int size = 0; public void push(int node) &#123; inStack.push(node); size++; &#125; public int pop() &#123; if (size == 0) return -1; size--; if (outStack.isEmpty()) &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125; return outStack.pop(); &#125;&#125; 用两个队列实现栈（未实现）12 包含min函数的栈 123456789101112131415161718192021222324252627282930313233class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;(); public void push(int node) &#123; stack.push(node); if (minStack.empty()) &#123; minStack.push(node); return; &#125; if (node &lt; minStack.peek()) &#123; minStack.push(node); &#125; else &#123; minStack.push(minStack.peek()); &#125; &#125; public void pop() &#123; if (!stack.empty()) &#123; stack.pop(); minStack.pop(); &#125; &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125; 栈的压入、弹出序列 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; int [] a=&#123;1,2,3,4,5&#125;; int [] b=&#123;4,5,3,1,2&#125;; System.out.println(IsPopOrder(a,b)); &#125; public static boolean IsPopOrder(int[] pushA, int[] popA) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int i = 0, j = 0, lena = pushA.length, lenb = popA.length; boolean isPopOrder = true; while (i &lt; lena) &#123; stack.push(pushA[i]); i++; // 栈顶与popA[j]相同，则出栈，否则继续进栈 while (stack.peek() == popA[j] &amp;&amp; j &lt; lenb) &#123; stack.pop(); j++; &#125; &#125; // 栈不为空，或者popA没有遍历完，则不是 if (!stack.isEmpty() || j != lenb) &#123; isPopOrder = false; &#125; return isPopOrder; &#125;&#125; 排序员工年龄排序 12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; int[] a = &#123;23,26,27,28,25,30,54,23,23&#125;; sortAge(a); for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; &#125; public static int[] sortAge(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return null; &#125; int oldest = 100; // 创建0-100的数组来统计每个年龄有多少人 int[] ages = new int[oldest + 1]; // 遍历数组进行统计 for (int i = 0; i &lt; arr.length; i++) &#123; int age = arr[i]; ages[age]++; &#125; int index = 0; // 遍历统计的数组，将年龄存回原数组 for (int age = 0; age &lt;= oldest; age++) &#123; for (int i = 0; i &lt; ages[age]; i++) &#123; arr[index] = age; index++; &#125; &#125; return arr; &#125;&#125; 回溯法矩阵中的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 判断矩阵中是否有路径 * * @author jizx * @date 2018/07/09 20:18 */public class HasPath &#123; public static void main(String[] args) &#123; HasPath app = new HasPath(); char[] matrix = \"ABCESFCSADEE\".toCharArray(); char[] str = \"ABCB\".toCharArray(); System.out.println(app.hasPath(matrix, 3, 4, str)); &#125; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (matrix == null || rows &lt; 1 || cols &lt; 1 || str == null) return false; boolean[][] visited = new boolean[rows][cols]; // 遍历矩阵中每个位置，穷举 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (findStr(matrix, rows, cols, i, j, str, visited)) return true; &#125; &#125; return false; &#125; private int strIndex = 0; private boolean findStr(char[] matrix, int rows, int cols, int row, int col, char[] str, boolean[][] visited) &#123; if (strIndex == str.length) return true; boolean find = false; // 矩阵中matrix[row][col] 的字符 与 str[strIndex]的相同，则继续探索该位置的四周与str[strIndex++]是否一样 if (row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; !visited[row][col] &amp;&amp; matrix[row * cols + col] == str[strIndex]) &#123; strIndex++; visited[row][col] = true; find = findStr(matrix, rows, cols, row - 1, col, str, visited) || findStr(matrix, rows, cols, row + 1, col, str, visited) || findStr(matrix, rows, cols, row, col - 1, str, visited) || findStr(matrix, rows, cols, row, col + 1, str, visited); // 如果该点的四周都没有找到符合下一字符的，则退回，重置该位置的状态，以及字符匹配的位置 if (!find) &#123; visited[row][col] = false; strIndex--; &#125; &#125; return find; &#125;&#125; 机器人的运动范围 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 机器人的运动范围 * * @author jizx * @date 2018/07/09 21:45 */public class RobotMovingCount &#123; public static void main(String[] args) &#123; RobotMovingCount app = new RobotMovingCount(); System.out.println(app.movingCount(18, 3, 4)); &#125; public int movingCount(int threshold, int rows, int cols) &#123; if (rows &lt; 0 || cols &lt; 0 || threshold &lt; 0) return 0; boolean[][] visited = new boolean[rows][cols]; return movingCount(threshold, rows, cols, 0, 0, visited); &#125; public int movingCount(int threshold, int rows, int cols, int row, int col, boolean[][] visited) &#123; int count = 0; if (canIn(rows, cols, row, col, threshold, visited)) &#123; visited[row][col] = true; // 能够到达的位置：当前位置+其他四个方向能够到达的总和 count = 1 + movingCount(threshold, rows, cols, row - 1, col, visited) + movingCount(threshold, rows, cols, row + 1, col, visited) + movingCount(threshold, rows, cols, row, col - 1, visited) + movingCount(threshold, rows, cols, row, col + 1, visited); &#125; return count; &#125; // 判断是否能进入该位置 public boolean canIn(int rows, int cols, int row, int col, int threshold, boolean[][] visited) &#123; if (!visited[row][col] &amp;&amp; row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols) &#123; int sum = 0; while (row != 0) &#123; sum += row % 10; row /= 10; &#125; while (col != 0) &#123; sum += col % 10; col /= 10; &#125; return sum &lt;= threshold; &#125; return false; &#125;&#125; 递归斐波那契数数列 123456789101112131415161718public class Solution &#123; // 非递归 public int Fibonacci(int n) &#123; int[] initial = &#123;0, 1&#125;; //初始化第0项、第1项 if (n &lt; 2) return initial[n]; // fn=f(n-1)+f(n-2) int fn_1 = 1; int fn_2 = 0; int fn = 0; for (int i = 2; i &lt;= n; i++) &#123; fn = fn_1 + fn_2; fn_2 = fn_1; fn_1 = fn; &#125; return fn; &#125;&#125; 青蛙跳台阶 但是要注意与斐波那契数列的下标起始位置不太一样 ，第0 项是1,即：1 1 2 3 5 。。。 1234567891011121314public static int JumpFloor(int target) &#123; int[] initial = &#123;0, 1&#125;; if (target &lt; 2) return initial[target]; int jumpn_1 = 1; //第1项是1 int jumpn_2 = 1; //第0项是1 int num = 0; for (int i = 2; i &lt;= target; i++) &#123; num = jumpn_1 + jumpn_2; jumpn_2 = jumpn_1; jumpn_1 = num; &#125; return num;&#125; 矩阵覆盖问题 二进制10.二进制中1的个数 用1扫描法： 12345678910111213public static int numOf1(int n) &#123; int count = 0; int matcher = 1; while (matcher != 0) &#123; // n与matcher按位 与运算，如果matcer的1 对应n的1，就不会为0 // n:0000101 // m:0000100 if ((n &amp; matcher) != 0) count++; //让matcer左移，进行扫描 matcher = matcher &lt;&lt; 1; &#125; return count;&#125; 减1法 123456789public static int numOf1(int n) &#123; int count = 0; while (n != 0) &#123; // 把一个整数减去1，再和原整数做 与运算，就会把该整数最右边一个1变成0 n = (n - 1) &amp; n; count++; &#125; return count; &#125; 数值精度问题由于精度原因，不能用等号判断两个double 小数是否相等。 当小数点后位数 大于15位时，jvm就会忽略这个精度，这种情况，我们在开发时如果需要更精确的比较double类型，就要用到 BigDecimal 这个类了。 1234567891011// jdk1.8double x1= 4.000000000000002;double x2= 4.000000000000005;x1&lt;x2 trueBigDecimal x3=new BigDecimal(4.0000000000000002);BigDecimal x4=new BigDecimal(4.0000000000000005);x3&lt;x4 true000000000000002 // double(15位)0000000000000002 // BigDecimal（16位） 数值的整数次方pow(x,n)思路：分治 简洁版 1234567891011121314151617public double pow(double x, int n) &#123; // 底数为0,不可以直接用等号判断，因为有精度的问题 if (Double.compare(x, 0.0) == 0) return 0.0; //指数&lt;0的情况，取绝对值，最后进行求倒数即可 if (n &lt; 0) return 1.0 / powWithUnsign(x, -n); else return powWithUnsign(x, n);&#125;public double powWithUnsign(double x, int n) &#123; if (n == 0) return 1.0; if (n == 1) return x; double result = powWithUnsign(x, n/2); if ((n&amp;1) == 1) return result * result * x; else return result * result;&#125; 详细版 12345678910111213141516171819202122232425262728293031323334public static double Power(double basse, int exponent) throws Exception &#123; // 输入底数为0，指数小于0 if (Double.compare(basse, 0.0) == 0 &amp;&amp; exponent &lt; 0) &#123; throw new Exception(\"非法\"); &#125; int absExponent = exponent;//指数取绝对值 if (exponent &lt; 0) &#123; absExponent = exponent * -1; &#125; double result = PowerWithUnsignedExponent(basse, absExponent); if (exponent &lt; 0) &#123; result = 1.0 / result; &#125; return result; &#125; public static double PowerWithUnsignedExponent(double base, int exponent) &#123; // 判断人为输入为0的情况，并不是右移产生的 if (exponent == 0) &#123; return 1; &#125; if (exponent == 1) &#123; return base; &#125; double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1); result *= result; if ((exponent &amp; 0x1) == 1) &#123; result *= base; &#125; return result; &#125; 打印1到最大的n位数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void printNMax(int n) &#123; if (n &lt;= 0) &#123; return; &#125; char[] number = new char[n]; for (int i = 0; i &lt; number.length; i++) &#123; number[i] = '0'; &#125; int a = number[1]; while (!increase(number, 8)) &#123; printNum(number); &#125; &#125; public static boolean increase(char[] number, int add) &#123; int sum = 0; int takeOver = 0;// 进位 boolean isMax = false; // 从最后一位开始加一 for (int i = number.length - 1; i &gt;= 0; i--) &#123; sum = number[i] - '0' + takeOver; // 个位进行加一 if (i == number.length - 1) &#123; sum += add; &#125; // 和大于10，则有进位，否则就可以结束循环 if (sum &gt;= 10) &#123; // 如果是最高位，则结束 if (i == 0) isMax = true; else &#123; sum -= 10; takeOver = 1; number[i] = (char) ('0' + sum); &#125; &#125; else &#123; number[i] = (char) ('0' + sum); break; &#125; &#125; return isMax; &#125; public static void printNum(char[] number) &#123; int i = 0; boolean isStart = false; while (i &lt; number.length) &#123; if (number[i] == '0' &amp;&amp; !isStart) &#123; &#125; else &#123; isStart = true; System.out.print(number[i]); &#125; i++; &#125; System.out.println(); &#125; 34.丑数 1234567891011121314151617181920212223public static int GetUglyNumber_Solution(int index) &#123; if (index &lt;= 0) &#123; return 0; &#125; // 保存丑数的数组，并初始化第一个丑数 int[] uglyNum = new int[index]; uglyNum[0] = 1; // 指向对应乘积刚好大于当前找到的丑数的下标 int base2 = 0;// 乘以2后的值，刚好略大于当前丑数的下标 int base3 = 0;// 乘以3后的值，刚好略大于当前丑数的下标 int base5 = 0;// 乘以5后的值，刚好略大于当前丑数的下标 int currentIndex = 1; while (currentIndex &lt; index) &#123; int nextNum = Math.min(Math.min(uglyNum[base2] * 2, uglyNum[base3] * 3), uglyNum[base5] * 5); uglyNum[currentIndex] = nextNum; // 更新下标，使得下标在刚好略大于当前丑数的下标 while (uglyNum[base2] * 2 &lt;= nextNum) base2++; while (uglyNum[base3] * 3 &lt;= nextNum) base3++; while (uglyNum[base5] * 5 &lt;= nextNum) base5++; currentIndex++; &#125; return uglyNum[index - 1]; &#125; 不用加减乘除做加法 思路： 12345678910111213public class Solution &#123; public int Add(int num1,int num2) &#123; int sum = 0; int carry = 0; do &#123; sum = num1 ^ num2; carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum; num2 = carry; &#125; while (carry != 0); return num1; &#125;&#125; 不使用新变量交换两个变量的值 12345678// 基于加减法a = a + b;b = a - b;a = a - b;// 基于异或a = a ^ b;b = a ^ b;a = a ^ b; 抽象建模44.扑克牌的顺子 1234567891011121314151617181920212223import java.util.*;public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; if (numbers == null || numbers.length != 5) return false; Arrays.sort(numbers); // 统计大王的个数 int king = 0; for (int i : numbers) &#123; if (i == 0) king++; else break; &#125; // 统计不连续间隔 int gaps = 0; // i=king的个数+1，从而跳过王 for (int i = king+1; i &lt; numbers.length; i++) &#123; if (numbers[i] == numbers[i - 1]) return false; // 出现对子，不可能是顺子 gaps += numbers[i] - numbers[i - 1] - 1; &#125; return gaps &lt;= king; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://jizx.vip/categories/算法/"},{"name":"java","slug":"算法/java","permalink":"https://jizx.vip/categories/算法/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jizx.vip/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://jizx.vip/tags/算法/"},{"name":"面试","slug":"面试","permalink":"https://jizx.vip/tags/面试/"}]},{"title":"java嵌套类","slug":"java嵌套类","date":"2018-03-03T12:39:30.000Z","updated":"2018-11-18T09:02:40.870Z","comments":true,"path":"2018/03/03/java嵌套类/","link":"","permalink":"https://jizx.vip/2018/03/03/java嵌套类/","excerpt":"讲解java中嵌套类的概念，也就是在类中定义另一个类的概念（未完待续。。。）","text":"讲解java中嵌套类的概念，也就是在类中定义另一个类的概念（未完待续。。。） 嵌套类java语言允许你在一个类中定义另一个类，这样的类称为嵌套类，形式如下： 123456class OuterClass &#123; ... class NestedClass &#123; ... &#125;&#125; 术语: 嵌套类分为2类：静态、非静态。静态的嵌套类称为静态嵌套类，非静态的嵌套类称为内部类，如下所示： 123456789class OuterClass &#123; ... static class StaticNestedClass &#123; ... &#125; class InnerClass &#123; ... &#125;&#125; 嵌套类是包围它的外部类（enclosing class）的一个成员，非静态嵌套类（内部类）可以访问到其他成员，即使它们被定义为私有的（private）。静态嵌套类不能访问其他成员。作为外部类的成员，嵌套类可以被声明为 private, public, protected, 或者 package private 四种访问权限 为什么要使用嵌套类呢? 这是一种有效组织那种只在某一处使用到的类的方法：比如一个类只对另外一个类有用，那么把它们两放在一起，嵌套在一起是合乎逻辑的，将这样的辅助类（helper classes）嵌套在一起使得java包更加简洁合理. 增强了封装性: 考虑两个顶层类（top-level classes）, A 和 B, 其中B需要访问A的成员，否则这些成员将被声明为私有。如果将B藏在A中, A的成员即使被定义为私有的，B也可以访问到， 另外，B本身也与外界隔离开来 更加可读，并且有利于维护代码: Nesting small classes within top-level classes places the code closer to where it is used. 静态嵌套类（Static Nested Classes）与类方法、类变量成员一样，一个静态嵌套类与外部类是相关联的，而且与静态方法类似，静态嵌套类不能直接获取到外部类的实例变量或者其中的函数：它只能通过类引用来使用它们。 注意：静态嵌套类与其外部类（或者其他类）的实例成员之间的交互，就像其他顶层类之间一样。实际上，一个静态嵌套类在表现上像是一个顶级类，其实是嵌套在另一个顶级类中的，以方便打包。使用到静态嵌套类时必须通过外部类，形如：OuterClass.StaticNestedClass比如要创建一个静态嵌套类的实例，语法如下：OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();​ 内部类（Inner Classes）与实例方法、实例变量成员一样，一个内部类与外部类的一个实例是相关联的，而且能够直接访问到外部类实例中的方法与变量，而且因为内部类是与实例相关联的，因此内部类中是无法定义静态成员的。 内部类的实例只能与外部类的实例同时存在，无法独立实例化，并且能够直接访问到外部类的方法与变量想要实例化一个内部类，你必须先实例化一个外部类，然后才能通过外部类创建一个内部类的实例，语法如下： OuterClass.InnerClass innerObject = outerObject.new InnerClass();内部类中有两种特殊的类：局部类、匿名类 局部类（Local Classes）Local classes are classes that are defined in a block, which is a group of zero or more statements between balanced braces. You typically find local classes defined in the body of a method. This section covers the following topics: Declaring Local Classes Accessing Members of an Enclosing Class Shadowing and Local Classes Local Classes Are Similar To Inner Classes Declaring Local ClassesYou can define a local class inside any block (see Expressions, Statements, and Blocks for more information). For example, you can define a local class in a method body, a for loop, or an if clause. The following example, LocalClassExample, validates two phone numbers. It defines the local class PhoneNumber in the method validatePhoneNumber: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class LocalClassExample &#123; static String regularExpression = &quot;[^0-9]&quot;; public static void validatePhoneNumber( String phoneNumber1, String phoneNumber2) &#123; final int numberLength = 10; // Valid in JDK 8 and later: // int numberLength = 10; class PhoneNumber &#123; String formattedPhoneNumber = null; PhoneNumber(String phoneNumber)&#123; // numberLength = 7; String currentNumber = phoneNumber.replaceAll( regularExpression, &quot;&quot;); if (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber; else formattedPhoneNumber = null; &#125; public String getNumber() &#123; return formattedPhoneNumber; &#125; // Valid in JDK 8 and later:// public void printOriginalNumbers() &#123;// System.out.println(&quot;Original numbers are &quot; + phoneNumber1 +// &quot; and &quot; + phoneNumber2);// &#125; &#125; PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1); PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2); // Valid in JDK 8 and later:// myNumber1.printOriginalNumbers(); if (myNumber1.getNumber() == null) System.out.println(&quot;First number is invalid&quot;); else System.out.println(&quot;First number is &quot; + myNumber1.getNumber()); if (myNumber2.getNumber() == null) System.out.println(&quot;Second number is invalid&quot;); else System.out.println(&quot;Second number is &quot; + myNumber2.getNumber()); &#125; public static void main(String... args) &#123; validatePhoneNumber(&quot;123-456-7890&quot;, &quot;456-7890&quot;); &#125;&#125; The example validates a phone number by first removing all characters from the phone number except the digits 0 through 9. After, it checks whether the phone number contains exactly ten digits (the length of a phone number in North America). This example prints the following: 12First number is 1234567890Second number is invalid Accessing Members of an Enclosing ClassA local class has access to the members of its enclosing class. In the previous example, the PhoneNumber constructor accesses the member LocalClassExample.regularExpression. In addition, a local class has access to local variables. However, a local class can only access local variables that are declared final. When a local class accesses a local variable or parameter of the enclosing block, it captures that variable or parameter. For example, the PhoneNumber constructor can access the local variable numberLength because it is declared final; numberLength is a captured variable. However, starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or effectively final. A variable or parameter whose value is never changed after it is initialized is effectively final. For example, suppose that the variable numberLength is not declared final, and you add the highlighted assignment statement in the PhoneNumber constructor to change the length of a valid phone number to 7 digits: 123456789PhoneNumber(String phoneNumber) &#123; numberLength = 7; String currentNumber = phoneNumber.replaceAll( regularExpression, &quot;&quot;); if (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber; else formattedPhoneNumber = null;&#125; Because of this assignment statement, the variable numberLength is not effectively final anymore. As a result, the Java compiler generates an error message similar to “local variables referenced from an inner class must be final or effectively final” where the inner class PhoneNumber tries to access the numberLength variable: 1if (currentNumber.length() == numberLength) Starting in Java SE 8, if you declare the local class in a method, it can access the method’s parameters. For example, you can define the following method in the PhoneNumber local class: 1234public void printOriginalNumbers() &#123; System.out.println(&quot;Original numbers are &quot; + phoneNumber1 + &quot; and &quot; + phoneNumber2);&#125; The method printOriginalNumbers accesses the parameters phoneNumber1 and phoneNumber2 of the method validatePhoneNumber. Shadowing and Local ClassesDeclarations of a type (such as a variable) in a local class shadow declarations in the enclosing scope that have the same name. See Shadowing for more information. Local Classes Are Similar To Inner ClassesLocal classes are similar to inner classes because they cannot define or declare any static members. Local classes in static methods, such as the class PhoneNumber, which is defined in the static method validatePhoneNumber, can only refer to static members of the enclosing class. For example, if you do not define the member variable regularExpression as static, then the Java compiler generates an error similar to “non-static variable regularExpression cannot be referenced from a static context.” Local classes are non-static because they have access to instance members of the enclosing block. Consequently, they cannot contain most kinds of static declarations. You cannot declare an interface inside a block; interfaces are inherently static. For example, the following code excerpt does not compile because the interface HelloThere is defined inside the body of the method greetInEnglish: 123456789101112public void greetInEnglish() &#123; interface HelloThere &#123; public void greet(); &#125; class EnglishHelloThere implements HelloThere &#123; public void greet() &#123; System.out.println(&quot;Hello &quot; + name); &#125; &#125; HelloThere myGreeting = new EnglishHelloThere(); myGreeting.greet();&#125; You cannot declare static initializers or member interfaces in a local class. The following code excerpt does not compile because the method EnglishGoodbye.sayGoodbye is declared static. The compiler generates an error similar to “modifier ‘static’ is only allowed in constant variable declaration” when it encounters this method definition: 12345678public void sayGoodbyeInEnglish() &#123; class EnglishGoodbye &#123; public static void sayGoodbye() &#123; System.out.println(&quot;Bye bye&quot;); &#125; &#125; EnglishGoodbye.sayGoodbye();&#125; A local class can have static members provided that they are constant variables. (A constant variable is a variable of primitive type or type String that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. See Understanding Class Members for more information.) The following code excerpt compiles because the static member EnglishGoodbye.farewell is a constant variable: 12345678910public void sayGoodbyeInEnglish() &#123; class EnglishGoodbye &#123; public static final String farewell = &quot;Bye bye&quot;; public void sayGoodbye() &#123; System.out.println(farewell); &#125; &#125; EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye(); myEnglishGoodbye.sayGoodbye();&#125;待补充。。。 匿名类（Anonymous Classes）Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once. This section covers the following topics: Declaring Anonymous Classes Syntax of Anonymous Classes Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class Examples of Anonymous Classes Declaring Anonymous ClassesWhile local classes are class declarations, anonymous classes are expressions, which means that you define the class in another expression. The following example, HelloWorldAnonymousClasses, uses anonymous classes in the initialization statements of the local variables frenchGreeting and spanishGreeting, but uses a local class for the initialization of the variable englishGreeting`:` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HelloWorldAnonymousClasses &#123; interface HelloWorld &#123; public void greet(); public void greetSomeone(String someone); &#125; public void sayHello() &#123; class EnglishGreeting implements HelloWorld &#123; String name = &quot;world&quot;; public void greet() &#123; greetSomeone(&quot;world&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Hello &quot; + name); &#125; &#125; HelloWorld englishGreeting = new EnglishGreeting(); HelloWorld frenchGreeting = new HelloWorld() &#123; String name = &quot;tout le monde&quot;; public void greet() &#123; greetSomeone(&quot;tout le monde&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Salut &quot; + name); &#125; &#125;; HelloWorld spanishGreeting = new HelloWorld() &#123; String name = &quot;mundo&quot;; public void greet() &#123; greetSomeone(&quot;mundo&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Hola, &quot; + name); &#125; &#125;; englishGreeting.greet(); frenchGreeting.greetSomeone(&quot;Fred&quot;); spanishGreeting.greet(); &#125; public static void main(String... args) &#123; HelloWorldAnonymousClasses myApp = new HelloWorldAnonymousClasses(); myApp.sayHello(); &#125; &#125; Syntax of Anonymous ClassesAs mentioned previously, an anonymous class is an expression. The syntax of an anonymous class expression is like the invocation of a constructor, except that there is a class definition contained in a block of code. Consider the instantiation of the frenchGreeting object: 12345678910HelloWorld frenchGreeting = new HelloWorld() &#123; String name = &quot;tout le monde&quot;; public void greet() &#123; greetSomeone(&quot;tout le monde&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Salut &quot; + name); &#125;&#125;; The anonymous class expression consists of the following: The new operator The name of an interface to implement or a class to extend. In this example, the anonymous class is implementing the interface HelloWorld. Parentheses that contain the arguments to a constructor, just like a normal class instance creation expression. Note: When you implement an interface, there is no constructor, so you use an empty pair of parentheses, as in this example. A body, which is a class declaration body. More specifically, in the body, method declarations are allowed but statements are not. Because an anonymous class definition is an expression, it must be part of a statement. In this example, the anonymous class expression is part of the statement that instantiates the frenchGreeting object. (This explains why there is a semicolon after the closing brace.) Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous ClassLike local classes, anonymous classes can capture variables; they have the same access to local variables of the enclosing scope: An anonymous class has access to the members of its enclosing class. An anonymous class cannot access local variables in its enclosing scope that are not declared as final or effectively final. Like a nested class, a declaration of a type (such as a variable) in an anonymous class shadows any other declarations in the enclosing scope that have the same name. See Shadowing for more information. Anonymous classes also have the same restrictions as local classes with respect to their members: You cannot declare static initializers or member interfaces in an anonymous class. An anonymous class can have static members provided that they are constant variables. Note that you can declare the following in anonymous classes: Fields Extra methods (even if they do not implement any methods of the supertype) Instance initializers Local classes However, you cannot declare constructors in an anonymous class. Examples of Anonymous ClassesAnonymous classes are often used in graphical user interface (GUI) applications. Consider the JavaFX example HelloWorld.java (from the section Hello World, JavaFX Style from Getting Started with JavaFX). This sample creates a frame that contains a Say ‘Hello World’ button. The anonymous class expression is highlighted: 12345678910111213141516171819202122232425262728293031import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.StackPane;import javafx.stage.Stage; public class HelloWorld extends Application &#123; public static void main(String[] args) &#123; launch(args); &#125; @Override public void start(Stage primaryStage) &#123; primaryStage.setTitle(&quot;Hello World!&quot;); Button btn = new Button(); btn.setText(&quot;Say &apos;Hello World&apos;&quot;); btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent event) &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;); StackPane root = new StackPane(); root.getChildren().add(btn); primaryStage.setScene(new Scene(root, 300, 250)); primaryStage.show(); &#125;&#125; In this example, the method invocation btn.setOnAction specifies what happens when you select the Say ‘Hello World’ button. This method requires an object of type EventHandler&lt;ActionEvent&gt;. The EventHandler&lt;ActionEvent&gt; interface contains only one method, handle. Instead of implementing this method with a new class, the example uses an anonymous class expression. Notice that this expression is the argument passed to the btn.setOnAction method. Because the EventHandler&lt;ActionEvent&gt; interface contains only one method, you can use a lambda expression instead of an anonymous class expression. See the section Lambda Expressions for more information. Anonymous classes are ideal for implementing an interface that contains two or more methods. The following JavaFX example is from the section Customization of UI Controls. The highlighted code creates a text field that only accepts numeric values. It redefines the default implementation of the TextField class with an anonymous class by overriding the replaceText and replaceSelection methods inherited from the TextInputControl class. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.geometry.Insets;import javafx.scene.Group;import javafx.scene.Scene;import javafx.scene.control.*;import javafx.scene.layout.GridPane;import javafx.scene.layout.HBox;import javafx.stage.Stage;public class CustomTextFieldSample extends Application &#123; final static Label label = new Label(); @Override public void start(Stage stage) &#123; Group root = new Group(); Scene scene = new Scene(root, 300, 150); stage.setScene(scene); stage.setTitle(&quot;Text Field Sample&quot;); GridPane grid = new GridPane(); grid.setPadding(new Insets(10, 10, 10, 10)); grid.setVgap(5); grid.setHgap(5); scene.setRoot(grid); final Label dollar = new Label(&quot;$&quot;); GridPane.setConstraints(dollar, 0, 0); grid.getChildren().add(dollar); final TextField sum = new TextField() &#123; @Override public void replaceText(int start, int end, String text) &#123; if (!text.matches(&quot;[a-z, A-Z]&quot;)) &#123; super.replaceText(start, end, text); &#125; label.setText(&quot;Enter a numeric value&quot;); &#125; @Override public void replaceSelection(String text) &#123; if (!text.matches(&quot;[a-z, A-Z]&quot;)) &#123; super.replaceSelection(text); &#125; &#125; &#125;; sum.setPromptText(&quot;Enter the total&quot;); sum.setPrefColumnCount(10); GridPane.setConstraints(sum, 1, 0); grid.getChildren().add(sum); Button submit = new Button(&quot;Submit&quot;); GridPane.setConstraints(submit, 2, 0); grid.getChildren().add(submit); submit.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; label.setText(null); &#125; &#125;); GridPane.setConstraints(label, 0, 1); GridPane.setColumnSpan(label, 3); grid.getChildren().add(label); scene.setRoot(grid); stage.show(); &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125; 遮盖（Shadowing）、变量作用域问题如果在特定范围内（比如在内部类或者方法中）有一个声明（成员变量声明或者方法参数名字）与该范围外的另一个声明拥有相同的名字，那么该范围内的声明就会遮盖掉范围外的声明。你就不能仅简单地通过名字来引用被遮盖的那个声明，请看下面的例子： 123456789101112131415161718192021public class ShadowTest &#123; public int x = 0; class FirstLevel &#123; public int x = 1; void methodInFirstLevel(int x) &#123; System.out.println(\"x = \" + x); System.out.println(\"this.x = \" + this.x); System.out.println(\"ShadowTest.this.x = \" + ShadowTest.this.x); &#125; &#125; public static void main(String... args) &#123; ShadowTest st = new ShadowTest(); ShadowTest.FirstLevel fl = st.new FirstLevel(); fl.methodInFirstLevel(23); &#125;&#125; 输出结果如下:123x = 23this.x = 1ShadowTest.this.x = 0 该例子中定义了3个名为x的变量：类ShadowTest的成员变量、内部类FirstLevel的成员变量、methodInFirstLevel方法的形参。methodInFirstLevel方法的形参遮盖住了内部类FirstLevel的成员变量，因此，当你在方法中使用x时，x表示的是方法的参数x。想要获得内部类FirstLevel的成员变量x，要通过关键字this 来代表外部的作用域（enclosing scope），也就是FirstLevel类： 1System.out.println(\"this.x = \" + this.x); 要获取到更大作用域的成员变量时，需要通过其所属的类的类名来访问，比如以下的语句，在methodInFirstLevel方法中获取最外层的ShadowTest 类的成员变量x 1System.out.println(\"ShadowTest.this.x = \" + ShadowTest.this.x); 参考资料：https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html","categories":[{"name":"java","slug":"java","permalink":"https://jizx.vip/categories/java/"},{"name":"基础","slug":"java/基础","permalink":"https://jizx.vip/categories/java/基础/"}],"tags":[{"name":"类","slug":"类","permalink":"https://jizx.vip/tags/类/"}]},{"title":"英语语法——中级：第3章.完成时态","slug":"英语语法——中级：第3章-完成时态","date":"2018-02-11T09:06:51.000Z","updated":"2018-11-18T09:02:40.913Z","comments":true,"path":"2018/02/11/英语语法——中级：第3章-完成时态/","link":"","permalink":"https://jizx.vip/2018/02/11/英语语法——中级：第3章-完成时态/","excerpt":"第3章.完成时态总结","text":"第3章.完成时态总结","categories":[{"name":"英语","slug":"英语","permalink":"https://jizx.vip/categories/英语/"},{"name":"语法","slug":"英语/语法","permalink":"https://jizx.vip/categories/英语/语法/"}],"tags":[{"name":"时态","slug":"时态","permalink":"https://jizx.vip/tags/时态/"}]},{"title":"英语语法——中级：第2章.名词、定语、状语从句","slug":"英语语法——中级：第2章-名词、定语、状语从句","date":"2018-02-11T09:00:15.000Z","updated":"2018-11-18T09:02:40.910Z","comments":true,"path":"2018/02/11/英语语法——中级：第2章-名词、定语、状语从句/","link":"","permalink":"https://jizx.vip/2018/02/11/英语语法——中级：第2章-名词、定语、状语从句/","excerpt":"第2章.名词、定语、状语从句总结","text":"第2章.名词、定语、状语从句总结","categories":[{"name":"英语","slug":"英语","permalink":"https://jizx.vip/categories/英语/"},{"name":"语法","slug":"英语/语法","permalink":"https://jizx.vip/categories/英语/语法/"}],"tags":[{"name":"从句","slug":"从句","permalink":"https://jizx.vip/tags/从句/"}]},{"title":"英语语法——中级：第1章.简单句与复合句","slug":"英语语法——中级：第1章-简单句与复合句","date":"2018-02-11T08:52:01.000Z","updated":"2018-11-18T09:02:40.910Z","comments":true,"path":"2018/02/11/英语语法——中级：第1章-简单句与复合句/","link":"","permalink":"https://jizx.vip/2018/02/11/英语语法——中级：第1章-简单句与复合句/","excerpt":"第1章.简单句与复合句总结","text":"第1章.简单句与复合句总结","categories":[{"name":"英语","slug":"英语","permalink":"https://jizx.vip/categories/英语/"},{"name":"语法","slug":"英语/语法","permalink":"https://jizx.vip/categories/英语/语法/"}],"tags":[{"name":"复合句","slug":"复合句","permalink":"https://jizx.vip/tags/复合句/"}]},{"title":"vim","slug":"vim","date":"2017-11-08T09:09:53.000Z","updated":"2020-07-14T14:58:19.228Z","comments":true,"path":"2017/11/08/vim/","link":"","permalink":"https://jizx.vip/2017/11/08/vim/","excerpt":"通过对linux中自带的vimtutor命令学习，以及《vim实用技巧》学习，然后对常用的vim命令进行总结，方便以后忘记了常看。","text":"通过对linux中自带的vimtutor命令学习，以及《vim实用技巧》学习，然后对常用的vim命令进行总结，方便以后忘记了常看。 123vim file +n ：打开文件并跳到第N行默认显示行号：编辑或新建~/.vimrc 添加一行 set nu 即可，或者在/etc/vimrc 内编辑 模式切换 按键操作 用途 &lt;Esc&gt; 切换到普通模式 &lt;Ctrl+[&gt; 切换到普通模式 &lt;Ctrl+o&gt; 切换到插入-普通模式，能让我们执行一次普通模式命令。 在此模式中， 可以执行一个普通模式命令， 执行完后， 马上又返回到插入模式 插入-普通模式是一个子模式， 可以让我们执行一个普通模式命令， 之后马上又回到插入模式。 普通模式命令的基本模式 operation [number] range 基础定位移动1234567891011121314151617181920212223242526272829303132333435363738394041\" 面向行的移动 k上 h左 l右 j下 4h 左4个字符 4k 上4行 4j 下4行 4l 右4个字符 2gg \"定位到第2行代码，等同于2G2G \"定位到第2行代码gg \"定位到整个代码的第1行G \"定位到整个代码的最后一行0或^ \"行首$ \"行尾\" 面向单词的移动w \"向后跳到下一个单词的开始处b \"向前跳到上一个单词的开始处e \"向后跳到下一个单词的结束处ge \"向前跳到上一个单词的结束处2e,2w,2b表示移动2个单位\" 面向字串的移动W、 B、 E 和gE \" 面向字符的移动f \"光标正向移动到行内的指定字符前F \"光标反向移动到行内的指定字符前t \"光标正向移动到行内的指定字符的前一个字符T \"光标反向移动到行内的指定字符的前一个字符; \"正向重复执行字符查找, \"反向重复执行字符查找\" 飞雷神mm \"将位置标记在m`m \"回到标记 m 的位置'm \"回到标记 m 的所在行首H \"当前屏幕可见的第一行M \"当前屏幕可见的中间L \"当前屏幕可见的最后一行Ctrl+o \"快速跳回上一个位置 快速移动行移动区分实际行与屏幕行(超出屏幕显示区域的vim会帮你soft wrap) , j、 k、 0 和 $ 都用于操作实际行，而如果在这些键前加上 g 前缀的话， 就会让 Vim 对屏幕行进行操作 命令 光标动作 j 向下移动一个实际行 gj 向下移动一个屏幕行 k 向上移动一个实际行 gk 向上移动一个屏幕行 0 移动到实际行的行首 g0 移动到屏幕行的行首 ^ 移动到实际行的第一个非空白字符 g^ 移动到屏幕行的第一个非空白字符 $ 移动到实际行的行尾 g$ 移动到屏幕行的行尾 如果你想让 j 及 k 命令操作屏幕行而不是实际行， 可以重新映射它们。把下面加到你的 vimrc 文件中 1234nnoremap k gknnoremap gk knnoremap j gjnnoremap gj j 基于单词的移动先学会用 w 和 b命令 ，e 和 ge 命令是对此命令集的补充 单词与字串 单词：字母、 数字、 下画线， 或其他非空白字符的序列组成，单词间以空白字符分隔（参见 :h word） 字串：由非空白字符序列组成， 字串间以空白字符分隔（参见 :h WORD） 普通用户可以这样简单地想： 字串比单词更长！ 我们之前面向单词的动作命令， 都有一个面向字串的命令与其对应， 这当中包括 W、 B、 E 和gE。 命令 光标动作 对应单词 w 正向移动到下一单词的开头 b 反向移动到当前单词/上一单词的开头 假设想把单词“fast”改成“faster” e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾 对应字串 W 正向移动到下一字串的开头 B 反向移动到当前单词/上一字串的开头 E 正向移动到当前单词/下一字串的结尾 gE 反向移动到上一字串的结尾 感受一下单词与字串的差别 1e.g. we&apos;re going too slow # 可以试一下这个文本 例如， 如果想把“we”“you” 按键操作 缓冲区内容 {start} e.g. we’re going too slow cwyou e.g. you’re going too slow 在另外一些时候， 我们可能更想把“we’re”“it’s” 按键操作 缓冲区内容 {start} e.g. we’re going too slow cWit’s e.g. it’s going too slow 基于字符的移动f{char} 在光标位置与当前行行尾之间查找指定的字符， 如果找到了， 就会把光标移到此字符上； 如果未找到， 则保持光标不动 命令 用途 f{char} 正向移动到下一个 {char} 所在之处 F{char} 反向移动到上一个 {char} 所在之处 t{char} 正向移动到下一个 {char} 所在之处的前一个字符上 T{char} 反向移动到上一个 {char} 所在之处的后一个字符上 ; 重复上次的字符查找命令 , 反转方向查找上次的字符查找命令 有意思的例子 按键操作 缓冲区内容 {start} I’ve been expecting you, Mister Bond. f, I’ve been expecting you, Mister Bond. dt. I’ve been expecting you. dt.表示删除从 当前光标所在字符，到t.所找到的点号（.）前的字符 技巧 在使用字符查找命令时， 最好是选择出现频率比较低的字母作目标字符。 1Improve your writing by deleting excellent adjectives. 让光标移到单词“excellent”上，更好的选择是用 fx， 这条命令一下就能让我们移动到此单词上， 接下来就可以用 daw 命令删除该单词了 飞雷神在Vim的前身vi里，并没有诸如现在的可视模式这样的功能。那时，位置标记是一个比现在重要得多的功能。但现在，很多在vi里需要用位置标记完成的工作，都可以在Vim里用可视模式来做，因此对位置标记的需求也就相应减少了。但是位置标记在Vim里并没有过时，它们仍然有用处。 第一步：标记 m{a-zA-Z} 命令会用选定的字母标记当前光标所在位置 小写位置标记只在每个缓冲区局部可见 大写位置标记则全局可见 第二步：跳转 有两种方式： &#39;{mark} 命令跳到位置标记所在行， 并把光标置于该行第一个非空白字符上； {mark}` 命令则把光标移动到设置此位置标记时光标所在之处；（推荐） Vim自动设置的标记 Vim 会自动设置一些位置标记， 这些标记用起来非常方便。 Vim 会自动设置一些位置标记， 这些标记用起来非常方便。 位置标记 跳转到 `` 当前文件中上次跳转动作之前的位置 `. 上次修改的地方 `^ 上次插入的地方 `[ 上次修改或复制的起始位置 `] 上次修改或复制的结束位置 `&lt; 上次高亮选区的起始位置 `&gt; 上次高亮选区的结束位置 括号间跳转% 命令允许在一组开、 闭括号间跳转（参见 :h % ） ， 它可作用于 ()、 {}以及[] 例子：修改括号的陷阱 假设想把 %w{London Berlin New\\ York} 改成普通的列表定义[&quot;London&quot;, &quot;Berlin&quot;, &quot;New York&quot;] 文本对象123var tpl = [ '&lt;a href=\"&#123;url&#125;\"&gt;&#123;title&#125;&lt;/a&gt;'] 在上面的代码中， 每个开括号字符{都对应一个闭括号字符}、[和]、&lt;和&gt;、以及HTML标签也是一样。这些配对符号具有规整的格式，而Vim能够理解其结构，并允许对它们分隔的区域进行操作。文本对象就是基于结构定义的文本区域（参见:htext-objects） 文本对象自身并不是动作命令， 不能用它们在文档中移动。 但是却可以在可视模式及操作符待决模式中使用文本对象 记住： 每当在命令语法里看到 {motion} 时， 也可以在这个地方使用文本对象， 常见的例子包括 d{motion}、 c{motion}和y{motion} Vim 的文本对象分为两类： 一类是操作分隔符的文本对象， 如i)、 i” 和it，称为 分隔符文本对象 另一类用于操作文本块， 如单词、 句子和段落，称为 范围文本对象 Vim 的文档把它们称为“块对象”（block object） 和“非块对象”(non-block object) 分隔符文本对象用于快速选择引号括号内容 以 i 开头的文本对象会选择分隔符内部的文本，而以a开头的文本对象会选择包括分隔符在内的整个文本，i——&gt;“inside”，a——&gt;“around”或“all”。 文本对 象 选择区域 文本对象 选择区域 a) 或 ab 一对圆括号 (parentheses) i) 或 ib 圆括号 (parentheses) 内部 a} 或 aB 一对花括号 {braces} i} 或 iB 花括号 {braces} 内部 a] 一对方括号 [brackets] i] 方括号 [brackets] 内部 a&gt; 一对尖括号 &lt;angle brackets&gt; i&gt; 尖括号 &lt;angle brackets&gt; 内部 a’ 一对单引号 ‘single quotes’ i’ 单引号 ‘single quotes’ 内部 a” 一对双引号 “double quotes” i” 双引号 “double quotes” 内部 a` 一对反引号 backticks i` 反引号 backticks 内部 at 一对 XML 标签 &lt;xml&gt;tags&lt;/xml&gt; it X 部ML标签&lt;xml&gt;tags&lt;/xml&gt;内 i( 和 i) 等同， a[ 和 a] 也相同 例子： 123(some text)di) 即可删除括号内容 范围文本对象 文本对象 选择范围 iw 当前单词 aw 当前单词及一个空格 iW 当前字串 aW 当前字串及一个空格 is 当前句子 as 当前句子及一个空格 ip 当前段落 ap 当前段落及一个空行 一般来说， d{motion} 命令和 aw、 as 和 ap 配合起来使用比较好， 而 c{motion} 命令和 iw 及类似的文本对象一起用效果会更好 例子 1、假设想删除下句中的单词“excellent” 此时可以用 daw 命令 按键操作 缓冲区内容 {start} Improve your writing by deleting excellent adjectives. daw Improve your writing by deleting adjectives. 这条命令会删除此单词，外加一个空格， 因此结果会很干净。 如果用的是 diw，删完后就会有两个连在一起的空格 2、假设想把此单词改成另外一个单词， 这次可以用 ciw 命令 按键操作 缓冲区内容 {start} Improve your writing by deleting excellent adjectives. ciwmost&lt;Esc&gt; Improve your writing by deleting most adjectives. ciw 命令只删除该单词， 而不删除其前后的空白字符， 随后它会进入插入模式， 这刚好是我们想要的效果。 如果用的是caw ， 最后两个单词就会连在一起， 变成“mostadjectives”。 编辑123456789101112131415161718192021222324252627282930313233343536373839i \"光标处插入a \"光标后一个字符处插入A \"光标所在行末尾插入o \"光标下方新建一行O \"光标上方新建一行p \"粘贴在光标后P \"粘贴在光标前y \"复制选择的文本yw或ye \"复制一个单词yy \"复制 光标所在的这一行4yy \"复制 光标所在行开始向下的4行dd \"剪切 光标所在的这一行2dd \"剪切 光标所在行 向下 2行d0 \"从当前的光标开始剪切，一直到行首D \"从当前的光标开始剪切，一直到行末daw \"删除光标所在的单词dw \"删除光标后的一个单词d2w \"删除光标后2个单词x \"删除当前的光标所在的字符，每次只会删除一个X \"删除当前光标前面的那个，每次只会删除一个r \"替换光标后的一个字符R \"连续替换光标后的字符ce或cw \"修改该单词到单词结尾C或c$ \"修改光标后该行的全部内容J \"连接两行. \"重复执行上一次的命令u \"撤销最后的操作U \"撤销对整行的修改ctrl+r \"反撤销ctrl+a 或 ctrl+x \"对光标下的数字进行加减，10ctrl+a可以每次加10，再配合点号.可以重复累加 * 撤销撤销块的概念 i{insert some text}&lt;Esc&gt; 是一次修改。 如果在插入模式中使用了 &lt;Up&gt;、 &lt;Down&gt;、 &lt;Left&gt;或 &lt;Right&gt;这些光标键， 将会产生一个新的撤销块。 操作符 + 动作命令 = 操作d{motion} ，d是操作符， motion是动作 操作符与动作命令的结合形成了一种语法。 这种语法的第一条规则很简单， 即一个操作由一个操作符， 后面跟一个动作命令组成。 学习新的动作命令及操作符， 就像是在学习Vim的词汇一样。 如果掌握了这一简单的语法规则， 在词汇量增长时， 就能表达更多的想法。 Vim的语法只有一条额外规则， 即当一个操作符命令被连续调用两次时， 它会作用于当前行。 所以 dd 删除当前行， 而 &gt;&gt; 缩进当前行。 gU 命令是一种特殊情况， 我们既可以用 gUgU ， 也可以用简化版的gUU 来使它作用于当前行。 Vim操作符 命令 用途 c 修改 d 删除 y 复制到寄存器 g~ 反转大小写 gu 转换为小写 gU 转换为大写 &gt; 增加缩进 &lt; 减小缩进 = 自动缩进 ! 使用外部程序过滤{motion}所跨越的行 一键代替两键 快捷按键 等效按键 效果 S ^C 清空当前行 C c$ 删除当前行光标后的内容 s cl TODO I ^i 在行首插入 A $a 在行尾插入 o A\\&lt;Enter> 在下方新建一行空白行 O ko&lt;&gt; 在上方新建一行空白行 删除与查找结合起来学会把d{motion} 操作符与查找动作结合在一起使用， 这是个很大的进步， 你可以好好在朋友和同事们面前炫耀一番了。 例子： 删除take与到get之间的内容 按键操作 缓冲区内容 {start} This phrase takes time but eventually gets to the point. d/ge\\ This phrase gets to the point. 虽然光标是在单词“gets”开头的“g”上的， 但此字符却被排除在删除操作之外（参见 :h exclusive ）。jizx的理解是/ge查找时，光标是在ge之前的，因此删除时不包括ge。 复制yyp 会使用寄存器，:t. 则不会 在复制距离较远的行时，:t 命令通常更加高效 删除一个单词1The end is nigh 假设光标在h上，要删除nigh，可行的方法有db x，b dw，以及daw 推荐daw,可以把 daw 命令解读为“delete a word”,因为.会把这一个命令完整记住，而其他的命令会被视为2部分 行尾添加字符串123&lt;C-v&gt;G$ &quot; 全选A; &quot; 进入插入模式，添加;&lt;Esc&gt; &quot; 完成插入 或者使用替换命令 1%s/$/;/g 对数字进行加减ctrl+a ctrl+x 分别会对光标下的数字进行加减，默认一次加1，10ctrl+a可以每次加10，再配合.可以重复累加 使用ctrl+a的话，对007会进行八进制的加法：007 + 001 = 010， 如果你想要10进制的，set nrformats=这会让Vim把所有数字都当成十进制， 不管它们是不是以0开头的。 重复与回退 目的 操作 重复 回退 做出一个修改 {edit} . u 在行内查找下一指定字符 f{char}/t{char} ; , 在行内查找上一指定字符 F{char}/T{char} ; , 在文档中查找下一处匹配项 /pattern n N 在文档中查找上一处匹配项 ?pattern n N 执行替换 :s/target/replacement &amp; u 执行一系列修改 qx{changes}q @x u 重复上次的 Ex 命令非常简单 :move5 @: u . 范式 用一次按键移动，另一次按键执行，再没有比这更好的了，不是吗？这就是我们的理想解决方案。我们将会一次又一次地看到这一编辑模式，所以为了方便起见，把它叫做“.范式”。 重复与计数 只在必要时使用次数 计算次数很是讨厌， 因此我宁愿按6次 . 命令， 也不愿意只为减少按键的次数， 而浪费同样的时间去统计次数。 如果我多按了一次 . 命令怎么办？ 没关系， 只要按一次 u 键就可以回退回来。 翻页123456789101112131415ctrl+f \"向下翻一页代码ctrl+b \"向上翻一页代码ctrl+d \"向下翻半页代码ctrl+u \"向上翻半页代码\" 可视化模式，可以配合d,x,y等进行修改，也可以进来末行模式:w filename 进行另存v \"字符可视化模式（Characterwise visual mode），文本选择是以字符为单位的，V \"行可视化模式（Linewise visual mode)，文本选择是以行为单位的。ctrl-V \"块可视化模式（Blockwise visual mode），可以选择一个矩形内的文本。&gt;&gt; \"向右移动代码&lt;&lt; \"向左移动代码shift+zz \"相当于wq 查找与替换123456789101112131415161718* \"高亮光标下的全部单词，使用 n 跳到下一处/xxx \"向下查找xxx/xxx\\c \"忽略大小写/xxx\\C \"区分大小写?xxx \"向上查找xxx?xxx\\c \"忽略大小写?xxx\\C \"区分大小写输入n则继续查找下一个匹配ctrl+o \"光标跳转到查询到的上一个位置ctrl+i \"光标跳转到查询到的下一个位置% \"快速查找光标所在处的括号所匹配的另一个括号 (),[],&#123;&#125;:s/old/new \"替换该行第一个匹配串:s/old/new/g \"替换该行全部匹配串:#,#s/old/new/g \"替换#到\"行之间的词:%s/old/new/gc \"替换全文匹配串，并逐个询问是否替换 命令*等效于输入 /\\&lt;&lt;C-r&gt;&lt;C-w&gt;\\&gt;&lt;CR&gt; 序列， 请参见命令行模式下的“快速复制单词”一节，关于 \\&lt; 和\\&gt;在模式中的作用， 请参见技巧77的讨论）。 在命令行模式中的%表示所有行 例子：在行尾添加分号 $表示行尾，替换为; 。不能写成%s/$/;$/g ，暂时不知道为什么。 1:%s/$/;/g 查看字符编码如果你想知道文档中任意字符的编码， 只需把光标移到它上面并按ga 命令， 然后屏幕下方会显示出一条消息， 分别以十进制和十六进制的形式显示出其字符编码（参见 :h ga ） 插入模式不离开插入模式粘贴在普通模式，使用复制命令yt 把“some text”复制到复制专用寄存器中 然后在插入模式中， 按 &lt;C-r&gt;0把刚才复制的文本粘贴到光标所在位置 &lt;C-r&gt;&lt;C-p&gt;{register}命令则会更智能一些，它会按原义插入寄存器内的文本，并修正任何不必要的缩进，不过这个命令有点不太好输入！因此，如果我想从 一个寄存器里粘贴很多行文本的话，我更喜欢切换到普通模式，然后使用某个粘贴命令。 编辑 按键操作 用途 &lt;C-h&gt; 删除前一个字符（同退格键） &lt;C-w&gt; 删除前一个单词 &lt;C-u&gt; 删至行首 插入特殊字符在插入模式下，ctrl+v进入特殊字符输入状态 假设想插入大写字母“A”， 它的字符编码是65， 因此需要输入 &lt;C-v&gt;065 假设想插入字符编码为00bf的反转问号（“¿”） ， 只需在插入模式中输入 &lt;C-v&gt;u00bf 如果&lt;C-v&gt; 命令后面跟一个非数字键， 它会插入这个按键本身代表的字符。 例如， 如果启用了 ‘expandtab’ 选项， 那么按\\ 键将会插入空格而不是制表符。 然而， 按 \\\\ 则会一直插入制表符， 不管 ‘expandtab’ 选项激活与否。 二合字母输入特殊字符 在插入模式中， 只需输入 &gt;{char1}{char2} 即可。 因此， 如果想输入以二合字母 ?I 表示的“¿”字符， 可以简单地输入 ?I 用命令:digraphs 可以查看可用的二合字母列表， 不过该命令的输出不太好阅读。 也可以用 :h digraph-table 查看另一个更为有用的列表。 总结 插入非常用字符 按键操作 用途 &lt;C-v&gt;065 以十进制字符编码插入字符A &lt;C-v&gt;u1F3B 以十六进制字符编码插入字符 &lt;C-v&gt;nondigit 按原义插入非数字字符 &lt;C-k&gt;{char1}{char2} 插入以二合字母{char1}{char2}表示的字符 可视模式 命令 用途 v 激活面向字符的可视模式 V 激活面向行的可视模式 &lt;C-v&gt; 激活面向列块的可视模式 gv 重选上次的高亮选区 可视模式间切换的命令。 按键操作 用途 &lt;Esc&gt;/ &lt;C-[&gt; 回到普通模式 v / V / \\&lt;C-v&gt; 切换到普通模式（在对应的面向字符可视模式、 面向行的可视模式和面 向列块的可视模式中使用时） V 切换到面向字符的可视模式 V 切换到面向行的可视模式 &lt;C-v&gt; 切换到面向列块的可视模式 O/o 切换高亮选区的活动端 经验 如果想使点命令能够重复某些有用的工作， 那么最好要远离可视模式。 作为一般的原则， 在做一系列可重复的修改时， 最好首选操作符命令， 而不是其对应的可视模式命令。 对一次性的修改任务来说， 可视模式完全够用， 并且尽管Vim的动作命令允许进行精确的移动， 但有时要修改的文本范围的结构很难用动作命令表达出来， 而处理这种情形恰恰是可视模式擅长的。 命令行模式1234567:w \"保存:w filename \"保存为指定的文件:q \"退出:wq \"保存并且推出:x \"等同于wq:r filename \"读取外部文件粘贴到光标处:r !ls \"获取命令输出内容粘贴到光标处 命令行补全:set col &lt;C-d&gt;命令会让Vim 显示可用的补全列表（参见 :h c_CTRL-D），如果多次按 &lt;Tab&gt; 键， 命令行上会依次显示colder、 colorscheme， 然后再回到最初的 col， 如此循环往复。 调整wildmode选项可以自定义补全行为（参见 :h wildmode） 。 bash shell的方式工作(列出所有候选项) 12set wildmenuset wildmode=longest,list zsh 提供的自动补全菜单 12set wildmenuset wildmode=full 当 wildmenu’选项被启用时， Vim 会提供一个补全导航列表。 可以按 、 或 正向遍历其列表项， 用 、 或 对其进行反向遍历。 执行 shell 命令:!{cmd} 适用于执行一次性命令，比如:!ls :shell 可以启动一个交互的shell会话执行多条命令，用exit命令可以退出此shell并返回Vim 注意区分 :!ls 和 :ls 的不同之处。前者调用的是 shell 中的 ls 命 令，而 :ls 调用的是 Vim的内置命令，用来显示缓冲区列表的内容。 在 Vim 的命令行中， 符号 % 代表当前文件名，如果当前正在编辑 Python 文件，可以用:!python %执行此文件。 推荐Ctrl-z 和 fg 假设正在 bash shell 中运行 Vim， 然后需要执行一些 shell 命令。 可以先按 Ctrl-z 挂起Vim 所属的进程， 并把控制权交还给bash。 此时 Vim 进程在后台处于挂起状态， 让我们可以像往常一样与 bash 会话进行交互。 运行下面这条命令可以查看当前的作业 列表。 12➾ $ jobs《[1]+ Stopped vim 在 bash 中， 可以用 fg 命令唤醒一个被挂起的作业， 把它移到前台。 这会让 Vim 恢复成挂起前的状态。 Ctrl-z 和 fg 命令比Vim 提供的 :shell 和 exit 命令更加方便快捷。 把缓冲区内容作为标准输入或输出 :read !{cmd} 把{cmd}命令的标准输出读入当前缓冲区中 :write !{cmd} 把缓冲区内容作为指定命令的标准输入 注意感叹号 根据叹号在命令行上的位置不同， 它的含义也不大相同。 1234➾ :write !sh➾ :write ! sh➾ :write! sh 前两个命令都会把缓冲区的内容传给外部的 sh 命令作为标准输入， 而最后一条命令调用 :write! 命令把缓冲区内容写到一个名为sh的文件， 这里的叹号表示强制 :write !sh 命令的作用是在shell中执行当前缓冲区中的每行内容， 查阅:h rename-files可看到该命令的一个绝佳示例。 当前目录中有以下文件：，想要将*.c 改为 *.blabuffer.ccharset.cdigraph.c… 12345$ vim:r !ls *.c:%s/\\(.*\\).c/mv &amp; \\1.bla:w !sh:q! 历史记录与bash一样，上下键↑↓可以浏览历史； 如果输入部分命令，↑↓就会过滤包含部分命令的记录 Vim 不仅会记录 Ex 命令的历史， 还会为查找命令单独保存一份历史记录。 在按 / 调出查找提示符后， 用 ↑↓可以正向或反向遍历之前的查找记录。 命令行窗口命令行窗口相当于另一个vim窗口，使用 Vim 完整的、 区分模式的编辑能力来修改历史命令。默认处于普通模式。基本上所有vim操作(i, x等)都可以使用 命令 动作 q/ 打开 正向查找命令 历史的命令行窗口 q? 打开 反向查找命令 历史的命令行窗口 q: 打开 Ex 命令历史的命令行窗口 &lt;Ctrl-f&gt; 当处于 命令行模式 下时意识到需要 更强大的编辑能力，可以用 映射项切换到命令行窗口中，此前已经输入命令行上的内容仍然 会得以保留 :q 退出命令行窗口 &lt;CR&gt; 执行光标所在行的命令 快速复制光标下的单词在输入命令行的时候，vim始终记住光标的位置，使用快捷键ctrl+r ctrl+w可以快速输入光标下的单词，ctrl+r ctrl+a可以快速输入光标下的字符串（字符串范围是离光标最近的前后两个空格之间的字符串） 1:%s/tally/&lt;C-r&gt;&lt;C-w&gt;/g # 将tally替换为光标下的单词 打字机模式用zz 命令可以重绘屏幕， 并把当前行显示在窗口正中， 这样就能够阅读当前行之上及之下的半屏内容。 我常常会键入&lt;C-o&gt;zz， 在插入-普通模式中触发这条命令。 此操作完成后就会直接回到插入模式， 因此可以不受中断地继续打字。 复制粘贴与寄存器复制粘贴删除快捷键普通模式：y(yank)、p(put) 、d(delete) Ex命令命令行模式： :delete c， 把当前行剪切到寄存器 c， 然后再执行 :put c命令将其粘贴至当前光标所在行之下 怎样才能知道 p 命令是把寄存器的文本粘贴到当前字符之后还是当前行之后呢？ 这取决于这个指定的寄存器是怎样被赋值的。 面向行的复制或者删除操作（如 dd、 yy 或者 dap） ， 将创建面向行的寄存器； 面向字符的复制或者删除操作（如x、 diw或者 das） 则创建面向字符的寄存器。 p的粘贴位置问题处理我不喜欢被迫去判断面向字符的文本区域到底是放在光标之前还是之后。 因此， 较之使用普通模式的 p 和 P 命令， 我有时更喜欢在插入模式中使用 &lt;C-r&gt;{register} 的映射项来粘贴面向字符的文本区域。 通过这种方式， 寄存器的文本总会被插入光标之前， 就像我们在插入模式下手动输入它们一样。 因此推荐在插入模式下： 通过输入 &lt;C-r&gt;&quot; 来插入无名寄存器的内容 通过输入 &lt;C-r&gt;0 来插入复制专用寄存器的内容 寄存器Vim的删除、 复制与粘贴命令都会用到众多寄存器中的某一个。 在普通模式，可以通过给命令加 &quot;{register}前缀的方式指定要用的寄存器。 若不指明， Vim将缺省使用无名寄存器，它用双引号表示，例如， &quot;&quot;p， 它完全等同于 p 命令。 在插入模式，可以输入ctrl+r {register}获取寄存器内容 查看寄存器内容:reg &quot;0 黑洞寄存器&quot;-删除文本而不把其内容复制到任何寄存器，用下画线符号（参见 :h quote_ ） 可以引用黑洞寄存器。 因此， &quot;_d{motion}会执行真正的删除操作。 复制专用寄存器&quot;0使用 y{motion} 命令时， 要复制的文本不仅会被拷贝到无名寄存器中， 而且也被拷贝到了复制专用寄存器 &quot;0。 复制专用寄存器 ，仅当使用 y{motion}命令时才会被赋值。 换句话讲， 使用 x、 s、 c{motion} 以及 d{motion} 命令均不会覆盖该寄存器。 有名寄存器&quot;a – &quot;zVim提供了一组以26个英文字母（参见 :h quote_alpha ） 命名的有名寄存器。 因此可以剪切（ “ad{motion}） 、 复制（”ay{motion}） 和粘贴（”ap） 多达26段文本。 用小写字母引用有名寄存器， 会覆盖该寄存器的原有内容； 用大写字母的话， 会将新内容添加到该寄存器的原有内容之后。 表达式寄存器&quot;=表达式寄存器可以用来执行一段Vim脚本 在普通模式中，执行&quot;=， Vim将跳到命令行模式， 并显示提示符“=”。 这时， 可以输入一段Vim脚本表达式并按 &lt;CR&gt; 执行， 如果返回的是字符串（或者可被强制转换成字符串的数据），Vim将会使用它。 在插入模式中， 输入 &lt;Cr&gt;=，会在屏幕的下方显示提示符“=”， 可以在其后输入要执行的表达式， 输入表达式后敲一下 &lt;CR&gt;，Vim就会把执行的结果插入文档的当前位置了。 1&lt;C-r&gt;=6*35&lt;CR&gt; # 就会得到结果 只读寄存器 寄存器 等价方法 内容 &quot;% &lt;C-r&gt;% 当前文件名 &quot;# &lt;C-r&gt;# 轮换文件名 &quot;. &lt;C-r&gt;. 上次插入的文本 &quot;: &lt;C-r&gt;: 上次执行的Ex命令 &quot;/ &lt;C-r&gt;/ 上次查找的模式 系统剪切板&quot;+与选择专用寄存器&quot;*Vim的加号寄存器&quot;+与系统剪贴板等效相通。 Linux的X11视窗系统支持另一种被叫作主剪贴板（primary）的剪贴板，它保存着上次被高亮选中的文本，可以用鼠标中键（如果有的话）把它们粘贴出来。Vim的星号寄存器对应主剪贴板，可用*号加以引用。 寄存器 用途 &quot;+ X11剪贴板， 用剪切、 复制与粘贴命令操作 &quot;* X11主剪贴板， 用鼠标中键操作 Windows与Mac OS X操作系统并没有主剪贴板的概念， 因此 &quot;+ 寄存器与 &quot;* 寄存器可以混用， 它们都代表系统剪贴板。 X11剪贴板的功能可在编译Vim时被激活或禁用。 如果想验证该功能是否在自己的Vim中被激活， 可运行 :version命令， 然后找到 xterm_clipboard关键字。 如果它前面有个减号， 就表示这个版本的Vim不支持该功能， 加号则表示此功能已被激活 用寄存器内容替换高亮选区的文本在可视模式下使用 p 命令时， Vim将用指定的寄存器内容来替换高亮选区中的文本， 它不再把无名寄存器既用于复制又用于删除， 因为根本就没有删除这一步。 相反的， 把删除和粘贴合成了一步， 完成高亮选区的替换。 粘贴缩进问题当在插入模式下使用系统粘贴命令时， Vim就像我们用手敲键盘一样地输入字符。 一旦 autoindent选项被启用， 意味着每当创建新行时， Vim都会保持同级缩进。 剪贴板中每行起始的空格是在之前自动缩进的基础上累加出来的， 这样将导致一行比一行往右偏。 打开粘贴 paste选项允许手动通知Vim“要使用系统粘贴命令了”。paste选项启用后，Vim将禁用所有插入模式下的映射项与缩写，并重置很多选项，其中就包括autoindent。 关闭粘贴 使用完系统粘贴命令之后，还要再次关闭paste选项。这意味着先切换回普通模式，再运行Ex命令:setpaste!。这样比较麻烦，可以通过下面的方法简化步骤： paste选项启用后， 在Vim插入模式下创建自定义映射项的方法都失效了。 作为替代方案， 可以把 pastetoggle选项（参见 :h’pastetoggle’ ） 映射成一个功能键。 推荐：:set pastetoggle=&lt;f5&gt; 终极方法（在xshell中没测试成功） 普通模式下的 “+p 命令用来粘贴加号寄存器中的内容， 即系统剪贴板的镜像。 更多细节， 请参见系统剪贴板（”+） 与选择专用寄存器（”*） 。 无论 paste与autoindent选项激活与否， 该命令都能保证位于剪贴板中的文本缩进不会乱套。 粘贴的推荐结论p 与 P 命令对于粘贴多行文本区域非常重要， 但是对于小段的、 面向字符的文本来讲， 使用 &lt;C-r&gt;{register} 映射项的方式会更直观。 查找与正则查找快捷键 命令 用途 n 跳至下一处匹配， 保持查找方向与偏移不变 N 跳至上一处匹配， 保持查找方向与偏移不变 / 正向跳转至相同模式的下一处匹配 ? 反向跳转至相同模式的上一处匹配 gn 进入面向字符的可视模式， 并选中下一处匹配 gN 进入面向字符的可视模式， 并选中上一处匹配 相关设置循环查找 123:set wrapscan :set ws&quot;如果只想在当前光标位置至文档结尾的范围内查找，而不想绕回文档继续查找的话 暂时关闭高亮 :set nohlsearch 命令彻底禁用查找高亮功能（使用 :se nohls 与 :se hls! 效果一样）。但在执行其他查找时，我们又可能想重新激活它。 :nohlsearch命令暂时关闭查找高亮功能（参见 :h :noh ）。此命令使得高亮功能一直处于关闭状态，直到执行新的或重复的查找命令为止。 通过创建映射项，可以加速操作。 1nnoremap&lt;silent&gt; &lt;C-l&gt; :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;` 边输入边查找 :set incsearch ：预览第一处匹配 将光标匹配到结尾 1/lang/e&lt;CR&gt; 查看多次后发现要移动到结尾处，可以不用重新输入模式，直接使用//e&lt;CR&gt; 历史记录Vim会一直记录我们执行过的查找模式，因此可以方便地重用它们。 在普通模式想再次执行上一次的查找时可以不输入模式，直接按 n ， N，/或者?，此时 Vim 将重用上一次的查找模式，然后正向或反向查找。 在命令行模式，当查找提示符/或?出现时，可以通过 &lt;Up&gt; 键，滚动浏览之前的查找记录。 自动补全快捷键&lt;C-r&gt;&lt;C-w&gt;会用当前预览的匹配结果对查找域进行自动补全。如果已在查找域中输入了“carr”，执行该命令会将“ot”添加到结尾，使其最终匹配完整的单词“carrot”。 注意，&lt;C-r&gt;&lt;C-w&gt; 自动补全功能在查找内容中存在元字符\\v前缀时会有瑕疵，&lt;C-r&gt;&lt;C-w&gt;会把光标下的完整单词，而不是单词的余下部分，作为补全的内容（例如，执行补全后会变成/\\vcarrcarrot&lt;CR&gt;）。 大小写相关临时区分大小写12/str\\C 区分大小写/str\\c 不区分大小写 小写字母\\c会让查找模式忽略大小写，而大写字母\\C会强制区分大小写。这两个元字符可以出现在模式的任意位置，不过在末尾可读写比较好。 smartcase选项smartcase选项被启用后，无论何时，只要在查找模式中输入了大写字母，ignorecase设置就不再生效了。 换句话说，如果模式全是由小写字母组成的，就会按照忽略大小写的方式查找，但只要输入一个大写字母，查找方式就会变成区分大小写的了。 正则转义问题之 一： very magic案例 123body &#123; color: #3c3c3c; &#125; a &#123; color: #0000EE; &#125;strong &#123; color: #0000EE; &#125; 想要匹配颜色 1/#\\([0-9a-fA-F]\\&#123;6&#125;\\|[0-9a-fA-F]\\&#123;3&#125;\\) 此例用到了3类括号。 方括号[]缺省具有特殊含义，因此不用转义。 圆括号()会按原义匹配普通字符(及)，因此需要转义，使其具有特殊含义。圆括号无论开闭括号都必须转义。 花括号{}也一样需要转义，不过，只需为开括号转义，而与之对应的闭括号则不用，因为Vim会推测我们的意图。 解决方法 可以利用 \\v模式开关来统一所有特殊符号的规则。该元字符将会激活 very magic搜索模式，即假定除_、大小写字母以及数字0～9之外 的所有字符都具有特殊含义。因此上例进行修改后如下： 1/\\v#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;) 由于出现在起始位置的\\v开关，位于它后面的所有字符都具有特 殊含义。这样一来，那些反斜杠字符就可以去掉了，可读性更强了。 总结 作为通用法则，如果想按正则表达式查找，就用模式开关 \\v， 而如果想按原义查找文本， \\V 会使得其后的模式中只有反斜杠有特殊的意义。 转义问题之二：特殊字符的特殊处理\\V原义开关使得按原义查找文本变得更容易，因为符号 .、+ 以及 * 的特殊含义被屏蔽掉了。但还有一些字符，其特殊含义无法被屏蔽。 要处理的字符串：http://vimdoc.net/search?q=/\\\\ 正向查找时要转义 / 字符1/\\Vhttp://vimdoc.net/search?q=/\\\\ # 错误写法 实际上只会匹配 /字符串/ ,也就是/\\Vhttp:/，因此需要对/进行转义 1/\\Vhttp:\\/\\/vimdoc.net\\/search?q=\\/\\\\\\\\ # 正确写法 反向查找时要转义?号与正向类似，匹配的内容是?字符串?，因此需要对?进行转义 1?http://vimdoc.net/search\\?q=/\\\\\\\\ 查找域结束符/与?你可能会觉得奇怪，为什么查找域会把某个字符视为结束符呢？它为什么不把所有位于查找提示符之后的内容都纳入查找匹配呢？答案是如果在查找域结束符之后附加某些标志位，可以调 整Vim查找命令的行为。例如，如果运行命令 /vim/e&lt;CR&gt;，光标将会移到每个匹配的结尾，而非起始。 每次都要转义符号 \\在查找域中，还有一个字符需要转义，即反斜杠。通常情况下，一 个 \\ 的出现预示着紧挨着它后面的字符将会得到某种特殊对待。如果变为 \\\\，前者会消除后者的特殊含义，让Vim查找一个反斜杠。 无论采用的是正向还是反向查找方式，反斜杠字符永远都需要转义。 用编程的方式转义字符用手动方式转义字符既耗时费力，又容易出错。幸运的是，Vim脚本提供了一个库函数escape({string}, {chars}) {chars} 参数将指定哪些字符需要用反斜杠转义。 如果要进行正向查找，可以调用 escape(str, &#39;/\\&#39;)，它会为每个 / 与 \\ 加上反斜杠前缀。 如果进行的是反向查找，则要换用 escape(str,&#39;?\\&#39;) &quot;uyi将正则复制到寄存器 u 中 输入 / 或 者 ? 调出查找提示符 依次输入原义开关 \\V与 &lt;C-r&gt;=，Vim就会从查找提示符的状态切换到表达寄存器提示符的状态了 =escape(@u, getcmdtype().&#39;\\&#39;) getcmdtype()返回命令类型，比如正向查找返回/，反向返回? 在Vim脚本中，.起到连接字符串的作用，因此正向查找时getcmdtype().&#39;\\&#39;将产生/\\ 单词边界1&lt; 与 &gt; 单词前后定界符 /\\v&lt;the&gt;只匹配 the ，而不会匹配 these。这是零宽度元字符，它们本身不匹配任何字符，仅表示单词与围绕此单词的空白字符（或标点符号）之间的边界 子匹配案例：查找重复的单词 1/\\v&lt;(\\w+)\\_s+\\1&gt; 诀窍就在于 () 与 \\1的组合使用。任何圆括号内部的匹配文本都会自动保存到一个临时的仓库。可以用 \\1引用这段被捕获的文本。另外，不论模式中是否使用了圆括号，元字符\\0永远会引用整个匹配。 \\_s会匹配空白符或换行符，\\_表示包含换行符，s在正则中表示空白符，因此还以是\\_w匹配字母或换行符。 不捕获子匹配 有时只想使用圆括号的分组功能，但并不关心捕获的子匹配。例如，可以使用以下模式来匹配作者名字的两种形式。 1/\\v(And|D)rew Neil 这一次使用圆括号的目的在于匹配“Andrew”或者“Drew”，但并不想捕获位于圆括号内部的“And或D”。可以在圆括号前面 加上% ，指示Vim不要将括号内的内容赋给寄存器 \\1，就像这样。 1/\\v%(And|D)rew Neil 如果你发现自己经常会用到多组圆括号，使用%的速度会比原来快了一些 案例：把所有的名和姓调换位置 12/\\v(%(And|D)rew) (Neil) :%s//\\2, \\1/g 该查找模式会把“Andrew”或者“Drew”赋给寄存器 \\1，而把“Neil”赋给寄存器 \\2。如果没有对第二组圆括号使用 %() ，便会得到无用的文本片段，从而扰乱替换域。 截取部分匹配比如想查找带引号的字符串，比如：&quot;Vim&quot;，但是只想修改 Vim，因此可使用元字 符 \\zs 与 \\ze对匹配进行裁剪，使其成为这个完整模式的一个子集 1/\\v&quot;\\zs[^&quot;]+\\ze&quot; \\zs 与\\ze之间的内容就是你感兴趣的内容，而外部的其他字符可以认为是额外的限制条件。 可以只有\\zs，比如查找Practical Vim，但只想修改 Vim，可以这样做: 1/Practical \\zsVim 增强*功能在普通模式下，* 命令可以查找光标下的单词。通过一小段 Vim脚本，可以重新定义可视模式下的 * 命令，使其可以查找当前选中高亮的文本，而不仅仅是光标下的单词。 12345678xnoremap * :&lt;C-u&gt;call &lt;SID&gt;VSetSearch(&apos;/&apos;)&lt;CR&gt;/&lt;C-R&gt;=@/&lt;CR&gt;&lt;CR&gt;xnoremap # :&lt;C-u&gt;call &lt;SID&gt;VSetSearch(&apos;?&apos;)&lt;CR&gt;?&lt;C-R&gt;=@/&lt;CR&gt;&lt;CR&gt;function! s:VSetSearch(cmdtype) let temp = @s norm! gv&quot;sy let @/ = &apos;\\V&apos; . substitute(escape(@s, a:cmdtype.&apos;\\&apos;), &apos;\\n&apos;, &apos;\\\\n&apos;, &apos;g&apos;) let @s = tempendfunction 可以直接将这段代码粘贴至你的 vimrc 文件中，或者安装visual star search插件。 工程目录查找：grep、vimgrep、ackvim内部grepvim的 :grep Waldo *命令是对外部 grep 程序的包装，用法与 grep 一致，Vim将在后台为我们在shell中执行 grep -n Waldo * 定制 grep配置grepprg与grepformat这两个选项，可以对 Vim 查找的行为进行定制。 12grepprg=&quot;grep -n $* /dev/null&quot; grepformat=&quot;%f:%l:%m,%f:%l%m,%f %l%m&quot; grepprg：$* 表示占位符，将会被:grep命令的参数代替 grepformat：%f表示文件名，%l表示行号，%m则表示匹配行的文本，%c表示列号。字符串可以包含以逗号分隔的多组格式。 vimgrep1:vim[grep][!] /&#123;pattern&#125;/[g][j] &#123;file&#125; … {file}参数一定不能为空，它可以是文件名、通配符、反引号表达 式以及这些类型的组合 1➾ :vim /going/g *.txt 除了可以使用和*通配符外，也可以使用##符号，它将被扩展成参数列表中的所有文件。 因此可以先把希望查找的文件加入参数列表，然后再在参数列表中的 所有文件上运行 :vimgrep 12➾s :args *.txt➾ :vim /going/g ## 优点：这种方式能够两件事分开：要在哪些文件中查找，以及要用什么模式查找。一旦文件被 加入参数列表，在这组文件上执行多少次:vimgrep命令都可以。 使用:vimgrep的主要优点在于其使用的模式与Vim的查找命令一 致。如果是使用 :grep 在工程范围内查找相同模式，就不得不先把该模式转化成POSIX正则表达式 ack：beyond grep首先，需要安装 ack 12345ubuntu➾ $ sudo apt-get install ack-grep ➾ $ sudo ln -s /usr/bin/ack-grep /usr/local/bin/ackOS X➾ $ brew install ack 定制 ‘grepprg’ 与 ‘grepformat’ 这两个选项， 实现让 :grep 调用 ack 12➾ :set grepprg=ack\\ --nogroup\\ --column\\ $*➾ :set grepformat=%f:%l:%c:%m 这样在浏览查找结果时，就可以跳转到每一处匹配的精确位置，而不仅是准确的行 grep采用的 是POSIX风格的正则表达式，ack则采用的是Perl风格的正则表达 式。如果 :grep命令在后台调用ack，可能会引起误导，因此也可以使用Ack.vim插件。fugitive.vim插件也提供了一个名为 :Ggrep的自定义命令用于执行git-grep。 替换1:[range]s[ubstitute]/&#123;pattern&#125;/&#123;string&#125;/[flags] 标志位 g 使得subsititute命令可在全局范围内执行，即可以修改一行 内的所有匹配，而不仅仅是第一处匹配。 c 让我们有机会可以确认或拒绝每一处修改。 n会抑制正常的替换行为，即让 Vim 不执行替换操作，而只是报告本次 substitute 命令匹配的个数。 执行 substitute 命令时，如果在当前文件中没有匹配到该模式，Vim 会提示错误信息“E486: 找不到模式”。标志位e专门用于屏蔽这些错误提 示。 &amp; 仅仅用于指示Vim重用上一次substitute命令所用过的标志 位。技巧93展示了其应用的场景。 替换域中的特殊字符一些字符在用作查找模式时具有特殊含义。替换域中也有一些特殊字符。过查询 :h sub-replacespecial ，可以找到完整的列表 符号 描述 \\r 插入一个换行符 \\t 插入一个制表符 \\\\ 插入一个反斜杠 \\1 插入第1个子匹配 \\2 插入第2个子匹配（以此类推，最多到 \\9） \\0 插入匹配模式的所有内容 &amp; 插入匹配模式的所有内容 ~ 使用上一次调用 :substitute时的 {string} \\={Vim script} 执行 {Vim Script} 表达式；并将返回的结果作为替换 {string} 全局替换将文件想象成二维平面，字符沿着x轴增加，文本行则随着y轴向下增长。在缺省情况下，substitute命令仅仅作用于当前行的第一处匹配。 为了使substitute命令作用于整个横轴，需要引入标志位g。g看似为全局之意（global），实则有误导之嫌。也许有人想借此标志位在整个文件范围内进行替换操作，但实际上，它仅表示“当前一整行范围”。 1:s/going/rolling/g 怎样才能控制substitute命令在整个文件的纵轴上执行呢？ 答案是设定一个范围。如果在substitute命令的开头加上前缀%，它就会在文件的每一行上执行了。 1:%s/going/rolling/g 每次替换进行询问引入标志位c后，vim 会对每处匹配结果提示“替换为str?” Vim会体贴 地提示所有的选项“y/n/a/q/l/E/Y”。下表展示了每种答案的含义。 回答 用途 y Yes 替换此处匹配 n No 忽略此处匹配 q Quit 退出替换过程 l last 替换此处匹配后退出 a all 替换此处与之后所有的匹配 &lt;C-e&gt; 向上滚动屏幕 &lt;C-y&gt; 向下滚动屏幕 一分为二：先查找再替换执行substitute命令通常包括两个步骤： 撰写查找模式 设计合适的替换字符串 利用查找的历史记录功能，可以将替换分为两步，先测试查找内容，然后进行替换。因此，一分为二的技术让我们消除了这两项任务的耦合性，这才是关键所在。 对于:%s/\\n/,将“换行替换为逗号”这种简单的命令，就没必要将它一分为二了，否则非但得不到 什么好处，反而有可能增加工作量。 对于复杂的内容，推荐一分为二。 1234567➾ /\\v&apos;(([^&apos;]|&apos;\\w)+)&apos;将查找域留空，Vim将重用上一次的查找命令➾ :%s//“\\1”/g实际上，我们刚才所做的等同于如下命令。➾ :%s/\\v&apos;(([^&apos;]|&apos;\\w)+)&apos;/“\\1”/g 但是也有不好的影响，会在命令历史中留下一项不完整的记录，从而导致当再想重用之前的substitute命令时，会遇到困难。 如果你觉得将来会以完整形式来调用历史记录中的substitute命令， 就要养成在查找域中填充内容的习惯。只需在命令行中输入 &lt;C-r&gt;/ ， 即可把上次的查找内容粘贴进来。因此，通过以下命令，就可以在命令历史中创建一项完整的记录。 12➾ /\\v&apos;(([^&apos;]|&apos;\\w)+)&apos;➾ :%s/&lt;C-r&gt;//“\\1”/g global命令:global 命令允许在某个指定模式的所有匹配行上运行Ex命令 1:[range] global[!] /&#123;pattern&#125;/ [range][Excmd] [Excmd]可以是除 :global命令之外的任何Ex命令，如果不指定任何 [Excmd]，Vim将缺省使用 :print。 :global! 或者 :vglobal（v表示invert）反转:global命令的行为。这两条命令将指示Vim在没有匹配到指定模式 的行上执行 [Excmd]。 案例复制TODO 内容假设想把所有TODO项收集到一起。 首先运行 qaq，将寄存器 a清空。 :g/TODO/yank A把包含TODO注释的行复制到此寄存器中 要用大写字母A引用寄存器。这意味着Vim将 把内容附加到指定的寄存器，用小写字母 a的话，则会覆盖原有寄存器 的内容。因此，这条global命令可以被解读为“将所有匹配模式 /TODO/ 的文本行依次附加到寄存器 a。 &quot;ap命令，就可以将寄存器 a的内容粘贴进去 了。 另一种方案 该命令是将所有TODO项 复制到当前文件的末尾，而不是把它们附加到寄存器。 1:g/TODO/t$ global 高级假设想对 CSS 内容进行排序 1234567891011121314151617html &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; &#125;# 排序后html &#123; border: 0; font-size: 100%; font: inherit; margin: 0; padding: 0; vertical-align: baseline; &#125; 命令 1:g/&#123;/ .+1,/&#125;/-1 sort 分析 Ex命令通常都会接受“范围”作为其参数，因此 global 命令可以扩展为如下： 1:g/&#123;pattern&#125;/[range][Excmd] 因此上面的排序命令可以分解为 2 部分 第一部分是g/{/找到{ 第二部分是.+1,/}/-1 sort，其中.+1,/}/-1 表示范围，去掉偏移后：.,/}/, . 符号通常表示光标所在行，但在 :global命令的上下文中，它则表示 {pattern} 的匹配行。因此.,/}/的含义是“从匹配模式/{/那一行开始，一直到匹配模式 /}/ 的那一行为止”。 结论 :global命令的广义形式如下： 1:g/&#123;start&#125;/ .,&#123;finish&#125; [Excmd] 可以将其解读为“对从 {start} 开始，到 {finish} 结束的所有文 本行，执行指定的 [Excmd]”。 例子 假设想对某一段指定范围内的文本内容进行缩进，用Ex命令 :&gt; 1:g/&#123;/ .+1,/&#125;/—1 &gt; 每当调用 :&gt; 命令时，Vim都会提示一条信息。如果在 [cmd] 的前面加 上 :slient（参见 :h :sil ），就可以屏蔽这些信息： 1:g/&#123;/sil .+1,/&#125;/−1 &gt; 文件缓冲区列表:ls查看缓存区 1:ls 标记 + 号， 表示这个缓冲区被修改过了 标记为a， 表示它当前是活动缓冲区（active） 标记为 h， 表示它是一个隐藏缓冲区（hidden） 切换缓冲区 12:bnext &quot;切换:bnext! &quot;强制切换，不保存 退出缓冲区 1:quit 当想关闭编辑会话时， vim就会提醒某个缓冲区中有未保存的修改 ，并把第一个有改动的隐藏缓冲区载入当前窗口， 这样就可以决定如何处理它。 如果要保留修改， 可以执行 :write 命令把缓冲区保存到文件； 如果想摒弃此修改， 可以执行 :edit!， 重新从磁盘读取此文件； 如果会话里有不止一个被修改过的隐藏缓冲区，那么每次执行:quit命令时，都会激活下一个未保存的缓冲区。可以用:write及:edit!来保存或摒弃此修改。 在退出时， 处理隐藏缓冲区的方式总结 命令 用途 :w[rite] 把缓冲区内容写入磁盘 :e[dit]! 把磁盘文件内容读入缓冲区（即回滚所做修改） :qa[ll]! 关闭所有窗口， 摒弃修改而无需警告 :wa[ll]! 把所有改变的缓冲区写入磁盘 参数列表:args当不带参数运行 :args 命令时， 它会打印当前参数列表的内容。 另外， 也可以用下列格式来设置参数列表的内容 1:args &#123;arglist&#125; 用文件名指定文件 :args index.html app.js 用 Glob 模式指定文件 :args **/*.js **/*.css *符号用于匹配0个或多个字符， 但它的范围仅局限于指定的目录， 而不会递归其子目录（参见 :h wildcard ） ** 通配符也匹配0个或多个字符， 但它可以递归进入指定目录的子目录 可以把这两种通配符结合起来用， 并加上部分文件名或目录名， 以此构造一个模式（即所谓的 glob模式） 用反引号读取命令指定文件 1:args `cat chapters.txt` 参数列表比缓冲区列表更容易管理，这使其成为对缓冲区进行分组的理想方式。使用:args {arglist}命令，一下就可清空并重新设置参数列表，接着可以用:next及:prev命令遍历参数列表中的文件，或是用:argdo命令在列表中的每个缓冲区上执行同一条命令。 多屏幕新建分屏 命令 用途 在新窗口中打开同一缓冲区 s 水平切分当前窗口， 新窗口仍显示当前缓冲区 v 垂直切分当前窗口， 新窗口仍显示当前缓冲区 在新窗口中打开另一个缓冲区 :sp[lit] {file} 水平切分当前窗口， 并在新窗口中载入{file} :vsp[lit] {file} 垂直切分当前窗口， 并在新窗口中载入{file} 先执行 &lt;C-w&gt;s， 再执行 :edit {filename} 水平切分当前窗口， 并在新窗口中载入{file} 先执行 &lt;C-w&gt;v， 再执行 :edit {filename} 垂直切分当前窗口， 并在新窗口中载入{file} 分屏切换可以使用鼠标来激活窗口，请注意:set mouse=TODO如何设置？ 也可以使用快捷键来激活窗口 上下左右与hjkl的一致 命令 用途 或w 在窗口间循环切换 h 切换到左边的窗口 j 切换到下边的窗口 k 切换到上边的窗口 l 切换到右边的窗口 关闭分屏 Ex 命令 普通模式命令 用途 :clo[se] c 关闭活动窗口 :on[ly] o 只保留活动窗口， 关闭其他所有窗口 调整分屏大小完整的列表请查阅 :h window-resize 命令 用途 = 使所有窗口等宽、 等高 _ 最大化活动窗口的高度 ｜ 最大化活动窗口的宽度 [N]_ 把活动窗口的高度设为[N]行 [N]｜ 把活动窗口的宽度设为[N]列 改变窗口大小是我喜欢用鼠标做的少量操作之一， 其做法很简单 重新排序分屏window-moving http://vimcasts.org/episodes/working-with-windows/ 标签tabVim 的标签页与缓冲区并非一一对应的关系， 相反， 应该把标签页想成容纳一系列窗口的容器 技巧41 如何使用标签页 不太明白 TODO :lcd {path} 命令让我们可以设置当前窗口的本地工作目录。 如果创建了一个新标签页， 并用 :lcd 命令切换到另一个目录， 就可以把每个标签页限制在不同的工程范围内。 注意： :lcd 只影响当前窗口，而非当前标签页。 如果一个标签页包含了两个或更多的窗口， 可以用:windo lcd {path} 命令为所有这些窗口设置本地工作目录。 打开和关闭标签:tabedit {filename} 命令可以打开一个新的标签页， 如果省略了 {filename} 参数， 那么 Vim 会创建一个新标签页， 里面包含一个空缓冲区。 命令 用途 :tabe[dit] {filename} 在新标签页中打开 {filename}，如果省略了 {filename} 参数， 那么 Vim 会创建一个新标签页， 里面包含一个空缓冲区。 \\T 把当前窗口移到一个新标签页 :tabc[lose] 关闭当前标签页及其中的所有窗口 :tabo[nly] 只保留活动标签页， 关闭所有其他标签页 标签页间切换 Ex 命令 普通模式命令 用途 :tabn[ext] {N} {N}gt 切换到编号为 {N} 的标签页 :tabn[ext] gt 切换到下一标签页 :tabp[revious] gT 切换到上一标签页 重排标签:tabmove [N]命令可以重新排列标签页 当 [N] 为0时， 当前标签页会被移到开头 如果省略 [N]， 当前标签页会被移到结尾 如果终端支持鼠标可以通过鼠标拖曳来进行重排操作。 使用sudo保存文件12345➾ :w !sudo tee % &gt; /dev/null《 Password: W12: Warning: File &quot;hosts&quot; has changed and the buffer was changed in Vim as well [O]k, (L)oad File, Load (A)ll, (I)gnore All: 此时进行两次交互。 首先要输入用户的密码， 然后 Vim 会警告我们该文件已被修 改了， 并显示出一个选项菜单。 这里建议按 l 键重新将该文件载入缓冲区。 这条命令是如何工作的？ :write !{cmd}命令会把缓冲区的内容作为标准输入传给指定的 {cmd}， {cmd} 可以是任何外部程序。 虽然Vim仍然是以普通用户运行的， 但是可以让调用的外部进程以超级用户权限运行。 在本例中， tee程序将以sudo权限运行， 也就是说它拥有写 /etc/hosts 文件的权限。在 Vim 命令行中， % 符号具有特殊含义。 它会展开成当前文件的完整路径/etc/hosts。 因此，该命令的后半部分可以展开为下面的命令：tee /etc/hosts &gt;/dev/null。 这条命令会把缓冲区的内容当作标准输入， 并用它来覆盖/etc/hosts 文件的内容。 之后， Vim 会检测到该文件已经被一个外部程序修改。 一般情况下， 这意味着缓冲区中的内容和文件不同步了， 这就是为什么 Vim 会提示我们做出选择， 是要保留缓冲区中的版本， 还是载入磁盘上的版本 。 宏按键黄金法则：在录制一个宏时，要确保每条命令都可被重复执行。 12345q&#123;register&#125; 录制q 停止@&#123;register&#125; 命令执行指定寄存器的内容100@&#123;register&#125; 以串行方式重复 100 次命令，执行指定寄存器的内容@@ 来重复最近调用过的宏 点与宏对于重复次数不多的工作，点范式是一种高效的编辑策略， 但它不能指定执行的次数。为了克服该限制，可以录制一个廉价 的、一次性的宏，然后再加次数进行回放。 11;.会先运行11次 ;命令，再运行1次 .命令，因此并不会运行成功。 通过录制一个最简单的宏，可以模拟执行11次的 ;.，即 qq;.q，然后11@q 首先 qq将指示Vim录制后续的按键操作并将它们保存至寄存器q中。然后再输入命令 ;.。最后按下q键结束宏的录制。可以加上次数11执 行这个宏 11@q，即执行11次 ;.。 并行宏执行宏的时候，如果遇到错误，后续的内容将不会继续执行，因此为了避免某一行文本运行失败而提前退出宏，推荐并行宏 123451. one2. two// break up the monotony3. three4. four 步骤： qa 0f.r)w~ q jVG 可视模式选择剩余行 :&#39;&lt;,&#39;&gt;normal @a 对剩余行都执行寄存器 a 中的宏 123451( One2( Two// break up the monotony3( Three4( Four 追加宏 你可能遇到刚一按下q键，停止了宏的录制，才发现应该在结束之前按一下j键，将光标移至下一行。 在输入 qa时，Vim将开始录制接下来的按键操作，并将它们保存到寄存器 a中，这会覆盖该寄存器原有的内容。 如果输入的是 qA，Vim也 会录制按键操作，但会把它们附加到寄存器a原有的内容之后。可以用这种方式更正该错误。 修改宏用于录制宏的寄存器，与用作复制、粘贴操作的寄存器相同。因此，如果想修改寄存器 a中的宏，只需将其粘贴至文档中，便可以像编辑普通文本一样编辑它了。 :put a 把寄存器 a中的内 容粘贴至新的一行 修改宏内容 0 回到行首 &quot;ay$ 复制宏内容到寄存器 a 中，&quot;add会将换行符都复制进去，因此不推荐 dd 删除文本 宏中的变量12345partridge in a pear tree turtle doves French hens calling birds golden rings 最终想变成这样 123451) partridge in a pear tree2) turtle doves3) French hens4) calling birds5) golden ring\b :let i=1 设置变量 qa 开始录制 I&lt;C-r&gt;=i&lt;CR&gt;)&lt;Esc&gt;插入变量 i :let i += 1 变量递增 q 退出录制 配置可以将定制化的选项写入文件，加以保存。此后通过 :source {file} 命令加载配置。在加载文件时，Vim会把每一行文本当作Ex命令加以执行，就好像在Vim命令行上执行它们一样。 每当想在当前缓冲区应用这些配置项时，可以运行这条命令：:source two-space-indent.vim vimrc 的路径 单次启用某个配置项，在命令模式下，先输入一个冒号，再输入配置 用户个人的配置 在UNIX 系统中，Vim希望能找到路径为 ~/.vimrc的文件 在Windows系统 中，理想的文件路径为 $HOME/_vimrc Vim 的全局配置一般在/etc/vim/vimrc或者/etc/vimrc，对所有用户生效 无论运行的是哪种系统，都可以通过:edit $MYVIMRC来编辑配置文件，:source $MYVIMRC为当前的Vim 会话加载新的配置选项，如果活动的缓冲区是vimrc文件则可以简化为:so% 查看、设置参数对于布尔类型，要么打开，要么关闭。”关闭”就是在”打开”前面加上前缀no。以 ‘ignorecase’ 选项为例 12345:set ignorecase &quot;打开:set noignorecase &quot;关闭:set ignorecase! &quot;反转该设置:set ignorecase? &quot;获取该选项当前的状态:set ignorecase&amp; &quot;重置为默认值 对于要用到字符串或者数字的配置 12:set tabstop=2:set ts=2 sts=2 sw=2 et &quot;可以用一条 set 语句设置多组选项。 另外，大多数Vim选项都有其简写形式。 生效范围局部生效 Vim的设置项通常全局生效，但有些选项只对一个窗口或缓冲区生效。例如，当运行 :setlocal tabstop=4时，只会影响当前活动的缓冲区。这意味着我们可以打开不同的文件，并为每个文件单独定制。 缓冲区生效 如果我们想在现有的所有缓冲区内应用同样的设置，可以运行以下命令。 1:bufdo setlocal tabstop=4 窗口生效 ‘number’ 选项只在窗口范围内生效。运行 :setlocal number 时，Vim将会激活当前活动窗口的显示行号功能。如果想为每个窗口都激活该功能，可以运行下面这条命令。 1:windo setlocal number 末行命令自动补全123\" 末行命令自动补全set wildmenu \" (跟下面组合使用？没看出效果)set wildmode=longest:list,full \"命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。 为特定类型的文件应用个性化设置我们的偏好设置有可能根据文件的类型不同而有所差异。例如，假设排版格式要求，对 Ruby文件要采用两个空格的缩进，而对JavaScript 文件采用4列宽度的制表符。 123456if has(&quot;autocmd&quot;) filetype on autocmd FileType ruby setlocal ts=2 sts=2 sw=2 et autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noet autocmd FileType javascript compiler nodelintendif autocmd语句的检测机制将指示Vim监听某一类事件，一旦该事件发生，Vim将执行指定的命令（参见 :h :autocmd ）。在本例中， 将监听 FileType事件，它会在Vim检测出当前文件类型时被触发。可以为相同类型的事件添加不止一条自动命令。 如果想在某一类文件中应用很多项设置，这样做会使 vimrc 变得很乱。另一种方法是使用文件类型插件（ftplugin）来定制不同文件类型。针对不同的语言，都有单独的配置文件，路径为~/.vim/after/ftplugin/javascript.vim 12setlocal ts=4 sts=4 sw=4 noet compiler nodelint 为了能够使用 ftplugin 机制，必须确保检测文件类型的功能以及插件功能都被激活了。请检查 vimrc，看看是否包含了filetype plugin on 推荐的配置http://www.ruanyifeng.com/blog/2018/09/vimrc.html 外观、代码风格12345678910111213141516171819202122232425262728293031323334353637383940\" 颜色相关syntax on \"打开语法高亮，自动识别代码set hlsearch \"搜索时，高亮显示匹配结果set hls \"高亮显示匹配到的关键字‘hlsearch’“set noh 取消高亮显示匹配结果”set nohlsearch 取消高亮显示匹配结果set showmatch \"光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号set t_Co=256 \"启用256色\" 换行相关set tabstop=4 \"按下Tab 键时，Vim 显示的空格数set wrap \"自动折行，即太长的行分成几行显示。set linebreak \"不会在单词内部折行。只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行\" 光标位置相关set scrolloff=5 \"垂直滚动时，光标距离顶部/底部的行数，方便看到后面的内容set sidescrolloff=15 \"水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用\" 状态栏相关set ruler \"在状态栏显示光标的当前位置（位于哪一行哪一列）set laststatus=2 \"是否显示状态栏。0:不显示，1:只在多窗口时显示，2:显示set showmode \"在底部显示，当前处于命令模式还是插入模式set showcmd \"命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失。\" 辅助显示set nuset number \"显示行号set list \"如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块。与listchars配合使用\"\"\"\"\"\"\"\"\"\"\"\"\"\" 没效果或没用的😁\" set cursorline 光标所在的当前行用下划线高亮(没什么用)\" set relativenumber 显示光标所在的当前行的行号，其他行都为相对于该行的相对行号。(没什么用)\" set spell spelllang=en_us 打开英语单词的拼写检查(不推荐，太亮了)\" set textwidth=80 设置行宽，即一行显示多少个字符。(没效果？)\" set wrapmargin=2 指定折行处与编辑窗口的右边缘之间空出的字符数 编辑相关123456789101112131415161718192021222324252627282930313233343536373839set mouse=a \"支持使用鼠标set encoding=utf-8 \"使用 utf-8 编码。\" 缩进相关set autoindent \"按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致set expandtab \"tab转为空格,而不是\\t。set softtabstop=4 \"Tab 转为多少个空格filetype indent on \"开启文件类型检查，并且载入与该类型对应的缩进规则。比如，如果编辑的是.py文件，Vim 就是会找 Python 的缩进规则~/.vim/indent/python.vimset history=1000 \"Vim 需要记住多少次历史操作。set nocompatible \"不与 Vi 兼容（采用 Vim 自己的操作命令）。\" 文件备份、历史相关set nobackup \"不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）。set swapfile \"创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.swp。set undofile \"关闭文件后仍保留撤销历史。Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以.un~开头。set autochdir \"自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。set backupdir=~/.vim/.backup// \"要新建这个文件夹set directory=~/.vim/.swp// \"要新建这个文件夹set undodir=~/.vim/.undo// \"要新建这个文件夹\" 设置备份文件、交换文件、操作历史文件的保存位置。结尾的//表示生成的文件名带有绝对路径，路径中用%替换目录分隔符，这样可以防止文件重名。set autoread \"打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示。\" 末行命令自动补全set wildmenu \"(跟下面组合使用？没看出效果)set wildmode=longest:list,full \"命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。\"\"\"\"\"\"\" 暂时不知道有什么用的set shiftwidth=4 \"在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者==（取消全部缩进）时，每一级的字符数\"实际行与屏幕行相关的按键映射nnoremap k gknnoremap gk knnoremap j gjnnoremap gj jnnoremap &lt;Space&gt; &lt;C-f&gt; \"Vim 空格翻页map &lt;F12&gt; :set mouse=&lt;CR&gt; \"F12按键设置为关闭鼠标选择功能 搜索相关12345set incsearch set is \"输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果set ignorecase set ic \"搜索时忽略大小写set smartcase \"如果同时打开了ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索Test时，将不匹配test；搜索test时，将匹配Test 自动生成相关12345678910111213141516171819\"创建py自动添加头部 jizxfunc SetTitle()call setline(1, \"\\#!/usr/bin/python\")call setline(2, \"\\# -*- coding=utf8 -*-\")call setline(3, \"\\\"\\\"\\\"\")call setline(4, \"\\# @Author : jizhongxian@baidu.com\")call setline(5, \"\\# @Created Time : \".strftime(\"%Y-%m-%d %H:%M:%S\"))call setline(6, \"\\# @Description : \")call setline(7, \"\\\"\\\"\\\"\")normal Gnormal 10o call setline(10, \"def main():\")call setline(11, \" pass\")call setline(13, \"def test():\")call setline(14, \" pass\")call setline(16, \"if __name__ == '__main__':\")call setline(17, \" main()\")endfuncautocmd bufnewfile *.py call SetTitle() tab相关缩进&lt;与&gt;要想让 &lt; 和 &gt; 命令正常工作， 需要把 ‘shiftwidth’ 及‘softtabstop’ 的值设为4， 并启用 ‘expandtab’ 选项。 如果想了解这些配置是如何协同工作的， 请查阅Vimcasts.org上的“Tabs and Spaces”主题。 tab and spacehttp://vimcasts.org/episodes/tabs-and-spaces/ 1tabstop, softtabstop, shiftwidth, expandtab 如果你喜欢使用 tab，那应该确保 tabstop == softtabstop. 减少缩进时混淆 tabs 和spaces。 如果你喜欢使用 space, 那应该确保 softtabstop == shiftwidth. 这样在不论在插入模式中 按下tab键，还是在普通/可视模式中使用缩进命令&gt;，都可以保证插入相同数量的空格。 12345678910111213141516171819202122232425262728&quot; put all this in your .vimrc or a plugin file&quot; Set tabstop, softtabstop and shiftwidth to the same valuecommand! -nargs=* Stab call Stab()function! Stab() let l:tabstop = 1 * input(&apos;set tabstop = softtabstop = shiftwidth = &apos;) if l:tabstop &gt; 0 let &amp;l:sts = l:tabstop let &amp;l:ts = l:tabstop let &amp;l:sw = l:tabstop endif call SummarizeTabs()endfunctionfunction! SummarizeTabs() try echohl ModeMsg echon &apos;tabstop=&apos;.&amp;l:ts echon &apos; shiftwidth=&apos;.&amp;l:sw echon &apos; softtabstop=&apos;.&amp;l:sts if &amp;l:et echon &apos; expandtab&apos; else echon &apos; noexpandtab&apos; endif finally echohl None endtryendfunction https://stackoverflow.com/questions/1562336/tab-vs-space-preferences-in-vim/1610732#1610732 关于粘贴缩进问题结论：使用:set paste 在Vim中粘贴Python代码后，缩进就全乱了。仔细研究了以下，原来是自动缩进的缘故，于是做如下设置： 1:set noai nosi 取消了自动缩进和智能缩进，这样粘贴就不会错行了。但在有的vim中不行，还是排版错乱。 后来发现了更好用的设置： 1:set paste 进入paste模式以后，可以在插入模式下粘贴内容，不会有任何变形。这个真是灰常好用，情不自禁看了一下帮助，发现它做了这么多事： 123456789101112131415textwidth设置为0wrapmargin设置为0set noaiset nosisofttabstop设置为0revins重置ruler重置showmatch重置formatoptions使用空值下面的选项值不变，但却被禁用：lispindentexprcindent 怪不得之前只设置noai和nosi不行，原来与这么多因素有关！ 快捷键设置但这样还是比较麻烦的，每次要粘贴的话，先set paste，然后粘贴，然后再set nopaste。更方便的方法是使用键盘映射： 12:map &lt;F10&gt; :set paste&lt;CR&gt; :map &lt;F11&gt; :set nopaste&lt;CR&gt; 这样在粘贴前按F10键启动paste模式，粘贴后按F11取消paste模式即可。其实，paste有一个切换paste开关的选项，这就是pastetoggle。通过它可以绑定快捷键来激活/取消 paste模式。比如（暂时没试成功） 1:set pastetoggle=&lt;F11&gt; 这样减少了一个快捷键的占用，使用起来也更方便一些。 以上这些设置只是打开这次回话才有效，想要永久有效，需要在~/.vimrc中添加上面的命令 12&quot; 不需要冒号set pastetoggle=&lt;F11&gt; 自动补全&lt;C-p&gt; 在插入模式下触发自动补全，并向上选择候选项（prev） &lt;C-n&gt;在插入模式下触发自动补全，并向下选择候选项（next） 补全类型 命令 补全类型 &lt;C-n&gt; 普通关键字 &lt;C-p&gt; 普通关键字 &lt;C-x&gt;&lt;C-n&gt; 当前缓冲区关键字 &lt;C-x&gt;&lt;C-i&gt; 包含文件关键字 &lt;C-x&gt;&lt;C-]&gt; 标签文件关键字 &lt;C-x&gt;&lt;C-k&gt; 字典查找 &lt;C-x&gt;&lt;C-l&gt; 整行补全 &lt;C-x&gt;&lt;C-f&gt; 文件名补全 &lt;C-x&gt;&lt;C-o&gt; 全能（Omni） 补全 不论使用哪种自动补全命令，当其弹出式菜单出现时，都可以用 与 选择菜单中的上一项或者下一项。 ignorecase选项被启用后，在自动补全时也会忽略大小写，在自动补全时也会忽略大小写，可以通过set infercase选项来修正这一行为。 弹出框操作 按键操作 作用 &lt;C-n&gt; 使用来自补全列表的下一个匹配项（next 匹配项） &lt;C-p&gt; 使用来自补全列表的上一个匹配项（previous 匹配项） &lt;Down&gt; 选择来自补全列表的下一个匹配项，但不改变文本 &lt;Up&gt; 选择来自补全列表的上一个匹配项，但不改变文本 &lt;C-y&gt;或&lt;CR&gt; 确认使用当前选中的匹配项（yes） &lt;C-e&gt; 还原最早输入的文本（从自动补全中exit） &lt;C-h&gt; （与 &lt;BS&gt;） 从当前匹配项中删除一个字符 &lt;C-l&gt; 从当前匹配项中增加一个字符 {char} 中止自动补全并插入字符 {char} 实时更新补全列表在与自动补全弹出式菜单的交互过程中，输入 &lt;C-n&gt;&lt;C-p&gt;是我最喜欢的技巧之一：在不关闭弹出式菜单的情况下，可以继续输入文本，而Vim将实时过滤补全列表。 该技巧对于其他自动补全功能也同样有效。例如，可以通过 &lt;C-x&gt; &lt;C-o&gt;&lt;C-p&gt; 对全能补全的结果进行实时性过滤。 定制普通关键字自动补全普通关键字自动补全，会把来自于缓冲区列表、包含文件以及标签文件的单词列表组合在一起，并生成补全建议。如果想改变该功能的行为，可以通过complete选项来定制普通关键字补全时扫描的位置。该选项包含一组由逗号分隔的单个字符，当某个参数出现时，就意味着需要扫描该参数代表的位置。该选项的缺省设置为complete=.,w,b,u,t,i。可以使用以下命令禁止扫描所有的包含文件。 1:set complete-=i 或者，可以通过以下命令来激活拼写字典自动补全功能。 1:set complete+=k 请查阅 :h ‘complete’ ，以便了解各个参数的作用。 启用字典有时候，我们可能想通过自动补全功能输入某个单词，但它并没有在任何打开的缓冲区、包含文件或者标签文件中出现过。在这种情况下，可以在字典中查找。 为了激活该功能，需要为Vim提供一份合适的单词列表。最简单的方法就是通过运行 :set spell 也可以通过dictionary’选项来指定一个或多个含有单词列表的文件（参见 :h ‘dictionary’） 补全一整行当使用自动补全功能补全单词时，Vim会记住该单词的来源位置。如果紧接着再次调用自动补全功能，Vim就会插入位于其后的单词。可以一次次重复此动作以插入整个单词序列。用这种方式复制短句通常比复制粘贴更快。 Vim的自动补全不仅仅可以插入单词序列，也可以用于插入一系列行。如果重复使用 &lt;C-x&gt;&lt;C-l&gt; 命令（技巧116），就可以插入文档其他位置上的若干个连续的行。 补全文件名Vim的文件名自动补全功能只相对于工作目录的路径进行扩展，而不是相对于当前编辑文件的路径，理解这一点很重要。 通过 :pwd命令（print working directory）获取到工作目录的路径信息 通过 :cd {path} 命令（change directory）随时切换工作目录 根据上下文自动补全技巧 119 输入 ba，由于“ba”作为CSS属性 的一部分，因此显示的列表内容将包括 background、background-attachment以及其他的几种属性。在此例中，选择的是 backgroundcolor。而当第二次触发全能补全时，尽管没有输入任何文本，但Vim会根据上下文判断出我们需要的是颜色信息，因此，它提供了3项补全建议：#、rgb( 以及 transparent。 拼写检查拼写检查快捷键12345678:set spell ”启用拼写检查:set spelllang=en_us “设置拼写字典，默认是英文[s &quot;反向跳转]s &quot;正向跳转z= &quot;更正建议列表zg &quot;把当前单词添加到拼写文件中,即可避免以后对该单词的错误检查，使Vim可以识别它zw &quot;把当前单词从拼写文件中删除zug &quot;撤销针对当前单词的zg或zw命令 使用其他拼写字典内置了支持英语的拼写文件，可以 到http://ftp.vim.org/vim/runtime/spell/ 下载它支持的其他几 十种语言的拼写文件 定制专有名词字典很多单词，如grep。我既不想让Vim将它们标记为拼写错误，也不想让Vim视其为合法的英语单词。作为折中方案，单独维护一个单词列表，专门用于保存Vim的术语。这样一来，在撰写 Vim相关的文章时，可以随时把它作为拼写文件加载进来。 123setlocal spelllang=en_us setlocal spellfile=~/.vim/spell/en.utf-8.add setlocal spellfile+=~/books/practical_vim/jargon.utf-8.add ‘spellfile’ 选项，可以指定一个文件路径，用于保存 由 zg 和 zw 命令添加、删除的单词 ~/.vim/spell/en.utf-8.add是缺省路径，它保存所有由 zg 命 令添加的单词 ~/books/practical_vim/jargon.utf-8.add 保存由我维护的Vim术语列表 现在对于每一个被拼写检查器误判的单词，目前都有两种处理方式，既可以通过 2zg将其添加到Vim的术语列表中，也可以通过 1zg 将其添加到缺省的单词列表中。 插入模式下使用自动补全只有某行文本出现的拼写错误不止一处时，&lt;C-x&gt;s 命令才能充分发挥出其优势，然后使用&lt;C-p&gt; &lt;C-n&gt;进行上下选择 根据创建的文件类型产生模板在~/.vimrc中添加一下内容，即可在创建*.py时，自动添加头部信息 12345678910111213func SetPyTitle() call setline(1, \"\\#!/usr/bin/python\") call setline(2, \"\\# -*- coding=utf8 -*-\") call setline(3, \"\\\"\\\"\\\"\") call setline(4, \"\\# @Author :\") call setline(5, \"\\# @Created Time : \".strftime(\"%Y-%m-%d %H:%M:%S\")) call setline(6, \"\\# @Description : \") call setline(7, \"\\\"\\\"\\\"\") normal G q'''''' normal o normal oendfuncautocmd bufnewfile *.py call SetPyTitle() 创建*.sh时，自动添加头部信息 12345678910111213func SetShTitle() call setline(1, \"\\#!/usr/bin/sh\") call setline(2, \"\\source ~/.bashrc\") call setline(3, \"\") call setline(4, \"\\# @Author : \") call setline(5, \"\\# @Created Time : \".strftime(\"%Y-%m-%d %H:%M:%S\")) call setline(6, \"\\# @Description : \") call setline(7, \"\") normal G q'''''' normal o normal oendfuncautocmd bufnewfile *.sh call SetShTitle() 插件推荐surround.vim 用它可以很容易地给选中的文本加分隔符 matchit.vim 可以在配对的关键字间跳转 其他自定义操作符:h :map-operator 自定义动作命令 :h omapinfo 别将反向字符查找命令弃之不用技巧 50 Vim 几乎为键盘上的每个键都赋予了一个功能。 如果想创建自定义映射项， 那么该把它们绑定到哪个键上呢？ Vim 提供了一个 &lt;Leader&gt; ， 以此作为用户自定义命令的名字空间。 下面的例子显示了如何利用 &lt;Leader&gt; 来创建自定义映射项。 12noremap &lt;Leader&gt;n nzznoremap &lt;Leader&gt;N Nzz 缺省的&lt;Leader&gt;键是\\，因此可以按\\n和\\N来触发刷新屏幕的功能。 在有些键盘上， \\ 命令不太容易够到， 因此 Vim 允许把&lt;Leader&gt;键映射为其他更方便的字符（参见 :h mapleader） 。 一个普遍的选择是把逗号设置为 &lt;Leader&gt; 键。 如果你也是这么做的， 我强烈建议把反向字符查找命令映射为另一个键。 下面给出了一个例子。 12let mapleader=&quot;,&quot;noremap \\ , ; 和, 命令是互为补充的， 如果去掉了其中一个，整个字符查找命令集的用处就会大打折扣了。 交互式教程https://www.openvim.com/ https://vim-adventures.com TODO技巧31没看懂 第7，9,16,17章还没看 技巧70 gn 的作用 c%(“) 的话，请参考技巧55以及技巧15。 技巧92 技巧 73 的总结 技巧21 gv命令会激活可视模式，并重新将上次被选中的文本高亮起 来 技巧96 交换两个或更多的单词 技巧97 在多个文件中执行查找与替换 虚拟替换模式替换制表符 POSIX风格的正则表达式，Perl风格的正则表达式来了解一下","categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"},{"name":"vim","slug":"linux/vim","permalink":"https://jizx.vip/categories/linux/vim/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"},{"name":"vim","slug":"vim","permalink":"https://jizx.vip/tags/vim/"}],"author":{"nick":"jizx"}}],"categories":[{"name":"linux","slug":"linux","permalink":"https://jizx.vip/categories/linux/"},{"name":"hadoop","slug":"hadoop","permalink":"https://jizx.vip/categories/hadoop/"},{"name":"python","slug":"python","permalink":"https://jizx.vip/categories/python/"},{"name":"深度学习","slug":"深度学习","permalink":"https://jizx.vip/categories/深度学习/"},{"name":"hive","slug":"hive","permalink":"https://jizx.vip/categories/hive/"},{"name":"vim","slug":"vim","permalink":"https://jizx.vip/categories/vim/"},{"name":"awk","slug":"linux/awk","permalink":"https://jizx.vip/categories/linux/awk/"},{"name":"工具","slug":"linux/awk/工具","permalink":"https://jizx.vip/categories/linux/awk/工具/"},{"name":"photoshop","slug":"photoshop","permalink":"https://jizx.vip/categories/photoshop/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://jizx.vip/categories/正则表达式/"},{"name":"windows","slug":"windows","permalink":"https://jizx.vip/categories/windows/"},{"name":"编辑器","slug":"编辑器","permalink":"https://jizx.vip/categories/编辑器/"},{"name":"Chrome","slug":"Chrome","permalink":"https://jizx.vip/categories/Chrome/"},{"name":"git","slug":"git","permalink":"https://jizx.vip/categories/git/"},{"name":"java","slug":"java","permalink":"https://jizx.vip/categories/java/"},{"name":"算法","slug":"算法","permalink":"https://jizx.vip/categories/算法/"},{"name":"java","slug":"算法/java","permalink":"https://jizx.vip/categories/算法/java/"},{"name":"基础","slug":"java/基础","permalink":"https://jizx.vip/categories/java/基础/"},{"name":"英语","slug":"英语","permalink":"https://jizx.vip/categories/英语/"},{"name":"语法","slug":"英语/语法","permalink":"https://jizx.vip/categories/英语/语法/"},{"name":"vim","slug":"linux/vim","permalink":"https://jizx.vip/categories/linux/vim/"}],"tags":[{"name":"scp","slug":"scp","permalink":"https://jizx.vip/tags/scp/"},{"name":"hadoop streaming","slug":"hadoop-streaming","permalink":"https://jizx.vip/tags/hadoop-streaming/"},{"name":"python","slug":"python","permalink":"https://jizx.vip/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://jizx.vip/tags/pandas/"},{"name":"python进阶","slug":"python进阶","permalink":"https://jizx.vip/tags/python进阶/"},{"name":"python高级","slug":"python高级","permalink":"https://jizx.vip/tags/python高级/"},{"name":"流畅的python","slug":"流畅的python","permalink":"https://jizx.vip/tags/流畅的python/"},{"name":"协议","slug":"协议","permalink":"https://jizx.vip/tags/协议/"},{"name":"深度学习","slug":"深度学习","permalink":"https://jizx.vip/tags/深度学习/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://jizx.vip/tags/tensorflow/"},{"name":"numpy","slug":"numpy","permalink":"https://jizx.vip/tags/numpy/"},{"name":"多线程","slug":"多线程","permalink":"https://jizx.vip/tags/多线程/"},{"name":"多进程","slug":"多进程","permalink":"https://jizx.vip/tags/多进程/"},{"name":"ing","slug":"ing","permalink":"https://jizx.vip/tags/ing/"},{"name":"time","slug":"time","permalink":"https://jizx.vip/tags/time/"},{"name":"机器学习","slug":"机器学习","permalink":"https://jizx.vip/tags/机器学习/"},{"name":"shell","slug":"shell","permalink":"https://jizx.vip/tags/shell/"},{"name":"效率","slug":"效率","permalink":"https://jizx.vip/tags/效率/"},{"name":"linux","slug":"linux","permalink":"https://jizx.vip/tags/linux/"},{"name":"环境","slug":"环境","permalink":"https://jizx.vip/tags/环境/"},{"name":"window","slug":"window","permalink":"https://jizx.vip/tags/window/"},{"name":"hive","slug":"hive","permalink":"https://jizx.vip/tags/hive/"},{"name":"vim","slug":"vim","permalink":"https://jizx.vip/tags/vim/"},{"name":"工具","slug":"工具","permalink":"https://jizx.vip/tags/工具/"},{"name":"awk","slug":"awk","permalink":"https://jizx.vip/tags/awk/"},{"name":"模块","slug":"模块","permalink":"https://jizx.vip/tags/模块/"},{"name":"logging","slug":"logging","permalink":"https://jizx.vip/tags/logging/"},{"name":"anaconda","slug":"anaconda","permalink":"https://jizx.vip/tags/anaconda/"},{"name":"jupyter","slug":"jupyter","permalink":"https://jizx.vip/tags/jupyter/"},{"name":"右键","slug":"右键","permalink":"https://jizx.vip/tags/右键/"},{"name":"命令","slug":"命令","permalink":"https://jizx.vip/tags/命令/"},{"name":"photoshop","slug":"photoshop","permalink":"https://jizx.vip/tags/photoshop/"},{"name":"曲线","slug":"曲线","permalink":"https://jizx.vip/tags/曲线/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://jizx.vip/tags/正则表达式/"},{"name":"系统优化","slug":"系统优化","permalink":"https://jizx.vip/tags/系统优化/"},{"name":"atom","slug":"atom","permalink":"https://jizx.vip/tags/atom/"},{"name":"vscode","slug":"vscode","permalink":"https://jizx.vip/tags/vscode/"},{"name":"编辑器","slug":"编辑器","permalink":"https://jizx.vip/tags/编辑器/"},{"name":"notepad++","slug":"notepad","permalink":"https://jizx.vip/tags/notepad/"},{"name":"截图","slug":"截图","permalink":"https://jizx.vip/tags/截图/"},{"name":"git","slug":"git","permalink":"https://jizx.vip/tags/git/"},{"name":"编码问题","slug":"编码问题","permalink":"https://jizx.vip/tags/编码问题/"},{"name":"打印","slug":"打印","permalink":"https://jizx.vip/tags/打印/"},{"name":"乱码","slug":"乱码","permalink":"https://jizx.vip/tags/乱码/"},{"name":"java","slug":"java","permalink":"https://jizx.vip/tags/java/"},{"name":"传参","slug":"传参","permalink":"https://jizx.vip/tags/传参/"},{"name":"方法调用","slug":"方法调用","permalink":"https://jizx.vip/tags/方法调用/"},{"name":"算法","slug":"算法","permalink":"https://jizx.vip/tags/算法/"},{"name":"面试","slug":"面试","permalink":"https://jizx.vip/tags/面试/"},{"name":"类","slug":"类","permalink":"https://jizx.vip/tags/类/"},{"name":"时态","slug":"时态","permalink":"https://jizx.vip/tags/时态/"},{"name":"从句","slug":"从句","permalink":"https://jizx.vip/tags/从句/"},{"name":"复合句","slug":"复合句","permalink":"https://jizx.vip/tags/复合句/"}]}