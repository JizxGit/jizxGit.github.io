<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>python进阶</title>
      <link href="/2020/03/02/python%E8%BF%9B%E9%98%B6/"/>
      <url>/2020/03/02/python%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>python进阶内容，帮助理解让你摸不着头脑的一些问题</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="python之外"><a href="#python之外" class="headerlink" title="python之外"></a>python之外</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><strong>KISS 原则</strong>：“Keep It Simple, Stupid”的首字母缩写。这个原则要求尽量寻找最简单的方案，尽量减少可变部分。这个警句是 Kelly Johnson 首创的。</li><li><strong>统一访问原则</strong>：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。</li></ul><h3 id="objects-types-classes-instances的区别"><a href="#objects-types-classes-instances的区别" class="headerlink" title="objects, types, classes, instances的区别"></a>objects, types, classes, instances的区别</h3><h4 id="object-对象"><a href="#object-对象" class="headerlink" title="object 对象"></a>object 对象</h4><p>对象 (object) 是 python 对数据的抽象总称。在 python 编程中，所有的数据都是以 对象 或者 对象 之间的关系表示的，每个对象都有对应的 ID、类型(type)和值(value)。</p><blockquote><p>[data model 原文] Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer,” code is also represented by objects.)</p><p>Every object has an identity, a type and a value.</p></blockquote><p>python 中一切都是对象，list、42、函数、模块都是 object</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">type(foo), id(foo)</span><br><span class="line"><span class="comment"># (&lt;class 'function'&gt;, 38110760)</span></span><br><span class="line"></span><br><span class="line">type(foo.__code__), id(foo.__code__)</span><br><span class="line"><span class="comment"># (&lt;class 'code'&gt;, 38111680)</span></span><br></pre></td></tr></table></figure><h4 id="type-类型"><a href="#type-类型" class="headerlink" title="type 类型"></a>type 类型</h4><p>一个对象的类型决定了该对象所能支持的操作(比如，能不能计算长度)，也定义了 该类型的对象 的 值。</p><blockquote><p>An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type.</p></blockquote><p>因此每个对象都属于某个类型 (type)，通过<code>type</code>内置函数可以确定对象的类型。类型 type 也是一个对象，因此它也有对应的类型，而这个类型是 <code>type</code> (The type is an object too, so it has a type of its own, which is called <code>type</code>.)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line"></span><br><span class="line">type(type(<span class="number">42</span>))</span><br><span class="line"><span class="comment"># &lt;class 'type'&gt;</span></span><br><span class="line"></span><br><span class="line">type(type(type(<span class="number">42</span>)))</span><br><span class="line"><span class="comment"># &lt;class 'type'&gt;</span></span><br></pre></td></tr></table></figure><p>是的，就这样无限循环下去了 ，Yep, it’s turtles all the way down.</p><h4 id="Classes-类"><a href="#Classes-类" class="headerlink" title="Classes 类"></a>Classes 类</h4><p><em>A class defines the blueprint, which can be instantiated to create</em> Object(s)</p><p>class 是一种机制，让我们通过 python 代码 创建新的用户自定义的类型 (type)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Joe</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">j = Joe()</span><br><span class="line">type(j)</span><br><span class="line"><span class="comment"># &lt;class '__main__.Joe'&gt;</span></span><br></pre></td></tr></table></figure><p>使用 class 机制，我们创建了 <code>Joe</code>——用户定义的新类型，<code>j</code>是类<code>Joe</code>的一个实例，换句话说：<code>j</code>是一个对象，它的类型是<code>Joe</code></p><p>Class 和 type 是指代相同概念的两个名称的示例。为了避免产生误解，当表示类型时，我尽量说”type” ，当指的是通过 class 新创建的类型时，我尽量说 “user-defined class” (or “user-defined type”) </p><blockquote><p>I will always try to say “type” when I mean a type, and “user-defined class” (or “user-defined type”) when referring to a new type created using the <code>class</code> construct.</p></blockquote><h4 id="Instances-实例"><a href="#Instances-实例" class="headerlink" title="Instances 实例"></a>Instances 实例</h4><p>不像 class 和 type，instance 和 object 是同义词，可以这样理解：<strong>对象(object)是某种类型(type)的实例 (instance)</strong>，因此 “42 is an instance of the type <code>int</code>“ 等价于 “42 is an <code>int</code> object”.</p><h3 id="python-版本"><a href="#python-版本" class="headerlink" title="python 版本"></a>python 版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform </span><br><span class="line">print(platform.python_version())</span><br><span class="line"><span class="comment"># 2.7.15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line">print(sys.version)</span><br><span class="line"><span class="comment"># 2.7.15 |Anaconda, Inc.| (default, Oct 23 2018, 13:35:16) </span></span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> Compatible Clang <span class="number">4.0</span><span class="number">.1</span> (tags/RELEASE_401/final)]</span><br><span class="line"></span><br><span class="line">print(sys.version_info)</span><br><span class="line"><span class="comment"># sys.version_info(major=2, minor=7, micro=15, releaselevel='final', serial=0)</span></span><br></pre></td></tr></table></figure><h3 id="python-反编译"><a href="#python-反编译" class="headerlink" title="python 反编译"></a>python 反编译</h3><p><a href="http://docs.python.org/3/library/dis.html）对其做了说明" target="_blank" rel="noopener">dis</a>模块为反汇编 Python 函数字节码提供了简单的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dis <span class="keyword">import</span> dis</span><br><span class="line">b = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> b</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    b=<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis(f)</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="keyword">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>           <span class="number">8</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="keyword">print</span>)</span><br><span class="line">             <span class="number">10</span> LOAD_GLOBAL              <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">12</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">14</span> POP_TOP</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">16</span> LOAD_CONST               <span class="number">1</span> (<span class="number">9</span>)</span><br><span class="line">             <span class="number">18</span> STORE_GLOBAL             <span class="number">1</span> (b)</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">0</span> (<span class="keyword">None</span>)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><h4 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h4><ul><li><p><strong>容器序列</strong>存放的是它们所包含的任意类型的对象的引用。</p></li><li><p><strong>扁平序列</strong>里存放的是<strong>元素的值本身</strong>，而不是其他对象的引用。换句话说，扁平序列其实是一段连续的内存空间。由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。</p></li></ul><h4 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h4><p>通常的原则是，<strong>只用列表推导来创建新的列表，并且尽量保持简短</strong>。 如果列表推导的代码超过了两行，你可能就要考虑是不是得用 for 循环重写了。</p><p>Python 2.x 中，在列表推导中 for 关键词之后的赋值操作可能会影响列表推导上下文 中的同名变量。像下面这个 Python 2.7 控制台对话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">'my precious'</span></span><br><span class="line">dummy = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'ABC]</span></span><br><span class="line"><span class="string">print(x)</span></span><br><span class="line"><span class="string"># '</span>C<span class="string">'</span></span><br></pre></td></tr></table></figure><p>x 原本的值被取代了，但是这种情况在 Python 3 中是不会出现的。</p><p>列表推导、生成器表达式，以及同它们很相似的集合（set）推导和字典（dict）推导，<strong>推导式在Python3中都有了自己的局部作用域</strong>，就像函数似的。<strong>表达式内部的变量和赋值只在局部起作用</strong>，表达式的上下文里的同名变量还可以被正常引用。</p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器表达式的语法跟列表推导差不多，只不过把<strong>方括号换成圆括号</strong>而已。</p><p>如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbols = <span class="string">'$¢£¥€¤'</span></span><br><span class="line">t = tuple( ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols )</span><br><span class="line"><span class="comment"># (36, 162, 163, 165, 8364, 164)</span></span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组的不可变性 其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 4302515784</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">-1</span>].append(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 </span><br><span class="line"><span class="comment"># (1, 2, [30, 40, 99])</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>]) </span><br><span class="line"><span class="comment"># 4302515784</span></span><br></pre></td></tr></table></figure><h5 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h5><p>在进行拆包的时候，我们不总是对元组里所有的数据都感兴趣，<code>_</code>占位符能作为占位符。</p><p><strong>如果做的是国际化软件，那么<code>_</code>可能就不是一个理想的占位符</strong>，因为它也是 gettext.gettext 函数的常用别名，gettext 模块的文档 （<a href="https://docs.python.org/3/library/gettext.html）里提到了这一点。在其他情况下，`_`" target="_blank" rel="noopener">https://docs.python.org/3/library/gettext.html）里提到了这一点。在其他情况下，`_`</a> 会 是一个很好的占位符。</p><p>除此之外，在元组拆包中使用 <code>*</code>也可以帮助我们把注意力集中在元组的部分元素上。</p><p>用*来处理剩下的元素</p><h5 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h5><p>元组已经设计得很好用了，但作为记录来用的话，还是少了一个功能：<strong>我们时常会需要给记录中的字段命名</strong>。namedtuple函数的出现帮我们解决了这个问题。</p><ol><li><p>创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者 可以是由数个字符串组成的可迭代对象，或者是由<strong>空格分隔开的字段名组成的字符串</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">City = namedtuple(<span class="string">'City'</span>, <span class="string">'name country population coordinates'</span>)</span><br><span class="line">City = namedtuple(<span class="string">'City'</span>, [name,country,population,coordinates])</span><br></pre></td></tr></table></figure></li><li><p>_fields 类属性、类方法 _make(iterable) 和实例方法 _asdict()。</p><ul><li><code>_fields</code> 属性是一个包含这个类所有字段名称的元组。</li><li>用 <code>_make()</code>通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟 City(*delhi_data) 是一样的。</li><li><code>_asdict()</code> 把具名元组以 collections.OrderedDict 的形式返回，我们可以利用它 来把元组里的信息友好地呈现出来。</li></ul></li></ol><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p><code>a:b:c</code> 这种用法只能作为索引或者下标用在 [] 中来返回一个切片对象：slice(a, b, c)</p><h4 id="命名切片"><a href="#命名切片" class="headerlink" title="命名切片"></a>命名切片</h4><p>可以给切片对象进行命名，方便管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">invoice = <span class="string">"""</span></span><br><span class="line"><span class="string">0.....6................................40........52...55........</span></span><br><span class="line"><span class="string">1909 Pimoroni PiBrella                  $17.50 3 $52.50</span></span><br><span class="line"><span class="string">1489 6mm Tactile Switch x20             $4.95 2 $9.90</span></span><br><span class="line"><span class="string">1510 Panavise Jr. - PV-201              $28.00 1 $28.00</span></span><br><span class="line"><span class="string">1601 PiTFT Mini Kit 320x240             $34.95 1 $34.95</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">SKU = slice(<span class="number">0</span>, <span class="number">6</span>)<span class="comment"># 第1列</span></span><br><span class="line">DESCRIPTION = slice(<span class="number">6</span>, <span class="number">40</span>)<span class="comment"># 第2列</span></span><br><span class="line">UNIT_PRICE = slice(<span class="number">40</span>, <span class="number">52</span>)<span class="comment"># 第3列</span></span><br><span class="line">QUANTITY = slice(<span class="number">52</span>, <span class="number">55</span>)<span class="comment"># 第4列</span></span><br><span class="line">ITEM_TOTAL = slice(<span class="number">55</span>, <span class="keyword">None</span>)<span class="comment"># 第5列</span></span><br><span class="line"></span><br><span class="line">line_items = invoice.split(<span class="string">'\n'</span>)[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> line_items:</span><br><span class="line">    print(item[UNIT_PRICE], item[DESCRIPTION]) <span class="comment"># 打印第3列、第2列</span></span><br></pre></td></tr></table></figure><h4 id="切片赋值"><a href="#切片赋值" class="headerlink" title="切片赋值"></a>切片赋值</h4><ul><li>如果赋值的对象是一个切片，那么<strong>赋值语句的右侧必须是个可迭代对象</strong>。即便只有单独一个值，也要把它转换成可迭代的序列。</li><li>切片的长度，<strong>可以不等于</strong> 赋值的迭代对象的长度，可以认为是<strong>把一个片段剪切为另一个片段</strong></li><li>但是如果是<code>[a:b:c]</code>中跨度<code>c</code>不为1的话，长度就必须相同。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">l = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># l [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]    <span class="comment"># 长度大于的情况</span></span><br><span class="line"><span class="comment"># l [0, 1, 20, 30, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line"><span class="comment"># l [0, 1, 20, 30, 5, 8, 9]</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"><span class="comment"># l [0, 1, 20, 11, 5, 22, 9]</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>]</span><br><span class="line"><span class="comment"># l [0, 1, 100, 22, 9]</span></span><br></pre></td></tr></table></figure><h4 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h4><p><code>+</code>：将a、b两个 list 中的元素复制到一个新的 list c 中</p><p><code>*</code>：将 list <code>[a,b,c]</code>中的元素，复制多次，得到新的 list<code>[a,b,c,  a,b,c,  a,b,c]</code></p><blockquote><p>a,b,c不能是引用类型的对象，不然复制后，改变其中一个就会改变所有</p></blockquote><p>产生一个3x3的方格，</p><p><strong>正确例子</strong>，使用列表生成式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">board = [[<span class="string">'_'</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'X'</span></span><br><span class="line"><span class="comment"># board [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): </span><br><span class="line">    row=[<span class="string">'_'</span>] * <span class="number">3</span> </span><br><span class="line">    board.append(row)</span><br></pre></td></tr></table></figure><p><strong>错误例子</strong>，相当于<code>weird_board = [[&#39;_&#39;,&#39;_&#39;,&#39;_&#39;]] * 3</code>， 将内部元素 list 复制了3份，但其实是同一个引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weird_board = [[<span class="string">'_'</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">print(weird_board)</span><br><span class="line"><span class="comment"># [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span></span><br><span class="line"></span><br><span class="line">weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'O'</span></span><br><span class="line">print(weird_board)</span><br><span class="line"><span class="comment"># weird_board [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row=[<span class="string">'_'</span>] * <span class="number">3</span> </span><br><span class="line">board = [] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    board.append(row)</span><br></pre></td></tr></table></figure><h4 id="增量赋值"><a href="#增量赋值" class="headerlink" title="增量赋值+="></a>增量赋值+=</h4><p>+= 背后的特殊方法是 <code>__iadd__</code> （用于“<strong>就地加法</strong>”）。但是如果一个类没有实现这个方法的话，Python 会退一步调用 <code>__add__</code> 。</p><p>在这个表达式中，<strong>变量名会不会被关联到新的对象</strong>，完全取决于这个类型有没有实现 <strong>`iadd</strong>` 这 个方法。</p><ul><li>如果 a 实现了 <code>__iadd__</code> 方法，就会调用这个方法。同时对可变序列（例如 list、bytearray 和 array.array）来说，<strong>a 会就地改动</strong>，就像调用了 a.extend(b) 一样。</li><li>如果 a 没有实现 <code>__iadd__</code> 的话，a += b 这个表达式的效果就变得跟 a = a + b 一样了：首先计算 a + b，<strong>得到一个新的对象</strong>，然后赋值给 a。</li></ul><p><strong>一个谜题</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]    <span class="comment"># t[2].extend([50, 60]) 就能避免这个异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line">print(t)</span><br><span class="line"><span class="comment"># (1, 2, [30, 40, 50, 60])</span></span><br></pre></td></tr></table></figure><p><code>t[2].extend([50, 60])</code>就能避免这个异常</p><p>背后原理</p><p>需要理解<code>s[a] += b</code> 生成的字节码：</p><ol><li><p>将 s[a] 的值存入 TOS（Top Of Stack，栈的顶端）。 </p></li><li><p>计算 TOS += b。这一步能够完成，是因为 TOS 指向的是一个可变对象（也就是示例 2-15 里的列表）。 </p></li><li>s[a] = TOS 赋值。这一步失败，是因为 s 是不可变的元组（示例 2-15 中的元组 t）。\</li></ol><p>原因就是：第1步中将引用存在了临时变量中，最后又重新进行赋值，tuple 又不可变，因此报错</p><p>得到的经验：</p><ul><li><p><strong>不要把可变对象放在元组里面</strong>。 </p></li><li><p>增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了 操作。</p></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li><p>list.sort 方法会<strong>就地排序列表</strong>，也就是说不会把原列表复制一份。这也是这个方法的 返回值是 None 的原因</p></li><li><p>内置函数 sorted，它会<strong>新建一个列表作为返回值</strong></p></li></ul><p>参数：</p><ol><li><strong>key</strong>：传入一个只有一个参数的函数，列表中的每个元素都会作为参数传入，得到的返回值将作为排序算法依赖的对比关键字。默认是一个恒等函数——参数是自己，返回值也是自己的函数</li><li><strong>reverse</strong>： False（默认）：升序，True：降序</li></ol><h4 id="其他列表类型"><a href="#其他列表类型" class="headerlink" title="其他列表类型"></a>其他列表类型</h4><h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>与C语言的数组很像，只能存放一种类型的数组，因此比较节省空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">floats = array(<span class="string">'d'</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>**<span class="number">7</span>))) <span class="comment"># 从生成器中获取数据</span></span><br><span class="line">print(floats[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 0.07802343889111107</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''保存数据到文件中'''</span></span><br><span class="line">fp = open(<span class="string">'floats.bin'</span>, <span class="string">'wb'</span>)</span><br><span class="line">floats.tofile(fp)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="string">'''从文件中读取数据'''</span></span><br><span class="line">floats2 = array(<span class="string">'d'</span>)</span><br><span class="line">fp = open(<span class="string">'floats.bin'</span>, <span class="string">'rb'</span>)</span><br><span class="line">floats2.fromfile(fp, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line">fp.close()</span><br><span class="line">print(floats2[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 0.07802343889111107</span></span><br></pre></td></tr></table></figure><p>从 Python 3.4 开始，数组类型不再支持诸如 list.sort() 这种就地排序方法。要给 数组排序的话，得用 sorted 函数新建一个数组：<code>a = array.array(a.typecode, sorted(a))</code></p><h5 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview"></a>memoryview</h5><p>不太了解，主要与numpy 相关</p><h5 id="collections-deque"><a href="#collections-deque" class="headerlink" title="collections.deque"></a>collections.deque</h5><p>我们可以把列表list当作栈或者队列来用（比如，把 .append 和 .pop(0) 合起来用，就能模拟栈的“先进先出”的特点）。但是删除列表的第一个元素 （抑或是在第一个元素之前添加一个元素）之类的操作是很耗时的，因为这些操作<strong>会牵扯到移动列表里的所有元素</strong>。</p><h5 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h5><p>堆</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><p><code>{}</code> 包起来的就是，<code>[]</code>包起来的是列表推导式，<code>()</code>包起来的是生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DIAL_CODES = [</span><br><span class="line">    (<span class="number">86</span>, <span class="string">'China'</span>),</span><br><span class="line">    (<span class="number">91</span>, <span class="string">'India'</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="string">'United States'</span>),</span><br><span class="line">    (<span class="number">62</span>, <span class="string">'Indonesia'</span>),</span><br><span class="line">    (<span class="number">55</span>, <span class="string">'Brazil'</span>),</span><br><span class="line">    (<span class="number">92</span>, <span class="string">'Pakistan'</span>),</span><br><span class="line">    (<span class="number">880</span>, <span class="string">'Bangladesh'</span>),</span><br><span class="line">    (<span class="number">234</span>, <span class="string">'Nigeria'</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="string">'Russia'</span>),</span><br><span class="line">    (<span class="number">81</span>, <span class="string">'Japan'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">country_code = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># country_code &#123;'China': 86, 'India': 91, 'Bangladesh': 880, 'United States': 1, 'Pakistan': 92, 'Japan': 81, 'Russia': 7, 'Brazil': 55, 'Nigeria': 234, 'Indonesia': 62&#125;</span></span><br></pre></td></tr></table></figure><h4 id="映射提供默认值"><a href="#映射提供默认值" class="headerlink" title="映射提供默认值"></a>映射提供默认值</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.get(k, [default])</span><br></pre></td></tr></table></figure><p>返回键 k 对应的值，如果字典里没有键 k，则返回 None 或者 default</p><h5 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault"></a>setdefault</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.setdefault(k, [default])</span><br></pre></td></tr></table></figure><p>若字典⾥有键 k，则返回对应的值v； 若⽆则让 d[k]=default，然后返回 default</p><p>优点如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dict.setdefault(key, []).append(new_value)</span><br></pre></td></tr></table></figure><p>跟这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    my_dict[key] = [] </span><br><span class="line">my_dict[key].append(new_value)</span><br></pre></td></tr></table></figure><p>二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用 setdefault 只需要一次就可以完成整个操作。</p><h5 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h5><p>在单纯地<strong>查找取值</strong>（而不是通过查找来插入新值）的时候，该怎么处理找不到的键呢？这就需要 defaultdict 来帮忙</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(default_factory)</span><br><span class="line"><span class="comment"># default_factory 必须是一个函数，可以返回默认值</span></span><br></pre></td></tr></table></figure><ol><li>默认值由 list 提供空列表<code>[]</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = [(<span class="string">'yellow'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'yellow'</span>, <span class="number">3</span>), (<span class="string">'blue'</span>, <span class="number">4</span>), (<span class="string">'red'</span>, <span class="number">1</span>)]</span><br><span class="line">d = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d[k].append(v)</span><br><span class="line">sorted(d.items())</span><br><span class="line"><span class="comment"># [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>默认值由 int 提供 0</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'mississippi'</span></span><br><span class="line">d = defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line">    d[k] += <span class="number">1</span></span><br><span class="line">print(sorted(d.items()))</span><br><span class="line"><span class="comment"># [('i', 4), ('m', 1), ('p', 2), ('s', 4)]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>默认值由 lambda 函数提供</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constant_factory</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: value</span><br><span class="line">d = defaultdict(constant_factory(<span class="string">'&lt;missing&gt;'</span>))</span><br><span class="line">d.update(name=<span class="string">'John'</span>, action=<span class="string">'ran'</span>)</span><br><span class="line">print(<span class="string">'%(name)s %(action)s to %(object)s'</span> % d)</span><br><span class="line"><span class="comment"># 'John ran to &lt;missing&gt;'</span></span><br></pre></td></tr></table></figure><p>总结</p><ul><li><p>这种技术比起等价的操作<code>dict.setdefault()</code>来得更加简单快捷</p></li><li><p>defaultdict 里的 default_factory 只会在 <code>__getitem__</code> 里被调用，在其他的方法里完全不会发挥作用。比如，dd 是个 defaultdict，k 是个找不到的键，<code>dd[k]</code> 这个表达式会调用 default_factory 创造某个默认值，而 <code>dd.get(k)</code>则会返回 None。</p></li></ul><h5 id="特殊方法-miss"><a href="#特殊方法-miss" class="headerlink" title="特殊方法__miss__"></a>特殊方法<code>__miss__</code></h5><p>基类 dict 并没有定义这个方法，但是 dict 是知道有这么个东西存在的。也就是说，如果有一个类继承了 dict，然后这个<strong>继承类提供了 <code>__missing__</code> 方法，那么在 <code>__getitem</code>__ 碰到找不到的键的时候，Python 就会自动调用它</strong>，而不是抛出一个 KeyError 异常。</p><blockquote><p>注意：<code>__missing__</code> 方法只会被 <code>__getitem__</code> 调用</p></blockquote><p>例子：数字<code>1</code>与字符串数字<code>&#39;1&#39;</code>映射到同一个值<code>v</code>上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict0</span><span class="params">(dict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, str):  <span class="comment"># 如果键本身就是字符串，那就抛出 KeyError 异常。</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[str(key)]    <span class="comment"># 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]    <span class="comment"># get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会。</span></span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()</span><br></pre></td></tr></table></figure><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>由<code>dict.keys()</code>、<code>dict.values()</code>、<code>dict.items()</code>返回得到的对象，都是视图对象，视图提供了字典条目的动态视图，意味着当字典被改动时，视图也跟着变化，反映出字典的变化</p><p>Keys views are set-like since their entries are unique and hashable. If all values are hashable, so that <code>(key, value)</code> pairs are unique and hashable, then the items view is also set-like. (Values views are not treated as set-like since the entries are generally not unique.) For set-like views, all of the operations defined for the abstract base class <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>collections.abc.Set</code></a> are available (for example, <code>==</code>, <code>&lt;</code>, or <code>^</code>).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dishes = &#123;<span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'sausage'</span>: <span class="number">1</span>, <span class="string">'bacon'</span>: <span class="number">1</span>, <span class="string">'spam'</span>: <span class="number">500</span>&#125;</span><br><span class="line">keys = dishes.keys()</span><br><span class="line">values = dishes.values()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> values:</span><br><span class="line">    n += val</span><br><span class="line">print(n)</span><br><span class="line"><span class="comment"># 504</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># keys、values 以一样的顺序进行迭代输出(insertion order)</span></span><br><span class="line">list(keys)</span><br><span class="line"><span class="comment"># ['eggs', 'sausage', 'bacon', 'spam']</span></span><br><span class="line">list(values)</span><br><span class="line"><span class="comment"># [2, 1, 1, 500]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># view 对象能够动态反映 dict 的改变</span></span><br><span class="line"><span class="keyword">del</span> dishes[<span class="string">'eggs'</span>]</span><br><span class="line"><span class="keyword">del</span> dishes[<span class="string">'sausage'</span>]</span><br><span class="line">list(keys)</span><br><span class="line"><span class="comment"># ['bacon', 'spam']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合操作</span></span><br><span class="line">print(keys &amp; &#123;<span class="string">'eggs'</span>, <span class="string">'bacon'</span>, <span class="string">'salad'</span>&#125;)</span><br><span class="line"><span class="comment"># &#123;'bacon'&#125;</span></span><br><span class="line"><span class="keyword">print</span> (keys ^ &#123;<span class="string">'sausage'</span>, <span class="string">'juice'</span>&#125;)</span><br><span class="line"><span class="comment"># &#123;'juice', 'sausage', 'bacon', 'spam'&#125;</span></span><br></pre></td></tr></table></figure><h4 id="集"><a href="#集" class="headerlink" title="集"></a>集</h4><ul><li><p>集合中的元素<strong>必须是可散列的</strong>，set 类型本身是不可散列的，但是 frozenset 可以。</p></li><li><p>如果是空集，那么必须写成 set() 的形式。如果只是写成 {} 的形式，跟以前一样，你创建的其实是个空字典。</p></li></ul><h3 id="文本和字节序列"><a href="#文本和字节序列" class="headerlink" title="文本和字节序列"></a>文本和字节序列</h3><p>从 Python 3 的 str 对象中获取的元素是 Unicode 字符，这相当于从 Python 2 的 unicode 对象中获取的元素</p><h4 id="常见字符集"><a href="#常见字符集" class="headerlink" title="常见字符集"></a>常见字符集</h4><ul><li><p><strong>latin1</strong>（即 iso8859_1）：一种重要的编码，是其他编码的基础，例如 cp1252 和 Unicode（注意，latin1 与 cp1252 的字节值是一样的，甚至连码位也相同）。</p></li><li><p><strong>cp1252</strong> ：Microsoft 制定的 latin1 超集，添加了有用的符号，例如弯引号和€（欧元）；有些 Windows 应用把它称为“<strong>ANSI</strong>”，但它并不是 ANSI 标准。</p></li><li><p><strong>cp437</strong>：IBM PC 最初的字符集，包含框图符号。与后来出现的 latin1 不兼容。</p></li><li><p><strong>gb2312</strong> ：用于编码简体中文的陈旧标准；这是亚洲语言中使用较广泛的多字节编码之一。</p></li><li><p><strong>utf-8</strong>：目前 Web 中最常见的 8 位编码； 3 与 ASCII 兼容（纯 ASCII 文本是有效的 UTF-8 文 本）。</p></li><li><p><strong>utf-16le</strong>：UTF-16 的 16 位编码方案的一种形式；所有 UTF-16 支持通过转义序列（称为“代理 对”，surrogate pair）表示超过 U+FFFF 的码位。</p></li></ul><h4 id="二进制显示问题"><a href="#二进制显示问题" class="headerlink" title="二进制显示问题"></a>二进制显示问题</h4><p>二进制序列其实是整数序列，<strong>各个字节</strong>的值可能会使用下列三种不同的方式显示：</p><ol><li>可打印的 ASCII 范围内的字节（从空格到 ~），使用 ASCII 字符本身</li><li>制表符、换行符、回车符和 \ 对应的字节，使用转义序列 \t、\n、\r 和 \。</li><li>其他字节的值，使用十六进制转义序列（例如，\x00 是空字节）</li></ol><h4 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h4><p><strong>编码：把码位转换成字节序列的过程</strong></p><p>把文本转换成字节序列 时，如果目标编码中没有定义某个字符，那就会抛出 <code>UnicodeEncodeError</code> 异常</p><ol><li>编码时指定 <code>error=&#39;ignore&#39;</code> 处理方式悄无声息地跳过无法编码的字符；这样做通常很是不妥。 </li><li><code>error=&#39;replace&#39;</code>，把无法编码的字符替换成 <code>?</code>；数据损坏了，但是用户知道出了问题。</li><li><code>error=&#39;xmlcharrefreplace&#39;</code> 把无法编码的字符替换成 XML 实体。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">city = <span class="string">'São Paulo'</span></span><br><span class="line">city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'replace'</span>)</span><br><span class="line">city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'xmlcharrefreplace'</span>)</span><br></pre></td></tr></table></figure><p><strong>解码：把字节序列转换成码位的过程</strong></p><p>不是每一个字节都包含有效的 ASCII 字符，也不是每一个字符序列都是有效的 UTF-8 或 UTF-16。因此，把二进制序列转换成文本时，遇到无法转换的字节序列时会抛出 <code>UnicodeDecodeError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">octets = <span class="string">b'Montr\xe9al'</span></span><br><span class="line"></span><br><span class="line">octets.decode(<span class="string">'cp1252'</span>) </span><br><span class="line"><span class="comment"># 'Montréal'</span></span><br><span class="line">octets.decode(<span class="string">'iso8859_7'</span>) </span><br><span class="line"><span class="comment"># 'Montrιal'</span></span><br><span class="line">octets.decode(<span class="string">'koi8_r'</span>)</span><br><span class="line"><span class="comment"># 'MontrИal'</span></span><br><span class="line"></span><br><span class="line">octets.decode(<span class="string">'utf_8'</span>) </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; UnicodeDecodeError: </span><br><span class="line">    <span class="string">'utf-8'</span> codec can<span class="string">'t decode byte 0xe9 in position 5: invalid continuation byte</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">octets.decode('</span>utf_8<span class="string">', errors='</span>replace<span class="string">')</span></span><br><span class="line"><span class="string"># '</span>Montr�al<span class="string">'</span></span><br></pre></td></tr></table></figure><p>使用 ‘replace’ 错误处理方式，\xe9 替换成了“� ”（码位是 U+FFFD），这是官方指 定的 REPLACEMENT CHARACTER（替换字符），表示未知字符。</p><h4 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h4><p>Python 3 默认使<strong>用 UTF-8 编码源码</strong>，Python 2（从 2.5 开始）则默认使用 ASCII。</p><p>如果加载的 .py 模块中包含 UTF-8 之外的数据，而且没有声明编码，会得到类似下面的消息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">'\xe1'</span> <span class="keyword">in</span> file ola.py on line</span><br></pre></td></tr></table></figure><p>为了修正这个问题，可以在文件顶部添加一个神奇的 coding 注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: cp1252</span></span><br><span class="line">print(<span class="string">'Olá, Mundo!'</span>)</span><br></pre></td></tr></table></figure><h4 id="如何知道字节序列的编码"><a href="#如何知道字节序列的编码" class="headerlink" title="如何知道字节序列的编码"></a>如何知道字节序列的编码</h4><p>如何找出字节序列的编码？</p><p>一般情况是不能。必须有人告诉你。有些通信协议和文件格式，如 HTTP 和 XML，包含明确指明内容编码的首部。</p><p>但是如果假定字节流是人类可读的纯文本，就可以通过试探和分析找出编码。</p><blockquote><p>例如，如果 b’\x00’ 字节经常出现，那么可能是 16 位或 32 位编码，而不是 8 位编码方案，因为纯文本中不能包含空字符；如果字节序列 b’\x20\x00’ 经常出现，那么可能是 UTF-16LE 编码中的空格字符（U+0020），而不是 鲜为人知的 U+2000 EN QUAD 字符——谁知道这是什么呢！</p></blockquote><p>统一字符编码侦测包 <a href="https://pypi.python.org/pypi/chardet" target="_blank" rel="noopener">Chardet</a>就是这样工作的，它能识别所支持的 30 种编码。Chardet是一个 Python 库，可以在程序中使用，也提供了命令行工具 chardetect。</p><h4 id="BOM-byte-order-mark"><a href="#BOM-byte-order-mark" class="headerlink" title="BOM(byte-order mark)"></a>BOM(byte-order mark)</h4><p>与字节序有关的问题<strong>只对一个字（word）占多个字节的编码</strong>（如 UTF-16 和 UTF-32）有影响。</p><blockquote><p>以及像 <code>long</code>这种多字节的数据类型，也受字节序影响</p></blockquote><p>UTF-16 编码在要编码的文本前面加上特殊的不可见字符 <strong>ZERO WIDTH NO-BREAK SPACE</strong>（U+FEFF），按照设计，U+FFFE 字符是不存在的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u16 = <span class="string">'El Niño'</span>.encode(<span class="string">'utf_16'</span>)</span><br><span class="line">print(u16)</span><br><span class="line"><span class="string">b'\xff\xfeE\x00l\x00 \x00N\x00i\x00\xf1\x00o\x00'</span></span><br></pre></td></tr></table></figure><p>在小字节序系统中，这个字符编码为<code>b&#39;\xff\xfe&#39;</code>（十进制数 255, 254）。</p><p>在大字节序系统中，这个字符编码为<code>b&#39;\xfe\xff&#39;</code>（十进制数 254, 255）。</p><p>所以编解码器知道该用哪个字节序。</p><p>UTF-16 有两个变种：</p><ul><li><strong>UTF-16LE</strong>，显式指明使用小字节序；</li><li><strong>UTF-16BE</strong>，显式指明使用大 字节序。</li></ul><p>如果使用这两个变种，不会生成 BOM：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u16le = <span class="string">'El Niño'</span>.encode(<span class="string">'utf_16le'</span>)</span><br><span class="line">list(u16le) </span><br><span class="line"><span class="comment"># [69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111, 0]</span></span><br><span class="line">u16be = <span class="string">'El Niño'</span>.encode(<span class="string">'utf_16be'</span>)</span><br><span class="line">list(u16be) </span><br><span class="line"><span class="comment"># [0, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111]</span></span><br></pre></td></tr></table></figure><p><strong>Intel x86 架构用的是小字节序</strong>，因此有很多文件用的是不带 BOM 的小字节序 UTF-16 编码。</p><p>UTF-8 的一大优势是，不管设备使用哪种字节序，生成的字节序列始终一致，因此不需要 BOM</p><blockquote><p>UTF-8以字节为编码单元，根据当前字节中开头几个1，就可以知道后面还有几个字节是共同组成一个字的。</p><p>比如下面的第2行，读取第1个字节后发现有2个1开头，就可以知道后面还有1个字节，共同组成一个字</p><p>0xxxxxxx                //文字符号0~127（ASCII）<br>110xxxxx 10xxxxxx            //128～2047<br>1110xxxx 10xxxxxx 10xxxxxx        //2048～65535<br>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx    //65535～0x10ffff</p></blockquote><p>尽管如此，某些 Windows 应用（尤其是 Notepad）依然会在 UTF-8 编码的 文件中添加 BOM；</p><p>UTF-8 编码的 U+FEFF 字符是一个三字节序列：<code>b&#39;\xef\xbb\xbf&#39;</code>。因此，如果文件以这三个字节开头，有可能是带有 BOM 的 UTF-8 文件。</p><h4 id="默认编码-最好不要使用"><a href="#默认编码-最好不要使用" class="headerlink" title="默认编码(最好不要使用)"></a>默认编码(最好不要使用)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, locale</span><br><span class="line"></span><br><span class="line">expressions = <span class="string">"""</span></span><br><span class="line"><span class="string">    locale.getpreferredencoding() </span></span><br><span class="line"><span class="string">    type(my_file) </span></span><br><span class="line"><span class="string">    my_file.encoding sys.stdout.isatty() </span></span><br><span class="line"><span class="string">    sys.stdout.encoding </span></span><br><span class="line"><span class="string">    sys.stdin.isatty() </span></span><br><span class="line"><span class="string">    sys.stdin.encoding </span></span><br><span class="line"><span class="string">    sys.stderr.isatty() </span></span><br><span class="line"><span class="string">    sys.stderr.encoding </span></span><br><span class="line"><span class="string">    sys.getdefaultencoding()</span></span><br><span class="line"><span class="string">    sys.getfilesystemencoding()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">my_file = open(<span class="string">'dummy'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> expression <span class="keyword">in</span> expressions.split():</span><br><span class="line">    value = eval(expression)</span><br><span class="line">    print(expression.rjust(<span class="number">30</span>), <span class="string">'-&gt;'</span>, repr(value))</span><br></pre></td></tr></table></figure><p><code>locale.getpreferredencoding()</code> 返回的编码是最重要的：这是打开文件的默 认编码，也是重定向到文件的 <code>sys.stdout/stdin/stderr</code> 的默认编码。</p><p>因此，关于编码默认值的<strong>最佳建议是：别依赖默认值</strong>。</p><h4 id="规范化-Unicode-字符串"><a href="#规范化-Unicode-字符串" class="headerlink" title="规范化 Unicode 字符串"></a>规范化 Unicode 字符串</h4><p>Unicode 有组合字符（<strong>变音符号</strong>和<strong>附加到前一个字符上的记号</strong>，打印时作为一个整体），所以字符串比较起来很复杂。</p><p>“café”这个词可以使用两种方式构成，分别有 4 个和 5 个码位，但是结果完全一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'café'</span></span><br><span class="line">s2 = <span class="string">'cafe\u0301'</span></span><br><span class="line">print(s1, s2)</span><br><span class="line"><span class="comment"># ('café', 'café')</span></span><br><span class="line">print(len(s1), len(s2))</span><br><span class="line"><span class="comment"># (4, 5)</span></span><br><span class="line">s1 == s2 </span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>在 Unicode 标准中，’é’ 和 ‘e\u0301’ 这样的序列叫“<strong>标准等价物</strong>”（canonical equivalent），应用程序应该把它们视作相同的字符。但是，Python 看到的是不同的码位序列，因此判定二者不相等。</p><p>解决方案是使用 unicodedata.normalize 函数提供的 Unicode 规范化。这个 函数的第一个参数是这 4 个字符串中的一个：’NFC’、’NFD’、’NFKC’ 和 ‘NFKD’。</p><p><strong>NFC与NFD</strong></p><ul><li><p>NFC（Normalization Form C）使用<strong>最少的码位</strong>构成等价的字符串，</p></li><li><p>NFD 把组合字符分解成基字符和单独的组合字符。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">'café'</span> <span class="comment"># 把"e"和重音符组合在一起</span></span><br><span class="line">s2 = <span class="string">'cafe\u0301'</span> <span class="comment"># 分解成"e"和重音符</span></span><br><span class="line"></span><br><span class="line">len(s1), len(s2) </span><br><span class="line"><span class="comment"># (4, 5)</span></span><br><span class="line">len(normalize(<span class="string">'NFC'</span>, s1)), len(normalize(<span class="string">'NFC'</span>, s2)) </span><br><span class="line"><span class="comment"># (4, 4)</span></span><br><span class="line">len(normalize(<span class="string">'NFD'</span>, s1)), len(normalize(<span class="string">'NFD'</span>, s2)) </span><br><span class="line"><span class="comment"># (5, 5)</span></span><br><span class="line">normalize(<span class="string">'NFC'</span>, s1) == normalize(<span class="string">'NFC'</span>, s2) </span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">normalize(<span class="string">'NFD'</span>, s1) == normalize(<span class="string">'NFD'</span>, s2) </span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><p><strong>NFKC 与 NFKD</strong> </p><p>字母 K 表 示“compatibility”（兼容性）</p><p>虽然 Unicode 的目标是为各个字符提供“规范的”码位，但是<strong>为了兼容现有的标准，有些字符会出现多次</strong>。</p><blockquote><p>虽然希腊字母表中有“μ”这个字母（码位是 U+03BC，GREEK SMALL LETTER MU），但是 Unicode 还是加入了微符号 ‘µ’（U+00B5），以便与 latin1 相互转 换。因此，微符号是一个“兼容字符”。</p></blockquote><p>兼容字符：<u>个人理解</u>就是比较复杂的字符，出现在其他字符集中的字符，为了兼容其他字符集而出现在 unicode 中，因此称作兼容字符，这些字符可以被替换成一个或者多个字符。</p><p>在 NFKC 和 NFKD 形式中，各个兼容字符<strong>会被替换成一个或多个“兼容分解”字符</strong>，即便这样有些格式损失，但仍是“首选”表述。如下：</p><ol><li><p>二分之一 ‘½’（U+00BD）经过兼容分解后得到的是 三个字符序列 ‘1/2’；</p></li><li><p>微符号 ‘µ’（U+00B5）经过兼容分解后得到的是小写字母 ‘μ’（U+03BC）。 8</p></li></ol><h5 id="大小写折叠-TODO"><a href="#大小写折叠-TODO" class="headerlink" title="大小写折叠(TODO)"></a>大小写折叠(TODO)</h5><p>流畅的 python 一书中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Utility functions for normalized Unicode string comparison.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nfc_equal</span><span class="params">(str1, str2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">'NFC'</span>, str1) == normalize(<span class="string">'NFC'</span>, str2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold_equal</span><span class="params">(str1, str2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (normalize(<span class="string">'NFC'</span>, str1).casefold() == normalize(<span class="string">'NFC'</span>, str2).casefold())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Normal Form C, case sensitive:</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">'café'</span></span><br><span class="line">s2 = <span class="string">'cafe\u0301'</span></span><br><span class="line"></span><br><span class="line">print(s1 == s2)             <span class="comment"># False</span></span><br><span class="line">print(nfc_equal(s1, s2))    <span class="comment"># True</span></span><br><span class="line">print(nfc_equal(<span class="string">'A'</span>, <span class="string">'a'</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Normal Form C with case folding:</span></span><br><span class="line"></span><br><span class="line">s3 = <span class="string">'Straße'</span></span><br><span class="line">s4 = <span class="string">'strasse'</span></span><br><span class="line"></span><br><span class="line">print(s3 == s4)             <span class="comment"># False</span></span><br><span class="line">print(nfc_equal(s3, s4))    <span class="comment"># False</span></span><br><span class="line">print(fold_equal(s3, s4))   <span class="comment"># True</span></span><br><span class="line">print(fold_equal(s1, s2))   <span class="comment"># True</span></span><br><span class="line">print(fold_equal(<span class="string">'A'</span>, <span class="string">'a'</span>)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h5 id="去掉变音符号"><a href="#去掉变音符号" class="headerlink" title="去掉变音符号"></a>去掉变音符号</h5><p>维基百科中介绍圣保罗市<code>São Paulo</code>——&gt; <code>Sao_Paulo</code> ，这就是去除变音符号。</p><p>版本1（过滤掉所有组合记号）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unicodedata </span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks</span><span class="params">(txt)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""去掉全部变音符号"""</span> </span><br><span class="line">    <span class="comment"># 把所有字符分解成基字符和组合记号。</span></span><br><span class="line">    norm_txt = unicodedata.normalize(<span class="string">'NFD'</span>, txt)</span><br><span class="line">    <span class="comment"># 过滤掉所有组合记号</span></span><br><span class="line">    shaved = <span class="string">''</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c)) </span><br><span class="line">    <span class="comment"># 重组所有字符</span></span><br><span class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">'NFC'</span>, shaved)</span><br></pre></td></tr></table></figure><p>版本2（只去除拉丁文字的变音符号）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks_latin</span><span class="params">(txt)</span>:</span></span><br><span class="line">    <span class="string">"""把拉丁基字符中所有的变音符号删除"""</span></span><br><span class="line">    norm_txt = unicodedata.normalize(<span class="string">'NFD'</span>, txt)</span><br><span class="line">    is_latin_base = <span class="keyword">False</span></span><br><span class="line">    keepers = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt:</span><br><span class="line">        <span class="comment"># 忽略拉丁基字符上的变音符号</span></span><br><span class="line">        <span class="keyword">if</span> unicodedata.combining(c) <span class="keyword">and</span> is_latin_base:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        keepers.append(c)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果不是组合字符，那就是新的基字符，判断是否为拉丁字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c):</span><br><span class="line">            is_latin_base = c <span class="keyword">in</span> string.ascii_letters</span><br><span class="line"></span><br><span class="line">    shaved = <span class="string">''</span>.join(keepers)</span><br><span class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">'NFC'</span>, shaved)</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>对大多数应 用来说，NFC 是最好的规范化形式。不区分大小写的比较应该使用 str.casefold()</strong></p><h4 id="文本排序"><a href="#文本排序" class="headerlink" title="文本排序"></a>文本排序</h4><p>(比较复杂，而且不一定成功，只适合 Unix)</p><p>在Python中，非ASCII文本的标准排序方式是使用locale.strxfrm函数，根据locale模块的文档，这个函数会“把字符串转<strong>换成适合所在区域进行比较的形式</strong>”。</p><p>使用 locale.strxfrm 函数之前，必须先为应用设定合适的区域设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> locale</span><br><span class="line"></span><br><span class="line">locale.setlocale(locale.LC_COLLATE, <span class="string">'pt_BR.UTF-8'</span>)</span><br><span class="line">fruits = [<span class="string">'caju'</span>, <span class="string">'atemoia'</span>, <span class="string">'cajá'</span>, <span class="string">'açaí'</span>, <span class="string">'acerola'</span>]</span><br><span class="line">sorted(fruits, key=locale.strxfrm)</span><br><span class="line"><span class="comment"># ['açaí', 'acerola', 'atemoia', 'cajá', 'caju']</span></span><br></pre></td></tr></table></figure><h5 id="PyUCA-库-推荐"><a href="#PyUCA-库-推荐" class="headerlink" title="PyUCA 库(推荐)"></a>PyUCA 库(推荐)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyuca</span><br><span class="line"></span><br><span class="line">coll = pyuca.Collator()</span><br><span class="line">fruits = [<span class="string">'caju'</span>, <span class="string">'atemoia'</span>, <span class="string">'cajá'</span>, <span class="string">'açaí'</span>, <span class="string">'acerola'</span>]</span><br><span class="line">sorted_fruits = sorted(fruits, key=coll.sort_key)</span><br><span class="line">print(sorted_fruits)</span><br><span class="line"><span class="comment"># ['açaí', 'acerola', 'atemoia', 'cajá', 'caju']</span></span><br></pre></td></tr></table></figure><p>PyUCA 没有考虑区域设置。如果想定制排序方式，可以把自定义的排序表路径传给 Collator() 构造方法。PyUCA 默认使用项目自带的 allkeys.txt（<a href="https://github.com/jtauber/pyuca），这就是" target="_blank" rel="noopener">https://github.com/jtauber/pyuca），这就是</a> Unicode 6.3.0 的<a href="http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt" target="_blank" rel="noopener">“Default Unicode Collation Element Table”</a>的副本。</p><h4 id="Unicode数据库"><a href="#Unicode数据库" class="headerlink" title="Unicode数据库"></a>Unicode数据库</h4><p>Unicode标准提供了一个完整的数据库（许多格式化的文本文件），不仅包括码位与字符名称之间的映射，还有各个字符的元数据，以及字符之间的关系。例如，Unicode数据库记录了字符是否可以打印、是不是字母、是不是数字，或者是不是其他数值符号。字符串的isidentifier、isprintable、isdecimal和isnumeric等方法就是靠这些信息作判断的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">re_digit = re.compile(<span class="string">r'\d'</span>)</span><br><span class="line"></span><br><span class="line">sample = <span class="string">'1\xbc\xb2\u0969\u136b\u216b\u2466\u2480\u3285'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> sample:</span><br><span class="line">    print(<span class="string">'U+%04x'</span> % ord(char),char.center(<span class="number">6</span>),</span><br><span class="line">            <span class="string">'re_dig'</span> <span class="keyword">if</span> re_digit.match(char) <span class="keyword">else</span> <span class="string">'-'</span>,</span><br><span class="line">            <span class="string">'isdig'</span> <span class="keyword">if</span> char.isdigit() <span class="keyword">else</span> <span class="string">'-'</span>,</span><br><span class="line">            <span class="string">'isnum'</span> <span class="keyword">if</span> char.isnumeric() <span class="keyword">else</span> <span class="string">'-'</span>,</span><br><span class="line">            format(unicodedata.numeric(char), <span class="string">'5.2f'</span>),</span><br><span class="line">            unicodedata.name(char),</span><br><span class="line">            sep=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure><p>unicodedata模块更多函数的说明（<a href="https://docs.python.org/3/library/unicodedata.html" target="_blank" rel="noopener">https://docs.python.org/3/library/unicodedata.html</a></p><h4 id="支持字符串和字节序列的双模式API"><a href="#支持字符串和字节序列的双模式API" class="headerlink" title="支持字符串和字节序列的双模式API"></a>支持字符串和字节序列的双模式API</h4><h5 id="正则表达式中的双模式"><a href="#正则表达式中的双模式" class="headerlink" title="正则表达式中的双模式"></a>正则表达式中的双模式</h5><p>如果使用<strong>字节序列</strong>构建正则表达式，\d和\w等模式<u>只能匹配ASCII字符</u>；</p><p>如果是<strong>字符串</strong>模式，就能匹配ASCII之外的Unicode数字或字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">re_numbers_str = re.compile(<span class="string">r'\d+'</span>)</span><br><span class="line">re_words_str = re.compile(<span class="string">r'\w+'</span>)</span><br><span class="line">re_numbers_bytes = re.compile(r<span class="string">b'\d+'</span>)</span><br><span class="line">re_words_bytes = re.compile(r<span class="string">b'\w+'</span>)</span><br><span class="line"></span><br><span class="line">text_str = (<span class="string">"Ramanujan saw \u0be7\u0bed\u0be8\u0bef"</span> <span class="string">" as 1729 = 1³ + 12³ = 9³ + 10³."</span>)</span><br><span class="line">text_bytes = text_str.encode(<span class="string">'utf_8'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Text'</span>, repr(text_str), sep=<span class="string">'\n '</span>)</span><br><span class="line">print(<span class="string">'Numbers'</span>)</span><br><span class="line">print(<span class="string">' str :'</span>, re_numbers_str.findall(text_str))</span><br><span class="line">print(<span class="string">' bytes:'</span>, re_numbers_bytes.findall(text_bytes))</span><br><span class="line">print(<span class="string">'Words'</span>)</span><br><span class="line">print(<span class="string">' str :'</span>, re_words_str.findall(text_str))</span><br><span class="line">print(<span class="string">' bytes:'</span>, re_words_bytes.findall(text_bytes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Text</span></span><br><span class="line"><span class="comment">#  'Ramanujan saw ௧௭௨௯ as 1729 = 1³ + 12³ = 9³ + 10³.'</span></span><br><span class="line"><span class="comment"># Numbers</span></span><br><span class="line"><span class="comment">#  str : ['௧௭௨௯', '1729', '1', '12', '9', '10']</span></span><br><span class="line"><span class="comment">#  bytes: [b'1729', b'1', b'12', b'9', b'10']</span></span><br><span class="line"><span class="comment"># Words</span></span><br><span class="line"><span class="comment">#  str : ['Ramanujan', 'saw', '௧௭௨௯', 'as', '1729', '1³', '12³', '9³', '10³']</span></span><br><span class="line"><span class="comment">#  bytes: [b'Ramanujan', b'saw', b'as', b'1729', b'1', b'12', b'9', b'10']</span></span><br></pre></td></tr></table></figure><h5 id="os-中的双模式-TODO"><a href="#os-中的双模式-TODO" class="headerlink" title="os 中的双模式(TODO)"></a>os 中的双模式(TODO)</h5><p><strong>不是很明白</strong></p><p>GNU/Linux内核不理解Unicode，因此你可能发现了，对任何合理的编码方案来说，在文件名中使用字节序列都是无效的，无法解码成字符串。</p><p>os模块中的所有函数、文件名或路径名参数既能使用字符串，也能使用字节序列。如果这样的函数使用字符串参数调用，该参数会使用<code>sys.getfilesystemencoding()</code>得到的编解码器自动编码，然后操作系统会使用相同的编解码器解码。这几乎就是我们想要的行为，与Unicode三明治最佳实践一致。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>编程语言理论家把“一等对象”定义为满足下述条件的程序实体：</p><ul><li><p>在运行时创建</p></li><li><p>能赋值给变量或数据结构中的元素</p></li><li><p>能作为参数传给函数</p></li><li><p>能作为函数的返回结果</p></li></ul><p>在 Python 中，整数、字符串和字典都是一等对象——没什么特别的。</p><p>有了一等函数，就可以使用函数式风格编程。函数式编程的特点之一是使用高阶函数</p><p>Python 不支持重载方法或函数</p><h3 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h3><ul><li><p><strong>非绑定方法</strong>（unbound method）：直接通过类访问的实例方法没有绑定到特定的实例上，因此把这种方法称为“非绑定 方法”。若想成功调用非绑定方法，必须显式传入类的实例作为第一个参数。那个实例会 赋值给方法的 self 参数</p></li><li><p><strong>形参</strong>（parameter）：声明函数时指定的零个或多个“形式参数”，这些是未绑定的局部变量。调用函数时， 传入的实参（“实际参数”）会绑定给这些变量。有5种：</p><ul><li><p><strong>位置或关键字参数</strong>(<em>positional-or-keyword</em>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(foo, bar=None)</span>:</span> ...</span><br></pre></td></tr></table></figure></li><li><p><strong>任意数量的位置参数</strong>(<em>var-positional</em>)：在名字前面加<code>*</code>的参数，如下面的<code>args</code>，除了已被其他参数(<code>arg1</code>,<code>arg2</code>)接受的任何位置参数，剩下的位置参数都提供给 <code>args</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg1, arg2, *args, **kwargs)</span>:</span> ...</span><br></pre></td></tr></table></figure></li><li><p><strong>任意数量的关键字参数</strong>(<em>var-keyword</em>)：在名字前面加<code>**</code>的参数，如上例的<code>kwargs</code>，除了被其他形参接收的实参，剩下的关键字参数都提供给 <code>kwargs</code> </p></li><li><p>仅位置参数(<em>positional-only</em>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span><span class="params">(x)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>仅关键字参数</strong>(<em>keyword-only</em>)：只能以关键字形式提供的参数，在<code>*arg</code>这种任意数量的位置参数或 单单一个<code>*</code> 后面的形参，就是仅关键字参数，如下面的<code>kw_only1</code>,<code>kw_only2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg, *, kw_only1, kw_only2)</span>:</span> ...</span><br></pre></td></tr></table></figure><blockquote><p>注意：上例只接收3个参数，这个<code>*</code>不接收任何参数，这只是<strong>定义仅关键字参数的语法</strong>，调用形式：<code>func(1,kw_only1=2,kw_only2=3)</code></p></blockquote></li></ul><p>参考：<a href="https://docs.python.org/3/glossary.html#term-parameter" target="_blank" rel="noopener">parameter</a></p></li><li><p><strong>实参</strong>（argument）：调用函数(或方法)时传给函数(或方法)的表达式。按照 Python 习惯的说法，实参和形参几乎等价。有2种：</p><ul><li><p>关键字参数：<code>name=val</code>或者通过<code>**</code>解压的字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complex(real=<span class="number">3</span>, imag=<span class="number">5</span>)</span><br><span class="line">complex(**&#123;<span class="string">'real'</span>: <span class="number">3</span>, <span class="string">'imag'</span>: <span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>位置参数：出现在参数列表的前面位置 或者 通过<code>*</code>解压的可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complex(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">complex(*(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure></li></ul><p>参考：<a href="https://docs.python.org/3/glossary.html#term-argument" target="_blank" rel="noopener">argument</a></p></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p><strong>接受函数为参数</strong>，或者把<strong>函数作为结果</strong>返回的函数是高阶函数</p><p>列表推导或生成器表达式具有map和filter两个函数的功能，而且更易于阅读</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list(map(fact, range(<span class="number">6</span>))) </span><br><span class="line"><span class="comment"># [1, 1, 2, 6, 24, 120]</span></span><br><span class="line">[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]  <span class="comment"># 列表推导式代替 map</span></span><br><span class="line"><span class="comment"># [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"></span><br><span class="line">list(map(factorial, filter(<span class="keyword">lambda</span> n: n % <span class="number">2</span>, range(<span class="number">6</span>))))</span><br><span class="line"><span class="comment"># [1, 6, 120]</span></span><br><span class="line">[factorial(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>) <span class="keyword">if</span> n % <span class="number">2</span>]    <span class="comment"># if 代替 filter，列表推导式代替 map</span></span><br><span class="line"><span class="comment"># [1, 6, 120]</span></span><br></pre></td></tr></table></figure><p>reduce在 Python 2 中是内置函数，在Python3中放到functools模块里了。这个函数最常用于求和，自2003年发布的Python2.3开始，<strong>最好使用内置的sum函数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add </span><br><span class="line"></span><br><span class="line">reduce(add, range(<span class="number">100</span>)) </span><br><span class="line"><span class="comment"># 4950</span></span><br><span class="line">sum(range(<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 4950</span></span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>为了使用高阶函数，有时创建一次性的小型函数更便利。这便是匿名函数存在的原因</p><p>Python 简单的句法限制了 lambda 函数的主体只能是一个表达式，而不是一个代码块，不能赋值，也不能使用 while 和 try 等</p><p>输入是传入到参数列表argument_list的值，输出是根据表达式expression计算得到的值。</p><ul><li><code>lambda x, y: x*y</code>；函数输入是x和y，输出是它们的积<code>x*y</code></li><li><code>lambda:None</code>；函数没有输入参数，输出是None</li></ul><h3 id="函数专有属性"><a href="#函数专有属性" class="headerlink" title="函数专有属性"></a>函数专有属性</h3><p>重点说明函数专有而用户定义的一般对象没有的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">pass</span></span><br><span class="line">obj = C() </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span> <span class="keyword">pass</span> </span><br><span class="line">sorted(set(dir(func)) - set(dir(obj))) </span><br><span class="line"><span class="comment"># ['__annotations__', '__call__', '__closure__', '__code__', '__defaults__', '__get__', '__globals__', '__kwdefaults__', '__name__', '__qualname__']</span></span><br></pre></td></tr></table></figure><h3 id="从定位参数到仅限关键字参数"><a href="#从定位参数到仅限关键字参数" class="headerlink" title="从定位参数到仅限关键字参数"></a>从定位参数到仅限关键字参数</h3><p>仅限关键字参数是 Python 3 新增的特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name, *content, cls=None, **attrs)</span>:</span></span><br><span class="line">    <span class="string">"""生成一个或多个HTML标签"""</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        attrs[<span class="string">'class'</span>] = cls</span><br><span class="line">    <span class="keyword">if</span> attrs:</span><br><span class="line">        attr_str = <span class="string">''</span>.join(<span class="string">' %s="%s"'</span> % (attr, value) <span class="keyword">for</span> attr, value <span class="keyword">in</span> sorted(attrs.items()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attr_str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> content:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\n'</span>.join(<span class="string">'&lt;%s%s&gt;%s&lt;/%s&gt;'</span> % (name, attr_str, c, name) <span class="keyword">for</span> c <span class="keyword">in</span> content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s%s /&gt;'</span> % (name, attr_str)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">print(tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, id=<span class="number">33</span>))</span><br><span class="line">print(tag(content=<span class="string">'testing'</span>, name=<span class="string">"img"</span>))</span><br><span class="line">my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line">print(tag(**my_tag))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;p id="33"&gt;hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment"># '&lt;img content="testing" /&gt;'</span></span><br><span class="line"><span class="comment"># '&lt;img class="framed" src="sunset.jpg" title="Sunset Boulevard" /&gt;'</span></span><br></pre></td></tr></table></figure><p>TODO 未理解</p><p>仅限关键字参数是 Python 3 新增的特性。在示例 5-10 中，cls 参数只能通过关键字参数 指定，它一定不会捕获未命名的定位参数。定义函数时若想指定仅限关键字参数，要把它 们放到前面有 <em> 的参数后面。如果不想支持数量不定的定位参数，但是想支持仅限关键 字参数，在签名中放一个 </em>，如下所示：</p><p>注意，仅限关键字参数不一定要有默认值，可以像上例中 b 那样，强制必须传入实参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, *, b)</span>:</span> </span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, b=<span class="number">2</span>) </span><br><span class="line"><span class="comment">#(1, 2)</span></span><br></pre></td></tr></table></figure><h3 id="获取函数参数的信息-不太明白TODO"><a href="#获取函数参数的信息-不太明白TODO" class="headerlink" title="获取函数参数的信息(不太明白TODO)"></a>获取函数参数的信息(不太明白TODO)</h3><p>使用 inspect 模块</p><h3 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span><span class="params">(text:str, max_len:<span class="string">'int &gt; 0'</span>=<span class="number">80</span>)</span> -&gt; str:</span></span><br><span class="line">    <span class="string">"""在max_len前面或后面的第一个空格处截断文本 """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><p>各个参数可以在 : 之后增加注解表达式。如果参数有默认值，注解放在参 数名和 = 号之间。</p></li><li><p>如果想注解返回值，在 ) 和函数声明末尾的 : 之间添加 -&gt; 和一个表达 式。</p></li></ul><p>注解表达式可以是任何类型，注解中最常用的类型是类（如 str 或 int）和字符串 （如 ‘int &gt; 0’）</p><p>Python 对注解所做的唯一的事情是，只是存储在函数的 <code>__annotations__</code> 属性（字典）中。换句话说，<strong>注解对 Python 解释器没有任何意义。注解只是元数据，可以供 IDE、框架和装饰器等工具使用。</strong></p><h3 id="支持函数式编程的包"><a href="#支持函数式编程的包" class="headerlink" title="支持函数式编程的包"></a>支持函数式编程的包</h3><h4 id="operator模块"><a href="#operator模块" class="headerlink" title="operator模块"></a>operator模块</h4><ul><li><p>以 <code>_</code> 开头的名称，因为它们基本上是实现细节</p></li><li><p>以 <code>i</code>开头、后面是另一个运算符的那些名称（如 iadd、iand 等），对应的是增量赋值运算符（如 +=、&amp;= 等）</p></li></ul><p>一、operator 模块为多个<strong>算术运算符</strong>提供了对应的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce </span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul   <span class="comment"># mul对应乘法函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">return</span> reduce(mul, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>二、operator 模块中还有一类函数，能替代从<strong>序列中取出元素或读取对象属性</strong>的 lambda 表达式</p><p><strong>itemgetter</strong> 的常见用途：根据元组的某个字段给元组列表排序，如果把<strong>多个参数</strong>传给 itemgetter，它构建的函数会返回提取的值<strong>构成的元组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">metro_data = [</span><br><span class="line">    (<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">'Mexico City'</span>, <span class="string">'MX'</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">    (<span class="string">'New York-Newark'</span>, <span class="string">'US'</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">    (<span class="string">'Sao Paulo'</span>, <span class="string">'BR'</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>))</span><br><span class="line">]</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_data, key=itemgetter(<span class="number">1</span>)):</span><br><span class="line">    print(city)</span><br><span class="line">cc_name = itemgetter(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果把多个参数传给 itemgetter，会返回提取的值构成的元组</span></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> metro_data:</span><br><span class="line">    print(cc_name(city))</span><br></pre></td></tr></table></figure><p><strong>attrgetter</strong>与itemgetter作用类似，它创建的函数根据名称提取对象的属性。如果把多个属性名传给attrgetter，它也会返回提取的值构成的元组。</p><p>此外，如果参数名中包含 <code>.</code>（点号），attrgetter 会深入嵌套对象，获取指定的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">metro_data = [</span><br><span class="line">    (<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">'Mexico City'</span>, <span class="string">'MX'</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">    (<span class="string">'New York-Newark'</span>, <span class="string">'US'</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">    (<span class="string">'Sao Paulo'</span>, <span class="string">'BR'</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>))</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">LatLong = namedtuple(<span class="string">'LatLong'</span>, <span class="string">'lat long'</span>)</span><br><span class="line">Metropolis = namedtuple(<span class="string">'Metropolis'</span>, <span class="string">'name cc pop coord'</span>)</span><br><span class="line"></span><br><span class="line">metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long)) <span class="keyword">for</span> name, cc, pop, (lat, long) <span class="keyword">in</span> metro_data ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># .的例子</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line">name_lat = attrgetter(<span class="string">'name'</span>, <span class="string">'coord.lat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_areas, key=attrgetter(<span class="string">'coord.lat'</span>)):</span><br><span class="line">    print(name_lat(city))</span><br><span class="line"><span class="comment"># ('Sao Paulo', -23.547778)</span></span><br><span class="line"><span class="comment"># ('Mexico City', 19.433333)</span></span><br><span class="line"><span class="comment"># ('Delhi NCR', 28.613889)</span></span><br><span class="line"><span class="comment"># ('Tokyo', 35.689722)</span></span><br><span class="line"><span class="comment"># ('New York-Newark', 40.808611)</span></span><br></pre></td></tr></table></figure><h4 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h4><p>functools.partial 这个高阶函数用于部分应用一个函数。</p><p><strong>部分应用</strong>：基于一个函数创建一个新的可调用对象，把原函数的某些参数固定。</p><p>partial 的第一个参数是一个可调用对象(callable)，后面跟着任意个<strong>要绑定的定位参数和关键字参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unicodedata, functools</span><br><span class="line">nfc = functools.partial(unicodedata.normalize, <span class="string">'NFC'</span>)</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">'café'</span></span><br><span class="line">s2 = <span class="string">'cafe\u0301'</span></span><br><span class="line"></span><br><span class="line">print(  s1, s2)</span><br><span class="line"><span class="comment">#('café', 'café')</span></span><br><span class="line"></span><br><span class="line">print(s1 == s2,nfc(s1) == nfc(s2) )</span><br><span class="line"><span class="comment"># False True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># partial 函数的一些属性</span></span><br><span class="line">print(nfc)</span><br><span class="line"><span class="comment"># functools.partial(&lt;built-in function normalize&gt;, 'NFC')</span></span><br><span class="line">print(nfc.func)</span><br><span class="line"><span class="comment"># &lt;built-in function normalize&gt;</span></span><br><span class="line">print(nfc.args)</span><br><span class="line"><span class="comment"># ('NFC',)</span></span><br><span class="line">print(nfc.keywords)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>对于理解装饰器、闭包非常重要</p><h3 id="闭包-自由变量"><a href="#闭包-自由变量" class="headerlink" title="闭包(自由变量)"></a>闭包(自由变量)</h3><p>闭包 是指 <strong>延伸了作用域的函数</strong>，其中包含函数定义体中引用、但是不在函数定义体中定义 的<strong>非全局变量</strong><code>__closure__</code>。函数是不是匿名的没有关系，<strong>关键是它能访问函数定义体之外定义的非全局变量</strong>。</p><p>类对象编程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可调用对象方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Averager</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line">        self.series.append(new_value)</span><br><span class="line">        total = sum(self.series)</span><br><span class="line">        <span class="keyword">return</span> total/len(self.series)</span><br></pre></td></tr></table></figure><p>函数式编程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数式编程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure><p>这两个示例有共通之处：调用 Averager() 或 make_averager() 得到一个可调用 对象 avg，它会更新历史值，然后计算当前均值。</p><p>在 averager 函数中，series 是<strong>自由变量</strong>（free variable），指未在本地作用域中绑定的变量(包括外层函数的参数，比如 <code>make_averager(arg)</code>,<code>arg</code>也算是)</p><p><img src="/2020/03/02/python进阶/./闭包.png" alt="image-20190402210650537"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_varnames </span><br><span class="line"><span class="comment"># ('new_value', 'total')</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars </span><br><span class="line"><span class="comment"># ('series',)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__ </span><br><span class="line"><span class="comment"># (&lt;cell at 0x107a44f78: list object at 0x107a91a48&gt;,)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents </span><br><span class="line"><span class="comment"># [10, 11, 12]</span></span><br></pre></td></tr></table></figure><p>审查返回的 averager 对象，我们发现 Python 在<code>__code__</code>属性（表示编译后的函数定义 体）中保存<u>局部变量</u>和<u>自由变量</u>的名称。</p><p><strong><code>__closure__</code>是每个被返回的函数的属性，如：avg，并非是make_averager的属性</strong></p><p><code>avg.__closure__</code>中的各个元素对应于<code>avg.__code__.co_freevars</code>中的一个名称。这些元素是 cell 对象，有个 <code>cell_contents</code> 属性，保存着真正的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历 闭包中的 自由变量</span></span><br><span class="line"><span class="keyword">for</span> cl <span class="keyword">in</span> avg.__closure__:</span><br><span class="line">    print(cl.cell_contents)</span><br></pre></td></tr></table></figure><p>综上：</p><p><strong>闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时， 虽然定义作用域不可用了，但是仍能使用那些绑定</strong>。 注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。</p><p>如果对自由变量赋值呢？特别是不可变类型，会发生什么问题？，请看 nolocal 的作用</p><h3 id="nolocal声明"><a href="#nolocal声明" class="headerlink" title="nolocal声明"></a>nolocal声明</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line">avg(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># UnboundLocalError: local variable 'count' referenced before assignment</span></span><br></pre></td></tr></table></figure><p><code>count += 1</code> 语句的作用其实与<code>count = count + 1</code>一样。因此，我们在 averager 的定义体中为 count 赋值了，这<strong>会把自由变量 count 变成局部变量</strong>。</p><blockquote><p>闭包一节中没有这个问题，是利用了列表是可变的对象这 一事实。但是对数字、字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑 定，例如 count = count + 1，其实<strong>会隐式创建局部变量</strong> count。</p></blockquote><p>为了解决这个问题，Python 3 引入了 nonlocal 声明。它的<strong>作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。</strong></p><blockquote><p>Python 2 没有 nonlocal，因此需要变通方法，基本上，这种处理方式是把内部函数需要修改 的变量（如 count 和 total）存储为可变对象（如字典或简单的实例）的元素或属性，并且把那个对象绑定给一个自由变量。</p></blockquote><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><h4 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h4><p><strong>装饰器是一个函数，是可调用的对象，其参数是另一个函数</strong>（且只有这1个参数？），二者接受相同的参数，而且（通常）返回被装饰的函数本该返回的值，同时还会做些额外操作。</p><p><strong>函数装饰器</strong> 用于在源码中“标记”函数，以某种方式增强函数的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义装饰器函数，增强 func 的功能(日志功能)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"begin %s"</span> % func.__name__)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">"end %s"</span> % func.__name__)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>然后强化 target 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure><p><code>@</code>语法糖，等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target'</span>)</span><br><span class="line">target()</span><br></pre></td></tr></table></figure><ul><li><code>@装饰器函数对象(函数名)</code> 、<code>@装饰器工厂函数(参数)</code>。<code>@</code>后面必须跟着装饰器函数对象，调用装饰器工厂函数也一样可以得到装饰器对象</li><li>装饰器可能会处理被 装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象</li><li>第二个特性是，装饰器 在加载模块时立即执行。而被装饰的函数只在明确调用 时运行</li></ul><p>functools.wrap的使用，实现装饰器的完整定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deco 是装饰器，第一个参数是“可调用对象”</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(num)</span>:</span></span><br><span class="line">        <span class="string">'''内部函数，打印 num'''</span></span><br><span class="line">        print(<span class="string">'running inner(%s)'</span> %num)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># target 被作为参数传入到 deco 中，并且 target 变成了 inner</span></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># running inner()  其实变成了 inner 函数</span></span><br><span class="line"></span><br><span class="line">print(target) <span class="comment"># &lt;function deco.&lt;locals&gt;.inner at 0x10063b598&gt; 其实变成了 inner 函数</span></span><br><span class="line">print(target.__doc__) <span class="comment"># 内部函数，打印 num</span></span><br><span class="line">print(target.__name__) <span class="comment"># inner</span></span><br></pre></td></tr></table></figure><p>实现的 target 装饰器有几个缺点：不支持关键字参数，而且遮盖了被装饰函 数的<code>__name__</code>和<code>__doc__</code>属性。 使用 <strong>functools.wraps</strong> 装饰器可以把相关的属 性从 func 复制到 clocked 中。此外，这个新版还能正确处理关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="comment"># functools的使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(num)</span>:</span></span><br><span class="line">        <span class="string">'''内部函数，打印 num'''</span></span><br><span class="line">        print(<span class="string">'running inner(%s)'</span> %num)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>装饰器在<u>真实代码</u>中的常用方式：</p><ol><li>装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。</li><li>大多数装饰器会在内部定义一个新的函数，然后将其返回。</li></ol><h4 id="标准库中的装饰器"><a href="#标准库中的装饰器" class="headerlink" title="标准库中的装饰器"></a>标准库中的装饰器</h4><p>Python 内置了三个用于装饰方法的函数：property、classmethod 和 staticmethod；</p><p>常见的装饰器是 functools.wraps，它的作用是协助构建行为良好的装饰器；</p><p>标准库中最值得关注的两个装饰器是 lru_cache 和全新的 singledispatch（Python 3.4 新增）；</p><h5 id="functools-lru-cache做备忘"><a href="#functools-lru-cache做备忘" class="headerlink" title="functools.lru_cache做备忘"></a>functools.lru_cache做备忘</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functools.lru_cache(maxsize=<span class="number">128</span>, typed=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><blockquote><p>maxsize 参数指定存储多少个调用的结果。</p><p>typed 参数如果设为 True，把<u>不同参数类型</u>得到的结果分开保存，即把通常认为相等的浮点数和整数参数（如 1 和 1.0）区分开。</p><p>lru_cache 使用字典存储结果，而且键根据调用时传入的定位 参数和关键字参数创建，所以被 lru_cache 装饰的函数，它的<u>所有参数都必须是可散列</u> 的。</p></blockquote><p>它把耗时的函数的结果保存起来，<strong>避免传入相同的参数时重复计算</strong>。LRU 三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存 条目会被扔掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>)+fibonacci(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><h5 id="重载：functools-singledispatch-单分派泛函数"><a href="#重载：functools-singledispatch-单分派泛函数" class="headerlink" title="重载：functools.singledispatch 单分派泛函数"></a>重载：functools.singledispatch 单分派泛函数</h5><blockquote><p>是 Python 3.4 增加的，PyPI 中的 singledispatch 包（<a href="https://pypi.python.org/pypi/singledispatch）可以向后兼容" target="_blank" rel="noopener">https://pypi.python.org/pypi/singledispatch）可以向后兼容</a> Python 2.6 到 Python 3.3。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br></pre></td></tr></table></figure><p>这个函数适用于任何 Python 类型，但是现在我们想做个扩展，让它使用特别的方式显示 某些类型。</p><ul><li><p>str：把内部的换行符替换为 ‘<code>&lt;br&gt;\n</code>‘；不使用 <code>&lt;pre&gt;</code>，而是使用 <code>&lt;p&gt;</code>。</p></li><li><p>int：以十进制和十六进制显示数字。</p></li><li><p>list：输出一个 HTML 列表，根据各个元素的类型进行格式化。</p></li></ul><p>因为 <strong>Python 不支持重载方法或函数</strong>，所以我们不能使用不同的签名定义 htmlize 的变体，也无法使用不同的方式处理不同的数据类型。</p><p><code>singledispatch</code> 装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用 <code>@singledispatch</code> 装饰的普通函数会变成<strong>泛函数</strong>（generic function）：<u>根据第一个参数的类型，以不同方式执行相同操作的一组函数</u>。 这是<strong>单分派</strong>。如果根据多个参数选择专门的函数，那就是<strong>多分派</strong>了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@htmlize.register(str)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    content = html.escape(text).replace(<span class="string">'\n'</span>, <span class="string">'&lt;br&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&#123;0&#125;&lt;/p&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(numbers.Integral)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以叠放多个 register 装饰器，让同一个函数支持不同类型</span></span><br><span class="line"><span class="meta">@htmlize.register(tuple)</span></span><br><span class="line"><span class="meta">@htmlize.register(abc.MutableSequence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br></pre></td></tr></table></figure><p>只要可能，注册的专门函数<u>应该处理抽象基类</u>（如 numbers.Integral 和 abc.MutableSequence），不要处理具体实现（如 int 和 list）。这样，代码支持的兼容类型更广泛。</p><h4 id="叠加装饰器"><a href="#叠加装饰器" class="headerlink" title="叠加装饰器"></a>叠加装饰器</h4><p>把 <code>@d1</code> 和<code>@d2</code> 两个装饰器按顺序应用到 f 函数上，作用相当于<code>f = d1(d2(f))</code>。</p><p>也就是说，下述代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1 </span></span><br><span class="line"><span class="meta">@d2 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure><h4 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h4><p>Python 把被装饰的函数作为第一个参数传给装饰器函数。那<strong>怎么 让装饰器接受其他参数呢</strong>？答案是：<strong>创建一个装饰器工厂函数，把参数传给它，返回一个 装饰器</strong>，然后再把它应用到要装饰的函数上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">registry = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span><span class="comment"># 装饰器工厂，利用参数定制【装饰器】</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>   <span class="comment"># 真正的装饰器</span></span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorate(%s)'</span> % (active, func))</span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> decorate      <span class="comment"># 装饰器工厂 返回定制后的[装饰器]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register(active=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使不传入参数，register 也必须作为函数调用，返回真正的 装饰器 decorate。</span></span><br><span class="line"><span class="meta">@register()       </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br></pre></td></tr></table></figure><p>这里的<strong>关键是</strong>，register() 要返回 decorate，然后把它应用到被装饰的函数上。</p><p>因此如果不使用 <code>@</code> 句法，那就要像常规函数那样使用 register；装饰 f 函数的句法是 <code>register()(f)</code>；不想添加（或把它删除）的话，句法是 <code>register(active=False)(f)</code></p><blockquote><p><code>register()(f)</code>=<code>decorate(f)</code>，因为decorate是register()运行结果</p></blockquote><h2 id="面向对象基础知识（引用）"><a href="#面向对象基础知识（引用）" class="headerlink" title="面向对象基础知识（引用）"></a>面向对象基础知识（引用）</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>首先，我们要抛弃变量是存储数据的盒子这一错误观念，应该理解为<strong>附加在对象上的标注</strong></p><p>为了理解 Python 中的赋值语句，应该<strong>始终先读右边</strong>。对象在右边创建或获取， 在此之后左边的变量才会绑定到对象上，<strong>这就像为对象贴上标注</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><img src="/2020/03/02/python进阶/./image-20190403153226415.png" alt="image-20190403153226415"></p><h3 id="is和"><a href="#is和" class="headerlink" title="is和=="></a>is和==</h3><ul><li><p><code>is</code> 运算符比较两个对象的标识；id() 函数返回对象标识的 整数表示。</p></li><li><p><code>==</code> 运算符比较两个对象的值（对象中保存的数据）</p></li></ul><blockquote><p>通常，我们关注的是值，而不是标识，因此 Python 代码中 <code>==</code>出现的频率比<code>is</code> 高。</p><p>在<strong>变量和单例值</strong>之间比较时，应该使用 <code>is</code>。最常使用 is 检查变量绑定的值 是不是 None。下面是推荐的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; x <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>is</code> 运算符比<code>==</code> 速度快，因为它不能重载，所以 Python 不用寻找并调用特殊方法，而是 直接比较两个整数 ID</p><h3 id="浅复制与深复制"><a href="#浅复制与深复制" class="headerlink" title="浅复制与深复制"></a>浅复制与深复制</h3><h4 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h4><p>构造方法<code>list()</code>或<code>[:]</code> 做的是<strong>浅复制</strong>：即复制了最外层容器，副本中的元素是源容器中 元素的引用。</p><blockquote><p>如果所有元素都是不可变的，那么这样没有问题，还能节省内存。 </p></blockquote><p><img src="/2020/03/02/python进阶/./image-20190404095010842.png" alt="image-20190404095010842"></p><p><code>l2 = list(l1)</code> 赋值后的程序状态。 <code>l1</code> 和<code>l2</code> 指代不同的列表， 但是二者引用同一个列表 [66, 55, 44] 和元组 (7, 8, 9)（图表由Python Tutor网站生成）</p><h4 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h4><p>copy 模块提供的 deepcopy 和 copy 函数能为任意对象做深复制和浅复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = list(passengers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">bus1 = Bus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>])</span><br><span class="line">bus2 = copy.copy(bus1)</span><br><span class="line">bus3 = copy.deepcopy(bus1)</span><br><span class="line"></span><br><span class="line">id(bus1), id(bus2), id(bus3)</span><br><span class="line"><span class="comment"># (4301498296, 4301499416, 4301499752) ➊</span></span><br><span class="line"></span><br><span class="line">id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)</span><br><span class="line"><span class="comment"># (4302658568, 4302658568, 4302657800) ➌</span></span><br><span class="line"></span><br><span class="line">bus1.drop(<span class="string">'Bill'</span>)</span><br><span class="line">bus2.passengers</span><br><span class="line"><span class="comment"># ['Alice', 'Claire', 'David'] ➋ bus1 中的 'Bill' 下车后，bus2 中也没有他了</span></span><br><span class="line"></span><br><span class="line">bus3.passengers</span><br><span class="line"><span class="comment"># ['Alice', 'Bill', 'Claire', 'David'] ➍</span></span><br></pre></td></tr></table></figure><p>此外，深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值。我 们可以实现特殊方法 <code>__copy__()</code>和 <code>__deepcopy__()</code>，控制 copy 和 deepcopy 的行 为，详情参见 copy 模块的文档（<a href="http://docs.python.org/3/library/copy.html）。" target="_blank" rel="noopener">http://docs.python.org/3/library/copy.html）。</a></p><h3 id="函数传参：参数共享"><a href="#函数传参：参数共享" class="headerlink" title="函数传参：参数共享"></a>函数传参：参数共享</h3><p>Python 唯一支持的参数传递模式是共享传参</p><ol><li><p><strong>共享传参</strong>指函数的各个形式参数获得实参中各个<u>引用的副本</u>。也就是说，函数内部的形参 是实参的别名。</p></li><li><p>不要使用可变类型作为参数的默认值</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line">    <span class="string">"""备受幽灵乘客折磨的校车"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line"></span><br><span class="line">bus1 = HauntedBus()</span><br><span class="line">bus2 = HauntedBus()</span><br><span class="line">HauntedBus.__init__.__defaults__[<span class="number">0</span>] <span class="keyword">is</span> bus1.passengers <span class="comment"># True</span></span><br><span class="line">bus2.passengers <span class="keyword">is</span> bus1.passengers <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>问题在于，没有指定初始乘客的 HauntedBus <strong>实例会共享同一个乘客列表</strong>。</p><h3 id="del和垃圾回收"><a href="#del和垃圾回收" class="headerlink" title="del和垃圾回收"></a>del和垃圾回收</h3><p><strong>del 语句删除名称，而不是对象</strong>。del 命令可能会导致对象被当作垃圾回收，但是仅当删 除的变量保存的是对象的最后一个引用，或者无法得到对象时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = s1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Gone with the wind...'</span>)</span><br><span class="line"></span><br><span class="line">ender = weakref.finalize(s1, bye)</span><br><span class="line"></span><br><span class="line">ender.alive</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> s1 <span class="comment"># del 不删除对象，而是删除对象的引用 </span></span><br><span class="line">ender.alive </span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">'spam'</span> <span class="comment"># 重新绑定最后一个引用 s2，让 &#123;1, 2, 3&#125; 无法获取。对象被销毁了，调用了 bye 回调，ender.alive 的值变成了 False。</span></span><br><span class="line"><span class="comment"># Gone with the wind...</span></span><br><span class="line"></span><br><span class="line">ender.alive</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>你可能觉得奇怪，为什么示例中的 {1, 2, 3} 对象被销毁了？毕竟，我们把 s1 引 用传给 finalize 函数了，而为了监控对象和调用回调，必须要有引用。这是因 为，finalize 持有 {1, 2, 3} 的弱引用</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们 说，弱引用不会妨碍所指对象被当作垃圾回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line">a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">wref = weakref.ref(a_set)</span><br><span class="line">print(wref)</span><br><span class="line"><span class="comment"># &lt;weakref at 0x100637598; to 'set' at 0x100636748&gt;</span></span><br><span class="line">wref()  <span class="comment"># &#123;0, 1&#125;</span></span><br><span class="line"></span><br><span class="line">a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment"># a_set 不再指代 &#123;0, 1&#125; 集合，因此集合的引用数量减少了。但是 _ 变量仍然指代它。</span></span><br><span class="line"></span><br><span class="line">wref()  <span class="comment"># &#123;0, 1&#125;</span></span><br><span class="line">print(wref() <span class="keyword">is</span> <span class="keyword">None</span>)  <span class="comment"># False ➎</span></span><br><span class="line">print(wref() <span class="keyword">is</span> <span class="keyword">None</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><blockquote><p>Python 控制台会自动把<code>_</code> 变量绑定到结果不为 None 的表达式结果上，不明显的隐式赋值会为对象创建新引用。</p></blockquote><p>计算➎这个表达式时，{0, 1} 存在，因此 wref() 不是 None。但是，随后 <code>_</code> 绑定到结 果值 False。现在 {0, 1} 没有强引用了。</p><p><strong>weakref</strong> 模块的文档（<a href="http://docs.python.org/3/library/weakref.html）指出，weakref.ref" target="_blank" rel="noopener">http://docs.python.org/3/library/weakref.html）指出，weakref.ref</a> 类其实是低层接口，供高级用途使用，多数程序最好使用 weakref 集合和 finalize。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kind)</span>:</span></span><br><span class="line">        self.kind = kind</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Cheese(%r)'</span> % self.kind</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">stock = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">catalog = [Cheese(<span class="string">'Red Leicester'</span>), Cheese(<span class="string">'Tilsit'</span>), Cheese(<span class="string">'Brie'</span>), Cheese(<span class="string">'Parmesan'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到弱引用 stock 中</span></span><br><span class="line"><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:</span><br><span class="line">    stock[cheese.kind] = cheese</span><br><span class="line"></span><br><span class="line">sorted(stock.keys())</span><br><span class="line"><span class="comment"># ['Brie', 'Parmesan', 'Red Leicester', 'Tilsit']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> catalog</span><br><span class="line">sorted(stock.keys()) <span class="comment"># 因为变量cheese还有对Cheese('Parmesan')的强引用</span></span><br><span class="line"><span class="comment"># ['Parmesan']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> cheese</span><br><span class="line">sorted(stock.keys())</span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 for 循环的变量的作用范围，而导致的意外；for 循环中的变量 cheese 是全局变量，除非显式删除，否则不会消失。</p></blockquote><h4 id="弱引用的局限"><a href="#弱引用的局限" class="headerlink" title="弱引用的局限"></a>弱引用的局限</h4><p>不是每个 Python 对象都可以作为弱引用的目标（或称所指对象）。</p><ul><li>基本的 list 和 dict 实例不能作为所指对象，但是它们的子类可以。</li><li>set 实例可以作为所指对象</li><li>用户定义的类型也没问 题，这就解释了示例中为什么使用那个简单的 Cheese 类</li><li>int 和 tuple 实 例不能作为弱引用的目标，甚至它们的子类也不行</li></ul><h2 id="迭代对象"><a href="#迭代对象" class="headerlink" title="迭代对象"></a>迭代对象</h2><h3 id="可迭代类、迭代器"><a href="#可迭代类、迭代器" class="headerlink" title="可迭代类、迭代器"></a>可迭代类、迭代器</h3><p>以下几种对象之间的关系：</p><ul><li>容器(container)</li><li>可迭代对象(Iterable)</li><li>迭代器(Iterator)</li><li>生成器(generator)</li><li>生成器表达式</li><li>{list, set, dict} 解析式</li></ul><p><img src="/2020/03/02/python进阶/Users/jizhongxian/notes/markdown/python/pyhton%E9%AB%98%E7%BA%A7/%E5%AE%B9%E5%99%A8%E3%80%81%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8_%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt=""></p><blockquote><p>相关的内建模块<code>itertools</code>，该模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是迭代对象，只有用<code>for</code>循环迭代的时候才真正计算。</p></blockquote><h4 id="定义可迭代类"><a href="#定义可迭代类" class="headerlink" title="定义可迭代类"></a>定义可迭代类</h4><p>在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如， Python 的序列协议只需要 <code>__len__</code> 和 <code>__getitem__</code> 两个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.words[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sen = Sentence(<span class="string">"abc def 123 456"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sen:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p><strong>我们发现 <code>__iter__</code>  和 <code>__getitem__</code>中实现任意一个，对象就是可迭代的</strong>，怎么解释这种情况呢，Python 解释器中有这样的描述</p><blockquote><p>解释器需要<strong>迭代对象 x 时， 会自动调用 iter(x)</strong><br>内置的 iter 函数有以下作用：</p><ol><li>优先检查对象是否实现了 __iter__ 方法， 如果实现了就调用它， 获取<br>一个迭代器。</li><li>如果没有实现 __iter__ 方法， 但是实现了  __getitem__ 方法，Python 会创建一个迭代器， 尝试按顺序（从索引 0 开始） 获取元素。</li><li>如果尝试失败， Python 抛出 TypeError 异常， 通常会提示“C object is not iterable”（C 对象不可迭代）</li></ol></blockquote><p>因此我们自定义可迭代对象需要实现 <code>__iter__</code> 函数；严格来讲，我们还需要实现 <code>__getitem__</code> 函数，这个函数的主要作用是当前对象可通过下标取值</p><h4 id="判断是否可迭代"><a href="#判断是否可迭代" class="headerlink" title="判断是否可迭代"></a>判断是否可迭代</h4><p><strong>什么是可迭代对象</strong>：使用 iter 内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的 <code>__iter__</code> 方法，那么对象就是可迭代的。</p><p>如果有一个未知的对象，我们怎么判断该对象是否可迭代呢，两种方式：</p><ul><li><strong>iter(x)</strong><br>这是最准确的判断方式，传入要判断的对象，只要对象实现了__getitem__ 、 __iter__中的其中一个，该对象都是可迭代的，否则抛出TypeError: ‘C’ object is not iterable 异常；<strong>这儿有个区别</strong>(有待考证)，如果仅仅实现了 __getitem__ ，调用 iter(x) 返回的是迭代器对象，如果实现的是 __iter__ ，那么调用 iter(x) 返回的是生成器对象；</li><li><strong>isinstance(x, abc.Iterable)</strong><br>该方式会自动忽略 __getitem__ 函数，仅当对象实现了 __iter__ 函数才返回 True，其他一律返回 False</li></ul><p>从 Python 3.4 开始，检查对象 x 能否迭代，<strong>最准确的方法是：调用 iter(x) 函数</strong>，如果不可迭代，再处理 TypeError 异常。这比使用 <code>isinstance(x, abc.Iterable)</code> 更准确，因为 iter(x) 函数会考虑到遗留的 <code>__getitem__</code> 方法， 而 abc.Iterable 类则不考虑。</p><blockquote><p><a href="https://www.jianshu.com/p/048d40d86759" target="_blank" rel="noopener">https://www.jianshu.com/p/048d40d86759</a></p></blockquote><h4 id="序列可以迭代的原因：iter函数"><a href="#序列可以迭代的原因：iter函数" class="headerlink" title="序列可以迭代的原因：iter函数"></a>序列可以迭代的原因：iter函数</h4><p>序列可以迭代的原因：iter函数</p><p>内置的 iter 函数有以下作用。</p><ol><li><p>检查对象是否实现了 <code>__iter__</code> 方法，如果实现了就调用它，获取一个迭代器。</p></li><li><p>如果没有实现 <code>__iter__</code> 方法，但是实现了 <code>__getitem__</code> 方法，Python 会创建一个迭代器，尝试按顺序（从索引 0 开始）获取元素。</p><blockquote><p>之所以对 <code>__getitem__</code> 方法做特殊处理，是为了向后兼容，而未来可能不会再这么做</p></blockquote></li><li><p>如果尝试失败，Python 抛出 TypeError 异常，通常会提示“C object is not iterable”（C 对象不可迭代），其中 C 是目标对象所属的类。</p></li></ol><h4 id="iter-函数鲜为人知的用法"><a href="#iter-函数鲜为人知的用法" class="headerlink" title="iter 函数鲜为人知的用法"></a>iter 函数鲜为人知的用法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter(calllable,stop_flag)</span><br></pre></td></tr></table></figure><ol><li>第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值</li><li>第二个参数是个标记值（哨符），当可调用的对象返回这个值时，触发迭代器抛出 StopIteration 异常，而不产出哨符</li></ol><p>内置函数<a href="https://docs.python.org/3/library/functions.html#iter" target="_blank" rel="noopener">iter</a>的文档中有个实用的例子。这段代码逐行读取文件，直到遇到空行或者到达文件末尾为止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'mydata.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> iter(fp.readline, <span class="string">''</span>):</span><br><span class="line">        process_line(line)</span><br></pre></td></tr></table></figure><h4 id="for-循环的原理"><a href="#for-循环的原理" class="headerlink" title="for 循环的原理"></a>for 循环的原理</h4><p>当进行 for 循环时:</p><ol><li>会调用 <code>iter(iterable)</code>从<code>__getitem__</code> 、<code>__iter__</code>中，获取迭代器<code>iterator</code></li><li>然后使用 <code>next(iterator)</code>，执行迭代器<code>iterator</code> 的<code>__next__()</code>函数，获取元素</li></ol><p>因此：</p><ul><li>可迭代对象至少实现__getitem__ 、 __iter__中的1个。</li><li>迭代器必须实现__next__()函数</li></ul><p><img src="/2020/03/02/python进阶/Users/jizhongxian/notes/markdown/python/pyhton%E9%AB%98%E7%BA%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1.png" alt=""></p><p>代码演示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> s: </span><br><span class="line">    print(n)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment">#3</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">it = iter(s)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">del</span> it</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>为了更好的理解迭代器的内部结构，我们先来定义一个生成斐波拉契数的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fib 既是可迭代对象，又是迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       self.prev = <span class="number">0</span></span><br><span class="line">       self.curr = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">       value = self.curr</span><br><span class="line">       self.curr += self.prev</span><br><span class="line">       self.prev = value</span><br><span class="line">       <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line">f = fib()</span><br><span class="line">print(list(islice(f, <span class="number">0</span>, <span class="number">10</span>)))</span><br></pre></td></tr></table></figure><p>注意这个类既是可迭代的 （因为具有<code>__iter__()</code>方法），也是它自身的迭代器(因为具有<code>__next__()</code>方法)。</p><p>迭代器内部状态保存在当前实例对象的<code>prev</code>以及<code>cur</code>属性中，在下一次调用中将使用这两个属性。每次调用<code>next()</code>方法都会执行以下两步操作：</p><ol><li>修改状态，以便下次调用<code>next()</code>方法</li><li>计算当前调用的结果</li></ol><p><a href="https://www.jianshu.com/p/4c8e4fb4ef37#" target="_blank" rel="noopener">https://www.jianshu.com/p/4c8e4fb4ef37#</a></p><h3 id="切片-1"><a href="#切片-1" class="headerlink" title="切片"></a>切片</h3><h4 id="切片的真相"><a href="#切片的真相" class="headerlink" title="切片的真相"></a>切片的真相</h4><p><code>iterable[index]</code>会调用 <code>__getitem__</code>，index 会转为 slice 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySeq</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">      </span><br><span class="line">s = MySeq()</span><br><span class="line"></span><br><span class="line">s[<span class="number">1</span>] <span class="comment"># 1</span></span><br><span class="line">s[<span class="number">1</span>:<span class="number">4</span>] <span class="comment"># slice(1, 4, None)</span></span><br><span class="line">s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>] <span class="comment"># slice(1, 4, 2)</span></span><br><span class="line">s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">9</span>] <span class="comment"># (slice(1, 4, 2), 9)</span></span><br><span class="line">s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">7</span>:<span class="number">9</span>] <span class="comment"># (slice(1, 4, 2), slice(7, 9, None)) 元组中甚至可以有多个切片对象</span></span><br></pre></td></tr></table></figure><ol><li>slice 是内置的类型（2.4.2 节首次出现）。 </li><li>通过审查 slice，发现它有 start、stop 和 step 数据属性，以及 indices 方法。</li></ol><p><code>indices</code>用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片，该方法会“整顿”元组，把 start、stop 和 stride 都变成非负数，而且都落在指定长度序列的边界内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="keyword">None</span>, <span class="number">10</span>, <span class="number">2</span>).indices(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># ➊ (0, 5, 2) 'ABCDE'[:10:2] 等同于 'ABCDE'[0:5:2]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="number">-3</span>, <span class="keyword">None</span>, <span class="keyword">None</span>).indices(<span class="number">5</span>) </span><br><span class="line"><span class="comment"># ➋ (2, 5, 1) 'ABCDE'[-3:] 等同于 'ABCDE'[2:5:1]</span></span><br></pre></td></tr></table></figure><h4 id="能正确处理切片的-getitem-方法"><a href="#能正确处理切片的-getitem-方法" class="headerlink" title="能正确处理切片的 getitem 方法"></a>能正确处理切片的 getitem 方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span><span class="params">()</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self) <span class="comment"># 获取类的类型，用于类型转换</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):</span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])<span class="comment">#转为同类型对象</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):</span><br><span class="line">            <span class="keyword">return</span> self._components[index]     <span class="comment">#返回单个元素</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">'&#123;cls.__name__&#125; indices must be integers'</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls=cls))</span><br></pre></td></tr></table></figure><h3 id="生成器-1"><a href="#生成器-1" class="headerlink" title="生成器"></a>生成器</h3><p><strong>生成器其实就是一种特殊的迭代器</strong>。它使一种更为高级、更为优雅的迭代器。</p><p>在Python中两种类型的生成器：<strong>生成器函数</strong>以及<strong>生成器表达式</strong>。</p><h4 id="生成器表达式-括号"><a href="#生成器表达式-括号" class="headerlink" title="生成器表达式(括号)"></a>生成器表达式(括号)</h4><blockquote><p>简单的逻辑可以使用表达式</p></blockquote><p>成器表达式与列表解析式类似（一个是<code>[]</code>,另一个是<code>()</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 创建 list</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">l = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers]  </span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25, 36]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 创建生成器</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">lazy_squares = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers) </span><br><span class="line">next(lazy_squares)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">list(lazy_squares)</span><br><span class="line"><span class="comment"># [4, 9, 16, 25, 36]</span></span><br><span class="line"><span class="comment"># 注意我们第一次调用next()之后，lazy_squares对象的状态已经发生改变，所以后面后面地调用list()方法只会返回部分元素组成的列表。</span></span><br></pre></td></tr></table></figure><p>注意我们第一次调用next()之后，lazy_squares对象的状态已经发生改变，所以后面后面地调用list()方法只会返回部分元素组成的列表。</p><h4 id="生成器函数-yield"><a href="#生成器函数-yield" class="headerlink" title="生成器函数(yield)"></a>生成器函数(yield)</h4><blockquote><p>复杂的逻辑使用函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    prev, curr = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> curr</span><br><span class="line">        prev, curr = curr, prev + curr</span><br><span class="line">        </span><br><span class="line">f = fib() </span><br><span class="line">list(islice(f, <span class="number">0</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>当调用<code>f = fib()</code>时，<strong>生成器被实例化</strong>并返回，这时并不会执行任何代码，生成器处于空闲状态</p><p><a href="https://www.jianshu.com/p/4c8e4fb4ef37#" target="_blank" rel="noopener">https://www.jianshu.com/p/4c8e4fb4ef37#</a></p><h4 id="yield注意事项"><a href="#yield注意事项" class="headerlink" title="yield注意事项"></a>yield注意事项</h4><p>yield 关键字<strong>只能把最近的外层函数变成生成器函数</strong></p><p>调用f()，会得到一个无限循环，而不是生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_yield</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        gen = do_yield(x)</span><br><span class="line">        print(gen)</span><br><span class="line"><span class="comment"># &lt;generator object f.&lt;locals&gt;.do_yield at 0x12c76fa98&gt;</span></span><br><span class="line">        </span><br><span class="line">print(f())</span><br></pre></td></tr></table></figure><p>可以使用yield from把工作委托给第三方完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_yield</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> do_yield(x)</span><br></pre></td></tr></table></figure><h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> iterable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iterable:</span><br><span class="line"><span class="meta">... </span><span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure><p>会从迭代器中依次产生值出来，因此可以这句话看做是一个生成器</p><p>yield from 不只是语法糖而已。</p><p>yield from还会创建通道，把生成器当成协程使用时，这个通道特别重要</p><blockquote><p>更多请参考协程部分</p></blockquote><h4 id="标准生成器函数库"><a href="#标准生成器函数库" class="headerlink" title="标准生成器函数库"></a>标准生成器函数库</h4><p>主要是在 itertools 和 functools 模块</p><p>参考：流畅的 python14.9节</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="可迭代的对象与迭代器的对比"><a href="#可迭代的对象与迭代器的对比" class="headerlink" title="可迭代的对象与迭代器的对比"></a>可迭代的对象与迭代器的对比</h4><p>可迭代的对象和迭代器之间的关系：<strong>Python 从可迭代的对象中获取迭代器，并且迭代器本身也是可迭代对象，但是可迭代的对象不是迭代器</strong></p><p><strong>标准的迭代器</strong>接口有两个方法：</p><ol><li><p><code>__next__</code>：返回下一个可用的元素，如果没有元素了，抛出 StopIteration 异常。</p></li><li><p><code>__iter__</code>：返回 self，以便在需要使用可迭代对象的地方可以用迭代器代替，例如在 for 循环中。</p></li></ol><p><img src="/2020/03/02/python进阶/./image-20190410153352063.png" alt="image-20190410153352063"></p><blockquote><p>迭代器在 collections.abc.Iterator 抽象基类中制定。这个类定义了 <strong>next</strong> 抽 象方法，而且继承自 Iterable 类</p></blockquote><h4 id="迭代器的定义"><a href="#迭代器的定义" class="headerlink" title="迭代器的定义"></a>迭代器的定义</h4><p>迭代器是这样的对象：实现了无参数的 <code>__next__</code> 方法，返回序列中的下一个元素； 如果没有元素了，那么抛出 StopIteration 异常。Python 中的迭代器还实现了 <code>__iter__</code> 方法，因此迭代器也可以迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it=iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it</span><br><span class="line">&lt;str_iterator object at <span class="number">0x1042e4940</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(it)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(iter(a))</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><ul><li><p>没有办法检查是否还有遗留的元素</p></li><li><p>如果想再次迭代，那就要调用 <code>iter(…)</code>，传入之前构建迭代器的可迭代对象</p></li></ul><h4 id="检查是否为迭代器"><a href="#检查是否为迭代器" class="headerlink" title="检查是否为迭代器"></a>检查是否为迭代器</h4><p>检查对象 x 是否为迭代器最好的方式是调用 <code>isinstance(x, abc.Iterator)</code>。得益于 <code>Iterator.__subclasshook__</code> 方法，即使对象 x 所属的类不是 Iterator 类的真实子类或虚拟子类，也能这样检查。</p><blockquote><p>在 Python 3.4 中，Lib/types.py，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># Iterators in Python aren't a matter of type but of protocol. A large </span></span><br><span class="line">&gt; <span class="comment"># and changing number of builtin types implement *some* flavor of </span></span><br><span class="line">&gt; <span class="comment"># iterator. Don't check the type! Use hasattr to check for both </span></span><br><span class="line">&gt; <span class="comment"># "__iter__" and "__next__" attributes instead.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这就是 abc.Iterator 抽象基类中 <strong>subclasshook</strong> 方法的作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(Iterable)</span>:</span></span><br><span class="line">&gt;     __slots__ = ()</span><br><span class="line">&gt; </span><br><span class="line">&gt;     @abstractmethod</span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;         <span class="string">'Return the next item from the iterator. When exhausted, raise StopIteration'</span></span><br><span class="line">&gt;         <span class="keyword">raise</span> StopIteration</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;         <span class="keyword">return</span> self</span><br><span class="line">&gt; </span><br><span class="line">&gt;     @classmethod</span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">&gt;         <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="keyword">if</span> (any(<span class="string">"__next__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__) <span class="keyword">and</span></span><br><span class="line">&gt;                     any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__)):</span><br><span class="line">&gt;                 <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="既是可迭代对象又是迭代器-坏注意"><a href="#既是可迭代对象又是迭代器-坏注意" class="headerlink" title="既是可迭代对象又是迭代器(坏注意)"></a>既是可迭代对象又是迭代器(坏注意)</h4><p>构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者</p><p>除了<code>__iter__</code> 方法之外，你可能还想在 Sentence 类（可迭代对象）中实现 <code>__next__</code> 方法，让 Sentence 实例既是可迭代的对象，也是自身的迭代器。可是，这种想法非常糟糕。</p><p><strong>迭代器可以迭代，但是可迭代的对象不是迭代器</strong></p><p><strong>可迭代的对象一定不能是自身的迭代器。</strong></p><blockquote><p>也就是说，可迭代的对象必须实现 <code>__iter__</code> 方法，但不能实现 <code>__next__</code> 方法。 </p><p>迭代器应该一直可以迭代。迭代器的 <code>__iter__</code> 方法应该返回自身。</p></blockquote><p>迭代器模式可用来： </p><ul><li>访问一个聚合对象的内容而<strong>无需暴露它的内部表示</strong> </li><li>支持对聚合对象的<strong>多种遍历</strong> </li><li>为遍历不同的聚合结构<strong>提供一个统一的接口</strong>（即支持多态迭代）</li></ul><p>为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用 <code>iter(my_iterable)</code> 都新建一个独立的迭代器。这就是为什么这个示例需要定义<code>SentenceIterator</code> 类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确做法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><h4 id="python-风格的迭代器"><a href="#python-风格的迭代器" class="headerlink" title="python 风格的迭代器"></a>python 风格的迭代器</h4><p>符合 Python 习惯的方式是，用生成器函数代替 SentenceIterator 类。</p><p><strong>惰性实现</strong></p><p>惰性实现是指尽可能延后生成值。这样做能节省内存，而且或许还可以避免做无用的处理。因此修改如下：</p><p><strong>惰性实现：生成器函数1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>生成器函数定义体中的 <strong>return 语句会触发生成器对象抛出 StopIteration 异常。</strong></p><p><strong>惰性实现：生成器函数2</strong></p><p><code>re.finditer</code> 函数是 <code>re.findall</code> 函数的惰性版本，返回的不是列表，而是一个生成器，按需生成 <code>re.MatchObject</code> 实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"><span class="comment">#取消了 self.words</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 生成器函数2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">            <span class="keyword">yield</span> match.group()</span><br></pre></td></tr></table></figure><p><strong>惰性实现：生成器表达式</strong></p><p>生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少 Sentence 类的代码</p><p>生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure><p>如果函数或构造方法只有一个参数，传入生成器表达式时只写一对括号就行了。不用写一对调用函数的括号，再写一对括号围住生成器表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(var)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">func(n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">10</span>)) <span class="comment"># (n for n in range(10))是生成器表达式，传入单参数的函数时不用外层的括号</span></span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类（class）</p><p>　　定义新类型的<strong>程序结构</strong>，里面有数据属性，以及用于操作数据属性的方法。</p><p>类型（type）</p><p>　　<strong>程序中的各种数据，限定可取的值和可对数据做的操作</strong>。有些 Python 类型近似于机器数据类型（例如 float 和 bytes），而另一些则是机器数据类型的扩展（例如，int 不受 CPU 字长的限制，str 包含多字节 Unicode 数据码位）和特别高层的抽象（例如 dict、 deque，等等）。类型分为两类：用户定义的类型和解释器内置的类型。在 Python 2.2 统一类型和类之前，类型和类是不同的实体，用户定义的类不能扩展内置的类型。而在那之后，内置的类型和新式类兼容了，类是 type 的实例。在 Python 3 中，所有类都是新式类。</p><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p>Python判断变量的类型有两种方法：<code>type(obj)</code>和<code>isinstance(obj，C)</code></p><p>对于<strong>基本的数据类型</strong>两个的效果都一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip_port = [<span class="string">'219.135.164.245'</span>, <span class="number">3128</span>]</span><br><span class="line"><span class="comment">### type()</span></span><br><span class="line"><span class="keyword">if</span> type(ip_port) <span class="keyword">is</span> list:</span><br><span class="line">    print(<span class="string">'list数组'</span>)</span><br><span class="line"><span class="comment">### isinstance()</span></span><br><span class="line"><span class="keyword">if</span> isinstance(ip_port, list):</span><br><span class="line">    print(<span class="string">'list数组'</span>)</span><br></pre></td></tr></table></figure><p><strong>区别之处</strong></p><p>isinstance() 和 type() 的区别在于：</p><ul><li><code>isinstance(obj，C)</code> 会判断 C 是不是父类类型</li><li><code>type(obj) == C</code>不会认为子类是一种父类类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">isinstance(A(), A)  <span class="comment"># returns True</span></span><br><span class="line">type(A()) == A      <span class="comment"># returns True</span></span><br><span class="line">isinstance(B(), A)    <span class="comment"># returns True</span></span><br><span class="line">type(B()) == A        <span class="comment"># returns False</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p><code>_var</code>“单下划线” 开始的成员变量叫做保护变量，只有类对象和子类对象能访问到这些变量；外部访问需通过类提供的接口（方法）进行访问<br>`</p><ul><li><p><code>__var</code>“双下划线” 开始的是私有成员（private），只有类对象自己能访问，连子类对象也不能访问到这个数据。</p><blockquote><p>Python解释器对外把<code>Student</code>类的<code>__name</code>变量改成了<code>_Student__name</code>（所以通过这个名字还是可以访问到的）</p></blockquote><p>注意下面的这种<em>错误写法</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line">bart.get_name()</span><br><span class="line"><span class="comment"># 'Bart Simpson'</span></span><br><span class="line">bart.__name = <span class="string">'New Name'</span> <span class="comment"># 设置__name变量！，并没有修改成功！</span></span><br><span class="line">print(bart.__name)</span><br><span class="line"><span class="comment"># 'New Name'</span></span><br><span class="line">bart.get_name() <span class="comment"># get_name()内部返回self.__name</span></span><br><span class="line"><span class="comment"># 'Bart Simpson'</span></span><br></pre></td></tr></table></figure></li><li><p><code>_var</code>“单下划线” 开始的成员变量叫做保护变量(不过《流畅的 python》9.7章不这样认为)，比如<code>_name</code>，按照约定俗成的规定，只有类对象和子类对象能访问到这些变量；外部访问需通过类提供的接口（方法）进行访问。</p><p>“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>在一个模块中以单下划线开头的变量和函数被默认当作内部函数，如果使用 <code>from a_module import *</code> 导入时，<strong>这部分变量和函数<u>不会</u>被导入</strong>。如果使用 <code>import a_module</code> 这样导入模块，仍然可以用 <code>a_module._some_var</code> 这样的形式访问到这样的对象，或者<code>from mymod import _privatefunc</code>。</p><blockquote><p>Python 解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多 Python 程序员 严格遵守的约定，他们不会在类外部访问这种属性</p></blockquote></li><li><p>变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量</p></li></ul><p>以模块<code>from module import *</code> <strong>不会导入</strong><code>_</code>和<code>__</code>开头的变量和函数，只有<code>import module as m</code> 然后<code>m.__var</code>这样是可以访问到。</p><p>参考：<a href="https://www.cnblogs.com/work115/p/5606981.html" target="_blank" rel="noopener">https://www.cnblogs.com/work115/p/5606981.html</a></p><h4 id="类属性与实例属性"><a href="#类属性与实例属性" class="headerlink" title="类属性与实例属性"></a>类属性与实例属性</h4><ul><li>实例属性</li></ul><p>给实例绑定属性的方法是通过实例变量<code>.</code>，或者通过<code>self</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name  <span class="comment"># 实例属性绑定方法1</span></span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>)</span><br><span class="line">s.score = <span class="number">90</span><span class="comment"># 实例属性绑定方法2</span></span><br></pre></td></tr></table></figure><ul><li>类属性</li></ul><p>直接在class中定义属性，这种属性是类属性，归<code>Student</code>类所有，这个属性虽然归类所有，但<strong>类的所有实例都可以访问</strong>到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'Student'</span></span><br></pre></td></tr></table></figure><h5 id="属性覆盖"><a href="#属性覆盖" class="headerlink" title="属性覆盖"></a>属性覆盖</h5><p>Python 有个很独特的特性：类属性可用于为实例属性提供默认值。</p><blockquote><p>使用<code>self.var</code> 读取它的值。因为实例本身没有 var 属性，所以 self.var 默认获 取的是<code>Class.var</code>类属性的值。</p></blockquote><p>如果为不存在的实例属性赋值，会新建实例属性。同名类属性不受影响，也就是把同名类属性遮盖了。借助这一特性，可以为各个实例的属性定制不同的值。</p><p>但是如果使用的好，就会出现下面的问题</p><p><strong>查找顺序（大坑）</strong></p><blockquote><p>实例属性-&gt;类属性</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'Student'</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line"></span><br><span class="line"><span class="string">''' 访问 '''</span></span><br><span class="line">print(s.name) <span class="comment"># 实例并没有name属性，所以会继续查找class的name属性</span></span><br><span class="line"><span class="comment"># Student</span></span><br><span class="line">print(Student.name) <span class="comment"># 打印类的name属性</span></span><br><span class="line"><span class="comment"># Student</span></span><br><span class="line"></span><br><span class="line"><span class="string">''' 修改 '''</span></span><br><span class="line">s.name = <span class="string">'Michael'</span> <span class="comment"># 给实例绑定name属性</span></span><br><span class="line">print(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></span><br><span class="line"><span class="comment"># Michael</span></span><br><span class="line">print(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></span><br><span class="line"><span class="comment"># Student</span></span><br><span class="line">Student.name=<span class="string">'new Student'</span> <span class="comment"># 这才是修改类属性</span></span><br><span class="line">print(Student.name) </span><br><span class="line"><span class="comment"># new Student</span></span><br><span class="line"></span><br><span class="line"><span class="string">''' 删除 '''</span></span><br><span class="line"><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span></span><br><span class="line">print(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></span><br><span class="line"><span class="comment"># new Student</span></span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，在编写程序的时候，<strong>千万不要对实例属性和类属性使用相同的名字</strong>，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><h4 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h4><p>Python下一切皆对象，每个对象都有多个属性(attribute)，Python对属性有一套统一的管理方案。</p><p>一共有4种：</p><ol><li><p>使用属性运算符</p><p><code>print(xmr.name)</code></p></li><li><p>通过属性字典__dict__<br><code>print(xmr.__dict__[&#39;name&#39;])</code></p></li><li><p>通过getattr函数<br><code>print(getattr(xmr, &#39;name&#39;))</code></p></li><li><p>operator.attrgetter (可用于排序)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">op = operator.attrgetter(<span class="string">'name'</span>)</span><br><span class="line">print(op(xmr)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"> </span><br><span class="line">people = [Person(<span class="string">'xiemanR'</span>, <span class="number">18</span>), Person(<span class="string">'zhangshan'</span>, <span class="number">17</span>), Person(<span class="string">'lisi'</span>, <span class="number">20</span>), Person(<span class="string">'wangwu'</span>, <span class="number">25</span>)]</span><br><span class="line"> </span><br><span class="line">r = sorted(people, key=operator.attrgetter(<span class="string">'age'</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></li></ol><p><code>__dict__与dir()</code>的区别：</p><ol><li><p>dir()是一个内建函数，返回的是list；dir()用来寻找一个对象的所有属性，包括<code>__dict__</code>中的属性，包括从父类中继承的属性)。</p></li><li><p><code>__dict__</code>是一个字典，键为属性名，值为属性值； <strong>并不是所有对象都拥有<strong>dict</strong>属性。</strong>许多内建类型就<a href="http://blog.csdn.net/lis_12/article/details/53511300" target="_blank" rel="noopener">没有<code>__dict__</code>属性</a>，如list，此时就需要用dir()来列出对象的所有属性。</p><ul><li><p>实例的<code>__dict__</code><strong>仅存储与该实例相关的实例属性(self.xx，但不包括@property)</strong>，正是因为实例的<code>__dict__</code>属性，每个实例的实例属性才会互不影响。</p></li><li><p>类的<code>__dict__</code>存储所有实例共享的变量和函数(类属性，方法等)，类的<code>__dict__</code>并不包含其父类的属性。</p></li></ul></li></ol><h4 id="属性操作：xxxattr函数"><a href="#属性操作：xxxattr函数" class="headerlink" title="属性操作：xxxattr函数"></a>属性操作：xxxattr函数</h4><p>仅仅把属性和方法列出来是不够的，配合内建函数<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p><ul><li><code>getattr(obj, 属性名/方法名, 默认值)</code></li><li><code>setattr(obj, 属性名/方法名, 值)</code></li><li><code>hasattr(obj, 属性名/方法名)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       self.x = <span class="number">9</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">return</span> self.x * self.x</span><br><span class="line"></span><br><span class="line">obj = MyObject()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 访问、修改属性</span></span><br><span class="line"><span class="keyword">if</span> hasattr(obj, <span class="string">'x'</span>):</span><br><span class="line">    print(getattr(obj, <span class="string">'x'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(obj, <span class="string">'y'</span>):</span><br><span class="line">    setattr(obj, <span class="string">'y'</span>, <span class="number">23</span>)</span><br><span class="line">    print(obj.y)</span><br><span class="line"></span><br><span class="line">print(getattr(obj, <span class="string">'z'</span>, <span class="number">0</span>))  <span class="comment"># 属性不存在时，提供默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 获取方法</span></span><br><span class="line"><span class="keyword">if</span> hasattr(obj,<span class="string">'power'</span>):</span><br><span class="line">    fn = getattr(obj,<span class="string">'power'</span>)</span><br><span class="line">    print(fn())</span><br></pre></td></tr></table></figure><p>属性查找失败后，解释器会调用<code>__getattr__</code>方法。</p><p>多数时候，如果实现了<code>__getattr__</code> 方法，那么也要定义 <code>__setattr__</code> 方法，以防对象的行为不一致。默认情况：在<strong>超类</strong>上调用 <code>__setattr__</code> 方法，提供标准行为。</p><p>为了实现<strong>只读</strong>的功能，可以通过<code>__setattr__</code>方法进行控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">    cls = type(self)</span><br><span class="line">    <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> cls.shortcut_names:</span><br><span class="line">            error = <span class="string">'readonly attribute &#123;attr_name!r&#125;'</span></span><br><span class="line">        <span class="keyword">elif</span> name.islower():</span><br><span class="line">            error = <span class="string">"can't set attributes 'a' to 'z' in &#123;cls_name!r&#125;"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> error:</span><br><span class="line">            msg = error.format(cls_name=cls.__name__, attr_name=name)</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(msg)</span><br><span class="line">    super().__setattr__(name, value)</span><br></pre></td></tr></table></figure><h4 id="特性-property"><a href="#特性-property" class="headerlink" title="特性 @property"></a>特性 @property</h4><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，<strong>没办法检查参数</strong>，导致可以把成绩随便改</p><p>装饰器（decorator）可以给函数动态加上功能。对于类的方法，装饰器一样起作用。Python内置的<code>@property</code>装饰器就是负责<strong>把一个方法变成属性</strong>调用的。</p><blockquote><p>内置的 property 经常用作装饰器，但它<strong>其实是一个类</strong></p></blockquote><p>特性是用于 管理<strong>实例属性</strong>的<strong>类属性</strong>，真正的值存储在私有属性 <code>__var</code> 中</p><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>方式1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight <span class="comment"># self.weight 会找到类属性(特性)weight，然后就会进入set_weight方法(访问顺序请看下面介绍)</span></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_weight</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            self.__weight = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    weight = property(get_weight, set_weight)</span><br></pre></td></tr></table></figure><p>类中的<strong>特性能影响实例属性的寻找方式</strong>，而一开始这种方式可能会让人觉得意外(访问顺序请看下面介绍)</p><p>方式2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">print(s.score)  <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line">s.score = <span class="number">60</span>  <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line">print(s.score)  <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line">s.score = <span class="number">9999</span> <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><p>只定义getter方法，不定义setter方法就是一个<strong>只读属性</strong></p><p><strong>删除操作</strong></p><p>可以使用 <code>@my_propety.deleter</code> 装饰器包装一个方法，负责删除特性管理 的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来自电影《巨蟒与圣杯》，感觉这个例子不太好，看不出效果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackKnight</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.members = [<span class="string">'an arm'</span>, <span class="string">'another arm'</span>, <span class="string">'a leg'</span>, <span class="string">'another leg'</span>]</span><br><span class="line">        self.phrases = [<span class="string">"'Tis but a scratch."</span>, <span class="string">"It's just a flesh wound."</span>, <span class="string">"I'm invincible!"</span>, <span class="string">"All right, we'll call it a draw."</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">member</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'next member is:'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.members[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @member.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">member</span><span class="params">(self)</span>:</span></span><br><span class="line">        text = <span class="string">'BLACK KNIGHT (loses &#123;&#125;)\n-- &#123;&#125;'</span></span><br><span class="line">        print(text.format(self.members.pop(<span class="number">0</span>), self.phrases.pop(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">knight = BlackKnight()</span><br><span class="line">knight.member</span><br><span class="line"><span class="comment"># next member is: 'an arm'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> knight.member</span><br><span class="line"><span class="comment"># BLACK KNIGHT (loses an arm)</span></span><br><span class="line"><span class="comment"># -- 'Tis but a scratch.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> knight.member</span><br><span class="line"><span class="comment"># BLACK KNIGHT (loses another arm)</span></span><br><span class="line"><span class="comment"># -- It's just a flesh wound.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> knight.member</span><br><span class="line"><span class="comment"># BLACK KNIGHT (loses a leg)</span></span><br><span class="line"><span class="comment"># -- I'm invincible!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> knight.member</span><br><span class="line"><span class="comment"># BLACK KNIGHT (loses another leg)</span></span><br><span class="line"><span class="comment"># -- All right, we'll call it a draw.</span></span><br></pre></td></tr></table></figure><p>在不使用装饰器的经典调用句法中，fdel 参数用于设置删值函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member = property(member_getter, fdel=member_deleter)</span><br></pre></td></tr></table></figure><h5 id="特性的文档"><a href="#特性的文档" class="headerlink" title="特性的文档"></a>特性的文档</h5><p>如果使用经典调用句法，为 property 对象设置文档字符串的方法是传入 doc 参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weight = property(get_weight, set_weight, doc=<span class="string">'weight in kilograms'</span>)</span><br></pre></td></tr></table></figure><p>使用装饰器创建 property 对象时，读值<code>@property</code> 装饰的方法的文档变成特性的文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''The bar attribute'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__[<span class="string">'bar'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @bar.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__dict__[<span class="string">'bar'</span>] = value</span><br></pre></td></tr></table></figure><h5 id="Property源码"><a href="#Property源码" class="headerlink" title="Property源码"></a>Property源码</h5><p>其实Property是数据描述符，参考：<a href="https://docs.python.org/3/howto/descriptor.html#id7" target="_blank" rel="noopener">Properties</a><a href="https://docs.python.org/3/howto/descriptor.html#properties" target="_blank" rel="noopener">¶</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"Emulate PyProperty_Type() in Objects/descrobject.c"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        <span class="keyword">if</span> doc <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            doc = fget.__doc__</span><br><span class="line">        self.__doc__ = doc</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">"unreadable attribute"</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fget(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">"can't set attribute"</span>)</span><br><span class="line">        self.fset(obj, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">"can't delete attribute"</span>)</span><br><span class="line">        self.fdel(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span><span class="params">(self, fget)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type(self)(fget, self.fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(self, fset)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type(self)(self.fget, fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span><span class="params">(self, fdel)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type(self)(self.fget, self.fset, fdel, self.__doc__)</span><br></pre></td></tr></table></figure><h4 id="特性工厂"><a href="#特性工厂" class="headerlink" title="特性工厂"></a>特性工厂</h4><p>工厂函数构建的特性利用，weight 特性覆盖了 weight 实例属性，对 self.weight 或 nutmeg.weight 的每个引用都由特性函数处理，只有 直接存取 <code>__dict__</code> 属性才能跳过特性的处理逻辑</p><p>在真实的系统中，分散在多个类中的多个字段可能要做同样的验证，此时最好把 quantity 工厂函数放在实用工具模块中，以便重复使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特性工厂</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(storage_name)</span>:</span></span><br><span class="line">    <span class="comment"># 运行这两个函数时，它们会从闭包中读取 storage_name，确定从哪里获取属性 的值，或者在哪里存储属性的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[storage_name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure><p>特性是类属性。构建各个 quantity 特性对象时，要传入 LineItem 实例属性 的名称，让特性管理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = quantity(<span class="string">'weight'</span>) <span class="comment"># 特性 weight 定义为类属性</span></span><br><span class="line">    price = quantity(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h4><p>参考：<a href="https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access" target="_blank" rel="noopener">Customizing attribute access</a></p><p>类可以定义这个这属性，<strong>限制实例能有哪些属性</strong>。</p><p>原因：默认情况下，Python 在各个实例中名为 <code>__dict__</code> 的字典里存储实例属性。为了使用底层的散列表提升访问速度，<u>字典会消耗大量内存</u>。</p><p>原理：如果要处理数百万个<strong>属性不多</strong>的实例，通过 <code>__slots__</code> 类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不用字典。</p><p>注意：</p><ul><li><p>父类中声明的 <code>__slots__</code> 会被子类继承，但是子类默认拥有<code>__dict__</code> 和<code>__weakref__</code>，因此子类默认是可以动态赋值，除非子类也定义了 <code>__slots__</code> ，只需定义额外的、父类中没有的 slots 即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'c'</span>,<span class="string">'d'</span>) <span class="comment"># 如果没有这一行，B类可以任意添加属性，因为有 __dict__属性</span></span><br><span class="line"></span><br><span class="line">a = B()</span><br><span class="line">a.a, a.b, a.c a.d= <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在类中定义 <code>__slots__</code> 属性之后， 不再拥有<code>__dict__</code>和 <code>__weakref__</code>属性，除非显式在 slots 中声明，或者父类中可用</p></li><li><p>如果不把 ‘<code>__dict__</code>‘ 加入 <code>__slots__</code>，实例不能再有 <code>__slots__</code> 中所列名称之外的其他属性，失去动态添加属性的功能</p></li><li><p>如果不把 ‘<code>__weakref__</code>‘ 加入 <code>__slots__</code>，实例就不能作为弱引用的目标</p></li><li><p><code>__slots__</code>实现方式是在类的层面上为每个变量创建描述符，因此不能定义与<code>__slots__</code>中的重名的类属性，比如想用于为实例提供默认值的类属性</p></li></ul><p>在类中定义告诉解释器：“这个类中的所有实例属性都在这儿了！</p><p><code>__slots__</code> 属性的值是一个字符 串组成的元组，指明允许有的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125;,&#123;&#125;&gt;'</span>.format(self.x, self.y)</span><br><span class="line">  </span><br><span class="line">v=Vector2d(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># 不允许赋值了给未知的属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.o=<span class="number">10</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Vector2d'</span> object has no attribute <span class="string">'o'</span></span><br></pre></td></tr></table></figure><h4 id="属性访问优先顺序"><a href="#属性访问优先顺序" class="headerlink" title="属性访问优先顺序"></a>属性访问优先顺序</h4><p><strong>特性都是类属性</strong>，但是特性管理的其实是实例属性的存取</p><ul><li>如果实例和所属的类有同名数据属性，那么实例属性会覆盖（或称遮盖）类属性</li><li>但是实例属性不会遮盖类特性</li><li>直接从 Class 中读取 prop 特性，获取的是特性对象本身，不会运行特性的读值方法</li></ul><blockquote><p><code>obj.attr</code> 这样的表达式不会从 obj 开始寻找 attr，而是从 <code>obj.__class__</code> 开始，而且，仅当类中没有名为 attr 的特性时，Python 才会在 obj 实例中寻找。这条规则不仅适用于特性，还适用于一整类描述符——<strong>覆盖型描述符</strong> （overriding descriptor） <strong>具体看描述符的 【属性访问的优先级规则】 一章</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>:</span></span><br><span class="line">    data = <span class="string">'the class data attr'</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'the prop value'</span></span><br><span class="line"></span><br><span class="line">Class.prop <span class="comment"># ➊ 直接从 Class 中读取 prop 特性，获取的是特性对象本身，不会运行特性的读值方法</span></span><br><span class="line"><span class="comment"># &lt;property object at 0x1072b7408&gt;</span></span><br><span class="line"></span><br><span class="line">obj.prop <span class="comment"># ➋ 执行特性的读值方法</span></span><br><span class="line"><span class="comment"># 'the prop value'</span></span><br><span class="line"></span><br><span class="line">obj.prop = <span class="string">'foo'</span> <span class="comment"># ➌ 执行特性的赋值方法</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last): AttributeError: can't set attribute</span></span><br><span class="line"></span><br><span class="line">obj.__dict__[<span class="string">'prop'</span>] = <span class="string">'foo'</span> <span class="comment"># ➍ 绕过特性，给实例添加 prop 属性</span></span><br><span class="line">vars(obj) <span class="comment"># ➎ </span></span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'bar'</span>,<span class="string">'prop'</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line"></span><br><span class="line">obj.prop <span class="comment"># ➏ 仍会运行特性的读值方法。特性没被实例属性遮盖。</span></span><br><span class="line"><span class="comment"># 'the prop value'</span></span><br><span class="line"></span><br><span class="line">Class.prop = <span class="string">'baz'</span> <span class="comment"># ➐覆盖 Class.prop 特性，销毁特性对象</span></span><br><span class="line">obj.prop <span class="comment"># ➑</span></span><br><span class="line"><span class="comment"># 'foo'</span></span><br></pre></td></tr></table></figure><h4 id="特殊属性的访问"><a href="#特殊属性的访问" class="headerlink" title="特殊属性的访问"></a>特殊属性的访问</h4><p>参考：<a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" target="_blank" rel="noopener">Special method lookup</a></p><p>结论：特殊方法的查找与普通属性一样，只有隐式的调用才会绕过一些限制</p><p><strong>隐式调用特殊方法</strong>（如使用<code>len()</code>,<code>repr()</code>,<code>hash()</code>就会隐式调用<code>__len__</code>等方法），只有当方法是定义在object 的类中 而不是在 object 实例的字典中时才能正确执行，(if defined on an object’s type, not in the object’s instance dictionary. )这也是为什么下面的代码会出现异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.__len__ = <span class="keyword">lambda</span>: <span class="number">5</span></span><br><span class="line">len(c)</span><br><span class="line"><span class="comment"># TypeError: object of type 'C' has no len()</span></span><br></pre></td></tr></table></figure><p>但是下面这样就没有问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">len(c) <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><p>这种现象在很多特殊方法上都有：<code>__hash__</code>,<code>__repr__</code></p><p>隐式调用特殊方法时，它会<strong>绕过 必须传入实例参数 的限制</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> .__hash__() == hash(<span class="number">1</span>)<span class="comment"># 实例调用特殊方法，会将本身传入第一个参数</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">int.__hash__() == hash(int)<span class="comment"># 类调用特殊方法，必须显式传入实例参数，否则报错</span></span><br><span class="line"><span class="comment"># TypeError: descriptor '__hash__' of 'int' object needs an argument</span></span><br><span class="line"></span><br><span class="line">type(<span class="number">1</span>).__hash__(<span class="number">1</span>) == hash(<span class="number">1</span>)<span class="comment"># 等价于上面，显式传入实例参数，就不会出错</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">type(int).__hash__(int) == hash(int)<span class="comment"># 调用元类的特殊方法，也需要显式传入实例参数，只不过这个实例是一个类对象</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>同时，它也会 <strong>绕过类、甚至元类的<code>__getattribute__()</code>方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(*args)</span>:</span></span><br><span class="line">        print(<span class="string">"Metaclass getattribute invoked"</span>)</span><br><span class="line">        <span class="keyword">return</span> type.__getattribute__(*args)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object, metaclass=Meta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(*args)</span>:</span></span><br><span class="line">        print(<span class="string">"Class getattribute invoked"</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__getattribute__(*args)</span><br><span class="line">        </span><br><span class="line">c = C()</span><br><span class="line">c.__len__()        <span class="comment"># ❶ 通过实例显式调用特殊方法，会调用"类"的 __getattribute__</span></span><br><span class="line"><span class="comment"># Class getattribute invoked</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line">type(c).__len__(c) <span class="comment"># ❷通过类显式调用特殊方法，会调用“元类"的 __getattribute__</span></span><br><span class="line"><span class="comment"># Metaclass getattribute invoked</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line">len(c)                      <span class="comment"># 隐式调用,绕过 __getattribute__</span></span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure><p>❷ 请参考：元类编程中的【类属性访问优先级】，就可以明白为什么会调用元类的方法</p><h4 id="总结：处理属性的重要属性与函数"><a href="#总结：处理属性的重要属性与函数" class="headerlink" title="总结：处理属性的重要属性与函数"></a>总结：处理属性的重要属性与函数</h4><h5 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h5><ol><li><code>__class__</code> ：对象所属类的引用，即 <code>obj.__class__</code> 与 <code>type(obj)</code> 的作用相同</li><li><code>__dict__</code> ：一个映射，存储对象或类的可写属性。有 <code>__dict__</code> 属性的对象，任何时候都能随意设置新属性。如果类有 <code>__slots__</code> 属性，它的实例可能没有 <code>__dict__</code>属性。</li><li><code>__slots__</code> ：类可以定义这个这属性，限制实例能有哪些属性。<code>__slots__</code> 属性的值是一个元组，每个元素是字符串，指明允许有的属性。 如果 <code>__slots__</code> 中没有 ‘<code>__dict__</code>‘，那么该类的实例没有 <code>__dict__</code> 属性，实例只允许有指定名称的属性。</li></ol><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><ol><li><p><code>dir([object])</code>：列出对象的<strong>大多数</strong>属性。<a href="https://docs.python.org/3/library/functions.html#dir" target="_blank" rel="noopener">官方文档</a>说<code>dir</code>函数的<strong>目的是交互式使用</strong>， 因此没有提供完整的属性列表，只列出一组【重要的】属性名。</p><blockquote><ul><li><p>dir 函数能审查有或没有 <strong>dict</strong> 属性的对象。</p></li><li><p>dir 函数不会列出 <strong>dict</strong> 属性本身，但会列出其中的键。</p></li><li><p>dir 函数也不会列出类的几个特殊属性，例如 <strong>mro</strong>、<strong>bases</strong> 和 <strong>name</strong>。 </p></li><li><p>如果没有指定可选的 object 参数，dir 函数会列出当前作用域中的名称。</p></li></ul></blockquote></li><li><p><code>vars([object])</code> ：返回 object 对象的 <code>__dict__</code> 属性；</p><p>如果实例所属的类定义了 <code>__slots__</code> 属性， 实例没有 <code>__dict__</code> 属性，那么 <code>vars</code> 函数不能处理那个实例（<code>dir</code> 函数能处理这样的实例）。如果没有指定参数，那么 vars() 函数的作用与 locals() 函数一样：返回表示本地作用域的字典。</p></li><li><p><code>getattr(object, name[, default])</code> ：从 object 对象中获取 name 字符串对应的属性。获取的<strong>属性可能来自对象所属的类或超类</strong>。如果没有找到指定的属性，getattr 函数抛出 AttributeError 异常，或者返回 default 参数的值。</p></li><li><p><code>hasattr(object, name)</code>：如果object 对象中存在指定的属性，或者能以某种方式（例如继承）通过 object 对象获取指定的属性，返回 True。<a href="https://docs.python.org/3/library/functions.html#hasattr" target="_blank" rel="noopener">文档</a>说：“这个函数的实现方法是调用 <code>getattr(object, name)</code> 函数，看看是否抛出 <code>AttributeError</code> 异常。”</p></li><li><p><code>setattr(object, name, value)</code> ：把 object 对象指定属性的值设为 value，前提是 object 对象能接受那个值。</p><p>这个函数<strong>可能会创建一个新属性，或者覆盖现有的属性</strong>。</p></li></ol><h5 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h5><p>​    使用点号或内置的 getattr、hasattr 和 setattr 函数存取属性都会触发下述列表中相应的特殊方法。直接通过实例的 <code>__dict__</code> 属性读写属性<strong>不会触发这些特殊方法</strong></p><p>​    仅当特殊方法在对象所属的<strong>类型上定义</strong>，而不是在对象的实例字典中定义时，才能确保隐式调用特殊方法调用成功（<code>obj.attr</code> 和 <code>getattr(obj, &#39;attr&#39;, 42)</code> 都会触发 <code>Class.__getattribute__(obj, &#39;attr&#39;)</code> 方法）</p><p>​    特殊方法 <strong>不会被同名实例属性遮盖</strong></p><ol><li><p><code>__dir__(self)</code>：把对象传给 dir 函数时调用，列出属性。例如，<code>dir(obj)</code> 触发 <code>Class.__dir__(obj)</code> 方法。</p></li><li><p><code>__getattr__(self, name)</code>：仅当搜索过 obj、Class 和超类之后，获取指定的属性失败时调用。也就是只有当试图访问不存在的属性时它才会被调用。表达式 <code>obj.no_such_attr</code>、<code>getattr(obj, &#39;no_such_attr&#39;)</code> 和 <code>hasattr(obj, &#39;no_such_attr&#39;)</code> 可能会触发 <code>Class.__getattr__(obj, &#39;no_such_attr&#39;)</code> 方法，但是，仅当在 obj、Class 和超类中找不到指定的属性时才会触发。<code>__getattr__</code>只在对象的类中寻找，而不在实例中寻找（这句话不是很明白）。</p></li><li><p><code>__getattribute__(self, name)</code>：点号、 <code>getattr</code> 和 <code>hasattr</code> 内置函数会触发这个方法。尝试获取指定的属性时总会调用这个方法，不过，寻找的<strong>属性是特殊属性或特殊方法时除外</strong>。</p><blockquote><p><strong>调用 <code>__getattribute__</code> 方法且抛出 AttributeError 异常时，才会调用 <code>__getattr__</code> 方法</strong>。为了在获取 obj 实例的属性时不导致无限递归，<code>__getattribute__</code> 方法的实现要使用 <code>super().__getattribute__(obj, name)</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="string">'''__getattr__ 与 __getattribute__的调用顺序'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">"attr"</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError <span class="comment"># 会进入__getattr__方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"__getattribute__"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"__getattr__"</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><code>__setattr__(self, name, value)</code>：尝试设置指定的属性时总会调用这个方法。</p><p>点号和 setattr 内置函数会触发这个方法。例如，<code>obj.attr = 42</code> 和 <code>setattr(obj, &#39;attr&#39;, 42)</code> 都会触发 <code>Class.__setattr__(obj, ‘attr’, 42)</code> 方法。</p></li><li><p><code>__delattr__(self, name)</code> ：只要使用 del 语句删除属性，就会调用这个方法。例如，<code>del obj.attr</code> 语句触发 <code>Class.__delattr__(obj, &#39;attr&#39;)</code> 方法。</p></li></ol><p><strong>注意</strong>：特殊方法 <code>__getattribute__</code> 和 <code>__setattr__</code>不管怎样都会调用，几乎会影响每一次属性存取</p><h3 id="实例方法、类方法、静态方法"><a href="#实例方法、类方法、静态方法" class="headerlink" title="实例方法、类方法、静态方法"></a>实例方法、类方法、静态方法</h3><p>首先形式上的区别：</p><ul><li><strong>实例方法</strong>隐含的参数为类实例self。</li><li><strong>类方法</strong>隐含的参数为类本身cls。 如果存在类的继承，那类方法获取的类是类树上最底层（具体）的类（子类）。</li><li><strong>静态方法</strong>无隐含参数，主要为了类实例也可以直接调用静态方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    class_var = <span class="string">"class_var"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">        self.class_var = name <span class="comment"># 绑定了实例属性class_var，并不会影响到外层真正的类属性</span></span><br><span class="line">        print(self.class_var)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">classMethod</span><span class="params">(cls, name)</span>:</span></span><br><span class="line">        print(cls)</span><br><span class="line">        print(cls.class_var)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">staticMethod</span><span class="params">(name)</span>:</span></span><br><span class="line">        print(name)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.class_var = <span class="string">"this is new"</span></span><br><span class="line"></span><br><span class="line">a.method(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment"># A.method("name") # 报错</span></span><br><span class="line">A.method(a, <span class="string">"name"</span>) <span class="comment"># 除非手动传入 实例对象</span></span><br><span class="line">print(<span class="string">"A的类属性不变："</span>, A.class_var)</span><br><span class="line"></span><br><span class="line">a.classMethod(<span class="string">"name"</span>) <span class="comment"># 会自动传入实例a的类A</span></span><br><span class="line">A.classMethod(<span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line">a.staticMethod(<span class="string">"name"</span>)</span><br><span class="line">A.staticMethod(<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>实例方法</th><th>类方法</th><th>静态方法</th></tr></thead><tbody><tr><td>实例调用</td><td>a.method(a,…)</td><td>a.classMethod(type(a),…)</td><td>a.staticMethod()</td></tr><tr><td>类调用</td><td>A.method(a,…)需要显式传入实例对象 <code>a</code></td><td>A.classMethod(A,…)</td><td>A.staticMethod()</td></tr></tbody></table><p>实例方法（普通方法）：随着实例属性的改变而改变</p><p>类方法（无论是类调用还是实例调用）：都是类属性的值，不随实例属性的变化而变化</p><p>静态方法：不可以访问类属性，故直接输出传入方法的值</p><ul><li><p>classmethod 最常见的用途是当函数只需要类的引用而不关心实例是什么的情况，另一个功能是定义备选 构造方法</p></li><li><p>staticmethod 不是特别有用，如果想定义不需要与类交互的函数，那么在模块中定义就好了。有时，函数虽然从不处理类，但是函数的功能与类紧密相关，因此想把它放在近处。即便如此，在同一模块中的类前面或后面定义函数也就行了。</p><blockquote><p>技术审校之一 Leonardo Rochael 不同意我对 staticmethod 的见解，作为反驳，他推荐阅读 Julien Danjou 写的一篇博客文章，题为<a href="https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods" target="_blank" rel="noopener">“The Definitive Guide on How to Use Static, Class or Abstract Methods in Python”</a>。Danjou 的这篇文章写得很好，我推 荐阅读。</p></blockquote></li></ul><h3 id="继承-TODO"><a href="#继承-TODO" class="headerlink" title="继承(TODO)"></a>继承(TODO)</h3><p>12章节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a=<span class="number">10</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b=<span class="number">20</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def __init__(self):</span></span><br><span class="line">    <span class="comment">#     super().__init__()</span></span><br></pre></td></tr></table></figure><p>与 java 不同，C 并不会继承实例的属性，默认<code>__init__</code>会调用超类的构造方法，因此会得到 a 属性，但是如果覆盖了<code>__init__</code>方法，没有调用超类的构造方法，就会失去 a 属性</p><h3 id="内置函数-特殊方法"><a href="#内置函数-特殊方法" class="headerlink" title="内置函数(特殊方法)"></a>内置函数(特殊方法)</h3><p>首先明确一点，<strong>特殊方法的存在是为了被 Python 解释器调用的</strong>，你自己并不需要调用它们。也就是说没有<code>my_object.__len__()</code>这种写法，而应该使用<code>len(my_object)</code>。</p><p><strong>特殊方法 不会被同名实例属性遮盖</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"class A"</span></span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># class A</span></span><br><span class="line">a.__str__=<span class="keyword">None</span> <span class="comment">#并不会被覆盖</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># class A</span></span><br></pre></td></tr></table></figure><p><strong>在执行<code>len(my_object)</code>的时候：</strong></p><ol><li>如果<code>my_object</code>是一个自定义类的对象，Python会自己去<strong>调用其中由你实现的<code>__len__</code>方法</strong>。</li><li><strong>如果是 Python 内置的类型</strong>，比如列表（list）、字符串（str）、字节序列 （bytearray）等，那么 CPython 会抄个近路，<code>__len__</code> 实际上<strong>会直接返回 PyVarObject 里的 ob_size 属性</strong>。PyVarObject 是表示内存中长度可变的内置对象的 C 语言结构体。直接读取这个值比调用一个方法要快很多。</li></ol><p>很多时候，特殊方法的调用是隐式的，比如 for i in x: 这个语句，背后其实用的是 iter(x)，而这个函数的背后则是 <code>x.__iter__()</code> 方法。当然前提是这个方法在 x 中被实现了。</p><p>通常你的代码无需直接使用特殊方法。通过内置的函数（例如len、iter、str，等等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。</p><h4 id="init-TODO"><a href="#init-TODO" class="headerlink" title="init TODO"></a>init TODO</h4><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>用于新建 <code>cls</code> 类的实例， <code>__new__()</code> 是静态方法（通过特殊方法实现的，不用<code>@staticmethod</code>）第一个参数是 需要创建出来的实例对应的类， 剩余的参数<code>args</code>将被传到 对象构造表达式（object constructor expression：<code>cls(args)</code>），<code>__new__()</code> 的返回值必须是一个新的对象，通常就是<code>cls</code>的实例。</p><p>覆盖 new 方法的一种典型实现是调用超类的 <code>__new__</code> 方法： <code>super().__new__(cls[, ...])</code> 然后对 新创建的实例 进行需要的操作，最后返回实例。</p><ul><li><p>如果返回的是 <code>cls</code>类的实例，就会调用该实例的 init 方法： <code>__init__(self[, ...])</code>,  <em>self</em> 就是这个实例本身，其他的参数与传递给 new 方法一样。</p></li><li><p>如果返回的不是 <code>cls</code>类的实例，就不会调用该实例的 init 方法</p></li></ul><p><a href="https://docs.python.org/3/reference/datamodel.html?highlight=__new__#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 主要是用于允许不可变类的子类(如 int, str, or tuple) 自定义实例的创建。 也常常在自定义的元类中被覆盖，用于自定义类的创建</p><p>new方法接受的参数虽然也是和init一样，<strong>init</strong> 和 <strong>new</strong> 最主要的区别在于：</p><ul><li><strong>new</strong> 是<u>创建这个类实例的方法</u>，通常用于控制生成一个新实例的过程。它是<strong>类级别的方法。</strong></li><li><strong>init</strong> 在得到 new 方法返回的实例后，用于初始化这个实例，<u>控制这个初始化的过程</u>，比如添加一些属性，做一些额外的操作，发生在类实例被创建完以后。它是<strong>实例级别的方法。</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">'''Silly Person'''</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, age)</span>:</span></span><br><span class="line">      print(<span class="string">'__new__ called.'</span>)</span><br><span class="line">      <span class="keyword">return</span> super(Person, cls).__new__(cls, name, age) </span><br><span class="line">      <span class="comment"># 调用超类的 new 方法</span></span><br><span class="line">      <span class="comment"># super().__new__(cls) 就会调用 object.__new__(Person)创建一个 Person 实例</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">      print(<span class="string">'__init__ called.'</span>)</span><br><span class="line">      self.name = name</span><br><span class="line">      self.age = age</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'&lt;Person: %s(%s)&gt;'</span> % (self.name, self.age)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__:</span></span><br><span class="line"><span class="string">piglei = Person(‘piglei’, 24)</span></span><br><span class="line"><span class="string">print(piglei)</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__new__ called.</span><br><span class="line">__init__ called.</span><br><span class="line"><span class="tag">&lt;<span class="name">Person:</span> <span class="attr">piglei</span>(<span class="attr">24</span>)&gt;</span></span><br></pre></td></tr></table></figure><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><h6 id="实现单例"><a href="#实现单例" class="headerlink" title="实现单例"></a>实现单例</h6><p>事实上，当我们理解了<strong>new</strong>方法后，我们还可以利用它来做一些其他有趣的事情，比如实现 设计模式中的 单例模式(singleton) 。<br>因为类每一次实例化后产生的过程都是通过<strong>new</strong>来控制的，所以通过重载<strong>new</strong>方法，我们 可以很简单的实现单例模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="comment"># 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'instance'</span>):</span><br><span class="line">            cls.instance = super(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"> </span><br><span class="line">obj1 = Singleton()</span><br><span class="line">obj2 = Singleton()</span><br><span class="line"> </span><br><span class="line">obj1.attr1 = <span class="string">'value1'</span></span><br><span class="line"><span class="keyword">print</span> obj1.attr1, obj2.attr1</span><br><span class="line"><span class="keyword">print</span> obj1 <span class="keyword">is</span> obj2</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>TODO：有参数的单例模式怎么实现</p><h6 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象 """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, arg)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(arg, abc.Mapping):</span><br><span class="line">            <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(arg, abc.MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(item) <span class="keyword">for</span> item <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():</span><br><span class="line">            <span class="keyword">if</span> iskeyword(key):</span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> FrozenJSON(self.__data[name])</span><br><span class="line"></span><br><span class="line">s=&#123;<span class="string">"key1"</span>:&#123;<span class="string">"num"</span>:<span class="number">11</span>&#125;,<span class="string">"key2"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">ss=FrozenJSON(s)</span><br><span class="line">print(ss.key1.num)</span><br><span class="line">print(ss.key2)</span><br><span class="line"><span class="comment"># 11</span></span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="repr与-str"><a href="#repr与-str" class="headerlink" title="repr与 str"></a>repr与 str</h4><ul><li><code>__repr__</code> 返回的字符串应该准确、无歧义，并且尽可能表达出如何用代码创建出这个被打印的对象。交互式控制台和调试程序（debugger）用 repr 函数来获取字符串表示形式；</li><li><code>__str__</code> 返回的字符串对终端用户更友好，在str()函数或是在用print函数打印一个对象的时候才被调用的</li></ul><p>如果你只想实现这两个特殊方法中的一个，<strong><code>__repr__</code> 是更好的选择</strong>，因为如果一个对象 没有 <code>__str__</code> 函数，而 Python 又需要调用它的时候，解释器会用 <code>__repr__</code> 作为替代。</p><p>使用 <strong>reprlib</strong> 模块可以生成长度有限的表示形式，<code>reprlib.repr()</code> 函数用于生成大型结构或递归结构的安全表示形式，它会限制输出字符串的长度，用 ‘…’ 表示截断的部分，如 <code>array(&#39;d&#39;, [0.0, 1.0, 2.0, 3.0, 4.0, …])</code>。</p><p> <a href="https://stackoverflow.com/questions/1436703/difference-between-str-and-repr" target="_blank" rel="noopener">Difference between <strong>str</strong> and <strong>repr</strong></a></p><h4 id="format格式化显示"><a href="#format格式化显示" class="headerlink" title="format格式化显示"></a>format格式化显示</h4><p>内置的<code>format()</code>函数和 <code>str.format()</code>方法把各个类型的格式化方式委托给相应的 <code>.__format__(format_spec)</code> 方法。<code>format_spec</code> 是格式说明符，它是：</p><ul><li><code>format(my_obj, format_spec)</code> 的第二个参数，或者 </li><li><code>str.format()</code> 方法的<code>str</code>中<code>{}</code> 代换字段中冒号后面的部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">1</span>/<span class="number">3</span></span><br><span class="line"></span><br><span class="line">format(n, <span class="string">'0.4f'</span>) <span class="comment"># 格式说明符是 '0.4f'</span></span><br><span class="line"><span class="comment"># 0.3333</span></span><br><span class="line"></span><br><span class="line"><span class="string">'n is &#123;rate:0.2f&#125;'</span>.format(rate=n) <span class="comment">#格式说明符是 '0.2f'</span></span><br><span class="line"><span class="comment"># n is 0.33</span></span><br></pre></td></tr></table></figure><p><code>{0.mass:5.3e}</code> 这样的格式字符串其实包含两部分，</p><ol><li><p>冒号左边的 <code>0.mass</code> 在代换字段句法中是<strong>字段名</strong>，</p></li><li><p>冒号后面的 <code>5.3e</code> 是<strong>格式说明符</strong>。</p><blockquote><p>格式说明符使用的表示法叫格式规范微语言(<a href="https://docs.python.org/3/library/string.html#formatspec" target="_blank" rel="noopener">Format Specification MiniLanguage</a>)</p></blockquote></li></ol><h5 id="自定义格式化代码"><a href="#自定义格式化代码" class="headerlink" title="自定义格式化代码"></a>自定义格式化代码</h5><p>如果类没有定义<code>__format__</code>方法，从 object 继承的方法<code>__format__</code>会返回 str(my_object)，然而，如果传入格式说明符，<code>object.__format__</code> 方法会抛出 TypeError</p><p>格式规范微语言是可扩展的，因为各个类可以自行决定如何解释 format_spec 参数。</p><p>为<strong>自定义的格式代码选择字母</strong>时，我会<strong>避免使用其他类型用过的字母</strong>。在格式 规范微语言(<a href="https://docs.python.org/3/library/string.html#formatspec" target="_blank" rel="noopener">Format Specification MiniLanguage</a>)中我们看到，整数使用的代码有 ‘bcdoxXn’，浮点数使用的代码有 ‘eEfFgGn%’，字符串使用的代码 有 ‘s’。因此，为极坐标选的代码是 ‘p’。各个类使用自己的方式解释格式代码， 在自定义的格式代码中重复使用代码字母是不会出错，但是可能会让用户困惑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>] <span class="comment">#删除 'p' 后缀</span></span><br><span class="line">            coords = (abs(self), self.angle()) <span class="comment">#极坐标：(magnitude, angle)</span></span><br><span class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">        components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(*components)</span><br></pre></td></tr></table></figure><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>为了把实例变成可散列的：</p><ol><li>必须使用 <code>__hash__</code> 方法，还需要<code>__eq__</code>方法</li><li>此外，还要<strong>让实例不可变</strong></li><li>根据特殊方法 <strong>hash</strong> 的文档 （<a href="https://docs.python.org/3/reference/datamodel.html），最好使用位运算符异或（^）**混合各分量的散列值**——我们会这么做。" target="_blank" rel="noopener">https://docs.python.org/3/reference/datamodel.html），最好使用位运算符异或（^）**混合各分量的散列值**——我们会这么做。</a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 是为了 tuple 方法能够使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br></pre></td></tr></table></figure><h4 id="iter-TODO"><a href="#iter-TODO" class="headerlink" title="iter(TODO)"></a>iter(TODO)</h4><h4 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h4><p>调用bytes() 函数时，会调用类中的<code>__byte__()</code>，返回字节序</p><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p><code>__dict__</code>是一个字典或者 mapping 类型的对象，用于保存对象可读写的属性（保存着实例中的全部属性）</p><ul><li><p><strong>属性引用</strong>[Attribute references]会被转换为在<code>__dict__</code>字典中查找， <code>m.x</code> 等价于 <code>m.__dict__[&quot;x&quot;]</code>.</p></li><li><p><strong>属性赋值</strong>[Attribute assignment] 会更新模块的命名空间字典（module’s namespace dictionary）， <code>m.x = 1</code> 等价于 <code>m.__dict__[&quot;x&quot;] = 1</code>.</p></li></ul><p>更新实例的 <code>__dict__</code> 属性，把值设为一个映射，能快速地在那个实例中创建一堆属性。</p><p>可以使用<code>vars(obj)</code>获取dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.key = <span class="number">0</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">'key1'</span>: <span class="number">1</span>, <span class="string">'key2'</span>: <span class="number">2</span>&#125;</span><br><span class="line">r = Record(**dic)</span><br><span class="line">print(r.__dict__)</span><br><span class="line">print(vars(r))</span><br><span class="line"><span class="comment"># &#123;'key': 0, 'key1': 1, 'key2': 2&#125;</span></span><br><span class="line"><span class="comment"># &#123;'key': 0, 'key1': 1, 'key2': 2&#125;</span></span><br></pre></td></tr></table></figure><p>Python 标准库中至少有两个与 Record 类似的类，其实例可以有任意个属性， 由传给构造方法的关键字参数构建——multiprocessing.Namespace 类和 argparse.Namespace 类</p><h4 id="getattr-TODO"><a href="#getattr-TODO" class="headerlink" title="getattr(TODO)"></a>getattr(TODO)</h4><p>个人结论：对找不到属性是，应该自定义 getattr，进行处理</p><h4 id="getattribute-TODO"><a href="#getattribute-TODO" class="headerlink" title="getattribute(TODO)"></a>getattribute(TODO)</h4><p>尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法 时除外。点号与 getattr 和 hasattr 内置函数会触发这个方法。调用 <strong>getattribute</strong> 方法且抛出 AttributeError 异常时，才会调用 <strong>getattr</strong> 方 法。为了在获取 obj 实例的属性时不导致无限递归，<strong>getattribute</strong> 方法的实现要 使用 super().<strong>getattribute</strong>(obj, name)。</p><p>Called unconditionally to implement attribute accesses for instances of the class. If the class also defines <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a>, the latter will not be called unless <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" target="_blank" rel="noopener"><code>__getattribute__()</code></a> either calls it explicitly or raises an <a href="https://docs.python.org/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>. This method should return the (computed) attribute value or raise an <a href="https://docs.python.org/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> exception.</p><p>In order to avoid infinite recursion in this method, its implementation should always call the base class method with the same name to access any attributes it needs, for example, <code>object.__getattribute__(self, name)</code>.</p><p>This method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" target="_blank" rel="noopener">Special method lookup</a>.</p><h4 id="setattr-TODO"><a href="#setattr-TODO" class="headerlink" title="__setattr__(TODO)"></a><code>__setattr__</code>(TODO)</h4><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在前面我们了解了<strong>对象属性访问和行为控制</strong>的一些特殊方法，例如<code>__getattribute__</code>、<code>__getattr__</code>、<code>__setattr__</code>、<code>__delattr__</code>。这些方法具有属性的”普适性”，可以用于属性查找、设置、删除的<strong>一般逻辑</strong>，也就是说<strong>所有的属性都可以使用这些方法实现属性的查找、设置、删除等操作。</strong></p><p>但是，这<strong>并不能很好地实现对某个具体属性的访问控制行为</strong>。假如要实现控制<code>dog.age</code>属性的类型只能是整数，如果单单去修改<code>__setattr__</code>方法满足它，那这个方法便有可能不能支持其他的属性设置。<strong>对属性的控制行为就由属性对象来控制</strong>。</p><p>这里单独抽离出来一个属性对象，在属性对象中定义这个属性的查找、设置、删除行为。这个属性对象就是描述符。<strong>描述符对象一般是作为其他类对象的属性而存在</strong>。在其内部定义了三个方法用来实现属性对象的查找、设置、删除行为，描述符是实现了特定协议的类：</p><ul><li><code>__get__</code>(self, instance, owner)：定义当试图取出描述符的值时的行为, owner 参数是托管类的 class 引用，instance 是该 class 的实例，self是描述符实例(具体术语请看后面定义)</li><li><code>__set__</code>(self, instance, value)：定义当描述符的值改变时的行为。</li><li><code>__delete__</code>(self, instance)：定义当描述符的值被删除时的行为。</li></ul><h3 id="术语概念"><a href="#术语概念" class="headerlink" title="术语概念"></a>术语概念</h3><p><img src="/2020/03/02/python进阶/./image-20190417114136034.png" alt="image-20190417114136034"></p><ul><li><p>描述符类：实现描述符协议的类。在图中，是 Quantity 类。</p></li><li><p>托管类：使用描述符对象管理类中某个属性的类，把描述符实例声明为<strong>类属性</strong>——图中的 LineItem 类。</p></li><li><p>描述符实例：描述符类的各个实例，声明为托管类的类属性。在图中，各个描述符实例使用箭头和带下划线的名称表示（在 UML 中，下划线表示类属性）。与黑色菱形接触的 LineItem 类包含描述符实例。</p></li><li><p>托管实例：托管类的实例。在这个示例中，LineItem 实例是托管实例（没在类图中展示）。</p></li><li><p>储存属性：托管【实例】中的属性<code>instance.__dict__[storage_name]</code>，用于存储由描述符管理的属性的值。在图中，LineItem 实例的 weight 和 price 属性是储存属性。这种属性与描述符属性不同，描述符属性都是类属性。</p></li><li><p>托管属性：托管类中由描述符实例处理的公开属性，值存储在储存属性中。虽然托管属性在托管类中定义，但是作用相当于实例属性（即各个实例通常有各自的值，存储在储存属性中）也就是说，<strong>描述符实例</strong>和<strong>储存属性</strong>为<strong>托管属性</strong>建立了基础。</p></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>描述符的用法是，创建 一个实例，作为另一个类的类属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">        self.storage_name = storage_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">          <span class="comment"># 必须直接处理托管实例的 __dict__ 属性；如果使用内置的 setattr 函数，因为[托管属性]和[储存属性]的名称不同，会再次触发 __set__ 方法，导致无限递归。</span></span><br><span class="line">            instance.__dict__[self.storage_name] = value </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = Quantity(<span class="string">'weight'</span>)</span><br><span class="line">    price = Quantity(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><p>不能试图使用下面这种错误的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.dict[self.storage_name] = value</span><br></pre></td></tr></table></figure><blockquote><p>错误的原因：想想 <code>__set__</code> 方法里的<code>self</code> 和 <code>instance</code>的意思。这里，<code>self</code> 是描述符实例，它其实是托管类的类属性。同一时刻，内存中可能有几千个 LineItem 实例，不过只会有2个描述符实例：LineItem.weight 和 LineItem.price。因此，存储在描述符实例中的数据，其实会变成 LineItem 类的类属性，从而由全部 LineItem 实例共享。</p></blockquote><h4 id="重复的属性名解决方案"><a href="#重复的属性名解决方案" class="headerlink" title="重复的属性名解决方案"></a>重复的属性名解决方案</h4><p>想要实现下面代码，避免重复的属性名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">weight = Quantity() </span><br><span class="line">price = Quantity()</span><br></pre></td></tr></table></figure><p>但是，赋值语句右手边的表达式先执行，而此时变量还不存在。 <code>Quantity()</code> 表达式计算的结果是创建描述符实例，而此时 Quantity 类中的代码无法猜出要把描述符绑定给哪个变量。</p><p>这里实现一个不太优雅但是可行的方案，更好的解决方案是使用类装饰器或元类：</p><p>想法：我们将为每个 Quantity 实例的 storage_name 属性自动生成一个唯一的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span> <span class="comment"># ❶ __counter 统计 Quantity 实例的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index) <span class="comment"># ❷ </span></span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>: <span class="comment"># ❹</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name) <span class="comment"># ➎</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span> <span class="comment"># ➏</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            setattr(instance, self.storage_name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><p>❷：定义[储存属性]，也就是<code>price = Quantity(&#39;price&#39;)</code>中右边的’price’，自动生成类似<code>_Quantity#0</code> 的储存属性名</p><p>❹：考虑<code>A.x</code>这种类直接访问属性的情况，具体看下面的 【触发 get 的几种形式】</p><p>➎，➏：这里可以使用内置的高阶函数 getattr 和 setattr 存取值，无需使用 <code>instance.__dict__</code>，因为托管属性和储存属性的名称不同</p><h3 id="触发-get-的几种形式"><a href="#触发-get-的几种形式" class="headerlink" title="触发 get 的几种形式"></a>触发 get 的几种形式</h3><p>参考：<a href="https://docs.python.org/3/howto/descriptor.html" target="_blank" rel="noopener">Descriptor HowTo Guide</a>、<a href="https://docs.python.org/3/reference/datamodel.html#invoking-descriptors" target="_blank" rel="noopener">Invoking Descriptors</a></p><p>描述符的方法调用起始于绑定<code>a.x</code>，从而触发<code>__getattribute__</code>方法，而参数如何装配，取决于<code>a</code>是实例还是类</p><ul><li>直接调用（少见）：代码直接调用描述符的 <code>__get__</code> 方法： <code>x.__get__(a)</code></li><li>实例绑定：<code>a.x</code> 由<code>object.__getattribute__()</code>转变为<code>type(a).__dict__[&#39;x&#39;].__get__(a, type(a))</code>.</li><li>类绑定：<code>A.x</code> 由<code>type.__getattribute__()</code>转变为<code>A.__dict__[&#39;x&#39;].__get__(None, A)</code>.</li><li>超类绑定：If a is an instance of super, then the binding super(B,obj).m() searches obj.<strong>class</strong>.<strong>mro</strong> for the base class Aimmediately preceding B and then invokes the descriptor with the call: <code>A.__dict__[&#39;m&#39;].__get__(obj, obj.__class__)</code>.(不太明白TODO)</li></ul><p>演示用的伪代码(TODO，不太明白)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">    <span class="string">"Emulate type_getattro() in Objects/typeobject.c"</span></span><br><span class="line">    v = object.__getattribute__(self, key)</span><br><span class="line">    <span class="keyword">if</span> hasattr(v, <span class="string">'__get__'</span>):</span><br><span class="line">        <span class="keyword">return</span> v.__get__(<span class="keyword">None</span>, self)</span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure><h3 id="特性工厂函数与描述符类比较"><a href="#特性工厂函数与描述符类比较" class="headerlink" title="特性工厂函数与描述符类比较"></a>特性工厂函数与描述符类比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        quantity.counter += <span class="number">1</span> <span class="comment"># counter 定义为 quantity 函数自身的属性</span></span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        quantity.counter = <span class="number">0</span></span><br><span class="line">        storage_name = <span class="string">'_&#123;&#125;:&#123;&#125;'</span>.format(<span class="string">'quantity'</span>, quantity.counter)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(instance, storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            setattr(instance, storage_name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure><p>我喜欢描述符类那种方式，主要有下列两个原因。</p><ol><li>描述符类可以使用子类扩展；若想重用工厂函数中的代码，除了复制粘贴，很难有其他方法。</li><li>与工厂函数中使用函数属性和闭包保持状态相比，在类属性和实例属性中保持状态更易于理解。</li></ol><h3 id="继承描述符"><a href="#继承描述符" class="headerlink" title="继承描述符"></a>继承描述符</h3><p>商品的描述信息不能为空，我们要再创建一个描述符：NonBlank。在设计 NonBlank 的过程中，我们发现，它与 Quantity 描述符很像，只是验证逻辑不同。</p><p>回想 Quantity 的功能，我们注意到它做了两件不同的事：管理托管实例中的储存属性， 以及验证用于设置那两个属性的值。由此可知，我们可以重构，并创建两个基类。</p><p><img src="/2020/03/02/python进阶/./image-20190424092434540.png" alt="image-20190424092434540"></p><p>模板方法设计模式：一个模板方法用一些抽象的操作定义一个算法，而子类将重定义这些操作以提供具体 的行为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span></span><br><span class="line">  </span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)</span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validated</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line"><span class="string">'''抽象基类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = self.validate(instance, value) <span class="comment"># set之前调用验证方法</span></span><br><span class="line">        super().__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validated)</span>:</span></span><br><span class="line">    <span class="string">"""继承Validated，实现具体的验证逻辑"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validated)</span>:</span></span><br><span class="line">    <span class="string">"""继承Validated，实现具体的验证逻辑：at least one non-space character"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">  description = NonBlank()</span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><h3 id="描述符的种类"><a href="#描述符的种类" class="headerlink" title="描述符的种类"></a>描述符的种类</h3><p>参考：<a href="https://docs.python.org/3/howto/descriptor.html" target="_blank" rel="noopener">https://docs.python.org/3/howto/descriptor.html</a></p><ul><li>任意实现<code>__get__</code>、<code>__set__</code>、<code>__delete__</code>方法中的一个就可以认为是描述符；</li><li>只实现<code>__get__</code> 方法的对象是<strong>非数据描述符（non-data descriptor）</strong>，意味着在初始化之后它们只能被读取，会被实例属性覆盖。常用于方法(方法其实是非属性描述符)</li><li>实现了<code>__get__</code> 和<code>__set__</code> 的对象是<strong>数据描述符（data descriptor）</strong></li><li>个人结论：只有<code>__set__</code>的对象不是数据描述符</li><li>实现<code>__set__</code>、<code>__delete__</code>中的任意一个的对象是数据描述符，意味着这种属性是可读写的。通常<code>__get__</code> 和<code>__set__</code> 都会定义，会覆盖普通实例属性；如果没有定义 <code>__get__</code> ，在实例中没有同名的实例属性的情况，返回描述符本身，否则返回实例属性</li><li>描述符的调用由<code>__getattribute__()</code> 方法触发，覆盖该方法可以阻止描述符的调用</li></ul><blockquote><p><a href="http://python.jobbole.com/88582/" target="_blank" rel="noopener">http://python.jobbole.com/88582/</a></p></blockquote><p><strong>特性(property)是数据描述符</strong>，不论有没有使用<a href="mailto:`@attr.setter" target="_blank" rel="noopener">`@attr.setter</a><code>定义赋值函数，因为这个类实现了</code><strong>set</strong>`方法，默认抛出 AttributeError: can’t set attribute(具体看【特性】-property 源码 这一节)</p><p><strong>推荐看属性的【访问优先级规则】，才能深刻理解为什么会有下面的现象</strong></p><p>定义做实验的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 辅助函数，仅用于显示 ###</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cls_name</span><span class="params">(obj_or_cls)</span>:</span></span><br><span class="line">    cls = type(obj_or_cls)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        cls = obj_or_cls</span><br><span class="line">    <span class="keyword">return</span> cls.__name__.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(obj)</span>:</span></span><br><span class="line">    cls = type(obj)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;class &#123;&#125;&gt;'</span>.format(obj.__name__)</span><br><span class="line">    <span class="keyword">elif</span> cls <span class="keyword">in</span> [type(<span class="keyword">None</span>), int]:</span><br><span class="line">        <span class="keyword">return</span> repr(obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; object&gt;'</span>.format(cls_name(obj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_args</span><span class="params">(name, *args)</span>:</span></span><br><span class="line">    pseudo_args = <span class="string">', '</span>.join(display(x) <span class="keyword">for</span> x <span class="keyword">in</span> args)</span><br><span class="line">    print(<span class="string">'-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'</span>.format(cls_name(args[<span class="number">0</span>]), name, pseudo_args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 对这个示例重要的类 ###</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Overriding</span>:</span></span><br><span class="line">    <span class="string">"""也称数据描述符或强制描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingNoGet</span>:</span>  <span class="comment"># ➌</span></span><br><span class="line">    <span class="string">"""没有``__get__``方法的覆盖型描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonOverriding</span>:</span>  <span class="comment"># ➍</span></span><br><span class="line">    <span class="string">"""也称非数据描述符或遮盖型描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Managed</span>:</span>  <span class="comment"># ➎ 托管类，使用各个描述符类的一个实例。</span></span><br><span class="line"></span><br><span class="line">    over = Overriding()</span><br><span class="line">    over_no_get = OverridingNoGet()</span><br><span class="line">    non_over = NonOverriding()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span>  <span class="comment"># ➏ 方法也是描述符，下一节会介绍</span></span><br><span class="line">        print(<span class="string">'-&gt; Managed.spam(&#123;&#125;)'</span>.format(display(self)))</span><br></pre></td></tr></table></figure><h4 id="同时有-get和set的数据描述符"><a href="#同时有-get和set的数据描述符" class="headerlink" title="同时有 get和set的数据描述符"></a>同时有 get和set的数据描述符</h4><p><strong>特性(property)是数据描述符</strong>，不论有没有使用<a href="mailto:`@attr.setter" target="_blank" rel="noopener">`@attr.setter</a><code>定义赋值函数，因为这个类实现了</code><strong>set</strong>`方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">obj = Managed()</span><br><span class="line"></span><br><span class="line">obj.over <span class="comment"># ➋ 触发描述符 __get__ 方法，第二个参数（instance）的值是托管实例 obj</span></span><br><span class="line"><span class="comment"># -&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br><span class="line"></span><br><span class="line">Managed.over <span class="comment"># ➌ 触发描述符 __get__ 方法，第二个参数（instance）的值是 None</span></span><br><span class="line"><span class="comment"># -&gt; Overriding.__get__(&lt;Overriding object&gt;, None, &lt;class Managed&gt;)</span></span><br><span class="line"></span><br><span class="line">obj.over = <span class="number">7</span> <span class="comment"># ➍ 触发描述符 __set__ 方法</span></span><br><span class="line"><span class="comment"># -&gt; Overriding.__set__(&lt;Overriding object&gt;, &lt;Managed object&gt;, 7)</span></span><br><span class="line"></span><br><span class="line">obj.over </span><br><span class="line"><span class="comment"># -&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br><span class="line"></span><br><span class="line">obj.__dict__[<span class="string">'over'</span>] = <span class="number">8</span> <span class="comment"># ➏ 跳过描述符</span></span><br><span class="line">vars(obj)</span><br><span class="line"><span class="comment"># &#123;'over': 8&#125;</span></span><br><span class="line"></span><br><span class="line">obj.over <span class="comment"># ➑ 即使有名为 over 的实例属性，Managed.over 描述符仍会覆盖读取 obj.over 这个操作。</span></span><br><span class="line"><span class="comment"># -&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br></pre></td></tr></table></figure><h4 id="只有-set-的数据描述符"><a href="#只有-set-的数据描述符" class="headerlink" title="只有 set 的数据描述符"></a>只有 set 的数据描述符</h4><p>覆盖型描述符既会实现 <code>__set__</code> 方法，也会实现 <code>__get__</code> 方法，不过也可以只实 现 <code>__set__</code> 方法。</p><p>赋值操作还是由描述符的 <code>__set__</code> 接管，而取值操作，分2种情况：</p><ul><li>有同名实例属性：返回实例属性</li><li>没有同名实例属性：返回描述符对象本身</li></ul><p>也就是说，<strong>实例属性的读操作 会遮盖描述符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">obj=Managed()</span><br><span class="line"></span><br><span class="line">obj.over_no_get <span class="comment"># ➊ 没有同名实例属性，返回描述符本身</span></span><br><span class="line"><span class="comment"># &lt;__main__.OverridingNoGet object at 0x665bcc&gt;</span></span><br><span class="line"></span><br><span class="line">Managed.over_no_get <span class="comment"># ➋ 直接从类属性中获取描述符本身，不考虑实例属性</span></span><br><span class="line"><span class="comment"># &lt;__main__.OverridingNoGet object at 0x665bcc&gt;</span></span><br><span class="line"></span><br><span class="line">obj.over_no_get = <span class="number">7</span> <span class="comment"># ➌</span></span><br><span class="line"><span class="comment"># -&gt; OverridingNoGet.__set__(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)</span></span><br><span class="line"></span><br><span class="line">obj.over_no_get <span class="comment"># ➍ 没有同名实例属性，仍然返回描述符本身</span></span><br><span class="line"><span class="comment"># &lt;__main__.OverridingNoGet object at 0x665bcc&gt;</span></span><br><span class="line"></span><br><span class="line">obj.__dict__[<span class="string">'over_no_get'</span>] = <span class="number">9</span> <span class="comment"># 添加同名实例属性</span></span><br><span class="line">obj.over_no_get <span class="comment"># ➏ 同名实例属性会遮盖描述符</span></span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">obj.over_no_get = <span class="number">7</span> <span class="comment"># ➐ 赋值经过描述符的 __set__ 方法处理</span></span><br><span class="line"><span class="comment"># -&gt; OverridingNoGet.__set__(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)</span></span><br><span class="line"></span><br><span class="line">obj.over_no_get <span class="comment"># ➑ 读取时，只要有同名的实例属性，描述符就会被遮盖</span></span><br><span class="line"><span class="comment"># 9</span></span><br></pre></td></tr></table></figure><h4 id="只有-get-的非数据描述符"><a href="#只有-get-的非数据描述符" class="headerlink" title="只有 get 的非数据描述符"></a>只有 get 的非数据描述符</h4><p>如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。</p><blockquote><p>作用：类中的方法就是非数据描述符，请看 【方法是非数据描述符 】一节</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj = Managed()</span><br><span class="line"></span><br><span class="line">obj.non_over ➊</span><br><span class="line"><span class="comment"># -&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br><span class="line"></span><br><span class="line">obj.non_over = <span class="number">7</span> ➋</span><br><span class="line">obj.non_over <span class="comment"># ➌ 现在，obj 有名为 non_over 的实例属性，把 Managed 类的同名描述符属性遮盖掉</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line">Managed.non_over <span class="comment"># ➍ 描述符依然存在，会通过类截获这次访问，触发描述符的__get__</span></span><br><span class="line"><span class="comment"># -&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, None, &lt;class Managed&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> obj.non_over <span class="comment"># ➎ 删除实例属性</span></span><br><span class="line">obj.non_over <span class="comment"># ➏ 恢复触发类中描述符的 __get__ 方法</span></span><br><span class="line"><span class="comment"># -&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br></pre></td></tr></table></figure><h4 id="在类中覆盖描述符"><a href="#在类中覆盖描述符" class="headerlink" title="在类中覆盖描述符"></a>在类中覆盖描述符</h4><p>从上面例子可以看出，依附在类上的描述符无法控制为类属性赋值的操作。其实，这意味着为类属性赋值能覆盖 描述符属性</p><p>不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。这是一种猴子补丁技术</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj = Managed()</span><br><span class="line">Managed.over = <span class="number">1</span></span><br><span class="line">Managed.over_no_get = <span class="number">2</span></span><br><span class="line">Managed.non_over = <span class="number">3</span></span><br><span class="line">obj.over, obj.over_no_get, obj.non_over</span><br><span class="line"><span class="comment"># (1, 2, 3)</span></span><br></pre></td></tr></table></figure><p>揭示了<strong>读写属性的另一种不对等</strong>：<strong>读类属性</strong>的操作可以由<strong>依附</strong>在托管类上定义有 <code>__get__</code> 方法的描述符处理，但是<strong>写类属性</strong>的操作<strong>不会由依附</strong>在托管类上定义有 <code>__set__</code> 方法的描述符处理</p><p>若<strong>想控制设置类属性的操作</strong>，要把描述符依附在类的类上，即依附在元类上。 默认情况下，对用户定义的类来说，其元类是 type</p><h3 id="描述符用法建议"><a href="#描述符用法建议" class="headerlink" title="描述符用法建议"></a>描述符用法建议</h3><p>内置的 property 类创建的其实是覆盖型描述符，<strong>set</strong> 方法和 <strong>get</strong> 方法都 实现了，即便不定义设值方法也是如此。特性的 <strong>set</strong> 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特 性</p><h4 id="只读描述符"><a href="#只读描述符" class="headerlink" title="只读描述符"></a>只读描述符</h4><p>并非只实现 get，<strong><code>__get__</code> 和 <code>__set__</code> 两个方法必须都定义</strong>，否则，实例的同名属性会遮盖描述符，只读属性<code>__set__</code>方法只需抛出 AttributeError 异常即可</p><h4 id="用于验证的描述符"><a href="#用于验证的描述符" class="headerlink" title="用于验证的描述符"></a>用于验证的描述符</h4><p>仅用于验证的描述符<code>attr</code>，<code>__set__</code> 方法应该检查 value 参数获得的值，然后使用描述符实例的名称为键，直接设置 <code>instance.__dict__[&#39;attr&#39;]=value</code> </p><p>可以没有 <code>__get__</code> 方法，这样，<strong>从实例中读取同名属性的速度很快</strong>，因为不用经过 <code>__get__</code> 方法处理</p><h4 id="只有-get-的描述符-高效缓存"><a href="#只有-get-的描述符-高效缓存" class="headerlink" title="只有 __get__的描述符(高效缓存)"></a>只有 <code>__get__</code>的描述符(高效缓存)</h4><p>那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，得到 value，然后通过<code>instance.__dict__[&#39;attr&#39;]=value</code>中设置同名属性，缓存结果，实例属性就会覆盖描述符。</p><h4 id="特殊方法不会被实例属性覆盖"><a href="#特殊方法不会被实例属性覆盖" class="headerlink" title="特殊方法不会被实例属性覆盖"></a>特殊方法不会被实例属性覆盖</h4><p>像<code>my_obj.the_method = 7</code> 这样简单赋值之后，后续通过该实例访问 the_method 得到的是数字 7，特殊方法不受这个问题的影响。<strong>解释器只会在类中寻找特殊的方法</strong>，也就是说 <code>repr(x)</code> 执行的其实是 <code>x.__class__.__repr__(x)</code></p><h3 id="属性访问的优先级规则"><a href="#属性访问的优先级规则" class="headerlink" title="属性访问的优先级规则"></a>属性访问的优先级规则</h3><p>参考：Invoking Descriptors<a href="https://docs.python.org/3/reference/datamodel.html#invoking-descriptors" target="_blank" rel="noopener">¶</a></p><p>获取属性时，必然调用默认 <code>Class.__getattribute__</code>，其内部逻辑如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">()</span>:</span></span><br><span class="line">    cls_attr = <span class="keyword">None</span>  <span class="comment"># 类中找到的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历父类链，查看每个类的 dict</span></span><br><span class="line">    <span class="keyword">for</span> <span class="class"><span class="keyword">class</span> <span class="title">in</span> <span class="title">obj</span>.<span class="title">mro</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="class"><span class="keyword">class</span>.<span class="title">__dict__</span>['<span class="title">x</span>'] <span class="title">is</span> <span class="title">not</span> <span class="title">None</span>:</span>  <span class="comment"># 类字典中查找</span></span><br><span class="line">            cls_attr =<span class="class"><span class="keyword">class</span> .<span class="title">__dict__</span>['<span class="title">x</span>']</span></span><br><span class="line"><span class="class">            <span class="title">break</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">if</span> <span class="title">cls_attr</span> <span class="title">is</span> <span class="title">not</span> <span class="title">None</span> <span class="title">and</span> <span class="title">is</span> <span class="title">Data</span> <span class="title">Descriptor</span>：</span></span><br><span class="line"><span class="class">        <span class="title">return</span> <span class="title">cls_attr</span>.<span class="title">__get__</span><span class="params">()</span>  # 返回数据描述符的值<span class="params">(get 和 set 都有)</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">if</span> <span class="title">obj</span>.<span class="title">__dict__</span>['<span class="title">x</span>'] <span class="title">is</span> <span class="title">not</span> <span class="title">None</span>:</span></span><br><span class="line">        <span class="keyword">return</span> obj.__dict__[<span class="string">'x'</span>]  <span class="comment"># 实例字典中查找</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cls_attr <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> cls_attr <span class="keyword">is</span> Non-Data Descriptor：<span class="comment">#(只有 get)</span></span><br><span class="line">            <span class="keyword">return</span> cls_attr.__get__()</span><br><span class="line">        <span class="keyword">return</span> cls_attr <span class="comment"># 普通数据、只有set的描述符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">raise</span> AttributeError</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> Class has the special method __getattr__:</span><br><span class="line">    <span class="keyword">return</span> Class.__getattr__()</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="/2020/03/02/python进阶/Users/jizhongxian/notes/markdown/python/pyhton%E9%AB%98%E7%BA%A7/%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="img"></p><blockquote><p>图来自：<a href="http://python.jobbole.com/88582/" target="_blank" rel="noopener">http://python.jobbole.com/88582/</a></p></blockquote><p>实验验证的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### 辅助函数，仅用于显示 ###</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cls_name</span><span class="params">(obj_or_cls)</span>:</span></span><br><span class="line">    cls = type(obj_or_cls)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        cls = obj_or_cls</span><br><span class="line">    <span class="keyword">return</span> cls.__name__.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(obj)</span>:</span></span><br><span class="line">    cls = type(obj)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;class &#123;&#125;&gt;'</span>.format(obj.__name__)</span><br><span class="line">    <span class="keyword">elif</span> cls <span class="keyword">in</span> [type(<span class="keyword">None</span>), int]:</span><br><span class="line">        <span class="keyword">return</span> repr(obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; object&gt;'</span>.format(cls_name(obj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_args</span><span class="params">(name, *args)</span>:</span></span><br><span class="line">    pseudo_args = <span class="string">', '</span>.join(display(x) <span class="keyword">for</span> x <span class="keyword">in</span> args)</span><br><span class="line">    print(<span class="string">'-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'</span>.format(cls_name(args[<span class="number">0</span>]), name, pseudo_args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 对这个示例重要的类 ###</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Overriding</span>:</span></span><br><span class="line">    <span class="string">"""也称数据描述符或强制描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingNoGet</span>:</span>  <span class="comment"># ➌</span></span><br><span class="line">    <span class="string">"""没有``__get__``方法的覆盖型描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonOverriding</span>:</span>  <span class="comment"># ➍</span></span><br><span class="line">    <span class="string">"""也称非数据描述符或遮盖型描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    over = Overriding()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"getattr"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Managed</span><span class="params">(Parent)</span>:</span>  <span class="comment"># ➎ 托管类，使用各个描述符类的一个实例。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__dict__[<span class="string">'over'</span>] = <span class="string">"obj.over"</span></span><br><span class="line">        self.__dict__[<span class="string">'over_no_get'</span>] = <span class="string">"obj.over_no_get"</span></span><br><span class="line">        self.__dict__[<span class="string">'non_over'</span>] = <span class="string">"obj.non_over"</span></span><br><span class="line"></span><br><span class="line">    over_no_get = OverridingNoGet()</span><br><span class="line">    over_no_get_cls = OverridingNoGet()</span><br><span class="line">    attr_cls = <span class="string">'attr_cls'</span></span><br><span class="line">    non_over = NonOverriding()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span>  <span class="comment"># ➏ 方法也是描述符，下一节会介绍</span></span><br><span class="line">        print(<span class="string">'-&gt; Managed.spam(&#123;&#125;)'</span>.format(display(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dd = Managed()</span><br><span class="line">print(dd.over)<span class="comment"># -&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br><span class="line">print(dd.over_no_get)<span class="comment"># obj.over_no_get</span></span><br><span class="line">print(dd.over_no_get_cls)<span class="comment"># &lt;__main__.OverridingNoGet object at 0x10d0ca320&gt;</span></span><br><span class="line">print(dd.attr_cls)<span class="comment"># attr_cls</span></span><br><span class="line">print(dd.non_over)<span class="comment"># obj.non_over</span></span><br><span class="line">print(dd.none)<span class="comment"># getattr</span></span><br></pre></td></tr></table></figure><h3 id="方法是非数据描述符"><a href="#方法是非数据描述符" class="headerlink" title="方法是非数据描述符"></a>方法是非数据描述符</h3><p>参考：<a href="https://docs.python.org/3/howto/descriptor.html#id8" target="_blank" rel="noopener">Functions and Methods</a></p><p>在类中定义的函数属于绑定方法类型（bound method）一种可调用类型，因为<strong>用户定义的函数都有 <code>__get__</code> 方法，但没有<code>__set__</code>方法</strong>，所以依附到类上时，就相当于<strong>非数据描述符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></span><br><span class="line">        <span class="string">"Simulate func_descr_get() in Objects/funcobject.c"</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> types.MethodType(self, obj)</span><br></pre></td></tr></table></figure><p>s<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.f</span><br></pre></td></tr></table></figure></p><p>s</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"Emulate PyClassMethod_Type() in Objects/funcobject.c"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, klass=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> klass <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            klass = type(obj)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*args)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.f(klass, *args)</span><br><span class="line">        <span class="keyword">return</span> newfunc</span><br></pre></td></tr></table></figure><p>z</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Managed</span>:</span>  <span class="comment"># ➎ 托管类，使用各个描述符类的一个实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#over = Overriding()</span></span><br><span class="line">    <span class="comment">#over_no_get = OverridingNoGet()</span></span><br><span class="line">    <span class="comment">#non_over = NonOverriding()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span>  <span class="comment"># ➏ 方法也是描述符，下一节会介绍</span></span><br><span class="line">        print(<span class="string">'-&gt; Managed.spam(&#123;&#125;)'</span>.format(display(self)))</span><br><span class="line"></span><br><span class="line">o = Managed()</span><br><span class="line">print(o.spam) <span class="comment"># ➊</span></span><br><span class="line"><span class="comment"># &lt;bound method Managed.spam of &lt;__main__.Managed object at 0x10909f160&gt;&gt;</span></span><br><span class="line">print(Managed.spam) <span class="comment"># ❷ </span></span><br><span class="line"><span class="comment"># &lt;function Managed.spam at 0x109097730&gt;</span></span><br></pre></td></tr></table></figure><p>➊ obj.spam 获取的是绑定方法对象。 </p><p>❷ 但是 Managed.spam 获取的是函数。</p><p>深入理解这种机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(collections.UserString)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Text(&#123;!r&#125;)'</span>.format(self.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">word = Text(<span class="string">'forward'</span>)</span><br><span class="line"></span><br><span class="line">print(word) <span class="comment">#➊</span></span><br><span class="line"><span class="comment"># Text('forward')</span></span><br><span class="line"></span><br><span class="line">print(word.reverse()) <span class="comment">#➋</span></span><br><span class="line"><span class="comment"># Text('drawrof')</span></span><br><span class="line"></span><br><span class="line">print(Text.reverse(word)) <span class="comment"># ➌等价于➋，显示地传入self参数:word对象</span></span><br><span class="line"><span class="comment"># Text('drawrof')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#与上面一样，显示地传入self参数:各种可迭代对象</span></span><br><span class="line">list(map(Text.reverse, [<span class="string">'repaid'</span>, (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>), Text(<span class="string">'stressed'</span>)]))</span><br><span class="line"><span class="comment"># ['diaper', (30, 20, 10), Text('desserts')]</span></span><br><span class="line"></span><br><span class="line">type(word.reverse),type(Text.reverse) <span class="comment"># ➍</span></span><br><span class="line"><span class="comment"># (&lt;class 'function'&gt;, &lt;class 'method'&gt;)</span></span><br><span class="line"></span><br><span class="line">Text.reverse.__get__(word) <span class="comment"># ➏ 等价于 word.reverse</span></span><br><span class="line"><span class="comment"># &lt;bound method Text.reverse of Text('forward')&gt;</span></span><br><span class="line"></span><br><span class="line">Text.reverse.__get__(<span class="keyword">None</span>, Text) <span class="comment"># ➐ 等价于 Text.reverse</span></span><br><span class="line"><span class="comment"># &lt;function Text.reverse at 0x101244e18&gt;</span></span><br><span class="line"></span><br><span class="line">word.reverse.__self__ <span class="comment"># ➑</span></span><br><span class="line"><span class="comment"># Text('forward')</span></span><br><span class="line"></span><br><span class="line">word.reverse.__func__ <span class="keyword">is</span> Text.reverse <span class="comment"># ➒ </span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">word.reverse.__call__ <span class="comment"># ➓ </span></span><br><span class="line"><span class="comment"># &lt;method-wrapper '__call__' of method object at 0x100aae988&gt;</span></span><br></pre></td></tr></table></figure><p>❽ 绑定方法对象有个 <code>__self__</code> 属性，其值是调用这个方法的实例引用</p><p>➒ 绑定方法的 <code>__func__</code> 属性是依附在托管类上那个原始函数的引用</p><h4 id="类中的方法第一个参数是-self-的秘密➓"><a href="#类中的方法第一个参数是-self-的秘密➓" class="headerlink" title="类中的方法第一个参数是 self 的秘密➓"></a>类中的方法第一个参数是 <code>self</code> 的秘密➓</h4><blockquote><p>与描述符一样，</p><p>通过托管类访问时，函数的 <code>__get__</code> 方法会返回自身的引用。但是，</p><p>通过实例访问时，函数的 <code>__get__</code> 方法返回的是绑定方法对象：一种可调用的对象，➓ 有个 <code>__call__</code> 方法，用于处理真正的调用过程。这个方法会调用 <code>__func__</code> 属性引用的原始函数，把函数的第一个参数设为绑定方法的 <code>__self__</code> 属性。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><a href="https://www.cnblogs.com/allen2333/p/8862341.html" target="_blank" rel="noopener">Python - 协议和鸭子类型</a></p><h4 id="鸭子类型（duck-typing）"><a href="#鸭子类型（duck-typing）" class="headerlink" title="鸭子类型（duck typing）"></a><strong>鸭子类型</strong>（duck typing）</h4><p>​    忽略对象的真正类型，转而关注对象有没有实现所需 的方法、签名和语义</p><p>​    多态的一种形式，在这种形式中，不管对象属于哪个类，也不管声明的具体接口是什 么，只要对象实现了相应的方法，函数就可以在对象上执行操作。</p><p>​    对 Python 来说，这基本上是指<strong>避免使用 isinstance 检查对象的类型</strong>（更别提 type(foo) is bar 这种更糟的检查方式了</p><p><strong>由来</strong>：</p><ol><li>When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.——James Whitcomb Riley</li><li><strong>不关注对象的类型，而关注对象的行为(方法)。</strong>它的行为是鸭子的行为，那么可以认为它是鸭子。</li></ol><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ol><li>在面向对象编程中，协议是<strong>非正式</strong>的接口，是一组方法，但只是一种文档，语言不对施加特定的措施或者强制实现。</li><li>虽然协议是非正式的，<strong>在Python中，应该把协议当成正式的接口。</strong></li><li>Python中存在多种协议，用于实现<strong>鸭子类型（对象的类型无关紧要，只要实现了特定的协议（一组方法）即可）</strong>。</li><li>需要成为相对应的鸭子类型，那就实现相关的协议，即相关的<code>__method__</code>。例如实现序列协议(<code>__len__</code>和<code>__getitem__</code>)，这个类就表现得像序列。</li><li>协议是正式的，没有强制力，可以根据具体场景实现一个具体协议的一部分。例如，为了支持迭代，只需实现<code>__getitem__</code>，不需要实现<code>__len__</code>。</li><li>在Python文档中，如果看到“文件类对象“（表现得像文件的对象），通常说的就是协议，这个对象就是鸭子类型。这是一种简短的说法，意思是：“行为基本与文件一致，实现了部分文件接口，满足上下文相关需求的东西。”</li><li></li></ol><p>猴子补丁：在运行时修 改类或模块，而不改动源码。</p><h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p>Alex Martelli 的警告：不要自己定义抽象基类，除非你要构建允许 用户扩展的框架。日常使用中，我们与抽象基类的联系应 该是创建现有抽象基类的子类，或者使用现有的抽象基类注册。</p><ul><li>声明抽象基类最简单的方式是继承 abc.ABC 或其他抽象基类</li></ul><blockquote><p>abc.ABC 是 Python 3.4 新增的类，如果你使用的是旧版 Python，那么无法继承现有的抽象基类。此时，必须在 class 语句中使用 metaclass= 关键字，把值设为 abc.ABCMeta（不是 abc.ABC）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 这是Python &lt; 3.4</span></span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line">&gt;      ...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在 Python 2 中必须使用 <code>__metaclass__</code> 类 属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 这是Python 2 ！！！ </span></span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(object)</span>:</span> </span><br><span class="line">&gt;     __metaclass__ = abc.ABCMeta</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>抽象方法使用 @abstractmethod 装饰器标记，而且定义体中通常只有文档字符串</li></ul><blockquote><p>除了 @abstractmethod 之外，abc 模块还定义了 <del>@abstractclassmethod、@abstractstaticmethod 和 @abstractproperty</del> 三个装饰器。然而，后三个装饰器从 Python 3.3 起废弃了，因为装饰器可以在 @abstractmethod 上堆叠，<code>abstractmethod()</code> 应该放在最里层，声明抽象类方法的推荐方式是：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod </span></span><br><span class="line"><span class="meta">    @abc.abstractmethod </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">an_abstract_classmethod</span><span class="params">(cls, ...)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="继承抽象基类"><a href="#继承抽象基类" class="headerlink" title="继承抽象基类"></a>继承抽象基类</h4><h5 id="具体子类"><a href="#具体子类" class="headerlink" title="具体子类"></a>具体子类</h5><p>必须实现全部的抽象方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Abstract)</span>:</span></span><br><span class="line">     <span class="string">'''实现全部抽象函数'''</span></span><br></pre></td></tr></table></figure><h5 id="虚拟子类"><a href="#虚拟子类" class="headerlink" title="虚拟子类"></a>虚拟子类</h5><p>注册虚拟子类的方式是<strong>在抽象基类上调用 register 方法</strong>。这么做之后，注册的类会变成 抽象基类的虚拟子类，而且 issubclass 和 isinstance 等函数都能识别，但是注册的类 <strong>不会从抽象基类中继承任何方法或属性</strong>。</p><blockquote><p>register 方法通常作为普通的函数调用（参见 11.9 节），不过也可以作为装饰器使用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tombola.register   # Tombola是抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3.3 或之前的版本，不能把 .register 当作类装饰器使用，必须使用标准的调用句法。</span></span><br><span class="line">Tombola.register(TomboList)</span><br></pre></td></tr></table></figure><p>虚拟子类不会继承注册的抽象基类，而且任何时候都不会检查它是否符合抽 象基类的接口，即便在实例化时也不会检查。为了避免运行时错误，虚拟子类要实现 所需的全部方法。(不明白)TODO</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>python异常之间的层次结构：<a href="https://docs.python.org/dev/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">Exception hierarchy</a></p><p><img src="/2020/03/02/python进阶/./image-20190408221552773.png" alt="image-20190408221552773"></p><h2 id="元类编程"><a href="#元类编程" class="headerlink" title="元类编程"></a>元类编程</h2><h3 id="类工厂函数"><a href="#类工厂函数" class="headerlink" title="类工厂函数"></a>类工厂函数</h3><p>通常，我们把 type 视作函数，因为我们像函数那样使用它，例如，调用 <code>type(obj)</code> 获取对象所属的类——作用与 <code>obj.__class__</code> 相同。然而，type 是一个类。当成类使用时，传入三个参数可以新建一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (MySuperClass, MyMixin), &#123;<span class="string">'x'</span>: <span class="number">42</span>, <span class="string">'x2'</span>: <span class="keyword">lambda</span> self: self.x * <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><p>type 的三个参数分别是 <code>name</code>、<code>bases</code> 和 <code>dict</code>。最后一个参数是一个映射，指定新类的属性名和值。上述代码的作用与下述代码相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MySuperClass, MyMixin)</span>:</span></span><br><span class="line">    x = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>因此尝试创建一个类似于 namedtuple 的类工厂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_factory</span><span class="params">(cls_name, field_names)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:  <span class="comment"># 不能调用.replace或.split方法</span></span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 假定field_names本就是标识符组成的序列 field_names = tuple(field_names) ➋</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面3个定义的函数是给新类的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span>  <span class="comment"># ➌</span></span><br><span class="line">        attrs = dict(zip(self.__slots__, args)) <span class="comment"># 位置参数 依次对应 到 slots 中的属性</span></span><br><span class="line">        attrs.update(kwargs) <span class="comment"># 关键字参数直接加入 attrs 中,关键字必须在 slots 中</span></span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># ➍</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.__slots__:</span><br><span class="line">            <span class="keyword">yield</span> getattr(self, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># ➎</span></span><br><span class="line">        values = <span class="string">', '</span>.join(<span class="string">'&#123;&#125;=&#123;!r&#125;'</span>.format(*i) <span class="keyword">for</span> i <span class="keyword">in</span> zip(self.__slots__, self))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;&#125;)'</span>.format(self.__class__.__name__, values)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 组建类属性</span></span><br><span class="line">    cls_attrs = dict(__slots__=field_names,</span><br><span class="line">                     __init__=__init__,</span><br><span class="line">                     __iter__=__iter__,</span><br><span class="line">                     __repr__=__repr__)</span><br><span class="line"><span class="comment"># 创建新的类</span></span><br><span class="line">    <span class="keyword">return</span> type(cls_name, (object,), cls_attrs)</span><br></pre></td></tr></table></figure><p>record_factory 函数创建的类，其实例有个局限——不能序列化，如果想了解完整的方案，请分析 collections.nameduple 函数的源码（<a href="https://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py#l236），搜索“pickling”这个词。" target="_blank" rel="noopener">https://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py#l236），搜索“pickling”这个词。</a></p><h3 id="定制描述符的类装饰器"><a href="#定制描述符的类装饰器" class="headerlink" title="定制描述符的类装饰器"></a>定制描述符的类装饰器</h3><p>一旦组建好整个类，而且把描述符绑定到类属性上之后，我们就可以审查类，并为描述符设置合理的储存属性名称。因此我们要在创建类时设置储存属性的名称，使用类装饰器或元类可以做到这一点。我们首先使用较简单的方式。</p><p>类装饰器与函数装饰器非常类似，是<strong>参数为类对象的函数，返回原来的类或修改后的类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entity</span><span class="params">(cls)</span>:</span> <span class="comment">#➊ cls 是类对象</span></span><br><span class="line">    <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items(): <span class="comment"># ➋ 遍历类属性</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(attr, Validated): <span class="comment"># ➌ 对 Validated 描述符的实例处理</span></span><br><span class="line">            desc = attr <span class="comment"># 对描述符进行处理</span></span><br><span class="line">            type_name = type(desc).__name__</span><br><span class="line">            desc.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@entity  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">  description = NonBlank()</span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><p><strong>类装饰器有个重大缺点</strong>：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承 也可能不继承装饰器所做的改动，具体情况视改动的方式而定。</p><p>因此需要元类。</p><h3 id="导入时与运行时"><a href="#导入时与运行时" class="headerlink" title="导入时与运行时"></a>导入时与运行时</h3><p>在导入时，解释器会从上到下一次性解析完 .py 模块的源码，然后生成用于执行的字节码。如果句法有错误，就在此时报告。如果本地的 <code>__pycache__</code> 文件夹中有最新的 .pyc 文件，解释器会跳过上述步骤。</p><p><code>import</code> 语句，它不只是声明，在进程中首次导入模块时，还会运行所导入模块中的全部<strong>顶层代码</strong>——以后导入相同的模块则使用缓存，只做名称绑定</p><blockquote><p>顶层代码可以做任何事，包括通常在“运行时”做的事，如：连接数据库</p></blockquote><ul><li><p>解释器会编译函数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是显然<strong>解释器 不会执行函数的定义体</strong></p></li><li><p><strong>解释器会执行每个类的定义体，甚至会执行嵌套类的定义体</strong>，说明类的定义体属于”顶层代码”</p></li></ul><p>接下来分析一下实际的import 与运行的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evalsupport.py</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[100]&gt; evalsupport module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco_alpha</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[200]&gt; deco_alpha'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[300]&gt; deco_alpha:inner_1'</span>)</span><br><span class="line"></span><br><span class="line">    cls.method_y = inner_1</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaAleph</span><span class="params">(type)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[400]&gt; MetaAleph body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dic)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[500]&gt; MetaAleph.__init__'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_2</span><span class="params">(self)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[600]&gt; MetaAleph.__init__:inner_2'</span>)</span><br><span class="line"></span><br><span class="line">        cls.method_z = inner_2</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[700]&gt; evalsupport module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaltime.py</span></span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassOne</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassOne body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassOne.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[4]&gt; ClassOne.__del__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_x</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassOne.method_x'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClassTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[6]&gt; ClassTwo body'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[7]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassOne tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    one = ClassOne()</span><br><span class="line">    one.method_x()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[14]&gt; evaltime module end'</span>)</span><br></pre></td></tr></table></figure><p>导入时代码的运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body <span class="comment"># 每个类的定义体都执行了</span></span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body <span class="comment"># 包括嵌套的类</span></span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha  <span class="comment"># 解释器先计算类3的定义体，然后调用依附在类上的装饰器函数</span></span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end</span><br></pre></td></tr></table></figure><p>运行时的运行结果，顺序与 import 时一样，只不过是增加了 main 函数中的执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ python3 evaltime.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassOne tests ..............................</span><br><span class="line">&lt;[<span class="number">3</span>]&gt; ClassOne.__init__</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassOne.method_x</span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1</span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">10</span>]&gt; ClassFour.method_y</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end</span><br></pre></td></tr></table></figure><h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>如果想定制整个类层次结构，而不是一次只定制一个类，使用元类更高效</p><p>元类是制造类的工厂，不过不是函数，而是类。元类是生产机器的机器。</p><p>根据 Python 对象模型，类是对象，因此类肯定是另外某个类的实例。默认情况下，Python 中的类是 type 类的实例，为了避免无限回溯，<strong>type 是其自身的实例</strong></p><p><img src="/2020/03/02/python进阶/./image-20190417160440937.png" alt="元类与类之间关系"></p><p><strong>object 类和 type 类之间的关系很独特</strong>：object类 是 type 的实例，而 type 是 object 的子类。这种关系很“神奇”，无法使用 Python 代码表述，因为定义其中一个之前另一个必须存在。type 是自身的实例这一点也很神奇。</p><p><strong>所有类（包括元类）都直接或间接地是 type 的实例， 不过只有元类同时也是 type 的子类</strong>。若想理解元类，一定要知道这种关系：元类（如 ABCMeta）从 type 类继承了构建类的能力。</p><h4 id="元类的入口：-init方法"><a href="#元类的入口：-init方法" class="headerlink" title="元类的入口： init方法"></a>元类的入口： init方法</h4><p>就元类本身而言，它们其实是很简单的：</p><p>1)   拦截类的创建</p><p>2)   修改类(在元类的<code>__init__</code>中)</p><p>3)   返回修改之后的类</p><p>在使用元类时，只要通过关键字<code>metaclass=元类</code>，那么在类对象<code>cls</code>加载（创建）完后，就会调用元类的<code>__init__</code>方法，对<code>cls</code>进行改造，而类装饰器是通过将 <code>cls</code> 直接传给函数，然后在函数中进行修改。</p><p>元类可以通过实现 <code>__init__</code> 方法定制实例， <code>__init__</code> 方法可以做到类装饰器能做的任何事情，但是作用更大。</p><p><code>__init__</code> 方法有四个参数，后面3个参数元 type 的一样：</p><ul><li>cls 　　要修改操作的类对象引用</li><li>name    类的名字</li><li>bases    类的超类</li><li>dic 　　类的属性字典</li></ul><p><strong>元类支持继承</strong>：ClassSix 类没有直接引用 MetaAleph 类，但是却受到了影响，因为它是 ClassFive 的子类，进而也是 MetaAleph 类的实例，所以由 <code>MetaAleph.__init__</code> 方法初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evalsupport.py</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[100]&gt; evalsupport module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco_alpha</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[200]&gt; deco_alpha'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[300]&gt; deco_alpha:inner_1'</span>)</span><br><span class="line"></span><br><span class="line">    cls.method_y = inner_1</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaAleph</span><span class="params">(type)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[400]&gt; MetaAleph body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dic)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[500]&gt; MetaAleph.__init__'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_2</span><span class="params">(self)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[600]&gt; MetaAleph.__init__:inner_2'</span>)</span><br><span class="line"></span><br><span class="line">        cls.method_z = inner_2</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[700]&gt; evalsupport module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaltime_meta.pyt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> MetaAleph</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime_meta module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[4]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFive</span><span class="params">(metaclass=MetaAleph)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[6]&gt; ClassFive body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[7]&gt; ClassFive.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassFive.method_z'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassSix</span><span class="params">(ClassFive)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassSix body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassSix.method_z'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFive tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    five = ClassFive()</span><br><span class="line">    five.method_z()</span><br><span class="line">    print(<span class="string">'&lt;[14]&gt; ClassSix tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    six = ClassSix()</span><br><span class="line">    six.method_z()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[15]&gt; evaltime_meta module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$python3 evaltime_meta.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__ <span class="comment"># 创建 ClassFive 时调用了 MetaAleph.__init__ </span></span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__ <span class="comment"># 创建 ClassSix 时也调用了 MetaAleph.__init__</span></span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1</span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassFour.method_y</span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFive tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; ClassSix tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2</span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br></pre></td></tr></table></figure><p>注意，ClassSix 类没有直接引用 MetaAleph 类，但是却受到了影响，因为它是 ClassFive 的子类，进而也是 MetaAleph 类的实例，所以由 MetaAleph.<strong>init</strong> 方法初始化。</p><h4 id="定制描述符的元类"><a href="#定制描述符的元类" class="headerlink" title="定制描述符的元类"></a>定制描述符的元类</h4><p>如果用户完全不用知道描述符或元类，直接继承库提供的类就能满足需求，那该多好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类，用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items():  <span class="comment"># ➋ 遍历类属性</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validated):  <span class="comment"># ➌ 对 Validated 描述符的实例处理</span></span><br><span class="line">                desc = attr  <span class="comment"># 对描述符进行处理</span></span><br><span class="line">                type_name = type(desc).__name__</span><br><span class="line">                desc.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span></span><br></pre></td></tr></table></figure><p>这样，用户直接继承 Entity 类即可，完全不需要考虑复杂的处理，甚至不用知道元类的存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(Entity)</span>:</span></span><br><span class="line">  description = NonBlank()</span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><h4 id="prepare-方法"><a href="#prepare-方法" class="headerlink" title="__prepare__方法"></a><code>__prepare__</code>方法</h4><blockquote><p>这个特殊方法只在元类中有用，而且必须声明为<strong>类方法</strong></p></blockquote><p>在某些应用中，可能需要知道类的属性定义的顺序。在默认情况下，名称到属性的映射是无序字典<code>dict</code>；元类或类装饰器获得映射时，属性在类定义体中的顺序已经丢失了。</p><blockquote><p>If the metaclass has no <code>__prepare__</code> attribute, then the class namespace is initialised as an empty ordered mapping.(官网：默认是有序的了嘛?)</p></blockquote><p>解决办法：Python 3 引入了特殊方法 <code>__prepare__</code> （用 <code>@classmethod</code> 装饰器定义），返回一个 <code>OrderedDict</code> 对象，<strong>用于储存名称到属性的映射</strong>。这样就保留了要构建的类在定义体中绑定属性的顺序。</p><p>在调用 <code>__new__</code> 和<code>__init__</code>方法之前，由解释器调用 <code>__prepare__</code> 方法获得 <code>OrderedDict</code> 对象，将其传给元类的 <code>__new__</code> 和 <code>__init__</code> 方法的 <code>attr_dict</code></p><p><img src="/2020/03/02/python进阶/Users/jizhongxian/notes/markdown/python/pyhton%E9%AB%98%E7%BA%A7/image-20190425110329118.png" alt="image-20190425110329118"></p><h4 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h4><p><code>dir(...)</code> 函数不会列出本节提到的任何一个属性</p><p>参见标准库参考中“Built-in Types”一章的“4.13. <a href="https://docs.python.org/3/library/stdtypes.html#special-attributes" target="_blank" rel="noopener">Special Attributes</a>”一节。 其中三个属性在本书中已经见过多次：<code>__mro__</code>、<code>__class__</code> 和 <code>__name__</code>。此外，还有以下属性。</p><ol><li><code>cls.__bases__</code>：由类的基类组成的元组。</li><li><code>cls.__qualname__</code>：Python 3.3 新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类的点分路径。例如，ClassOne的内部类 ClassTwo 的 <code>__qualname__</code> 属性，其值是字符串 ‘<strong>ClassOne.ClassTwo</strong>‘，而 <code>__name__</code> 属性的值是 ‘ClassTwo’</li><li><code>cls.__subclasses__()</code>：这个方法返回一个列表，列表中是内存里现存的子类，包含类的直接子类。这个方法的实现使用弱引用，防止在超类和子类（子类在 <code>__bases__</code> 属性中储存指向超类的强引用）之间出现循环引用。</li><li><code>cls.mro()</code>：构建类时，如果需要获取储存在类属性 <code>__mro__</code> 中的超类元组，解释器会调用这个方法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。</li></ol><h3 id="类的创建过程"><a href="#类的创建过程" class="headerlink" title="类的创建过程"></a>类的创建过程</h3><p>默认情况下，类通过<code>type()</code>函数创建，类的定义体在一个新的命名空间中执行，类名被绑定为<code>type(name, bases, namespace)</code>的结果</p><p>当类的定义代码被执行了以后，会进行以下步骤：</p><ul><li>MRO entries are resolved;</li><li>the appropriate metaclass is determined;</li><li>the class namespace is prepared;</li><li>the class body is executed;</li><li>the class object is created.</li></ul><p>想要自定义 类的创建过程，可以在定义类时，通过 <code>metaclass</code>参数指定元类，或者继承自有 <code>metalclass</code> 参数的父类，如下：MyClass 和 MySubclass 都是 元类 Meta 的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># both MyClass and MySubclass are instances of Meta:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(metaclass=Meta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubclass</span><span class="params">(MyClass)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>1.<strong>处理 MRO 名单</strong></p><p><a href="https://docs.python.org/3/reference/datamodel.html#resolving-mro-entries" target="_blank" rel="noopener">Resolving MRO entries</a> 不明白</p><p>If a base that appears in class definition is not an instance of <a href="https://docs.python.org/3/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a>, then an <code>__mro_entries__</code> method is searched on it. If found, it is called with the original bases tuple. This method must return a tuple of classes that will be used instead of this base. The tuple may be empty, in such case the original base is ignored.</p><p>2.<strong>确定合适的元类</strong></p><ol><li><p>没有基类和指定的元类，那么就是默认的 <code>type</code> 元类</p></li><li><p>有指定元类，并且不是 <code>type()</code>的实例，那么直接用它作为元类</p></li><li><p><code>type()</code>的实例被指定为元类，或者指定了基类，那么使用the most derived metaclass</p><blockquote><p>most derived metaclass 是从显示指定的元类(if any)和所有基类的元类中选出来的。most derived metaclass 是这些候选元类的子类型(subtype)，如果不满足该条件，抛出<code>TypeError</code></p></blockquote></li></ol><p>3.<strong>准备类的命名空间</strong></p><p>合适元类决定下来后，就开始准备命名空间。</p><p>如果元类有<code>__prepare__()</code>属性（方法），那么命名空间就由该函数的返回值确定，<code>namespace =metaclass.__prepare__(name, bases, **kwds)</code></p><p>kwds 是来自类定义时的参数(if any)</p><p>如果没有<code>__prepare__()</code>属性（方法），那么命名空间就初始化为空的有序字典(empty ordered mapping)</p><p>4.<strong>执行类的定义体</strong></p><p>类定义体 会以<code>exec(body, globals(), namespace)</code>的方式执行，与普通调用<code>exec()</code>的关键不同是：当类的定义是在函数中时，lexical scoping 允许类定义体引用当前范围与外部范围的名字(<strong>不是很明白</strong>)</p><p>5.<strong>创建出类对象</strong></p><p>执行类主体填充类命名空间后，通过调用<code>metaclass(name, bases, namespace, **kwds)</code>来创建 类对象，也就会调用 <code>metaclass .__init__()</code>。</p><p>类对象会被<code>super()</code>所引用，在类中，如果有方法使用了<code>__class__</code> 或<code>super</code>，<code>__class__</code>就会成为一个隐式的闭包。</p><p>当使用默认的元类<code>type</code>，或者最终调用<code>type.__new__</code>的其他元类，在创建类对象后，下面这些额外可自定义的步骤会被调用</p><ul><li>first, <code>type.__new__</code> collects all of the descriptors in the class namespace that define a <a href="https://docs.python.org/3/reference/datamodel.html#object.__set_name__" target="_blank" rel="noopener"><code>__set_name__()</code></a> method;</li><li>second, all of these <code>__set_name__</code> methods are called with the class being defined and the assigned name of that particular descriptor;</li><li>finally, the <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" target="_blank" rel="noopener"><code>__init_subclass__()</code></a> hook is called on the immediate parent of the new class in its method resolution order.</li></ul><p>在类对象创建完成后，如果有类装饰器的话，就会被传到其中，返回的新的类对象才会被绑定到本地的命名空间中，成为定义的类</p><h3 id="类属性访问的优先级"><a href="#类属性访问的优先级" class="headerlink" title="类属性访问的优先级"></a>类属性访问的优先级</h3><p>参考：<a href="http://www.betterprogramming.com/object-attribute-lookup-in-python.html" target="_blank" rel="noopener">http://www.betterprogramming.com/object-attribute-lookup-in-python.html</a></p><p>  Class “C” 是 Metaclass “M”的实例 , 调用 <code>C.name</code> 会进行下面的步骤：</p><ul><li>获取类的<code>Metaclass</code> (Get the Metaclass from Class)</li><li><p>调用<code>Metaclass</code>的特殊方法 <code>__getattribute__</code></p><p><code>__getattribute__</code>的内部逻辑：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    meta_attr= <span class="keyword">None</span> <span class="comment"># 元类属性</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> meta_parent <span class="keyword">in</span> Metaclass.__mor__:</span><br><span class="line"><span class="keyword">if</span> meta_parent.__dict__[<span class="string">'name'</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">meta_attr = meta_parent.__dict__[<span class="string">'name'</span>]</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> meta_attr <span class="keyword">is</span> data descriptor: </span><br><span class="line"><span class="keyword">return</span> meta_attr.__get__()<span class="comment"># 返回元类的数据描述符的值</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在继承链中查找，只要找到就返回，</span></span><br><span class="line">    <span class="keyword">for</span> class_parent <span class="keyword">in</span> Class.__mro__:</span><br><span class="line">      <span class="keyword">if</span> class_parent.__dict__[<span class="string">'name'</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">          cls_attr = class_parent.__dict__[<span class="string">'name'</span>]</span><br><span class="line">          <span class="keyword">if</span> cls_attr <span class="keyword">is</span> data/non-data descriptor: </span><br><span class="line">              <span class="keyword">return</span> cls_attr.__get__()<span class="comment"># 获取描述符的值</span></span><br><span class="line">            <span class="keyword">return</span> cls_attr<span class="comment">#返回普通的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回元类的属性</span></span><br><span class="line">    <span class="keyword">if</span> meta_attr <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">      <span class="keyword">if</span> meta_attr <span class="keyword">is</span> non-data descriptor:</span><br><span class="line">          <span class="keyword">return</span> meta_attr.__get__()</span><br><span class="line">        <span class="keyword">return</span> meta_attr</span><br><span class="line"></span><br><span class="line"><span class="keyword">raise</span> an AttributeError <span class="comment"># 都没有找到，抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> MetaClass has the special method __getattr__:</span><br><span class="line">  <span class="keyword">return</span> MetaClass.__getattr__()</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：</p><p>1） <a href="http://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="noopener">Monkey patching</a></p><p>2)   class decorators</p><p>当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>Python 施加了一些限制，做好了灵活性、可用性和安全性方面的平衡：</p><ul><li><p>不能重载<strong>内置类型</strong>的运算符</p></li><li><p>不能新建运算符，只能重载现有的</p></li><li><p>某些运算符不能重载——is、and、or 和 not（不过位运算符 &amp;、| 和 ~ 可以）</p></li></ul><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>只需实现相应的特殊方法。这些特殊方法只有一个参数：self，<strong>始终返回一个新对象</strong>，也就是说，不能修改self</p><p>-（<code>__neg__</code>）：一元取负算术运算符。如果 x 是 -2，那么 -x == 2。</p><p>+（<code>__pos__</code>）：一元取正算术运算符。通常，x == +x，但也有一些例外。如果好奇，请阅读“x 和 +x 何时不相等”附注栏。</p><p>~（<code>__invert__</code>）：对整数按位取反，定义为 ~x == -(x+1)。如果 x 是 2，那么 ~x == -3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(-x <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(self)</span><br></pre></td></tr></table></figure><p><strong>x 和 +x 何时不相等</strong></p><p>第一例与 decimal.Decimal 类有关，</p><p>x 是 Decimal 实例，在算术运算的上下文中创建，然后<u>在不同的上下文中</u>计算 +x，那么 x != +x</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"></span><br><span class="line">ctx = decimal.getcontext()</span><br><span class="line"></span><br><span class="line">ctx.prec = <span class="number">40</span> <span class="comment"># 设置上下文精度</span></span><br><span class="line">one_third = decimal.Decimal(<span class="string">'1'</span>) / decimal.Decimal(<span class="string">'3'</span>)</span><br><span class="line"><span class="comment"># Decimal('0.3333333333333333333333333333333333333333')</span></span><br><span class="line">one_third == +one_third ➎</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">ctx.prec = <span class="number">28</span> <span class="comment"># 修改精度，不同上下文</span></span><br><span class="line">one_third == +one_third ➐</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">+one_third</span><br><span class="line"><span class="comment"># Decimal('0.3333333333333333333333333333')</span></span><br></pre></td></tr></table></figure><p>第二例与 collections.Counter 类有关</p><p>Counter <strong>相加时，负值和零值计数会从结果中剔除</strong>。而一元运算符 + 等同于加上一个空 Counter，因此它产生一个新的 Counter 且仅保留大于零的计数器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ct = Counter(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="comment"># Counter(&#123;'a': 5, 'r': 2, 'b': 2, 'd': 1, 'c': 1&#125;)</span></span><br><span class="line"></span><br><span class="line">ct[<span class="string">'r'</span>] = <span class="number">-3</span></span><br><span class="line">ct[<span class="string">'d'</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">ct</span><br><span class="line"><span class="comment"># Counter(&#123;'a': 5, 'b': 2, 'c': 1, 'd': 0, 'r': -3&#125;)</span></span><br><span class="line"></span><br><span class="line">+ct </span><br><span class="line"><span class="comment"># Counter(&#123;'a': 5, 'b': 2, 'c': 1&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><p>实现一元运算符和中缀运算符的特殊方法<strong>一定不能修改操作数</strong>，<code>__add__</code>返回一个新 Vector 实例，而没有影响 self 或 other。</p><h4 id="二元运算的反向-不同类型之间的运算"><a href="#二元运算的反向-不同类型之间的运算" class="headerlink" title="二元运算的反向(不同类型之间的运算)"></a><strong>二元运算的反向</strong>(不同类型之间的运算)</h4><p>为了支持不同类型之间的运算，Python 为中缀运算符特殊方法提供了特殊的分派机制：</p><p><img src="/2020/03/02/python进阶/./image-20190410095307180.png" alt="image-20190410095307180"></p><p>对表达式 <code>a + b</code> 来说，解释器会执行以下几步操作（见图）</p><ol><li><p>如果 a 有<code>__add__</code> 方法，而且返回值不是 <code>NotImplemented</code>，调用 <code>a.__add__(b)</code>， 然后返回结果。</p></li><li><p>如果 a 没有<code>__add__</code>方法，或者调用 <code>__add__</code> 方法返回 <code>NotImplemented</code>，检查 b 有没有<code>__radd</code><strong> 方法，如果有，而且没有返回 <code>NotImplemented</code>，调用 `b.</strong>radd__(a)`，然后返回结果。</p><blockquote><p><code>__radd__</code> 是 <code>__add__</code> 的反向”（reversed）版本或者“反射”（reflected）版本</p></blockquote></li><li><p>如果 b 没有 <code>__radd__</code> 方法，或者调用 <code>__radd__</code> 方法返回 <code>NotImplemented</code>，抛出 <code>TypeError</code>，解释器会在错误消息中指明操作数类型不支持：<code>TypeError: unsupported operand type(s) for +: &#39;Class1&#39; and &#39;Class2&#39;</code></p></li></ol><blockquote><p>别把 NotImplemented 和 NotImplementedError 搞混了。</p><p>前者是特殊的单例值，如果中缀运算符特殊方法不能处理给定的操作数，那么要把它return给解释器，让解释器<strong>尝试对调操作数</strong>，调用运算符的反向特殊方法（如<code>__radd__</code> ）。</p><p>而 <code>NotImplementedError</code> 是一种异常，抽象类中的占位方法把它抛出（raise），提醒子类必须覆盖</p></blockquote><p><strong>反向方法一般只需委托正向的方法即可</strong>。</p><p>如果中缀运算符的正向方法（如 <code>__mul__</code>）只处理与 self 属于同 一类型的操作数，那就无需实现对应的反向方法（如<code>__rmul__</code>），因为按照定义， 反向方法是为了处理类型不同的操作数。</p><h4 id="操作数类型不同时的异常处理"><a href="#操作数类型不同时的异常处理" class="headerlink" title="操作数类型不同时的异常处理"></a>操作数类型不同时的异常处理</h4><p>考虑一下可能发生的错误（Vector 代表向量）：</p><ol><li><p>如果提供的对象不可迭代（<code>Vector([1,2]) + 1</code>），那么 <code>__add__</code> 就无法处理，而且提供的错误消息不是很有用。</p></li><li><p>如果操作数是可迭代对象（<code>Vector([1,2]) + &#39;ABC&#39;</code>），但是它的元素不能与 Vector 中的浮点数元素相加，给出的消息也没什么用</p></li></ol><p>如果操作数的类型不同，我们要检测出不能处理的操作数。两种方式可以处理这个问题：</p><ol><li>鸭子类型，直接尝试执行运算，如果有问题，捕获 TypeError 异常；</li><li>另一种是显式使用 <code>isinstance</code> 测试，<code>__mul__</code> 方法就是这么做的。</li></ol><p>这两种方式<strong>各有优缺点</strong>：鸭子类型更灵活，但是显式检查更能预知结果。如果选择使用<code>isinstance</code>，要小心，不能测试具体类，而<strong>要测试抽象基类</strong>，比如：numbers.Real</p><p>方法1：为了遵守鸭子类型精神，我们不能测试 other 操作数的类型，或者它的元素的类型，我们要<strong>捕获异常，然后返回 NotImplemented</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self + other</span><br></pre></td></tr></table></figure><p>方法2：白鹅类型。我们将使用 isinstance() 检查 scalar 的类型，但是不硬编码具体的类型，而是检查 numbers.Real 抽象基类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终版本</span></span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(scalar, numbers.Real): </span><br><span class="line">        <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> self * scalar</span><br></pre></td></tr></table></figure><h3 id="比较运算符号"><a href="#比较运算符号" class="headerlink" title="比较运算符号"></a>比较运算符号</h3><ul><li><p>正向方法返回<code>NotImplemented</code>的话， 调用反向方法</p></li><li><p>参数对调：对 <code>==</code> 来说，正向和反向调用都是<code>__eq__</code>方法，只是把参数对调了；正向的 <code>__gt__</code> 方法调用的是反向的 <code>__lt__</code>方法，并把参数对调</p></li><li><p>后备机制：对 <code>==</code> 和<code>!=</code> 来说，如果反向调用失败，Python有后备机制， 会比较对象的 ID，而不抛出 TypeError</p></li><li><code>!=</code> 运算符我们不用实现它：因为从 object 继承的 <code>__ne__</code> 方法的后备行为满 足了我们的需求：定义了 <code>__eq__</code> 方法，而且它不返回 <code>NotImplemented</code>，<code>__ne__</code> 会对<code>__eq__</code>返回的结果取反。</li></ul><p><img src="/2020/03/02/python进阶/./image-20190410142104597.png" alt="image-20190410142104597"></p><p><strong>注意类型检查</strong></p><p>对操作数过度宽容可能导致令人惊讶的结果，因此，我们要保守一点，做些类型检查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="comment"># 如果other操作数是Vector实例或子类的实例，那就像之前那样比较。</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(other, Vector):</span><br><span class="line">        <span class="keyword">return</span> (len(self) == len(other) </span><br><span class="line">                <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><h3 id="增量赋值运算符-就地方法"><a href="#增量赋值运算符-就地方法" class="headerlink" title="增量赋值运算符(就地方法)"></a>增量赋值运算符(就地方法)</h3><ul><li><p>就地运算符(<code>+=</code>,<code>*=</code>)用于增量赋值</p></li><li><p>如果一个类没有实现表中列出的就地运算符，增量赋值运算符只是语法糖：<code>a += b</code> 的 作用与 <code>a = a + b</code> 完全一样。对不可变类型来说，这是预期的行为，而且，如果定义了 <code>__add__</code> 方法的话，不用编写额外的代码，<code>+=</code> 就能使用。</p></li><li>增量赋值<strong>不会修改不可变类型</strong>，而是新建实例，然后重新绑定</li><li>可变类型实现了就地运算符方法，会<strong>就地修改左操作数</strong>，而不会创建新对象作为结果，<strong>必须返回 self</strong>。</li></ul><p><img src="/2020/03/02/python进阶/./image-20190410141306137.png" alt="image-20190410141306137"></p><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="keyword">from</span> bingo <span class="keyword">import</span> BingoCage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableBingoCage</span><span class="params">(BingoCage)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, Tombola):</span><br><span class="line">            <span class="keyword">return</span> AddableBingoCage(self.inspect() + other.inspect())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># 是否同类型</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, Tombola):</span><br><span class="line">            other_iterable = other.inspect()</span><br><span class="line"><span class="comment"># 尝试迭代 other</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                other_iterable = iter(other)</span><br><span class="line">            <span class="keyword">except</span> TypeError:</span><br><span class="line">                self_cls = type(self).__name__</span><br><span class="line">                msg = <span class="string">"right operand in += must be &#123;!r&#125; or an iterable"</span></span><br><span class="line">                <span class="keyword">raise</span> TypeError(msg.format(self_cls))</span><br><span class="line">        self.load(other_iterable)</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>在实现的过程中，我们得知在可接受的类型方面，<strong>+ 应该比 += 严格</strong>。对序列类型来说，+ 通常要求两个操作数属于同一类型，而 += 的右操作数往往可以是任何可迭代对象。</p><h2 id="上下文管理器和-else-块"><a href="#上下文管理器和-else-块" class="headerlink" title="上下文管理器和 else 块"></a>上下文管理器和 else 块</h2><h3 id="else"><a href="#else" class="headerlink" title="else"></a>else</h3><p>不过与if/else差别很大，<strong>使用then关键字更好理解</strong></p><p>总结：如果异常或者 return、break 或 continue 语句导致控制权跳到了复合语句的主块之外，else 子句也会被跳过。</p><ul><li><code>for</code>：仅当 for 循环运行完毕时（即 for 循环没有被 break 语句中止）才运行 else 块。 </li><li><code>while</code>：仅当 while 循环因为条件为假值而退出时（即 while 循环没有被 break 语句中止） 才运行 else 块。</li><li><code>try</code> :仅当 try 块中没有异常抛出时才运行 else 块。<a href="https://docs.python.org/3/reference/compound_stmts.html" target="_blank" rel="noopener">官方文档</a>还指出：“else 子句抛出的异常不会由前面的 except 子句处理。”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">if</span> item.flavor == <span class="string">'banana'</span>:</span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     <span class="keyword">raise</span> ValueError(<span class="string">'No banana flavor found!'</span>)</span><br></pre></td></tr></table></figure><p>下面有个疑问：有必要用 else吗？(TODO)，直接写 after_call()可以吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dangerous_call()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    log(<span class="string">'OSError...'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    after_call()</span><br></pre></td></tr></table></figure><h3 id="with与上下文管理器"><a href="#with与上下文管理器" class="headerlink" title="with与上下文管理器"></a>with与上下文管理器</h3><ul><li><p><strong>上下文管理器协议</strong>包含 <code>__enter__</code> 和 <code>__exit__</code> 两个方法。</p></li><li><p>在定义类时，<strong>含有<code>__enter__</code>和<code>__exit__</code>方法的对象就是上下文管理器。</strong></p></li><li><p><code>with</code>语句的目的是简化<code>try/finally</code>模式。当with遇到上下文管理器，就会在执行语句体之前，先执行上下文管理器的<code>__enter__</code>方法，然后再执行语句体，执行完语句体后，最后执行<code>__exit__</code>方法，以此扮演 <code>finally</code>子句的角色</p><blockquote><p>这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、<code>return</code>语句或<code>sys.exit()</code>调用而中止，也会<strong>执行指定的操作</strong>。</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'实例化一个对象'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入'</span>)</span><br><span class="line">        <span class="comment"># return self</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'退出'</span>)</span><br><span class="line">        <span class="comment"># return True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with 上下文管理器：</span></span><br><span class="line"><span class="comment">#    　语句体</span></span><br><span class="line">obj = ContextManager()</span><br><span class="line"><span class="keyword">with</span> obj:</span><br><span class="line">    print(<span class="string">'正在执行'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个对象</span></span><br><span class="line"><span class="comment"># 进入</span></span><br><span class="line"><span class="comment"># 正在执行</span></span><br><span class="line"><span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><p>与函数和模块不同，<strong>with 块没有定义新的作用域</strong>，退出后变量还可以使用。</p><p><strong>enter 与 exit 细节</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 上下文管理器 <span class="keyword">as</span> target:</span><br><span class="line">    代码语句体</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><p>解释器调用 <code>__enter__</code> 方法时，除了隐式的 self 之外，不会传入任何参数。</p></li><li><p>传给 <code>__exit__</code> 方法的三个参数列举如下:</p><ul><li>exc_type：异常类（例如 ZeroDivisionError）</li><li>exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用 exc_value.args 获取。</li><li>traceback：traceback 对象</li></ul><blockquote><p>如果一切正常，Python 调用 <code>__exit__</code> 方法时传入的参数是 <code>None, None, None</code>；如果抛出了异常，这三个参数是异常数据</p></blockquote></li></ul><p><strong>返回值</strong></p><ul><li><p>如果使用了<code>as</code>，则是把上下文管理器的 <code>__enter__()</code> 方法的<strong>返回值赋值给 target</strong>，target 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”），<code>__enter__</code> 方法<strong>除了返回上下文管理器之外，还可能返回其他对象。</strong></p></li><li><p>出现异常时，<code>__exit__</code> 返回 False（默认不写返回值时，即为False），则会重新抛出异常，让with之外的语句逻辑来处理异常，这也是通用做法；如果返回True，则忽略异常，不再对异常进行处理</p></li></ul><p>请看下面的具体例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.original_write = sys.stdout.write</span><br><span class="line">        sys.stdout.write = self.reverse_write <span class="comment"># 替换标准输出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'JABBERWOCKY'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        sys.stdout.write = self.original_write <span class="comment"># 恢复标准输出</span></span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:</span><br><span class="line">            print(<span class="string">'Please DO NOT divide by zero!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line">    print(<span class="string">'Alice, Kitty and Snowdrop'</span>)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pordwonS dna yttiK ,ecilA</span></span><br><span class="line"><span class="comment"># YKCOWREBBAJ</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with 块已经执行完毕。输出不再是反向的了。可以看出，__enter__ 方法返回的值——即存储在 what 变量中的值——是字符串'JABBERWOCKY'。</span></span><br><span class="line">print(what) </span><br><span class="line">print(<span class="string">'Back to normal.'</span>)</span><br><span class="line"><span class="comment"># 'JABBERWOCKY'</span></span><br><span class="line"><span class="comment"># Back to normal.</span></span><br></pre></td></tr></table></figure><p>上下文管理器对象存在的目的是管理with语句，就像迭代器的存在是为了管理for语句一样。</p><h3 id="使用-contextmanager"><a href="#使用-contextmanager" class="headerlink" title="使用@contextmanager"></a>使用@contextmanager</h3><blockquote><p><code>@contextmanager</code>装饰器优雅且实用，把三个不同的 Python 特性结合到了一起：函数装 饰器、生成器和 with 语句。</p></blockquote><p><strong>用法形式</strong></p><p>在使用 <code>@contextmanager</code> 装饰的生成器中，<code>yield</code> 语句的作用是把函数的定义体分成两部分：</p><ol><li><code>yield</code> 语句前面的所有代码在 <code>with</code> 块<strong>开始时</strong>（即解释器调用 <code>__enter__</code> 方法时）执行</li><li><code>yield</code> 语句后面的代码在 <code>with</code> 块<strong>结束时</strong>（即调用 <code>__exit__</code> 方法时）执行</li></ol><p>在 @contextmanager 装饰器装饰的生成器中，yield 与迭代没有任何关系</p><p><strong>原理</strong></p><p>其实，contextlib.contextmanager 装饰器会把函数<strong>包装</strong>成实现 <code>__enter__</code> 和 <code>__exit__</code> 方法的类。</p><blockquote><p>类的名称是 _GeneratorContextManager。具体的工作方式，可以阅读 Python 3.4 发行版中 <a href="https://hg.python.org/cpython/file/3.4/Lib/contextlib.py#l34" target="_blank" rel="noopener">Lib/contextlib.py</a>。</p></blockquote><p>这个类的 <code>__enter__</code> 方法有如下作用：</p><ol><li>调用生成器函数，保存生成器对象（这里把它称为 gen）</li><li>调用 <code>next(gen)</code>，执行到 <code>yield</code> 关键字所在的位置</li><li><p>返回 <code>next(gen)</code> 产出的值，以便把产出的值绑定到 <code>with/as</code> 语句中的目标变量上。</p><p>with 块终止时，<code>__exit__</code> 方法会做以下几件事：</p></li><li><p>检查<code>with</code>有没有发生异常，有没有把异常传给 exc_type；如果有，调用 <code>gen.throw(exception)</code>，在生成器函数定义体中包含 <code>yield</code> 关键字的那一行抛出异常，但是，如果那里没有处理错误的代码，可能出现无法避免的错误(具体见下面的例子)</p></li><li>否则，调用 <code>next(gen)</code>，继续执行生成器函数定义体中 yield 语句之后的代码。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    msg = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 try 的原因如下面的解释：</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'JABBERWOCKY'</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        msg = <span class="string">'Please DO NOT divide by zero!'</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write</span><br><span class="line">        <span class="keyword">if</span> msg:</span><br><span class="line">            print(msg)</span><br><span class="line">            </span><br><span class="line"><span class="string">'''测试'''</span></span><br><span class="line"><span class="keyword">with</span> looking_glass() <span class="keyword">as</span> what:</span><br><span class="line">    print(<span class="string">'Alice, Kitty and Snowdrop'</span>)</span><br><span class="line">    print(what)</span><br><span class="line">    <span class="keyword">raise</span> ZeroDivisionError <span class="comment"># 模拟在 with 块中抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pordwonS dna yttiK ,ecilA</span></span><br><span class="line"><span class="comment"># YKCOWREBBAJ</span></span><br><span class="line"></span><br><span class="line">print(what)</span><br><span class="line"><span class="comment"># 'JABBERWOCKY'</span></span><br></pre></td></tr></table></figure><p>如果在 with 块中抛出了异常，Python 解释器会将其捕获， 然后在 <code>looking_glass</code> 函数的 <code>yield</code> 表达式里再次抛出。但是，如果那里没有处理错误的代码， <code>looking_glass</code> 函数会中止，永远无法恢复成原来的 <code>sys.stdout.write</code> 方法，导致系统处于无效状态。</p><p> <strong>默认返回值</strong></p><p>使用 <code>@contextmanager</code> 装饰器时，<strong>默认的行为是返回 <code>True</code>，与上下文管理器默认返回<code>False</code>不同</strong>：装饰器提供的 <code>__exit__</code>方法假定发给生成器的所有异常都得到处理了，因此应该压制异常。 如果不想让 <code>@contextmanager</code> 压制异常，必须在被装饰的函数中显式重新抛出异常。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协同程序，协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。</p><p>从句法上看，协程与生成器类似，都是定义体中包含 <code>yield</code> 关键字的函数。</p><p>但是在协程中，<code>yield</code> 通常出现在表达式的右边（例如，<code>datum = yield data</code>），<strong>可以产出值，也可以不产出</strong>——如果 <code>yield</code> 关键字后面没有表达式，那么生成器产出 <code>None</code>。</p><p>协程可能会从调用方接收数据，不过调用方<strong>把数据提供给协程使用</strong>的是 <code>.send(datum)</code> 方法，而不是 <code>next(…)</code> 函数。通常，调用方会把值推送给协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">    x = <span class="keyword">yield</span><span class="comment"># 需要调用 next 后，才会停在这里</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine received:'</span>, x)</span><br><span class="line"></span><br><span class="line">my_coro = simple_coroutine()</span><br><span class="line"></span><br><span class="line">print(my_coro)</span><br><span class="line"><span class="comment"># ➌ &lt;generator object simple_coroutine at 0x100c2be10&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#预先激活</span></span><br><span class="line">next(my_coro) </span><br><span class="line"><span class="comment"># -&gt; coroutine started</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#发送数据</span></span><br><span class="line">my_coro.send(<span class="number">42</span>) <span class="comment">#</span></span><br><span class="line"><span class="comment"># -&gt; coroutine received: 42</span></span><br><span class="line"><span class="comment"># 运行到结束，抛出 stopIteration</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   ...</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><h4 id="协程状态"><a href="#协程状态" class="headerlink" title="协程状态"></a>协程状态</h4><p>协程可以身处四个状态中的一个。当前状态可以使用 <code>inspect.getgeneratorstate(...)</code> 函数确定：</p><ol><li><p>‘GEN_CREATED’：等待开始执行，通过对其调用<code>next()</code>进入下一个状态</p></li><li><p>‘GEN_RUNNING’ ：解释器正在执行</p><blockquote><p>只有在多线程应用中才能看到这个状态。此外，生成器对象在自己身上调用 getgeneratorstate 函数也行，不过这样做没什么用。</p></blockquote></li><li><p>‘GEN_SUSPENDED’ ：在 yield 表达式处暂停</p></li><li>‘GEN_CLOSED’ ：执行结束</li></ol><p>协程在 <code>yield</code> 关键字所在的位置暂停执行，在赋值语句中，= 右边的代码在赋值之前执行。因此，对于 <code>b = yield a</code> 这行代码来说，等到客户端代码 再激活协程时才会设定 b 的值。具体看下面的图示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; Started: a ='</span>, a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">'-&gt; Received: b ='</span>, b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">'-&gt; Received: c ='</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"></span><br><span class="line">my_coro2 = simple_coro2(<span class="number">14</span>)</span><br><span class="line">print(getgeneratorstate(my_coro2))</span><br><span class="line"><span class="comment"># 'GEN_CREATED'</span></span><br><span class="line"></span><br><span class="line">print(next(my_coro2)) <span class="comment">#预激，进入下一个状态</span></span><br><span class="line"><span class="comment"># -&gt; Started: a = 14</span></span><br><span class="line"><span class="comment"># 14</span></span><br><span class="line"></span><br><span class="line">print(getgeneratorstate(my_coro2))</span><br><span class="line"><span class="comment"># 'GEN_SUSPENDED'</span></span><br><span class="line"></span><br><span class="line">my_coro2.send(<span class="number">28</span>)</span><br><span class="line"><span class="comment"># -&gt; Received: b = 28</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">my_coro2.send(<span class="number">99</span>)</span><br><span class="line"><span class="comment"># -&gt; Received: c = 99</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br><span class="line"></span><br><span class="line">print(getgeneratorstate(my_coro2))</span><br><span class="line"><span class="comment"># 'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/02/python进阶/./image-20190412104610202.png" alt="image-20190412104610202"></p><h3 id="预激协程的装饰器"><a href="#预激协程的装饰器" class="headerlink" title="预激协程的装饰器"></a>预激协程的装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average <span class="comment">#➊</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">        </span><br><span class="line">coro_avg = averager()</span><br><span class="line"></span><br><span class="line">next(coro_avg)<span class="comment"># 需要通过next()进行预激，让代码运行到➊处</span></span><br><span class="line">print(coro_avg.send(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 10.0</span></span><br><span class="line">print(coro_avg.send(<span class="number">30</span>))</span><br><span class="line"><span class="comment"># 20.0</span></span><br><span class="line">print(coro_avg.send(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># 15.0</span></span><br></pre></td></tr></table></figure><p>使用协程之前必须预激，可是这一步容易忘记。为了避免忘记，可以在协程上使用一个<strong>特殊的装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""装饰器：向前执行到第一个`yield`表达式，预激`func`"""</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primer</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        gen = func(*args,**kwargs)</span><br><span class="line">        next(gen) <span class="comment"># 预激</span></span><br><span class="line">        <span class="keyword">return</span> gen</span><br><span class="line">    <span class="keyword">return</span> primer</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"></span><br><span class="line"><span class="string">'''测试'''</span></span><br><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line">coro_avg = averager()</span><br><span class="line"></span><br><span class="line">getgeneratorstate(coro_avg)</span><br><span class="line"><span class="comment"># 'GEN_SUSPENDED'</span></span><br><span class="line"></span><br><span class="line">coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 10.0</span></span><br><span class="line">coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 20.0</span></span><br><span class="line">coro_avg.send(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 15.0</span></span><br></pre></td></tr></table></figure><h3 id="终止协程和异常处理"><a href="#终止协程和异常处理" class="headerlink" title="终止协程和异常处理"></a>终止协程和异常处理</h3><p>协程中未处理的异常会向上冒泡，<strong>传给</strong> <code>next</code> 函数或 <code>send</code> 方法的<strong>调用方</strong>（即触发协程的对象）</p><p><strong>在协程内没有处理异常，协程会终止</strong>。如果试图重新激活协程，会抛出 <code>StopIteration</code> 异常。</p><p>从 Python 2.5 开始，客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。</p><ul><li><p><code>generator.throw(exc_type[, exc_value[, traceback]])</code></p><p>致使生成器在【暂停的 <code>yield</code> 表达式处】抛出指定的异常。</p><blockquote><p>如果生成器处理了抛出的异常，代码会向前执行到下一个 <code>yield</code> 表达式，而产出的值会成为throw 方法的返回值。</p><p>如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。</p></blockquote></li><li><p><code>generator.close()</code></p><p>致使生成器在【暂停的 yield 表达式处】抛出 <code>GeneratorExit</code> 异常，协程正常关闭</p><blockquote><p>如果生成器没有处理这个异常，或者抛出了 <code>StopIteration</code> 异常（通常是指运行到结尾），调用方不会报错。</p><p>收到 <code>GeneratorExit</code> 异常后，生成器一定不能产出值，否则解释器会抛出 <code>RuntimeError</code> 异常。生成器抛出的其他异常会向上冒泡，传给调用方。</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""为这次演示定义的异常类型。"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handling</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> DemoException:</span><br><span class="line">            print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'This line should never run.'</span>)</span><br><span class="line"></span><br><span class="line">exc_coro = demo_exc_handling()</span><br><span class="line">next(exc_coro)</span><br><span class="line"><span class="comment"># -&gt; coroutine started</span></span><br><span class="line"></span><br><span class="line">exc_coro.send(<span class="number">11</span>)</span><br><span class="line"><span class="comment"># -&gt; coroutine received: 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 正常 close</span></span><br><span class="line">exc_coro.close()</span><br><span class="line">print(getgeneratorstate(exc_coro))</span><br><span class="line"><span class="comment"># 'GEN_CLOSED'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 抛出可处理的异常，协程继续</span></span><br><span class="line">exc_coro.throw(DemoException)</span><br><span class="line"><span class="comment"># *** DemoException handled. Continuing...</span></span><br><span class="line">print(getgeneratorstate(exc_coro))</span><br><span class="line"><span class="comment"># GEN_SUSPENDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 抛出不可处理的异常，协程关闭，异常冒泡</span></span><br><span class="line">exc_coro.throw(ZeroDivisionError)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># ZeroDivisionError</span></span><br><span class="line">print(getgeneratorstate(exc_coro))</span><br><span class="line"><span class="comment"># 'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><h3 id="协程的返回值"><a href="#协程的返回值" class="headerlink" title="协程的返回值"></a>协程的返回值</h3><p>在 Python 3.3 之前，如果生成器返回值，解释器会报句法错误。</p><p>return 表达式的值会传给调用方，赋值给 <code>StopIteration</code> 异常的一个属 性。这样做有点不合常理，但是能保留生成器对象的常规行为——耗尽时抛出 <code>StopIteration</code> 异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span>  <span class="comment"># 取消了term = yield average 形式</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">break</span>     <span class="comment"># 通过传入 None 跳出并返回 Result</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)</span><br><span class="line">  </span><br><span class="line">coro_avg = averager()</span><br><span class="line">next(coro_avg) <span class="comment"># 预激</span></span><br><span class="line">coro_avg.send(<span class="number">10</span>)</span><br><span class="line">coro_avg.send(<span class="number">30</span>)</span><br><span class="line">coro_avg.send(<span class="number">6.5</span>)</span><br><span class="line"><span class="comment"># 获取返回值</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    coro_avg.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">    result = exc.value</span><br><span class="line"></span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># Result(count=3, average=15.5)</span></span><br></pre></td></tr></table></figure><h3 id="yield-from-1"><a href="#yield-from-1" class="headerlink" title="yield from"></a>yield from</h3><h4 id="概念与功能"><a href="#概念与功能" class="headerlink" title="概念与功能"></a>概念与功能</h4><p>使用 <code>yield from</code> 句法调用协程时，会自动预激</p><p><code>yield from x</code> 表达式对 x 对象所做的第一件事是，调用 <code>iter(x)</code>，从中获取迭代器。因此，x 可以是任何可迭代的对象。(替代产出值的嵌套 for 循环)</p><p><code>yield from</code> 的<strong>主要功能是打开双向通道</strong>，<u>把最外层的调用方与最内层的子生成器连接起来</u>，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。</p><p><strong>术语概念</strong></p><p><img src="/2020/03/02/python进阶/./image-20190412145617283.png" alt="image-20190412145617283"></p><blockquote><p>委派生成器在 <code>yield from</code> 表达式处暂停时， 调用方可以直接把数据发给子 生成器， 子生成器再把产出的值发给调用方。 子生成器返回之后， 解释器会抛出 <code>StopIteration</code> 异常， 并把返回值附加到异常对象上， 此时委派生成器会恢复</p></blockquote><ul><li><p>委派生成器：包含 <code>yield from &lt;iterable&gt;</code> 表达式的生成器函数。</p></li><li><p>子生成器：从 <code>yield from</code> 表达式中 <code>&lt;iterable&gt;</code> 部分获取的生成器。</p><blockquote><p>这就是 PEP 380 的标题 （“Syntax for Delegating to a Subgenerator”）中所说的“子生成器”（subgenerator）。 </p></blockquote></li><li><p>调用方 ：PEP 380 指代调用委派生成器的客户端代码。</p><blockquote><p>在不同的语境中，我会使用“客户端”代替“调用方”，以此与委派生成器（也是调用方，因为它调用了子生成器）区分开。</p></blockquote></li></ul><p>在生成器 gen 中使用 <code>yield from subgen()</code> 时，子生成器 subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直接控制 subgen。与此同时，gen 会阻塞，等待 <code>subgen</code>终止返回</p><p><strong><code>subgen</code> 返回的值会成为 <code>yield from</code> 表达式的值</strong>：<code>yield from</code> 会处理解释器会抛出 <code>StopIteration</code> 异常，获取附加到异常对象上的返回值， 此时委派生成器会恢复</p><p>子生成器 <code>subgen</code> 可能是简单的迭代器，只实现了 <code>__next__</code> 方法，<code>yield from</code> 也能处理这种子生成器。不过，引入 <code>yield from</code> 结构的目的是为了支持实现了 <code>__next__</code>、<code>send</code>、<code>close</code> 和 <code>throw</code> 方法的生成器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total / count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average) <span class="comment"># 返回的值会成为 yield from 表达式的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="comment"># 这是个协程，运行结束后会抛出 StopIteration，因此 True 是让它永不结束，然后在➊处覆盖实例，让解释器垃圾回收即可，不用担心无限循环，后面有个不用 True 的版本</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  </span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager() </span><br><span class="line">        <span class="comment"># yield from 会处理 解释器会抛出 StopIteration 异常，获取附加到异常对象上的返回值， 此时委派生成器会恢复</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，即调用方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key) <span class="comment"># ➊ group 是个生成器</span></span><br><span class="line">        next(group)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value)</span><br><span class="line">        group.send(<span class="keyword">None</span>)  <span class="comment"># 重要！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(results) # 如果要调试，去掉注释</span></span><br><span class="line">    report(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出报告</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> sorted(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">';'</span>)</span><br><span class="line">        print(<span class="string">'&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'</span>.format(result.count, group, result.average, unit))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'girls;kg'</span>:</span><br><span class="line">        [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">'girls;m'</span>:</span><br><span class="line">        [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">'boys;kg'</span>:</span><br><span class="line">        [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">'boys;m'</span>:</span><br><span class="line">        [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure><p>不用 True 的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="comment"># while True:</span></span><br><span class="line">    <span class="comment">#     print("start")</span></span><br><span class="line">    <span class="comment">#     results[key] = yield from averager()</span></span><br><span class="line">    <span class="comment">#     print("end")</span></span><br><span class="line">    <span class="comment">#     print(results)</span></span><br><span class="line">    results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line">    <span class="comment"># 收到 None 后，委托生成器恢复运行</span></span><br><span class="line">    print(<span class="string">"end"</span>) </span><br><span class="line">    <span class="comment"># 然后该协程会抛出 StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，即调用方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)</span><br><span class="line">        next(group)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            group.send(<span class="keyword">None</span>)  <span class="comment"># 重要！</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration: <span class="comment"># 处理委托生成器的异常</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="yield-from-的行为"><a href="#yield-from-的行为" class="headerlink" title="yield from 的行为"></a>yield from 的行为</h4><ul><li><p>子生成器产出的值都<strong>直接传给</strong>委派生成器的调用方（即客户端代码）。</p></li><li><p>调用方使用 <code>send()</code> 方法发给委派生成器的值都<strong>直接传给</strong>子生成器。如果发送的值是 <code>None</code>，那么会调用子生成器的 <code>__next__()</code> 方法。如果发送的值不是 <code>None</code>，那么会调用子生成器的 <code>send()</code> 方法。<strong>如果调用的方法抛出 <code>StopIteration</code> 异常，那么委派生成器恢复运行。</strong>任何其他异常都会向上冒泡，传给委派生成器。</p></li><li>生成器退出时，生成器（或子生成器）中的 return expr 表达式会触发 StopIteration(expr) 异常抛出。</li><li><code>yield from</code> <strong>表达式的值</strong>是子生成器终止时传给 <strong><code>StopIteration</code> 异常的第一个参数</strong>。</li></ul><p><code>yield from</code> 结构的另外两个特性与异常和终止有关。 </p><ul><li><p>传入委派生成器的异常，除了 <code>GeneratorExit</code> 之外都传给子生成器的 <code>throw()</code> 方法。如果调用 <code>throw()</code> 方法时抛出 <code>StopIteration</code> 异常，委派生成器恢复运 行。<code>StopIteration</code> 之外的异常会向上冒泡，传给委派生成器。</p></li><li><p>如果把 <code>GeneratorExit</code> 异常传入委派生成器，或者在委派生成器上调用 <code>close()</code> 方 法，那么在子生成器上调用 <code>close()</code> 方法，如果它有的话。如果调用 <code>close()</code> 方法 导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 <code>GeneratorExit</code> 异常。</p></li></ul><h4 id="伪代码模拟yield-from-的行为"><a href="#伪代码模拟yield-from-的行为" class="headerlink" title="伪代码模拟yield from 的行为"></a>伪代码模拟yield from 的行为</h4><p>伪代码，等效于委派生成器中的 <code>RESULT = yield from EXPR</code> 语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_i = iter(EXPR)  <span class="comment"># ➊ EXPR 可以是任何可迭代的对象</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = next(_i)  <span class="comment"># ➋ 预激子生成器</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value  <span class="comment"># ➌</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  <span class="comment"># ➍</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _s = <span class="keyword">yield</span> _y  <span class="comment"># ➎</span></span><br><span class="line">        <span class="comment"># ➏ 这一部分用于关闭委派生成器和子生成器。</span></span><br><span class="line">        <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e:  </span><br><span class="line">           <span class="comment"># 因为子生成器可以是任何可迭代的对象， 所以可能没有 close 方法。</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.close</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _m()</span><br><span class="line">            <span class="keyword">raise</span> _e</span><br><span class="line">        <span class="comment"># 这一部分处理调用方通过 .throw(...) 方法传入的异常</span></span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e: </span><br><span class="line">            _x = sys.exc_info()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.throw</span><br><span class="line">            <span class="keyword">except</span> AttributeError:  <span class="comment"># ➐如果子生成器可以是迭代器，从而没有 throw 方法可调用</span></span><br><span class="line">                <span class="keyword">raise</span> _e</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># ➑ 如果子生成器有 throw 方法，调用它并传入调用方发来的异常。</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    _y = _m(*_x)</span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># ➒ 如果产出值时没有异常</span></span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># ➓ 尝试让子生成器向前执行</span></span><br><span class="line">                <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># ⓫</span></span><br><span class="line">                    _y = next(_i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _y = _i.send(_s)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:  <span class="comment"># ⓬ 子生成器抛出 StopIteration 异常，获取 value 属性的值，赋值给 _r，然后退 出循环，让委派生成器恢复运行。</span></span><br><span class="line">                _r = _e.value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">RESULT = _r</span><br></pre></td></tr></table></figure><h2 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h2><h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><h5 id="namedtuple-1"><a href="#namedtuple-1" class="headerlink" title="namedtuple"></a>namedtuple</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。</p><h5 id="defaultdict-1"><a href="#defaultdict-1" class="headerlink" title="defaultdict"></a>defaultdict</h5><p>如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code> ，<code>dd = defaultdict(lambda: &#39;N/A&#39;)</code>  默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p><h5 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h5><p><code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序</p><h5 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h5><p><code>ChainMap</code>可以把多个<code>dict</code>组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个dict，但是<strong>查找的时候，会按照顺序在内部的<code>dict</code>依次查找。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。</span></span><br><span class="line"><span class="comment"># 我们可以用ChainMap实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"><span class="keyword">import</span> os, argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造缺省参数:</span></span><br><span class="line">defaults = &#123;</span><br><span class="line">    <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'guest'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造命令行参数:</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'-u'</span>, <span class="string">'--user'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-c'</span>, <span class="string">'--color'</span>)</span><br><span class="line">namespace = parser.parse_args()</span><br><span class="line">command_line_args = &#123; k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> vars(namespace).items() <span class="keyword">if</span> v &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成ChainMap: 依次从这3个字典里查找是否有指定的字段，优先级依次递减</span></span><br><span class="line">combined = ChainMap(command_line_args, os.environ, defaults)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印参数:</span></span><br><span class="line">print(<span class="string">'color=%s'</span> % combined[<span class="string">'color'</span>])</span><br><span class="line">print(<span class="string">'user=%s'</span> % combined[<span class="string">'user'</span>])</span><br></pre></td></tr></table></figure><h5 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h5><p>常用的就是<code>items()</code>k-v对, <code>keys()</code>键,  <code>values()</code>值  ,<code>elements()</code>打印全部的 k(出现几次就重复几次)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">s=[<span class="string">'asdf'</span>,<span class="string">'asd'</span>,<span class="string">'asdf'</span>,<span class="string">'sdf'</span>]</span><br><span class="line">c=Counter(s)</span><br><span class="line">print(c)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> c.items():</span><br><span class="line">    print(k,v)</span><br><span class="line">print(<span class="string">"-----"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c.elements():</span><br><span class="line">    print(i)</span><br><span class="line">print(<span class="string">"-----"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c.keys():</span><br><span class="line">    print(i)</span><br><span class="line">print(<span class="string">"-----"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c.values():</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000</a></p><h3 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h3><p>可以参考流畅的 python14.9中的标准函数库，里面有详细的介绍</p><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>reduce 函数时最好提供第三个参数，<code>reduce(function, iterable, initializer)</code>，这样能避免这个异常：<code>TypeError: reduce() of empty sequence with no initial value</code>（这个错误消息很棒，说明了问题，还提供了解决方法）。如果序列为空，initializer 是返回的结果；</p><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><p>zip 函数的名字取自拉链系结物（zipper fastener），因为这个物品用于把 两个拉链边的链牙咬合在一起，与文件压缩没有关系。</p><p>itertools.zip_longest 函数的行为有所不同：使用可选的 fillvalue（默认 值为 None）填充缺失的值，因此可以继续产出，直到最长的可迭代对象耗尽。</p><h5 id="all"><a href="#all" class="headerlink" title="all"></a>all</h5><p>如果所有分量对的比较结果都是 True，那么结果就是 True。只要有一次比较的结果是 False，all 函数就返回 False。</p><p><code>return len(self) == len(other) and all(a == b for a, b in zip(self, other))</code></p><h4 id="可迭代的归约函数"><a href="#可迭代的归约函数" class="headerlink" title="可迭代的归约函数"></a>可迭代的归约函数</h4><p><img src="/2020/03/02/python进阶/./image-20190411102548312.png" alt="image-20190411102548312"></p><p>表中的函数都接受一个可迭代的对象(iterable)，然后返回单个结果。这些函数叫“归约”函数（“合拢”函数或“累加”函数）</p><p>这里列出的每个内置函数都可以使用 <code>functools.reduce</code> 函数实现</p><p>但是对 <code>all</code> 和 <code>any</code> 函数来说，有一项重要的优化措施是 <code>reduce</code> 函数做不到的：<strong>这两个函数会短路</strong>（一旦确定了结果就立即停止使用迭代器）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短路现象</span></span><br><span class="line">g = (n <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">0.0</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">any(g) </span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">next(g) </span><br><span class="line"><span class="comment"># 8</span></span><br></pre></td></tr></table></figure><p>sorted 和这些归约函数<strong>只能处理最终会停止的可迭代对象</strong></p><h3 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h3><p>自己定义上下文管理器类之前，先看一下 Python 标准库文档中的“<a href="https://docs.python.org/3/library/contextlib.html" target="_blank" rel="noopener">29.6 contextlib Utilities for with-statement contexts</a>“。contextlib 模块中有一些类和其他函数，使用范围广泛。</p><h2 id="奇淫巧技"><a href="#奇淫巧技" class="headerlink" title="奇淫巧技"></a>奇淫巧技</h2><h4 id="长度为1的切片，是一个元素还是一个列表？"><a href="#长度为1的切片，是一个元素还是一个列表？" class="headerlink" title="长度为1的切片，是一个元素还是一个列表？"></a>长度为1的切片，是一个元素还是一个列表？</h4><p><code>s[0] == s[:1]</code> 只对 str 这个序列类 型成立。不过，str 类型的这个行为十分罕见。对其他各个序列类型来说，<code>s[i]</code>返 回一个元素，而 s[i:i+1] 返回一个相同类型的序列，里面是 s[i] 元素。</p><h3 id="True-False测试"><a href="#True-False测试" class="headerlink" title="True False测试"></a>True False测试</h3><p>默认情况，一个对象都会被认为是 true ，除非定义的 <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a> 返回 <code>False</code> 或者 <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> 返回 0 , 下面是常见的内建对象返回 False 的情况:</p><ul><li>constants defined to be false: <code>None</code> and <code>False</code>.</li><li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li><li>empty sequences and collections: <code>&#39;&#39;</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li></ul><h4 id="在-Python-中，很多情况下类和函数可以互换"><a href="#在-Python-中，很多情况下类和函数可以互换" class="headerlink" title="在 Python 中，很多情况下类和函数可以互换"></a>在 Python 中，很多情况下类和函数可以互换</h4><p>这不仅是因为 Python 没有 new 运算符，还因为有特殊的 <code>__new__</code> 方法，可以把类变成工厂方法，生成不同类型的对象，或者返回事先构建好的实例，而不是每次都创建一个新实例。</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>我编写的每个类都使用驼峰式名称</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h3><h4 id="强类型和弱类型语言"><a href="#强类型和弱类型语言" class="headerlink" title="强类型和弱类型语言"></a>强类型和弱类型语言</h4><p>　　如果一门语言<strong>很少隐式转换类型</strong>，说明它是强类型语言；如果经常这么做，说明 它是弱类型语言。Java、C++ 和 Python 是强类型语言。PHP、JavaScript 和 Perl 是弱类型语言。</p><blockquote><p>Python 不会自动在字符串和数字之间强制转换</p></blockquote><h4 id="静态类型和动态类型"><a href="#静态类型和动态类型" class="headerlink" title="静态类型和动态类型"></a>静态类型和动态类型</h4><p>在<u>编译时</u><strong>检查类型</strong>的语言是静态类型语言，在<u>运行时</u><strong>检查类型</strong>的语言是动态类型语言。<strong>静态类型需要声明类型</strong>（有些现代语言使用类型推导避免部分类型声明）。</p><p>静态类型使得一些工具（编译器和 IDE）便于分析代码、找出错误和提供其他服务 （优化、重构，等等）。动态类型便于代码重用，代码行数更少，而且能让接口自然 成为协议而不提早实行。</p><p>综上，Python 是<strong>动态强类型语言</strong>。</p><p>必须使用 self 访问实例属性也备受批评。 我自己并不介意输入 self 限定符，这样便于把局部变量和属性区分开</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python进阶 </tag>
            
            <tag> python高级 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>attention图解</title>
      <link href="/2020/02/04/attention%E5%9B%BE%E8%A7%A3/"/>
      <url>/2020/02/04/attention%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="回顾自注意力机制"><a href="#回顾自注意力机制" class="headerlink" title="回顾自注意力机制"></a>回顾自注意力机制</h3><p>语言离不开语境，比如这个第二定律：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">机器人第二定律</span><br><span class="line">机器人必须服从人给予它的命令，当命令与第一定律冲突时例外。</span><br></pre></td></tr></table></figure><p>笔者已强调了句子中有三处单词与其他单词有联系。如果不结合语境是无法理解或者处理单词的，所以在模型处理这句话时，了解语境是必要的：</p><p>·    这句话是讲机器人的</p><p>·    这样的命令是定律早期的一部分，也即“人类发出的指令”</p><p>·    第一定律就是指整个第一定律</p><p>自注意力层的流程就是这样。如同烘培一样，它会在加工特定文字之前对其关联词进行预处理（再传递给神经网络层）。其方式就是对每个单词在语段中的相关度进行评分，然后把结果向量加起来。</p><p>例如，顶部的transformer模块的自注意力层在处理“it”时，将重点放在了“robot”上。那么传递给神经网络层的向量将是三个单词中每个单词的向量乘以其分数的总和。</p><p><img src="/2020/02/04/attention图解/./1.png" alt="img"></p><h3 id="自注意力机制处理"><a href="#自注意力机制处理" class="headerlink" title="自注意力机制处理"></a>自注意力机制处理</h3><p>自注意力机制会贯穿于语段中每个词的处理路径。其中重要的组件是三个向量：</p><p>·    Query(查询)：展示了当前的单词，该单词会使用键给其他单词评分。我们只需要注意目前正在处理的词的查询。</p><p>·    Key（键）：键向量就像段中所有单词的标签，是搜索相关词汇时的匹配项。</p><p>·    Value（值）：值向量是实际单词的体现，给每个单词的相关度评过分后，加起来的值就会用来表示当前的单词。</p><p><img src="/2020/02/04/attention图解/./2.png" alt="img"></p><p>该过程可大致理解为在文件柜里进行搜索。查询就如同写有搜索主题的便利贴，键是里面的文件夹名称。对着便利贴寻找标签时，会提取文件夹中的内容，这些内容就是值向量。如果所找值不是一个，而是无数文件夹中的各个值，就要另当别论了。</p><p>将查询向量乘以每个键向量，得到的值即为每个文件夹对应的分数（从专业角度讲：乘指的是向量点乘，乘积会通过 softmax 函数处理）。</p><p><img src="/2020/02/04/attention图解/./3.png" alt="img"></p><p>将值与其分数相乘，再求总和——得出自注意力层结果。</p><p><img src="/2020/02/04/attention图解/./4.png" alt="img"></p><p>该加权向量值的结果，会让模型将50%的注意力都放在词语“robot”上，30%的注意力放在“a”上，还有19%会在“it”上。</p><p>英文原版：<a href="https://jalammar.github.io/illustrated-gpt2/" target="_blank" rel="noopener">https://jalammar.github.io/illustrated-gpt2/</a> </p></the></excerpt>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>keras</title>
      <link href="/2020/02/04/keras/"/>
      <url>/2020/02/04/keras/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h5 id="下载mnist数据集，网络失败的问题"><a href="#下载mnist数据集，网络失败的问题" class="headerlink" title="下载mnist数据集，网络失败的问题"></a>下载mnist数据集，网络失败的问题</h5><p>Keras file is located into a new path in Google Cloud Storage (Before it was in AWS S3)：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://storage.googleapis.com/tensorflow/tf-keras-datasets/mnist.npz</span><br></pre></td></tr></table></figure><p>When using:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.keras.datasets.mnist.load_data()</span><br></pre></td></tr></table></figure><p>You can pass a <code>path</code> parameter.</p><p><code>load_data()</code> will call <code>get_file()</code> which takes as parameter <code>fname</code>, if path is a full path and file exists, it will not be downloaded.</p><p>Example:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gsutil cp gs://tensorflow/tf-keras-datasets/mnist.npz /tmp/data/mnist.npz</span></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">'/tmp/data/mnist.npz'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data(path)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(train_images)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">60000</span></span><br></pre></td></tr></table></figure></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python数据分析库</title>
      <link href="/2020/02/04/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%93/"/>
      <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h5 id="argpartition"><a href="#argpartition" class="headerlink" title="argpartition"></a>argpartition</h5><p>numpy.argpartition：是将第k大的数字，放在第k个位置。类似于快排找第k大的数，对其它数不做排序，比较省计算。</p><p>参考<a href="https://zhuanlan.zhihu.com/p/35325758" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35325758</a></p><h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html#grouping" target="_blank" rel="noopener">https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html#grouping</a></p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>panda 对象、索引都有 name 属性</p><ol><li><p>series，可以认为它是一个长度固定且有序的字典</p><ol><li><p>索引index，可以指定字符串数组为索引，根据此数组顺序进行排序，索引对象是不可变的，无法修改索引对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index[1]=&apos;d&apos;  # TypeError</span><br></pre></td></tr></table></figure></li><li><p>值 value</p></li></ol></li><li><p>dataframe，表示矩阵的数据表，行列索引都用，列索引一般由你指定，行索引可以自动生成，可以嵌套 dataframe</p></li><li><p>当你将列表或者数组赋值给列时，长度必须与 DataFrame 匹配</p></li><li><p>列是 series？同一列有相同的信息（数据类型）。行是 dataframe？</p></li></ol><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><code>Frame[&quot;colunm&quot;]</code>可以获取列，<code>frame.colunm</code> 也可以，但是必须是有效的 Python 值，不存在键时会报错</p><p><code>Frame[&quot;colunm&quot;]=arrange(6)</code>可以创建新的列，但是<code>Frame.colunm=arrange(6)</code>不可以</p><p>索引像数组一样，但是方法像集合</p><p><img src="/2020/02/04/数据分析库/../../../Desktop/个人笔记/image-20191215160830739.png" alt="image-20191215160830738"></p><h5 id="reindex"><a href="#reindex" class="headerlink" title="reindex"></a>reindex</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2=df.reindex(index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],columns=[<span class="string">'f'</span>,<span class="string">'d'</span>,<span class="string">'w'</span>])</span><br></pre></td></tr></table></figure><p>method=’ffile’，向前填充，’bfill’向后填充</p><p>fill_value=0 这是填充值</p><h5 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h5><p>删除 指定行、列，并返回新的对象，如果要修改原对象，可以设置 inplace=True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.drop([<span class="string">"row1"</span>])</span><br><span class="line">data.drop([<span class="string">"col1"</span>],axis=<span class="number">1</span>)</span><br><span class="line">data.drop([<span class="string">"col1"</span>],axis=<span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>数值切片时与 Python 一致不含之后一列，但是字符串切片时，是包含最后的。</p><h5 id="loc-与-iloc"><a href="#loc-与-iloc" class="headerlink" title="loc 与 iloc"></a>loc 与 iloc</h5><p>loc 轴标签，iloc 整数标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.loc[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">loc[:<span class="number">1</span>] <span class="comment"># 包含 1</span></span><br><span class="line">iloc[:<span class="number">1</span>] <span class="comment"># 不包含1 ，有点坑</span></span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><code>sort_index(axis=)</code>，对索引进行排序</p><p><code>sort_values(by=[&#39;a&#39;,&#39;b&#39;])</code>，对值进行排序</p><h4 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h4><p>na : not available</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dropna 过滤掉 na (how=&apos;all&apos;, axis=1，thresh=2)全部是 na 时才是删除，并指定为列，thresh 表示只删除第2列或者行</span><br><span class="line">fillna 替换 na</span><br><span class="line">isnull 判断是否为 na</span><br><span class="line">notnull</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="series"><a href="#series" class="headerlink" title="series"></a>series</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([1, 3, 5, np.nan, 6, 8])</span><br></pre></td></tr></table></figure><h4 id="dataFrame"><a href="#dataFrame" class="headerlink" title="dataFrame"></a>dataFrame</h4><h5 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>) <span class="comment"># 创建时间列表，作为下面的索引</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04','2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>, <span class="number">4</span>), index=dates, columns=list(<span class="string">'ABCD'</span>)) <span class="comment"># index是行索引，columns 是列索引</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   A         B         C         D</span></span><br><span class="line"><span class="string">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span></span><br><span class="line"><span class="string">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span></span><br><span class="line"><span class="string">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span></span><br><span class="line"><span class="string">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span></span><br><span class="line"><span class="string">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span></span><br><span class="line"><span class="string">2013-01-06 -0.673690  0.113648 -1.478427  0.524988</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h5 id="传递字典"><a href="#传递字典" class="headerlink" title="传递字典"></a>传递字典</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span>: <span class="number">1.</span>,</span><br><span class="line">               <span class="string">'B'</span>: pd.Timestamp(<span class="string">'20130102'</span>),</span><br><span class="line">               <span class="string">'C'</span>: pd.Series(<span class="number">1</span>, index=list(range(<span class="number">4</span>)), dtype=<span class="string">'float32'</span>),</span><br><span class="line">               <span class="string">'D'</span>: np.array([<span class="number">3</span>] * <span class="number">4</span>, dtype=<span class="string">'int32'</span>),</span><br><span class="line">               <span class="string">'E'</span>: pd.Categorical([<span class="string">"test"</span>, <span class="string">"train"</span>, <span class="string">"test"</span>, <span class="string">"train"</span>]),</span><br><span class="line">               <span class="string">'F'</span>: <span class="string">'foo'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><h4 id="查看部分内容"><a href="#查看部分内容" class="headerlink" title="查看部分内容"></a>查看部分内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br><span class="line">df.tail(3)</span><br></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.index     <span class="comment"># 行索引</span></span><br><span class="line">df.columns   <span class="comment"># 列索引</span></span><br></pre></td></tr></table></figure><h4 id="转为-numpy"><a href="#转为-numpy" class="headerlink" title="转为 numpy"></a>转为 numpy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df.to_numpy()</span><br><span class="line">Out[17]: </span><br><span class="line">array([[ 0.4691, -0.2829, -1.5091, -1.1356],</span><br><span class="line">       [ 1.2121, -0.1732,  0.1192, -1.0442],</span><br><span class="line">       [-0.8618, -2.1046, -0.4949,  1.0718],</span><br><span class="line">       [ 0.7216, -0.7068, -1.0396,  0.2719],</span><br><span class="line">       [-0.425 ,  0.567 ,  0.2762, -1.0874],</span><br><span class="line">       [-0.6737,  0.1136, -1.4784,  0.525 ]])</span><br></pre></td></tr></table></figure><blockquote><p>  使用<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy" target="_blank" rel="noopener"><code>DataFrame.to_numpy()</code>](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy) 有时代价会非常大，特别是当每列数据类型不同的时候，这是pandas 与 NumPy本质的不同造成的: <strong>整个NumPy数组只有一种数据类型 ,而 pandas 的每一列都可以是不同的数据类型</strong>. 当你使用<code>DataFrame.to_numpy()</code></a>, pandas 要选择一种能覆盖 DataFrame 中所有数据的 NumPy dtype ，最终往往是<code>object</code>, 这就需要将每个值都转为 Python object类型。</p></blockquote><h4 id="查看数值类型的列的统计信息"><a href="#查看数值类型的列的统计信息" class="headerlink" title="查看数值类型的列的统计信息"></a>查看数值类型的列的统计信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.describe()</span><br><span class="line">”“”</span><br><span class="line">count  <span class="number">6.000000</span>  <span class="number">6.000000</span>  <span class="number">6.000000</span>  <span class="number">6.000000</span></span><br><span class="line">mean   <span class="number">0.073711</span> <span class="number">-0.431125</span> <span class="number">-0.687758</span> <span class="number">-0.233103</span></span><br><span class="line">std    <span class="number">0.843157</span>  <span class="number">0.922818</span>  <span class="number">0.779887</span>  <span class="number">0.973118</span></span><br><span class="line">min   <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span></span><br><span class="line"><span class="number">25</span>%   <span class="number">-0.611510</span> <span class="number">-0.600794</span> <span class="number">-1.368714</span> <span class="number">-1.076610</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">0.022070</span> <span class="number">-0.228039</span> <span class="number">-0.767252</span> <span class="number">-0.386188</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">0.658444</span>  <span class="number">0.041933</span> <span class="number">-0.034326</span>  <span class="number">0.461706</span></span><br><span class="line">max    <span class="number">1.212112</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span>  <span class="number">1.071804</span></span><br><span class="line">“”“</span><br></pre></td></tr></table></figure><h4 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.T</span><br></pre></td></tr></table></figure><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><h4 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h4><p>默认是对行索引排序，axis=1 时对列索引排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>) <span class="comment"># 列索引逆序</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   D         C         B         A</span></span><br><span class="line"><span class="string">2013-01-01 -1.135632 -1.509059 -0.282863  0.469112</span></span><br><span class="line"><span class="string">2013-01-02 -1.044236  0.119209 -0.173215  1.212112</span></span><br><span class="line"><span class="string">2013-01-03  1.071804 -0.494929 -2.104569 -0.861849</span></span><br><span class="line"><span class="string">2013-01-04  0.271860 -1.039575 -0.706771  0.721555</span></span><br><span class="line"><span class="string">2013-01-05 -1.087401  0.276232  0.567020 -0.424972</span></span><br><span class="line"><span class="string">2013-01-06  0.524988 -1.478427  0.113648 -0.673690</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="内容排序"><a href="#内容排序" class="headerlink" title="内容排序"></a>内容排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by=<span class="string">'B'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   A         B         C         D</span></span><br><span class="line"><span class="string">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span></span><br><span class="line"><span class="string">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span></span><br><span class="line"><span class="string">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span></span><br><span class="line"><span class="string">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span></span><br><span class="line"><span class="string">2013-01-06 -0.673690  0.113648 -1.478427  0.524988</span></span><br><span class="line"><span class="string">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><h4 id="某行、某列"><a href="#某行、某列" class="headerlink" title="某行、某列"></a>某行、某列</h4><p>列选择：<code>df[&#39;A&#39;]</code>等价于 <code>df.A</code></p><p>行切片：<code>df[0:3]</code></p><h4 id="一大片"><a href="#一大片" class="headerlink" title="一大片"></a>一大片</h4><h5 id="loc：通过-label"><a href="#loc：通过-label" class="headerlink" title="loc：通过 label"></a>loc：通过 label</h5><p>通过 label 选择，指定哪些行，哪些列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [28]: df.loc[&apos;20130102&apos;:&apos;20130104&apos;, [&apos;A&apos;, &apos;B&apos;]]</span><br><span class="line">Out[28]: </span><br><span class="line">                   A         B</span><br><span class="line">2013-01-02  1.212112 -0.173215</span><br><span class="line">2013-01-03 -0.861849 -2.104569</span><br><span class="line">2013-01-04  0.721555 -0.706771</span><br></pre></td></tr></table></figure><p><code>at</code>快速定位一个值 (等价于上面的方法):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [31]: df.at[dates[0], &apos;A&apos;]</span><br><span class="line">Out[31]: 0.4691122999071863</span><br></pre></td></tr></table></figure><h5 id="iloc：通过下标"><a href="#iloc：通过下标" class="headerlink" title="iloc：通过下标"></a>iloc：通过下标</h5><p>指定行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [32]: df.iloc[3]</span><br><span class="line">Out[32]: </span><br><span class="line">A    0.721555</span><br><span class="line">B   -0.706771</span><br><span class="line">C   -1.039575</span><br><span class="line">D    0.271860</span><br><span class="line">Name: 2013-01-04 00:00:00, dtype: float64</span><br></pre></td></tr></table></figure><p>指定连续的行与列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [33]: df.iloc[3:5, 0:2]</span><br><span class="line">Out[33]: </span><br><span class="line">                   A         B</span><br><span class="line">2013-01-04  0.721555 -0.706771</span><br><span class="line">2013-01-05 -0.424972  0.567020</span><br></pre></td></tr></table></figure><p>指定某些行与列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [34]: df.iloc[[1, 2, 4], [0, 2]]</span><br><span class="line">Out[34]: </span><br><span class="line">                   A         C</span><br><span class="line">2013-01-02  1.212112  0.119209</span><br><span class="line">2013-01-03 -0.861849 -0.494929</span><br><span class="line">2013-01-05 -0.424972  0.276232</span><br></pre></td></tr></table></figure><p><code>iat</code>：快速获得一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [38]: df.iat[1, 1]</span><br><span class="line">Out[38]: -0.17321464905330858</span><br><span class="line"></span><br><span class="line"># 等价于</span><br><span class="line">In [37]: df.iloc[1, 1]</span><br><span class="line">Out[37]: -0.17321464905330858</span><br></pre></td></tr></table></figure><h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>基本形式：<code>df[条件表达式]</code></p><p>所有满足条件的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df[df &gt; <span class="number">0</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   A         B         C         D</span></span><br><span class="line"><span class="string">2013-01-01  0.469112       NaN       NaN       NaN</span></span><br><span class="line"><span class="string">2013-01-02  1.212112       NaN  0.119209       NaN</span></span><br><span class="line"><span class="string">2013-01-03       NaN       NaN       NaN  1.071804</span></span><br><span class="line"><span class="string">2013-01-04  0.721555       NaN       NaN  0.271860</span></span><br><span class="line"><span class="string">2013-01-05       NaN  0.567020  0.276232       NaN</span></span><br><span class="line"><span class="string">2013-01-06       NaN  0.113648       NaN  0.524988</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>某一列满足条件的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df[df.A &gt; <span class="number">0</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   A         B         C         D</span></span><br><span class="line"><span class="string">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span></span><br><span class="line"><span class="string">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span></span><br><span class="line"><span class="string">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><code>isin()</code>辅助过滤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df2 = df.copy()</span><br><span class="line">df2[<span class="string">'E'</span>] = [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   A         B         C         D      E</span></span><br><span class="line"><span class="string">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one</span></span><br><span class="line"><span class="string">2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one</span></span><br><span class="line"><span class="string">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two</span></span><br><span class="line"><span class="string">2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three</span></span><br><span class="line"><span class="string">2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four</span></span><br><span class="line"><span class="string">2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">df2[df2[<span class="string">'E'</span>].isin([<span class="string">'two'</span>, <span class="string">'four'</span>])]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   A         B         C         D     E</span></span><br><span class="line"><span class="string">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two</span></span><br><span class="line"><span class="string">2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><h4 id="新增一列"><a href="#新增一列" class="headerlink" title="新增一列"></a>新增一列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 通过 series 新增</span><br><span class="line">s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range(&apos;20130102&apos;, periods=6))</span><br><span class="line"></span><br><span class="line"># 通过 numpy 新增</span><br><span class="line">df.loc[:, &apos;D&apos;] = np.array([5] * len(df))</span><br></pre></td></tr></table></figure><h4 id="通过-label-定位来赋值"><a href="#通过-label-定位来赋值" class="headerlink" title="通过 label 定位来赋值"></a>通过 label 定位来赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [48]: df.at[dates[0], &apos;A&apos;] = 0</span><br></pre></td></tr></table></figure><h4 id="通过下标-position-定位来赋值"><a href="#通过下标-position-定位来赋值" class="headerlink" title="通过下标 position 定位来赋值"></a>通过下标 position 定位来赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [49]: df.iat[0, 1] = 0</span><br></pre></td></tr></table></figure><p>经过上面 3 次操作后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [51]: df</span><br><span class="line">Out[51]: </span><br><span class="line">                   A         B         C  D    F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059  5  NaN</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  5  3.0</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232  5  4.0</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  5  5.0</span><br></pre></td></tr></table></figure><h4 id="通过条件筛选赋值"><a href="#通过条件筛选赋值" class="headerlink" title="通过条件筛选赋值"></a>通过条件筛选赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [52]: df2 = df.copy()</span><br><span class="line"></span><br><span class="line">In [53]: df2[df2 &gt; 0] = -df2</span><br><span class="line"></span><br><span class="line">In [54]: df2</span><br><span class="line">Out[54]: </span><br><span class="line">                   A         B         C  D    F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059 -5  NaN</span><br><span class="line">2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0</span><br><span class="line">2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0</span><br><span class="line">2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0</span><br><span class="line">2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0</span><br></pre></td></tr></table></figure><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>默认 nan 不参与计算</p><h4 id="判断-nan"><a href="#判断-nan" class="headerlink" title="判断 nan"></a>判断 <code>nan</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [60]: pd.isna(df1)</span><br><span class="line">Out[60]: </span><br><span class="line">                A      B      C      D      F      E</span><br><span class="line">2013-01-01  False  False  False  False   True  False</span><br><span class="line">2013-01-02  False  False  False  False  False  False</span><br><span class="line">2013-01-03  False  False  False  False  False   True</span><br><span class="line">2013-01-04  False  False  False  False  False   True</span><br></pre></td></tr></table></figure><h4 id="删除含有-NaN-的行"><a href="#删除含有-NaN-的行" class="headerlink" title="删除含有 NaN 的行"></a>删除含有 NaN 的行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [58]: df1.dropna(how=&apos;any&apos;)</span><br><span class="line">Out[58]: </span><br><span class="line">                   A         B         C  D    F    E</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0</span><br></pre></td></tr></table></figure><h4 id="填充NaN"><a href="#填充NaN" class="headerlink" title="填充NaN"></a>填充NaN</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [59]: df1.fillna(value=5)</span><br><span class="line">Out[59]: </span><br><span class="line">                   A         B         C  D    F    E</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059  5  5.0  1.0</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  5.0</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  5.0</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 平均值</span><br><span class="line">df.mean()</span><br><span class="line"></span><br><span class="line"># 频率计算(series 方法)</span><br><span class="line">s = pd.Series(np.random.randint(0, 7, size=10))</span><br><span class="line">s.value_counts()</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map()</code>是Series对象的一个函数，DataFrame中没有map()，map()的功能是将一个自定义函数作用于Series对象的每个元素。</p><h4 id="aplay"><a href="#aplay" class="headerlink" title="aplay"></a>aplay</h4><p><code>apply()</code>函数的功能是将一个自定义函数作用于DataFrame的行或者列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">df.apply(np.cumsum)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">                   A         B         C   D     F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059   5   NaN</span><br><span class="line">2013-01-02  1.212112 -0.173215 -1.389850  10   1.0</span><br><span class="line">2013-01-03  0.350263 -2.277784 -1.884779  15   3.0</span><br><span class="line">2013-01-04  1.071818 -2.984555 -2.924354  20   6.0</span><br><span class="line">2013-01-05  0.646846 -2.417535 -2.648122  25  10.0</span><br><span class="line">2013-01-06 -0.026844 -2.303886 -4.126549  30  15.0</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">df.apply(lambda x: x.max() - x.min())</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">A    2.073961</span><br><span class="line">B    2.671590</span><br><span class="line">C    1.785291</span><br><span class="line">D    0.000000</span><br><span class="line">F    4.000000</span><br><span class="line">dtype: float64</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="applymap"><a href="#applymap" class="headerlink" title="applymap"></a>applymap</h4><p><code>applymap()</code>函数的功能是将自定义函数作用于DataFrame的所有元素</p><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><p>Note that pattern-matching in str generally uses <a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener">regular expressions</a> by default. str 是通过正则匹配到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;Aaba&apos;, &apos;Baca&apos;, np.nan, &apos;CABA&apos;, &apos;dog&apos;, &apos;cat&apos;])</span><br><span class="line">s.str.lower()</span><br></pre></td></tr></table></figure><h4 id="合并数据"><a href="#合并数据" class="headerlink" title="合并数据"></a>合并数据</h4><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><p>添加一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(8, 4), columns=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;])</span><br><span class="line">s = df.iloc[3]  # 选择原表中的第 4 行</span><br><span class="line">df.append(s, ignore_index=True) # 添加一行到表的最后</span><br></pre></td></tr></table></figure><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p>多行拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: df</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">-0.548702</span>  <span class="number">1.467327</span> <span class="number">-1.015962</span> <span class="number">-0.483075</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.637550</span> <span class="number">-1.217659</span> <span class="number">-0.291519</span> <span class="number">-1.745505</span></span><br><span class="line"><span class="number">2</span> <span class="number">-0.263952</span>  <span class="number">0.991460</span> <span class="number">-0.919069</span>  <span class="number">0.266046</span></span><br><span class="line"><span class="number">3</span> <span class="number">-0.709661</span>  <span class="number">1.669052</span>  <span class="number">1.037882</span> <span class="number">-1.705775</span></span><br><span class="line"><span class="number">4</span> <span class="number">-0.919854</span> <span class="number">-0.042379</span>  <span class="number">1.247642</span> <span class="number">-0.009920</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.290213</span>  <span class="number">0.495767</span>  <span class="number">0.362949</span>  <span class="number">1.548106</span></span><br><span class="line"><span class="number">6</span> <span class="number">-1.131345</span> <span class="number">-0.089329</span>  <span class="number">0.337863</span> <span class="number">-0.945867</span></span><br><span class="line"><span class="number">7</span> <span class="number">-0.932132</span>  <span class="number">1.956030</span>  <span class="number">0.017587</span> <span class="number">-0.016692</span></span><br><span class="line"><span class="number">8</span> <span class="number">-0.575247</span>  <span class="number">0.254161</span> <span class="number">-1.143704</span>  <span class="number">0.215897</span></span><br><span class="line"><span class="number">9</span>  <span class="number">1.193555</span> <span class="number">-0.077118</span> <span class="number">-0.408530</span> <span class="number">-0.862495</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># break it into pieces</span></span><br><span class="line">In [<span class="number">75</span>]: pieces = [df[:<span class="number">3</span>], df[<span class="number">3</span>:<span class="number">7</span>], df[<span class="number">7</span>:]]  <span class="comment">#  从第4 、8行拆开，分成 3 份，然后再进行拼接，还原会原表</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: pd.concat(pieces)</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">-0.548702</span>  <span class="number">1.467327</span> <span class="number">-1.015962</span> <span class="number">-0.483075</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.637550</span> <span class="number">-1.217659</span> <span class="number">-0.291519</span> <span class="number">-1.745505</span></span><br><span class="line"><span class="number">2</span> <span class="number">-0.263952</span>  <span class="number">0.991460</span> <span class="number">-0.919069</span>  <span class="number">0.266046</span></span><br><span class="line"><span class="number">3</span> <span class="number">-0.709661</span>  <span class="number">1.669052</span>  <span class="number">1.037882</span> <span class="number">-1.705775</span></span><br><span class="line"><span class="number">4</span> <span class="number">-0.919854</span> <span class="number">-0.042379</span>  <span class="number">1.247642</span> <span class="number">-0.009920</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.290213</span>  <span class="number">0.495767</span>  <span class="number">0.362949</span>  <span class="number">1.548106</span></span><br><span class="line"><span class="number">6</span> <span class="number">-1.131345</span> <span class="number">-0.089329</span>  <span class="number">0.337863</span> <span class="number">-0.945867</span></span><br><span class="line"><span class="number">7</span> <span class="number">-0.932132</span>  <span class="number">1.956030</span>  <span class="number">0.017587</span> <span class="number">-0.016692</span></span><br><span class="line"><span class="number">8</span> <span class="number">-0.575247</span>  <span class="number">0.254161</span> <span class="number">-1.143704</span>  <span class="number">0.215897</span></span><br><span class="line"><span class="number">9</span>  <span class="number">1.193555</span> <span class="number">-0.077118</span> <span class="number">-0.408530</span> <span class="number">-0.862495</span></span><br></pre></td></tr></table></figure><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>Sql 风格的合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">82</span>]: left = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'lval'</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line">In [<span class="number">83</span>]: right = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'rval'</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: left</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line">   key  lval</span><br><span class="line"><span class="number">0</span>  foo     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  bar     <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: right</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">   key  rval</span><br><span class="line"><span class="number">0</span>  foo     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  bar     <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: pd.merge(left, right, on=<span class="string">'key'</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">   key  lval  rval</span><br><span class="line"><span class="number">0</span>  foo     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  bar     <span class="number">2</span>     <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>类似于数据库的 <code>group by</code>，会有以下步骤</p><ul><li>根据条件来分组</li><li>对每个组应用指定的方法function </li><li>将结果汇总到数据类型中（serie或者 dataframe）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">91</span>]: df = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>,</span><br><span class="line">   ....:                          <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'foo'</span>],</span><br><span class="line">   ....:                    <span class="string">'B'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>,</span><br><span class="line">   ....:                          <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'three'</span>],</span><br><span class="line">   ....:                    <span class="string">'C'</span>: np.random.randn(<span class="number">8</span>),</span><br><span class="line">   ....:                    <span class="string">'D'</span>: np.random.randn(<span class="number">8</span>)&#125;)</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: df</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">     A      B         C         D</span><br><span class="line"><span class="number">0</span>  foo    one <span class="number">-1.202872</span> <span class="number">-0.055224</span></span><br><span class="line"><span class="number">1</span>  bar    one <span class="number">-1.814470</span>  <span class="number">2.395985</span></span><br><span class="line"><span class="number">2</span>  foo    two  <span class="number">1.018601</span>  <span class="number">1.552825</span></span><br><span class="line"><span class="number">3</span>  bar  three <span class="number">-0.595447</span>  <span class="number">0.166599</span></span><br><span class="line"><span class="number">4</span>  foo    two  <span class="number">1.395433</span>  <span class="number">0.047609</span></span><br><span class="line"><span class="number">5</span>  bar    two <span class="number">-0.392670</span> <span class="number">-0.136473</span></span><br><span class="line"><span class="number">6</span>  foo    one  <span class="number">0.007207</span> <span class="number">-0.561757</span></span><br><span class="line"><span class="number">7</span>  foo  three  <span class="number">1.928123</span> <span class="number">-1.623033</span></span><br></pre></td></tr></table></figure><p>根据一列分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">93</span>]: df.groupby(<span class="string">'A'</span>).sum()</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">            C        D</span><br><span class="line">A                     </span><br><span class="line">bar <span class="number">-2.802588</span>  <span class="number">2.42611</span></span><br><span class="line">foo  <span class="number">3.146492</span> <span class="number">-0.63958</span></span><br></pre></td></tr></table></figure><p>根据 多列分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">94</span>]: df.groupby([<span class="string">'A'</span>, <span class="string">'B'</span>]).sum()</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">                  C         D</span><br><span class="line">A   B                        </span><br><span class="line">bar one   <span class="number">-1.814470</span>  <span class="number">2.395985</span></span><br><span class="line">    three <span class="number">-0.595447</span>  <span class="number">0.166599</span></span><br><span class="line">    two   <span class="number">-0.392670</span> <span class="number">-0.136473</span></span><br><span class="line">foo one   <span class="number">-1.195665</span> <span class="number">-0.616981</span></span><br><span class="line">    three  <span class="number">1.928123</span> <span class="number">-1.623033</span></span><br><span class="line">    two    <span class="number">2.414034</span>  <span class="number">1.600434</span></span><br></pre></td></tr></table></figure><h4 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h4><h5 id="时间-序列生成"><a href="#时间-序列生成" class="headerlink" title="时间 序列生成"></a>时间 序列生成</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'3/6/2012 00:00'</span>, periods=<span class="number">5</span>, freq=<span class="string">'D'</span>) </span><br><span class="line"><span class="comment">#起始时间点，数据量，跨度（D：day,M:minute,S：second）</span></span><br></pre></td></tr></table></figure><h4 id="Reshaping-TODO"><a href="#Reshaping-TODO" class="headerlink" title="Reshaping  TODO"></a>Reshaping  TODO</h4><p>TODO</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sklearn</title>
      <link href="/2020/02/04/sklearn/"/>
      <url>/2020/02/04/sklearn/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h4 id="模型保存与加载"><a href="#模型保存与加载" class="headerlink" title="模型保存与加载"></a>模型保存与加载</h4><p>pickle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> pickle</span><br><span class="line">&gt;&gt;&gt; s = pickle.dumps(clf)  # clf是模型对象</span><br><span class="line">&gt;&gt;&gt; clf2 = pickle.loads(s)</span><br><span class="line">&gt;&gt;&gt; clf2.predict(X[<span class="number">0</span>:<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>joblib</p><p>在某些情况，可以使用<code>joblib</code>来代替<code>pickle</code>,，特别是对一些大的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from joblib import dump, load</span><br><span class="line">&gt;&gt;&gt; dump(clf, &apos;filename.joblib&apos;) </span><br><span class="line">&gt;&gt;&gt; clf = load(&apos;filename.joblib&apos;)</span><br></pre></td></tr></table></figure><h4 id="设置超参"><a href="#设置超参" class="headerlink" title="设置超参"></a>设置超参</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clf = SVC()  #实例化</span><br><span class="line">clf.set_params(kernel=&apos;linear&apos;).fit(X, y)  # 实例化后，可以修改超参，进行训练</span><br><span class="line">clf.set_params(kernel=&apos;rbf&apos;, gamma=&apos;scale&apos;).fit(X, y)   # 训练后可以再修改超参，然后再进行训练</span><br></pre></td></tr></table></figure><h4 id="标签处理"><a href="#标签处理" class="headerlink" title="标签处理"></a>标签处理</h4><blockquote><p> <code>fit</code>训练时使用的是哪种类型的标签，预测就会使用对应的类型输出标签。</p><p> 预测时模型可能输出全为0的结果，表示该样本不属于任何类别</p></blockquote><p>情况1：多类别 标签 one-hot 化：<code>LabelBinarizer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import LabelBinarizer</span><br><span class="line">y = [0, 0, 1, 3, 1, 2]</span><br><span class="line">y = LabelBinarizer().fit_transform(y)</span><br><span class="line">print y</span><br><span class="line"></span><br><span class="line">###################################</span><br><span class="line"></span><br><span class="line">[[1 0 0 0]</span><br><span class="line"> [1 0 0 0]</span><br><span class="line"> [0 1 0 0]</span><br><span class="line"> [0 0 0 1]</span><br><span class="line"> [0 1 0 0]</span><br><span class="line"> [0 0 1 0]]</span><br></pre></td></tr></table></figure><p>情况2：多标签 ，每个样本属于多个类别的请情况，使用<code>MultiLabelBinarizer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import MultiLabelBinarizer</span><br><span class="line">y = [[0, 1], [0, 2], [1, 3], [0, 2, 3], [2, 4]] # 每个样本的标签可能有2-3个</span><br><span class="line">y = MultiLabelBinarizer().fit_transform(y)</span><br><span class="line">print y</span><br><span class="line">classif.fit(X, y).predict(X)</span><br><span class="line"></span><br><span class="line">###################################</span><br><span class="line"></span><br><span class="line">[[1 1 0 0 0]</span><br><span class="line"> [1 0 1 0 0]</span><br><span class="line"> [0 1 0 1 0]</span><br><span class="line"> [1 0 1 1 0]</span><br><span class="line"> [0 0 1 0 1]]</span><br><span class="line"> </span><br><span class="line">array([[1, 1, 0, 0, 0],</span><br><span class="line">       [1, 0, 1, 0, 0],</span><br><span class="line">       [0, 1, 0, 1, 0],</span><br><span class="line">       [1, 0, 1, 0, 0],</span><br><span class="line">       [1, 0, 1, 0, 0]])</span><br></pre></td></tr></table></figure><h4 id="获取超参"><a href="#获取超参" class="headerlink" title="获取超参"></a>获取超参</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; estimator = Estimator(param1=1, param2=2)</span><br><span class="line">&gt;&gt;&gt; estimator.param1</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Estimated parameters: When data is fitted with an estimator, parameters are estimated from the data at hand. 所有的 estimated parameters 都是模型的属性，并以下划线结尾:</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; estimator.estimated_param_</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/10km/article/details/51906821" target="_blank" rel="noopener">https://blog.csdn.net/10km/article/details/51906821</a></p><p><a href="https://my.oschina.net/leejun2005/blog/150662" target="_blank" rel="noopener">https://my.oschina.net/leejun2005/blog/150662</a></p><h4 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a>网格搜索</h4><p>TODO</p><p><a href="https://blog.csdn.net/u012897374/article/details/74999940" target="_blank" rel="noopener">https://blog.csdn.net/u012897374/article/details/74999940</a></p></the></excerpt>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>python 多线程与多进程</title>
      <link href="/2019/12/07/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/12/07/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>与线程相关的标准库模块</p><p><img src="/2019/12/07/python-多线程/./线程相关模块.png" alt="Pasted Graphic"></p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>方式一，定义线程函数，实例化<code>Thread</code>类（简单）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code to execute in an independent thread</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'T-minus'</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and launch a thread</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,))</span><br><span class="line"><span class="comment"># t = Thread(target=countdown, args=(10,), daemon=True) #守护进程</span></span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>方式二，定义线程类，可实现复杂需求（推荐）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountdownTask</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._running = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他辅助方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">terminate</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._running = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程执行的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self._running <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'T-minus'</span>, n)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">c = CountdownTask()</span><br><span class="line">t = Thread(target=c.run, args=(<span class="number">10</span>,))</span><br><span class="line"><span class="comment"># t = Thread(target=countdown, args=(10,), daemon=True) #守护进程</span></span><br><span class="line">t.start()</span><br><span class="line">c.terminate() <span class="comment"># 终止信号</span></span><br><span class="line">t.join()      <span class="comment"># Wait for actual termination (if needed)</span></span><br></pre></td></tr></table></figure><p>方式三，继承 Thread 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountdownThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.n &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'T-minus'</span>, self.n)</span><br><span class="line">            self.n -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">c = CountdownThread(<span class="number">5</span>)</span><br><span class="line">c.start()</span><br></pre></td></tr></table></figure><p>尽管这样也可以工作，但这使得你的代码依赖于 <code>threading</code> 库，所以你的这些代码只能在线程上下文中使用。</p><p>而方式二的代码可以被用在其他的上下文中，可能与线程有关，也可能与线程无关。比如，你可以通过 <code>multiprocessing</code> 模块在一个单独的进程中执行你的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line">c = CountdownTask(5)</span><br><span class="line">p = multiprocessing.Process(target=c.run)</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程一般是一个等待客户端请求服务的服务器。 如果没有客户端请求， 守护线程就是空闲的。 如果把一个线程设置为守护线程，就<strong>表示这个线程是不重要的</strong>，主线程准备退出时，不需要等待这个子线程执行完成。<br>启动线程之前执行如下赋值语句： <code>thread.daemon = True</code>（调用 thread.setDaemon(True)的旧方法已经弃用了）。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="event-对象"><a href="#event-对象" class="headerlink" title="event 对象"></a>event 对象</h4><p>TODO</p><p><strong><code>event</code> 对象最好单次使用</strong>，就是说，你创建一个 event 对象，让某个线程等待这个对象，一旦这个对象被设置为真，你就应该丢弃它。尽管可以通过 <code>clear()</code> 方法来重置 event 对象，但是很难确保安全地清理 event 对象并对它重新赋值。很可能会发生错过事件、死锁或者其他问题（特别是，你无法保证重置 event 对象的代码会在线程再次等待这个 event 对象之前执行）。<strong>如果一个线程需要不停地重复使用 event 对象，你最好使用 <code>Condition</code> 对象来代替。</strong></p><h4 id="Condition-对象"><a href="#Condition-对象" class="headerlink" title="Condition 对象"></a>Condition 对象</h4><p>TODO</p><p><code>event</code>对象的一个重要特点是当它被设置为真时会唤醒所有等待它的线程。如果你只想唤醒单个线程，最好是使用信号量或者 <code>Condition</code> 对象来替代</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>I/O 和访问相同的数据结构都属于临界区，因此需要用锁来防止多个线程同时进入临界区。为了加锁，需要添加一行代码来引入Lock（或RLock），然后创建一个锁对象。当情况更加复杂，你可能需要一个更强大的同步原语来代替锁。</p><p><code>Lock</code> 对象和 <code>with</code> 语句块一起使用可以保证互斥执行，每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。相当于<code>lock.acquire()；... lock.release()</code>。相比于这种显式调用的方法，<strong><code>with</code> 语句更加优雅，也更不容易出错</strong>，特别是程序员可能会忘记调用 release() 方法或者程序在获得锁之后产生异常这两种情况（使用 with 语句可以保证在这两种情况下仍能正确释放锁）。</p><h5 id="Lock的最佳实践"><a href="#Lock的最佳实践" class="headerlink" title="Lock的最佳实践"></a>Lock的最佳实践</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedCounter</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    利用这个类，将需要共享的数据、锁都封装起来，暴露给线程的只有方法，是一种非常好的实现方法。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initial_value = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incr</span><span class="params">(self,delta=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Increment the counter with locking</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">with</span> self._value_lock:</span><br><span class="line">             self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decr</span><span class="params">(self,delta=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Decrement the counter with locking</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">with</span> self._value_lock:</span><br><span class="line">             self._value -= delta</span><br></pre></td></tr></table></figure><h5 id="RLock可重入锁"><a href="#RLock可重入锁" class="headerlink" title="RLock可重入锁"></a>RLock可重入锁</h5><p>一个 <code>RLock</code> （可重入锁）可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下，当锁被持有时，只有一个线程可以使用完整的函数或者类中的方法。</p><p>与一个标准的锁不同的是，已经持有这个锁的方法在调用同样使用这个锁的方法时，无需再次获取锁。比如 下面的<code>decr</code> 方法。 这种实现方式的一个<strong>特点</strong>是，无论这个类有多少个实例都只用一个锁。因此在需要大量使用计数器的情况下内存效率更高。不过这样做也有<strong>缺点</strong>，就是在程序中使用大量线程并频繁更新计数器时会有争用锁的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedCounter</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    A counter object that can be shared by multiple threads.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _lock = threading.RLock()   <span class="comment"># 所有类的实例共享的一个类级锁</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initial_value = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self._value = initial_value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incr</span><span class="params">(self,delta=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Increment the counter with locking</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">with</span> SharedCounter._lock:</span><br><span class="line">            self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decr</span><span class="params">(self,delta=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Decrement the counter with locking</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">with</span> SharedCounter._lock:</span><br><span class="line">             self.incr(-delta)</span><br></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>threading 模块包括两种信号量类：<code>Semaphore</code> 和 <code>BoundedSemaphore</code>。如你所知，信号量实际上就是计数器，它们从固定数量的有限资源起始。</p><p>相对于简单地作为锁使用，<strong>信号量更适用于那些需要在线程之间引入信号或者限制的程序</strong>。比如，你需要限制一段代码的并发访问量，你就可以像下面这样使用信号量完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 5 个线程并发</span></span><br><span class="line">_fetch_url_sema = Semaphore(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> _fetch_url_sema:</span><br><span class="line">        <span class="keyword">return</span> urllib.request.urlopen(url)</span><br></pre></td></tr></table></figure><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 <code>queue</code> 库中的队列了。创建一个被多个线程共享的 <code>Queue</code> 对象，这些线程通过使用 <code>put()</code> 和 <code>get()</code> 操作来向队列中添加或者删除元素。</p><h4 id="Queue-模块"><a href="#Queue-模块" class="headerlink" title="Queue 模块"></a>Queue 模块</h4><p>使用 <code>Queue</code> 模块（Python 2.x 版本，在Python 3.x版本中重命名为<code>queue</code>）来提供线程间通信的机制，<code>Queue</code> 对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。通过使用 <code>put()</code> 和 <code>get()</code> 操作来向队列中添加或者删除元素。 </p><p><strong>生产者和消费者</strong></p><p>关于<strong>消费者的关闭问题</strong>解决方法是在队列中放置一个特殊的值，当消费者读到这个值的时候，终止执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># Object that signals shutdown</span></span><br><span class="line">_sentinel = object()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Put the sentinel on the queue to indicate completion</span></span><br><span class="line">    out_q.put(_sentinel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check for termination</span></span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> _sentinel:</span><br><span class="line">            in_q.put(_sentinel) <span class="comment"># 将这个标注放回队列，然后结束当前进程</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h5 id="队列流量控制与非阻塞"><a href="#队列流量控制与非阻塞" class="headerlink" title="队列流量控制与非阻塞"></a>队列流量控制与非阻塞</h5><p>在创建 Queue 对象时提供可选的 <code>size</code> 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，<strong>为队列中的元素数量添加上限是有意义的</strong>。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。</p><p> <code>get()</code> 和 <code>put()</code> 方法都<strong>支持非阻塞方式和设定超时</strong>，这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = q.get(block=<span class="keyword">False</span>) <span class="comment"># 非阻塞式</span></span><br><span class="line"><span class="keyword">except</span> queue.Empty:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = q.get(timeout=<span class="number">5.0</span>) <span class="comment"># 超时</span></span><br><span class="line"><span class="keyword">except</span> queue.Empty:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.put(item, block=<span class="keyword">False</span>) <span class="comment"># 非阻塞</span></span><br><span class="line"><span class="keyword">except</span> queue.Full:</span><br><span class="line">    log.warning(<span class="string">'queued item %r discarded!'</span>, item)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h5 id="不安全的一些方法"><a href="#不安全的一些方法" class="headerlink" title="不安全的一些方法"></a>不安全的一些方法</h5><p>你最好不要在你的代码中使用这些<strong>不是线程安全的</strong>方法： <code>q.qsize()</code> ， <code>q.full()</code> ， <code>q.empty()</code> 获取一个队列的当前大小和状态。因为可能你对一个队列使用 <code>empty()</code> 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。</p><h4 id="Condition自定义线程安全的数据结构"><a href="#Condition自定义线程安全的数据结构" class="headerlink" title="Condition自定义线程安全的数据结构"></a><code>Condition</code>自定义线程安全的数据结构</h4><p>尽管队列是最常见的线程间通信机制，但是仍然可以自己通过创建自己的数据结构并添加所需的锁和同步机制来实现线程间通信。最常见的方法是使用 <code>Condition</code> 变量来包装你的数据结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  自定义的优先级队列</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._queue = []</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item, priority)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            self._cv.notify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            <span class="keyword">while</span> len(self._queue) == <span class="number">0</span>:</span><br><span class="line">                self._cv.wait()</span><br><span class="line">            <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="双向通信"><a href="#双向通信" class="headerlink" title="双向通信"></a>双向通信</h4><p>使用队列来进行线程间通信是一个单向、不确定的过程。通常情况下，你没有办法知道接收数据的线程是什么时候接收到的数据并开始工作的。下面提供 2 种解决办法</p><p>方式一：队列对象提供一些基本完成的特性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 提示队列，消费者数据处理完成</span></span><br><span class="line">        in_q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for all produced items to be consumed</span></span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 将 (data, event) 元组放入队列中</span></span><br><span class="line">        evt = Event()</span><br><span class="line">        out_q.put((data, evt))</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 等待消费者通知</span></span><br><span class="line">        evt.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 获取到数据和 Event 对象</span></span><br><span class="line">        data, evt = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 通知消费者数据处理完成</span></span><br><span class="line">        evt.set()</span><br></pre></td></tr></table></figure><h4 id="数据深拷贝"><a href="#数据深拷贝" class="headerlink" title="数据深拷贝"></a>数据深拷贝</h4><p>使用线程队列有一个要注意的问题是，向队列中添加数据项时并不会复制此数据项，线程间通信实际上是<strong>在线程间传递对象引用</strong>。如果你担心对象的共享状态，那你最好只传递1）不可修改的数据结构（如：整型、字符串或者元组）或者2）一个对象的深拷贝。</p><p>使用 copy 模块进行深拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> copy  <span class="comment"># 使用 copy 模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(copy.deepcopy(data)) <span class="comment"># 深拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br></pre></td></tr></table></figure><h3 id="死锁问题TODO"><a href="#死锁问题TODO" class="headerlink" title="死锁问题TODO"></a>死锁问题TODO</h3><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p05_locking_with_deadlock_avoidance.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p05_locking_with_deadlock_avoidance.html</a></p><h3 id="线程本地存储对象-TODO"><a href="#线程本地存储对象-TODO" class="headerlink" title="线程本地存储对象 TODO"></a>线程本地存储对象 TODO</h3><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p06_storing_thread_specific_state.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p06_storing_thread_specific_state.html</a></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><code>concurrent.futures</code> 函数库有一个 <code>ThreadPoolExecutor</code> 类可以被用来完成这个任务。通常应该避免编写线程数量可以无限制增长的程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> AF_INET, SOCK_STREAM, socket</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_client</span><span class="params">(sock, client_addr)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Handle a client connection</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">'Got connection from'</span>, client_addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        msg = sock.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(<span class="string">'Client closed connection'</span>)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(addr)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  服务器线程</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">    pool = ThreadPoolExecutor(<span class="number">128</span>)  <span class="comment"># 定义线程池大小</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        pool.submit(echo_client, client_sock, client_addr)</span><br><span class="line"></span><br><span class="line">echo_server((<span class="string">''</span>,<span class="number">15000</span>))</span><br></pre></td></tr></table></figure><p>对比手动实现线程池，如果你想手动创建你自己的线程池， 通常可以使用一个Queue来轻松实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_client</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Handle a client connection</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sock, client_addr = q.get()  <span class="comment"># 阻塞性等待</span></span><br><span class="line">    print(<span class="string">'Got connection from'</span>, client_addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        msg = sock.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(<span class="string">'Client closed connection'</span>)</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(addr, nworkers)</span>:</span></span><br><span class="line">    <span class="comment"># Launch the client workers，区别的地方</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(nworkers):</span><br><span class="line">        t = Thread(target=echo_client, args=(q,))</span><br><span class="line">        t.daemon = <span class="keyword">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run the server</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        q.put((client_sock, client_addr)) <span class="comment"># 区别的地方</span></span><br><span class="line"></span><br><span class="line">echo_server((<span class="string">''</span>,<span class="number">15000</span>), <span class="number">128</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>ThreadPoolExecutor</code> 相对于手动实现的一个好处在于它使得 任务提交者更方便的<strong>从被调用函数中获取返回值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    u = urllib.request.urlopen(url)</span><br><span class="line">    data = u.read()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Submit work to the pool</span></span><br><span class="line">a = pool.submit(fetch_url, <span class="string">'http://www.python.org'</span>)</span><br><span class="line">b = pool.submit(fetch_url, <span class="string">'http://www.pypy.org'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the results back</span></span><br><span class="line">x = a.result()</span><br><span class="line">y = b.result()</span><br></pre></td></tr></table></figure><p>例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。 特别的，<code>a.result()</code> 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>由于 Python 的 GIL 的限制，<strong>多线程更适合于 I/O 密集型应用</strong>（I/O 释放了 GIL，可以允 许更多的并发），而不是计算密集型应用。对于后一种情况而言，为了实现更好的并行性，我们有<strong>两种策略</strong>来解决GIL的缺点。</p><p>方法一：如果你完全工作于Python环境中，你可以使用 <code>multiprocessing</code> 模块来创建一个进程池， 并像协同处理器一样的使用它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Processing pool (see below for initiazation)</span></span><br><span class="line">pool = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU 密集性的任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_work</span><span class="params">(args)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在线程中调用进程池</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_thread</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        ...</span><br><span class="line">        r = pool.apply(some_work, (args))</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initiaze the pool</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> multiprocessing</span><br><span class="line">    pool = multiprocessing.Pool()</span><br></pre></td></tr></table></figure><p>这个通过使用一个技巧利用进程池解决了GIL的问题。 当一个线程想要执行CPU密集型工作时，会将任务发给进程池。 然后进程池会在另外一个进程中启动一个单独的Python解释器来工作。 当线程等待结果的时候会释放GIL。 并且，由于计算任务在单独解释器中执行，那么就不会受限于GIL了。 在一个多核系统上面，你会发现这个技术可以让你很好的利用多CPU的优势。</p><p>方法二：另外一个解决GIL的策略是使用C扩展编程技术。这里不做讨论。</p><p>如果你准备使用一个进程池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 </p><ol><li>被执行的操作需要放在一个通过<code>def</code>语句定义的Python函数中，不能是<code>lambda</code>、闭包可调用实例等， 并且函数参数和返回值必须要兼容pickle。 </li><li>同样，要执行的任务量必须足够大以弥补额外的通信开销。</li></ol><h3 id="jupyter-的-bug"><a href="#jupyter-的-bug" class="headerlink" title="jupyter 的 bug"></a>jupyter 的 bug</h3><p><strong>jupyter的setDeamon有bug</strong>，<code>setDaemon(True)</code>在<code>jupyter</code>中会主进程会等待子进程结束。这是有问题的。</p><p><code>setDaemon()</code> ： 设置此线程<strong>是否被主线程守护回收</strong>，<strong>需要在 <code>start</code> 方法前调用</strong>。</p><ul><li>默认<code>False</code>不回收，也就是主进程运行到最后一行后，会等待子进程结束；</li><li>设为<code>True</code>相当于向主线程中注册守护，主线程结束时会将其一并回收，子进程不论是否运行完成</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,id)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.id=id</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">"this is "</span> + str(self.id)+ self.getName())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="number">999</span>)</span><br><span class="line">    t1.setDaemon(<span class="keyword">False</span>)</span><br><span class="line">    t1.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">"I am the father thread"</span>)</span><br></pre></td></tr></table></figure><p><code>join()</code>： 设置主线程是否同步阻塞自己来待此子线程执行完毕</p><ul><li>没有<code>t.join()</code>时，主进程启动子进程后会继续执行后续代码，然后等待子进程结束（如果没有设置<code>t1.setDaemon(True)</code>）</li><li><code>join</code>时，主进程会被阻塞，等待调用了<code>t.join()</code>的子进程<code>t</code>结束。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.id = id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"this is "</span> + str(self.id) + self.getName())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ts=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ts.append(MyThread(i))</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ts:</span><br><span class="line">        t.start()<span class="comment">#  启动了第1个子进程，之后调用join，主进程就被阻塞，无法启动下一个子进程</span></span><br><span class="line">        t.join()<span class="comment">#  主进程会卡在这里，一直等待第1个子进程运行结束，才进入下一次循环，启动下一个进程</span></span><br><span class="line">    print(<span class="string">"I am the father thread"</span>)</span><br></pre></td></tr></table></figure><p>这才是比较正确的做法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.id = id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"this is "</span> + str(self.id) + self.getName())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ts=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ts.append(MyThread(i))</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ts:</span><br><span class="line">        t.start()<span class="comment"># 启动所有子进程，子进程在后台，主进程继续后面的代码，不会阻塞</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ts:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"start"</span>+t.getName()</span><br><span class="line">        t.join()<span class="comment"># 这时候进行join，使得主进程在这里被第一个子进程t阻塞，但是所有子进程都在运行。第一个进程结束后，主进程恢复运行，执行第二个子进程的join，这时的第二个子进程是有可能已经结束了的</span></span><br><span class="line">    print(<span class="string">"I am the father thread"</span>)</span><br></pre></td></tr></table></figure><p>所以 <code>setDeamon(True)</code>与<code>join</code>共用时应该是没有效果的（我的观点）</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python cookbook</title>
      <link href="/2019/12/01/python-cookbook/"/>
      <url>/2019/12/01/python-cookbook/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">python cookbook</a>的阅读笔记，对内容进行了简练。将常用的知识点记录下来。</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="字典的构造方式"><a href="#字典的构造方式" class="headerlink" title="字典的构造方式"></a>字典的构造方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a,b,c是常用的方式</span></span><br><span class="line">a = dict(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>) <span class="comment"># 注意 one、two、three表示字符串，不用加引号</span></span><br><span class="line">b = &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</span><br><span class="line">c = dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">d = dict([(<span class="string">'two'</span>, <span class="number">2</span>), (<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'three'</span>, <span class="number">3</span>)])</span><br><span class="line">e = dict(&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>&#125;)</span><br><span class="line">a == b == c == d == e <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h4 id="字典键值的获取"><a href="#字典键值的获取" class="headerlink" title="字典键值的获取"></a>字典键值的获取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one = a[<span class="string">'four'</span>] <span class="comment"># 键不存在时，会报错KeyError，因此推荐get方法，设置默认值</span></span><br><span class="line">one = a.get(<span class="string">'four'</span>)</span><br><span class="line"><span class="comment"># None</span></span><br><span class="line">one=a.get(<span class="string">'four'</span>,<span class="number">4</span>) <span class="comment"># get(key [,default])</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h4 id="字典键值的添加"><a href="#字典键值的添加" class="headerlink" title="字典键值的添加"></a>字典键值的添加</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="string">'key'</span>] = value</span><br><span class="line">a.setdefault(<span class="string">"key"</span>[,default])   <span class="comment"># 不要被这个名字给骗了，注意不会使用default修改原来的值</span></span><br><span class="line"><span class="comment"># 如果key在字典中，返回他的value. If not, 插入该键，设置为default 并返回 default。default 默认是 None。注意不会使用default修改原来的值。</span></span><br></pre></td></tr></table></figure><p>个人觉得与get的差别只有 不存在给定的键时会不会在字典中添加该键。</p><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,<span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    <span class="comment"># counts[kw] += 1 会抛出KeyError异常</span></span><br><span class="line">    counts[kw] = counts.setdefault(kw, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># counts[kw] = counts.get(kw, 0) + 1 效果相同</span></span><br></pre></td></tr></table></figure><h4 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h4><p>有没有一种字典它本身提供了默认值的功能呢？答案是肯定的，那就是 <code>collections.defaultdict</code> 。</p><p>定义：<code>defaultdict</code>([<em>default_factory</em>[, <em>…</em>]])</p><blockquote><p><code>default_factory</code>：必须是<code>callable</code>类型，因此可以是类型（如int、list）、函数。在 <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.__missing__" target="_blank" rel="noopener"><code>__missing__()</code></a> 方法中会使用default_factory ; default_factory使用第一个参数初始化，否则为None。</p><p><code>__missing__</code>：在调用 <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法或者<code>dict[key]</code>未找到key时，会调用<code>__missing__</code>(<em>key</em>)方法。 如果default_factory 是 None，则抛出异常。如果不是None，则为给定键提供默认值，插入到字典中，并返回。</p></blockquote><p>注意：这种形式的默认值只有在通过 <code>dict[key]</code>或者 <code>dict.__getitem__(key)</code> 访问的时候才有效。</p><p><strong>default_factory：类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">s = <span class="string">'mississippi'</span></span><br><span class="line">d = defaultdict(int) <span class="comment"># 默认为0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line">     d[k] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">sorted(d.items())</span><br><span class="line"><span class="comment"># [('i', 4), ('m', 1), ('p', 2), ('s', 4)]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">s = [(<span class="string">'yellow'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'yellow'</span>, <span class="number">3</span>), (<span class="string">'blue'</span>, <span class="number">4</span>), (<span class="string">'red'</span>, <span class="number">1</span>)]</span><br><span class="line">d = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">     d[k].append(v)</span><br><span class="line"></span><br><span class="line">sorted(d.items())</span><br><span class="line">[(<span class="string">'blue'</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="string">'red'</span>, [<span class="number">1</span>]), (<span class="string">'yellow'</span>, [<span class="number">1</span>, <span class="number">3</span>])]</span><br></pre></td></tr></table></figure><p><strong>default_factory：函数、lambda 函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提供函数</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constant_factory</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: value</span><br><span class="line"></span><br><span class="line">d = defaultdict(constant_factory(<span class="string">'&lt;missing&gt;'</span>)) <span class="comment"># </span></span><br><span class="line">d.update(name=<span class="string">'John'</span>, action=<span class="string">'ran'</span>)</span><br><span class="line">print(<span class="string">'%(name)s %(action)s to %(object)s'</span> % d)</span><br><span class="line"><span class="comment"># 'John ran to &lt;missing&gt;'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提供lambda 函数</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">s = <span class="string">'mississippi'</span></span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span> : <span class="number">0</span>) <span class="comment"># 默认为0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line">     d[k] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">sorted(d.items())</span><br><span class="line"><span class="comment"># [('i', 4), ('m', 1), ('p', 2), ('s', 4)]</span></span><br></pre></td></tr></table></figure><h3 id="队列与堆"><a href="#队列与堆" class="headerlink" title="队列与堆"></a>队列与堆</h3><h4 id="deque队列"><a href="#deque队列" class="headerlink" title="deque队列"></a>deque队列</h4><ul><li>在队列<strong>两端插入或删除</strong>元素时间复杂度都是 <code>O(1)</code> ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 <code>O(N)</code> 。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>deque(maxlen=N)</code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; q = deque(maxlen=3)</span><br><span class="line">&gt;&gt;&gt; q.append(1)</span><br><span class="line">&gt;&gt;&gt; q.append(2)</span><br><span class="line">&gt;&gt;&gt; q.append(3)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line">deque([1, 2, 3], maxlen=3)</span><br><span class="line">&gt;&gt;&gt; q.append(4)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line">deque([2, 3, 4], maxlen=3)</span><br><span class="line">&gt;&gt;&gt; q.append(5)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line">deque([3, 4, 5], maxlen=3)</span><br></pre></td></tr></table></figure><h4 id="heapq堆-TODO"><a href="#heapq堆-TODO" class="headerlink" title="heapq堆(TODO )"></a>heapq堆(TODO )</h4><p>在底层实现里面，首先会先将集合数据<strong>进行堆排序后放入一个列表中</strong></p><h3 id="解压赋值、星号表达式"><a href="#解压赋值、星号表达式" class="headerlink" title="解压赋值、星号表达式"></a>解压赋值、星号表达式</h3><h4 id="解压赋值给多个变量"><a href="#解压赋值给多个变量" class="headerlink" title="解压赋值给多个变量"></a>解压赋值给多个变量</h4><ul><li><p>任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。 唯一的前提就是<strong>变量的数量必须跟序列元素的数量是一样的。</strong></p></li><li><p>解压赋值可以用在<strong>任何可迭代对象</strong>上面，而不仅仅是列表或者元组。 包括字符串，文件对象，迭代器和生成器。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;Hello&apos;</span><br><span class="line">a, b, c, d, e = s</span><br></pre></td></tr></table></figure><ul><li>你可能只想解压一部分，丢弃其他的值。可以使用任意变量名去占位，到时候丢掉这些变量就行了，最常用的占位符就<code>_</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [ &apos;ACME&apos;, 50, 91.1, (2012, 12, 21) ]</span><br><span class="line">_, shares, price, _ = data</span><br></pre></td></tr></table></figure><h4 id="变量与星号"><a href="#变量与星号" class="headerlink" title="变量与星号"></a>变量与星号</h4><p>扩展的迭代解压语法是专门<strong>为解压不确定个数或任意个数元素的可迭代对象</strong>而设计的。</p><p>假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是<u>不确定数量</u>的电话号码。 你可以像下面这样分解这些记录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以解压元组</span></span><br><span class="line">record = (<span class="string">'Dave'</span>, <span class="string">'dave@example.com'</span>, <span class="string">'773-555-1212'</span>, <span class="string">'847-555-1212'</span>)</span><br><span class="line">name, email, *phone_numbers = record</span><br><span class="line">print(name)             <span class="comment">#'Dave'</span></span><br><span class="line">print(email)            <span class="comment">#'dave@example.com'</span></span><br><span class="line">print(phone_numbers)    <span class="comment"># ['773-555-1212', '847-555-1212']</span></span><br></pre></td></tr></table></figure><p>你有一个公司前 8 个月销售数据的序列， 但是你想看下最近一个月数据和前面 7 个月的平均值的对比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以解压列表</span></span><br><span class="line">*trailing, current = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">print(trailing)            <span class="comment"># [10, 8, 7, 1, 9, 5, 10]</span></span><br><span class="line">print(current)            `<span class="comment"># 3</span></span><br><span class="line">trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs)</span><br></pre></td></tr></table></figure><p>在学期末的时候， 统计家庭作业的平均成绩，但是排除掉第一个和最后一个分数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first, *middle, last = grades</span><br><span class="line">avg(middle)</span><br></pre></td></tr></table></figure><p><strong>星号<code>*</code>解压出的变量永远都是list列表类型</strong> ，不管解压的数量是多少(包括 0 个)。试着理解下面这些容易让人困惑的点：</p><ul><li><p><code>*elements = iterable</code> 会让 <code>elements</code> 变为 list 类型；</p></li><li><p>但是 <code>elements = *iterable,</code> 会让 <code>elements</code> 变成 tuple类型</p><blockquote><p>因为这等价于<code>elements= e1,e2...en,</code>(e是iterable对象中的元素)，<code>e1,e2...en,</code>就是tuple类型，试试这个<code>a=1,</code>，a就成了一个tuple对象，等价于<code>a=(1,)</code></p></blockquote></li></ul><p>理解上面的以后，下面的就能理解了吧。</p><ul><li><p><code>first, *elements = *iterable,</code> ，elements是list类型</p></li><li><p><code>*elements, = *iterabl,</code> ，elements是list类型。</p><blockquote><p>注意：<code>*elements = *iterabl,</code></p><p>SyntaxError: starred assignment target must be in a list or tuple</p><p>报错提示：星号赋值的目标element必须在list、tuple中，因此像上面的写法（加个逗号）才是对的。</p></blockquote></li></ul><h4 id="函数与星号"><a href="#函数与星号" class="headerlink" title="函数与星号"></a>函数与星号</h4><p>一、函数定义中的星号</p><p>函数定义中的星号，<code>def func(a,*b)</code> 表示接受可变参数，分配给位置参数后剩下的参数(关键字参数、<code>**</code>解压的字典参数除外)会被封装为tuple。</p><p>整体的参数定义的<strong>顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong>。</p><p>在一个函数的接收参数中，同时出现”非关键字参数（位置参数）”和”关键字参数”时，可以使用一个<strong>单星号</strong>来分隔这两种参数，这种叫做<strong>命名关键字参数</strong>。命名关键字参数可以有默认值，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mix</span><span class="params">(a,b,*,x,y=<span class="number">4</span>)</span>:</span></span><br><span class="line">    <span class="string">"""位置参数与命名关键字参数混合"""</span></span><br><span class="line">    <span class="keyword">return</span> a,b,x,y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 星号前面的a和b是位置参数，星号后面的x和y是关键字参数，并且 x 有默认值</span></span><br><span class="line"><span class="comment"># 调用mix()函数并传入参数时，关键字参数一定要使用"变量名=值"的形式传入数据，如果同位置参数一样传入数据，就会引发一个TypeError异常</span></span><br><span class="line"></span><br><span class="line">print(mix(<span class="number">1</span>,<span class="number">2</span>,x=<span class="number">3</span>,y=<span class="number">4</span>))</span><br><span class="line">print(mix(<span class="number">1</span>,<span class="number">2</span>,x=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># print(mix(1,2,3,4)) </span></span><br><span class="line"><span class="comment"># Error, mix() takes 2 positional arguments but 4 were given</span></span><br></pre></td></tr></table></figure><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了（<strong>func2中的 b 是命名关键字参数，不是默认参数</strong>），但是调用时必须显示指明给命名参数的赋值，否则会被可变参数全部接收，无法改变默认值。出现你意料之外的问题，如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置参数，默认参数，可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(a,b=<span class="number">3</span>,*c)</span>:</span></span><br><span class="line">    print(vars())</span><br><span class="line"></span><br><span class="line">func1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)     <span class="comment"># 2会赋值给默认参数b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位置参数，可变参数，命名关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(a,*c,b=<span class="number">3</span>)</span>:</span></span><br><span class="line">    print(vars())</span><br><span class="line"></span><br><span class="line">func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)     <span class="comment"># 2，3，4全部被可变参数接收，默认参数b不会被改变</span></span><br><span class="line">func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,b=<span class="number">4</span>)   <span class="comment"># 除非显示指定要改变默认参数</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># &#123;'c': (3, 4), 'b': 2, 'a': 1&#125;</span></span><br><span class="line"> <span class="comment"># &#123;'c': (2, 3, 4), 'b': 3, 'a': 1&#125;</span></span><br><span class="line"> <span class="comment"># &#123;'c': (2, 3), 'b': 4, 'a': 1&#125;</span></span><br></pre></td></tr></table></figure><p>综合的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a,b 是位置参数，c 是默认参数，d 是可变参数，e,f 是命名关键字参数，并且 e 有默认值，kw 是关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,c=<span class="number">1</span>,*d,e=<span class="number">1</span>,f,**kw)</span>:</span></span><br><span class="line">    print(vars())</span><br><span class="line">    </span><br><span class="line">d=&#123;<span class="string">'m'</span>:<span class="number">4</span>&#125;</span><br><span class="line">func(*(<span class="number">1</span>,<span class="number">2</span>),<span class="number">3</span>,*(<span class="number">4</span>,<span class="number">5</span>),<span class="number">6</span>, e=<span class="number">2</span>,f=<span class="number">3</span>,**d,**&#123;<span class="string">'x'</span>: <span class="number">2</span>&#125;, y=<span class="number">3</span>,**&#123;<span class="string">'z'</span>: <span class="number">3</span>&#125;,g=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 等价于如下：</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,e=<span class="number">2</span>,f=<span class="number">3</span>,**&#123;<span class="string">'m'</span>:<span class="number">4</span>,<span class="string">'x'</span>:<span class="number">2</span>,<span class="string">'y'</span>:<span class="number">3</span>,<span class="string">'z'</span>:<span class="number">3</span>,<span class="string">'g'</span>:<span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure><p>关键字参数和命名关键字参数的区别在于：<strong>前者可以传递任何名字的参数，而后者只能传递*后面名字的参数。</strong></p><p>二、函数调用时的星号</p><p>在调用函数时，<code>func(1,*[2,3,4,5])</code>， <code>*</code>操作符会将 iterable对象（如 list、 tuple）中的元素提取出来，就像他们是另外的位置参数，替换了原本iterable对象的位置，因此相当于<code>func(1,2,3,4,5)</code>，对于字典对象的解压也是一样的。</p><blockquote><p>在 version 3.5之前，只能接收一个<code>*</code> 和 <code>**</code> unpackings，之后( <a href="https://www.python.org/dev/peps/pep-0448" target="_blank" rel="noopener"><strong>PEP 448</strong></a>) 发生了一些改变： 函数调用时，允许接受<strong>任意多个</strong> <code>*</code> 和 <code>**</code> unpackings。</p></blockquote><p>因此在理解调用函数时出现的<code>*</code>与<code>**</code>，<strong>将他们替换为”位置参数”和”关键字参数”即可。</strong>因此在调用时，位置参数 与 <code>*</code> 表达式参数 没有位置顺序的限制 ，关键字参数 与<code>**</code>表达式参数也没有位置顺序的限制。</p><p>参数顺序问题：</p><p>函数调用也是遵循参数定义的顺序规则，关键字参数 必须在 位置参数 之后， <code>**</code> 表达式参数 在 <code>*</code> 表达式参数之后。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,c=<span class="number">1</span>,*d,e=<span class="number">1</span>,**kw)</span>:</span></span><br><span class="line">    print(vars())</span><br><span class="line">    </span><br><span class="line">d=&#123;<span class="string">'m'</span>:<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用时的顺序，以及任意多个 unpacking 参数</span></span><br><span class="line">func(*(<span class="number">1</span>,<span class="number">2</span>),<span class="number">3</span>,*(<span class="number">4</span>,<span class="number">5</span>),<span class="number">6</span>, e=<span class="number">2</span>, **d,**&#123;<span class="string">'x'</span>: <span class="number">2</span>&#125;, y=<span class="number">3</span>,**&#123;<span class="string">'z'</span>: <span class="number">3</span>&#125;,f=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 等价于 func(1,2,3,4,5,6,e=2,&#123;'m':4,'x':2,'y':3,'z':3,'f':5&#125;)  记住诀窍：将*与**替换为"位置参数"和"关键字参数"即可</span></span><br></pre></td></tr></table></figure><p>虽然“<code>*</code>表达式参数“可以出现在”关键字参数”后面，但是 它会比“关键字参数”（<code>**</code>表达式）<strong>优先处理</strong> ，相当于python 帮你提前了。(在这里那个替换诀窍暂时不能用。)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a, b)</span><br><span class="line">f(<span class="number">1</span>, *(<span class="number">2</span>,))</span><br><span class="line"><span class="comment"># 1 2</span></span><br><span class="line"></span><br><span class="line">f(b=<span class="number">1</span>, *(<span class="number">2</span>,))</span><br><span class="line"><span class="comment"># 2 1</span></span><br><span class="line"></span><br><span class="line">f(a=<span class="number">1</span>, *(<span class="number">2</span>,)) <span class="comment"># 2先被赋值给 a，因此 a=1 会导致重复赋值</span></span><br><span class="line"><span class="comment"># TypeError: f() got multiple values for keyword argument 'a'</span></span><br></pre></td></tr></table></figure></p><p>重复键问题：</p><p>字典与Function 对待重复键是不同的，字典允许重复键，但函数会引发error。比如如果一个位置参数<code>def func(a)</code> 通过 位置、关键字这两种方法提供了值<code>func(1,a=3)</code>就会引发错误；使用 <code>**</code> unpackings引起得出重复，比如 <code>f(**{&#39;x&#39;: 2},**{&#39;x&#39;: 3})</code>，也会引发错误。</p><h4 id="zip与星号"><a href="#zip与星号" class="headerlink" title="zip与星号(*)"></a>zip与星号(*)</h4><p>zip 方法在 Python 2 和 Python 3 中的不同：</p><ul><li>在 Python 3 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。</li><li>在python3中（<strong>有个大坑</strong>），处于优化内存的考虑，<strong>只能访问一次</strong>(操作一次），内存就会释放</li></ul><ol><li><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">   </span><br><span class="line">lis=list(zip(a,b,c)) </span><br><span class="line">print(lis)</span><br><span class="line"><span class="comment"># [(1, 4, 7), (2, 5, 8), (3, 6, 9)]</span></span><br></pre></td></tr></table></figure></li><li><p>星号*进行解压，解压的效果：提取iterable对象内的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">zipped_list = list(zip(a,b))</span><br><span class="line">print(zipped_list) </span><br><span class="line">print(*zipped_list)</span><br><span class="line"><span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"><span class="comment"># (1, 4) (2, 5) (3, 6)</span></span><br></pre></td></tr></table></figure></li><li><p>zip 与 *zip 进行逆操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">lis = zip(a,b)   <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">result = zip(*lis) <span class="comment"># 等价于 zip( (1, 4), (2, 5), (3, 6) )</span></span><br><span class="line">aa,bb = list(result)</span><br><span class="line">print(aa,bb)</span><br><span class="line"><span class="comment"># (1, 2, 3), (4, 5, 6) 又获得原来的a、b</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="用Shell通配符匹配字符串"><a href="#用Shell通配符匹配字符串" class="headerlink" title="用Shell通配符匹配字符串"></a>用Shell通配符匹配字符串</h3><p><code>fnmatch</code> 模块提供了两个函数—— <code>fnmatch()</code> 和 <code>fnmatchcase()</code> ，可以用 <strong>Unix Shell</strong> 中常用的通配符(比如 <code>*.py</code> , <code>Dat[0-9]*.csv</code> 等)去匹配文本字符串。</p><p><code>fnmatch()</code> 函数匹配能力介于简单的字符串方法和强大的正则表达式之间。 如果在数据处理操作中只需要简单的通配符就能完成的时候，这通常是一个比较合理的方案。</p><p>如果你的代码需要做文件名的匹配，最好使用 <code>glob</code> 模块。参考5.13小节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch, fnmatchcase</span><br><span class="line"></span><br><span class="line">print(fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'*.txt'</span>))</span><br><span class="line">print(fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'?oo.txt'</span>))</span><br><span class="line">print(fnmatch(<span class="string">'Dat45.csv'</span>, <span class="string">'Dat[0-9]*'</span>))</span><br><span class="line">names = [<span class="string">'Dat1.csv'</span>, <span class="string">'Dat2.csv'</span>, <span class="string">'config.ini'</span>, <span class="string">'foo.py'</span>]</span><br><span class="line">[name <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> fnmatch(name, <span class="string">'Dat*.csv'</span>)]</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># ['Dat1.csv', 'Dat2.csv']</span></span><br></pre></td></tr></table></figure><p><code>fnmatch()</code> 函数使用<strong>底层操作系统的大小写敏感规则</strong>(不同的系统是不一样的)来匹配模式。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># On OS X (Mac)</span><br><span class="line">fnmatch(&apos;foo.txt&apos;, &apos;*.TXT&apos;)</span><br><span class="line"># False</span><br><span class="line"># On Windows</span><br><span class="line">fnmatch(&apos;foo.txt&apos;, &apos;*.TXT&apos;)</span><br><span class="line"># True</span><br></pre></td></tr></table></figure><p>如果你对这个区别很在意，可以使用 <code>fnmatchcase()</code> 来代替。它完全使用你的模式大小写匹配。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fnmatchcase(&apos;foo.txt&apos;, &apos;*.TXT&apos;)</span><br><span class="line"># False</span><br></pre></td></tr></table></figure><h3 id="正则表达式匹配字符串"><a href="#正则表达式匹配字符串" class="headerlink" title="正则表达式匹配字符串"></a>正则表达式匹配字符串</h3><p>如果你想匹配的是字面字符串，那么你通常只需要调用<u>基本字符串方法</u>就行， 比如 <code>str.find()</code> , <code>str.endswith()</code> , <code>str.startswith()</code> 或者类似的方法。</p><p>对于复杂的匹配需要使用正则表达式和 <code>re</code> 模块， 核心步骤就是先使用 <code>re.compile()</code> 编译正则表达式字符串， 然后使用 <code>match()</code> , <code>search()</code>,<code>findall()</code> 或者 <code>finditer()</code> 等方法。</p><blockquote><p>需要注意的是 <code>match()</code> 方法仅仅检查字符串的从头开始部分，出现在字符串中间的子串不会匹配到。它的匹配结果有可能并不是你期望的那样。</p></blockquote><p>如果你仅仅是做一次简单的文本匹配/搜索操作的话，可以略过编译部分，直接使用 <code>re</code> 模块级别的函数。如果你打算做大量的匹配和搜索操作的话，最好先编译正则表达式，然后再重复使用它。 </p><blockquote><p>模块级别的函数会将<strong>最近编译过的模式缓存起来</strong>，因此并不会消耗太多的性能， 但是如果使用预编译模式的话，你将会进一步减少查找和一些额外的处理损耗。</p></blockquote><p>当写正则式字符串的时候，相对普遍的做法是使用原始字符串比如 <code>r&#39;(\d+)/(\d+)/(\d+)&#39;</code> 。 这种字符串将不去解析反斜杠，这在正则表达式中是很有用的。 如果不这样做的话，你必须使用两个反斜杠，类似 <code>&#39;(\\d+)/(\\d+)/(\\d+)&#39;</code> 。</p><h3 id="字符串搜索和替换"><a href="#字符串搜索和替换" class="headerlink" title="字符串搜索和替换"></a>字符串搜索和替换</h3><p>对于简单的字面模式，直接使用 <code>str.replace()</code> 方法即可，对于复杂的模式，请使用 <code>re</code> 模块中的 <code>sub()</code> 函数。如将形式为 <code>11/27/2012</code> 的日期字符串改成 <code>2012-11-27</code> 。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span></span><br><span class="line">re.sub(<span class="string">r'(\d+)/\d+)/(\d+)'</span>, <span class="string">r'\3-\1-\2'</span>, text)</span><br><span class="line"><span class="comment"># 'Today is 2012-11-27. PyCon starts 2013-3-13.'</span></span><br></pre></td></tr></table></figure><p><code>sub()</code> 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 <code>\3</code> 指向前面模式的捕获组号。</p><p><code>sub()</code> 函数除了接受替换字符串外，还能接受一个回调函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">'UPPER PYTHON, lower python, Mixed Python'</span></span><br><span class="line">re.findall(<span class="string">'python'</span>, text, flags=re.IGNORECASE)</span><br><span class="line"><span class="comment"># ['PYTHON', 'python', 'Python']</span></span><br><span class="line"></span><br><span class="line">re.sub(<span class="string">'python'</span>, <span class="string">'snake'</span>, text, flags=re.IGNORECASE) <span class="comment"># 替换为字符串</span></span><br><span class="line"><span class="comment"># 'UPPER snake, lower snake, Mixed snake'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matchcase</span><span class="params">(word)</span>:</span></span><br><span class="line">    <span class="comment"># 定义 处理不同match时替换为不同的字符串 的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(m)</span>:</span></span><br><span class="line">        text = m.group()</span><br><span class="line">        <span class="keyword">if</span> text.isupper():</span><br><span class="line">            <span class="keyword">return</span> word.upper()</span><br><span class="line">        <span class="keyword">elif</span> text.islower():</span><br><span class="line">            <span class="keyword">return</span> word.lower()</span><br><span class="line">        <span class="keyword">elif</span> text[<span class="number">0</span>].isupper():</span><br><span class="line">            <span class="keyword">return</span> word.capitalize()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> word</span><br><span class="line">    <span class="keyword">return</span> replace</span><br><span class="line"></span><br><span class="line">re.sub(<span class="string">'python'</span>, matchcase(<span class="string">'snake'</span>), text, flags=re.IGNORECASE) <span class="comment"># 使用回调函数</span></span><br><span class="line"><span class="comment"># 'UPPER SNAKE, lower snake, Mixed Snake'</span></span><br></pre></td></tr></table></figure><h3 id="多行匹配模式"><a href="#多行匹配模式" class="headerlink" title="多行匹配模式"></a>多行匹配模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">comment = re.compile(<span class="string">r'/\*(.*?)\*/'</span>)</span><br><span class="line">text1 = <span class="string">'/* this is a comment */'</span></span><br><span class="line">text2 = <span class="string">'''/* this is a</span></span><br><span class="line"><span class="string">multiline comment */</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">comment.findall(text1)</span><br><span class="line"><span class="comment"># [' this is a comment ']</span></span><br><span class="line">comment.findall(text2)</span><br><span class="line"><span class="comment"># []</span></span><br><span class="line"></span><br><span class="line">re.compile(<span class="string">r'/\*(.|\n)*?\*/'</span>)</span><br></pre></td></tr></table></figure><h3 id="将Unicode文本标准化-统一unicode文本"><a href="#将Unicode文本标准化-统一unicode文本" class="headerlink" title="将Unicode文本标准化(统一unicode文本)"></a>将Unicode文本标准化(统一unicode文本)</h3><p>处理Unicode字符串，需要<strong>确保所有字符串在底层有相同的表示</strong>。</p><p>因为在Unicode中，<strong>某些字符能够用多个合法的编码表示</strong>。为了说明，考虑下面的这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'Spicy Jalape\u00f1o'</span></span><br><span class="line">s2 = <span class="string">'Spicy Jalapen\u0303o'</span></span><br><span class="line">print(s1)</span><br><span class="line"><span class="comment"># 'Spicy Jalapeño'</span></span><br><span class="line">print(s1)</span><br><span class="line"><span class="comment"># 'Spicy Jalapeño'</span></span><br><span class="line">s1 == s2</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">len(s1)</span><br><span class="line"><span class="comment"># 14</span></span><br><span class="line">len(s2)</span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure><p>为了修正这个问题，你可以使用unicodedata模块先将文本标准化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line">t1 = unicodedata.normalize(<span class="string">'NFC'</span>, s1)</span><br><span class="line">t2 = unicodedata.normalize(<span class="string">'NFC'</span>, s2)</span><br><span class="line">print(t1 == t2)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(ascii(t1))</span><br><span class="line"><span class="string">'Spicy Jalape\xf1o'</span></span><br><span class="line">t3 = unicodedata.normalize(<span class="string">'NFD'</span>, s1)</span><br><span class="line">t4 = unicodedata.normalize(<span class="string">'NFD'</span>, s2)</span><br><span class="line">print(t3 == t4)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(ascii(t3))</span><br><span class="line"><span class="comment"># 'Spicy Jalapen\u0303o'</span></span><br></pre></td></tr></table></figure><h4 id="标准化的标准"><a href="#标准化的标准" class="headerlink" title="标准化的标准"></a>标准化的标准</h4><p><code>normalize()</code> 第一个参数指定字符串标准化的方式。 NFC表示<strong>字符应该是整体</strong>组成(比如可能的话就使用单一编码，会把’eu0301’2个字节压缩到1个字节’é’。)，而NFD表示字符应该<strong>分解为多个组合字符</strong>表示。</p><p>python同样支持扩展的标准化形式NFKC和NFKD，它们在处理某些字符的时候增加了额外的兼容特性。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'\ufb01'</span> <span class="comment"># 一个单字节的字符</span></span><br><span class="line"><span class="string">'ﬁ'</span></span><br><span class="line">unicodedata.normalize(<span class="string">'NFD'</span>, s)</span><br><span class="line"><span class="string">'ﬁ'</span></span><br><span class="line"><span class="comment"># 注意组合的字符如何被分解</span></span><br><span class="line">unicodedata.normalize(<span class="string">'NFKD'</span>, s)</span><br><span class="line"><span class="string">'fi'</span></span><br><span class="line">unicodedata.normalize(<span class="string">'NFKC'</span>, s)</span><br><span class="line"><span class="string">'fi'</span></span><br></pre></td></tr></table></figure><h4 id="处理和音字符（TODO-2-12还没看）"><a href="#处理和音字符（TODO-2-12还没看）" class="headerlink" title="处理和音字符（TODO 2.12还没看）"></a>处理和音字符（TODO 2.12还没看）</h4><p>在清理和过滤文本的时候字符的标准化也是很重要的。 比如，假设你想清除掉一些文本上面的变音符的时候(可能是为了搜索和匹配)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = unicodedata.normalize(<span class="string">'NFD'</span>, s1)</span><br><span class="line"><span class="string">''</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> t1 <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c))</span><br><span class="line"><span class="string">'Spicy Jalapeno'</span></span><br></pre></td></tr></table></figure><p>最后一个例子展示了 <code>unicodedata</code> 模块的另一个重要方面，也就是测试字符类的工具函数。<strong><code>combining()</code> 函数可以测试一个字符是否为和音字符。</strong></p><h4 id="正则中匹配unicode字符"><a href="#正则中匹配unicode字符" class="headerlink" title="正则中匹配unicode字符"></a>正则中匹配unicode字符</h4><p>如果你想在模式中包含指定的Unicode字符，你可以使用Unicode字符对应的转义序列(比如 <code>\uFFF</code>或者 <code>\UFFFFFFF</code> )。 </p><p>下面是一个匹配几个不同<u>阿拉伯编码页面</u>中所有字符的正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arabic = re.compile(<span class="string">'[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]+'</span>)</span><br></pre></td></tr></table></figure><h4 id="注意大小写转换问题"><a href="#注意大小写转换问题" class="headerlink" title="注意大小写转换问题"></a>注意大小写转换问题</h4><p>当执行匹配和搜索操作的时候，最好是先标准化并且清理所有文本为标准化格式。 但是同样也应该注意一些特殊情况，比如在忽略大小写匹配和大小写转换时的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pat = re.compile(<span class="string">'stra\u00dfe'</span>, re.IGNORECASE)</span><br><span class="line">s = <span class="string">'straße'</span></span><br><span class="line">pat.match(s) <span class="comment"># 匹配成功</span></span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object at 0x10069d370&gt;</span></span><br><span class="line">pat.match(s.upper()) <span class="comment"># 匹配失败</span></span><br><span class="line">s.upper() <span class="comment"># Case folds</span></span><br><span class="line"><span class="comment"># 'STRASSE'</span></span><br></pre></td></tr></table></figure><h3 id="删除字符串中空白字符（不需要的字符）"><a href="#删除字符串中空白字符（不需要的字符）" class="headerlink" title="删除字符串中空白字符（不需要的字符）"></a>删除字符串中空白字符（不需要的字符）</h3><h4 id="开始、结束的字符"><a href="#开始、结束的字符" class="headerlink" title="开始、结束的字符"></a>开始、结束的字符</h4><p>用于删除开始或结尾的字符，默认情况下，<code>strip、lstrip、rstrip</code>方法会去除空白字符，但是你也可以指定其他字符，<strong>注意strip()指定其他字符的使用，只要在开始或者结尾位置的字符符合指定的字符之一，就会被删除。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="string">'---=-hello===-='</span></span><br><span class="line">t.lstrip(<span class="string">'-'</span>)</span><br><span class="line"><span class="comment"># '=-hello===-='</span></span><br><span class="line"></span><br><span class="line">t.rstrip(<span class="string">'='</span>)</span><br><span class="line"><span class="comment"># '---=-hello==-'</span></span><br><span class="line"></span><br><span class="line">t.strip(<span class="string">'-='</span>)   <span class="comment">#注意该情况</span></span><br><span class="line"><span class="comment"># 'hello'</span></span><br></pre></td></tr></table></figure><h4 id="中间的字符"><a href="#中间的字符" class="headerlink" title="中间的字符"></a>中间的字符</h4><p>如果你<strong>想处理中间的空格</strong>，那么你需要求助其他技术。比如使用 <code>replace()</code> 方法或者是用正则表达式替换。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.replace(<span class="string">' '</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment"># 'helloworld'</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.sub(<span class="string">'\s+'</span>, <span class="string">' '</span>, s)</span><br><span class="line"><span class="comment"># 'hello world'</span></span><br></pre></td></tr></table></figure><h4 id="strip与生成器"><a href="#strip与生成器" class="headerlink" title="strip与生成器"></a>strip与生成器</h4><p>通常情况下你想将字符串 <code>strip</code> 操作和其他迭代操作相结合，比如从文件中读取多行数据。 如果是这样的话，那么生成器表达式就可以大显身手了。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    lines = (line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>在这里，表达式 <code>lines = (line.strip() for line in f)</code> 执行数据转换操作。 <strong>这种方式非常高效</strong>，因为它不需要预先读取所有数据放到一个临时的列表中去。 它仅仅只是创建一个生成器，并且每次返回行之前会先执行 <code>strip</code> 操作。</p><h3 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h3><p>结论：优先选择 <code>format()</code> 函数或者方法。</p><ul><li><code>format()</code> 要比 <code>%</code> 操作符的功能更为强大。</li><li><code>format()</code> 也比使用 <code>ljust()</code> , <code>rjust()</code> 或 <code>center()</code> 方法更通用(<em>使用 <code>&lt;,&gt;</code> 或者 <code>^</code> 字符后面紧跟一个指定的宽度</em>)， 因为它可以用来格式化任意对象，而不仅仅是字符串。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用空格对齐</span></span><br><span class="line">format(text, <span class="string">'&lt;20'</span>)   <span class="comment"># 等价于 text.ljust(20) </span></span><br><span class="line"><span class="comment"># 'Hello World         '</span></span><br><span class="line">format(text, <span class="string">'&gt;20'</span>)   <span class="comment"># 等价于 text.rjust(20)</span></span><br><span class="line"><span class="comment"># '         Hello World'</span></span><br><span class="line">format(text, <span class="string">'^20'</span>)   <span class="comment"># 等价于 text.center(20)</span></span><br><span class="line"><span class="comment"># '    Hello World     '</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用指定字符对齐</span></span><br><span class="line">format(text, <span class="string">'=&gt;20'</span>)  <span class="comment"># 等价于 text.rjust(20,'=')</span></span><br><span class="line"><span class="comment"># '=========Hello World'</span></span><br><span class="line">format(text, <span class="string">'*^20'</span>)  <span class="comment"># 等价于 text.center(20,'*')</span></span><br><span class="line"><span class="comment"># '****Hello World*****'</span></span><br></pre></td></tr></table></figure><p>当格式化多个值的时候，这些格式代码也可以被用在 <code>format()</code> 方法中。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;'</span>.format(<span class="string">'Hello'</span>, <span class="string">'World'</span>)</span><br><span class="line"><span class="comment"># '     Hello      World'</span></span><br></pre></td></tr></table></figure><h3 id="合并拼接字符串"><a href="#合并拼接字符串" class="headerlink" title="合并拼接字符串"></a>合并拼接字符串</h3><h4 id="推荐使用-join"><a href="#推荐使用-join" class="headerlink" title="推荐使用 join"></a>推荐使用 join</h4><p>如果你仅仅只是合并少数几个字符串，使用加号(+)通常已经足够了。</p><p>如果你想要合并的字符串是在一个序列或者 <code>iterable</code> 中，那么最快的方式就是使用 <code>join()</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parts = [<span class="string">'Is'</span>, <span class="string">'Chicago'</span>, <span class="string">'Not'</span>, <span class="string">'Chicago?'</span>]</span><br><span class="line"><span class="string">' '</span>.join(parts)</span><br><span class="line"><span class="comment"># 'Is Chicago Not Chicago?'</span></span><br></pre></td></tr></table></figure><blockquote><p>初看起来，这种语法看上去会比较怪，但是 <code>join()</code> 被指定为字符串的一个方法。 这样做的部分原因是你想去连接的对象可能来自各种不同的数据序列(比如列表，元组，字典，文件，集合或生成器等)， 如果在所有这些对象上都定义一个 <code>join()</code>方法明显是冗余的。 </p></blockquote><p>一个相对比较聪明的技巧是<strong>利用生成器表达式</strong>转换数据为字符串的同时合并字符串，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>]</span><br><span class="line"><span class="string">','</span>.join(str(d) <span class="keyword">for</span> d <span class="keyword">in</span> data)</span><br><span class="line"><span class="comment"># 'ACME,50,91.1'</span></span><br></pre></td></tr></table></figure><h4 id="避免不必要的拼接"><a href="#避免不必要的拼接" class="headerlink" title="避免不必要的拼接"></a>避免不必要的拼接</h4><p>比如在打印的时候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(a + <span class="string">':'</span> + b + <span class="string">':'</span> + c) <span class="comment"># Ugly</span></span><br><span class="line">print(<span class="string">':'</span>.join([a, b, c])) <span class="comment"># Still ugly</span></span><br><span class="line">print(a, b, c, sep=<span class="string">':'</span>) <span class="comment"># 推荐</span></span><br></pre></td></tr></table></figure><p>当混合使用I/O操作和字符串连接操作的时候，有时候需要仔细研究你的程序。 比如，考虑下面的两端代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 1 (string concatenation)</span></span><br><span class="line">f.write(chunk1 + chunk2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Version 2 (separate I/O operations)</span></span><br><span class="line">f.write(chunk1)</span><br><span class="line">f.write(chunk2)</span><br></pre></td></tr></table></figure><p>如果<strong>两个字符串很小，那么第一个版本性能会更好些</strong>，因为I/O系统调用天生就慢。 另外一方面，如果两个字符串很大，那么第二个版本可能会更加高效， 因为<strong>它避免了创建一个很大的临时结果并且要复制大量的内存块数据</strong>。</p><h3 id="以指定列宽-格式化字符串"><a href="#以指定列宽-格式化字符串" class="headerlink" title="以指定列宽 格式化字符串"></a>以指定列宽 格式化字符串</h3><p>使用 <code>textwrap</code> 模块来格式化字符串的输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"Look into my eyes, look into my eyes, the eyes, the eyes, the eyes, not around the eyes, don't look around the eyes, look into my eyes, you're under."</span></span><br><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line">print(textwrap.fill(s, <span class="number">70</span>))</span><br><span class="line"><span class="comment"># Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,</span></span><br><span class="line"><span class="comment"># not around the eyes, don't look around the eyes, look into my eyes,</span></span><br><span class="line"><span class="comment"># you're under.</span></span><br><span class="line"></span><br><span class="line">print(textwrap.fill(s, <span class="number">40</span>))</span><br><span class="line"><span class="comment"># Look into my eyes, look into my eyes,</span></span><br><span class="line"><span class="comment"># the eyes, the eyes, the eyes, not around</span></span><br><span class="line"><span class="comment"># the eyes, don't look around the eyes,</span></span><br><span class="line"><span class="comment"># look into my eyes, you're under.</span></span><br><span class="line"></span><br><span class="line">print(textwrap.fill(s, <span class="number">40</span>, initial_indent=<span class="string">'    '</span>))</span><br><span class="line"><span class="comment">#     Look into my eyes, look into my</span></span><br><span class="line"><span class="comment"># eyes, the eyes, the eyes, the eyes, not</span></span><br><span class="line"><span class="comment"># around the eyes, don't look around the</span></span><br><span class="line"><span class="comment"># eyes, look into my eyes, you're under.</span></span><br><span class="line"></span><br><span class="line">print(textwrap.fill(s, <span class="number">40</span>, subsequent_indent=<span class="string">'    '</span>))</span><br><span class="line"><span class="comment"># Look into my eyes, look into my eyes,</span></span><br><span class="line"><span class="comment">#    the eyes, the eyes, the eyes, not</span></span><br><span class="line"><span class="comment">#    around the eyes, don't look around</span></span><br><span class="line"><span class="comment">#    the eyes, look into my eyes, you're</span></span><br><span class="line"><span class="comment">#    under.</span></span><br></pre></td></tr></table></figure><p>当你希望输出自动匹配终端大小的时候。 你可以使用 <code>os.get_terminal_size()</code> 方法来获取终端的大小尺寸。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.get_terminal_size().columns</span><br></pre></td></tr></table></figure><p><code>fill()</code> 方法接受一些其他可选参数来控制tab，语句结尾等。 参阅 <a href="https://docs.python.org/3.6/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener">textwrap.TextWrapper文档</a> 获取更多内容。</p><h3 id="在字符串中处理html和xml-TODO-未看"><a href="#在字符串中处理html和xml-TODO-未看" class="headerlink" title="在字符串中处理html和xml(TODO 未看)"></a>在字符串中处理html和xml(TODO 未看)</h3><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p17_handle_html_xml_in_text.html#htmlxml" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p17_handle_html_xml_in_text.html#htmlxml</a></p><h3 id="字符串令牌解析-TODO-未看"><a href="#字符串令牌解析-TODO-未看" class="headerlink" title="字符串令牌解析(TODO 未看)"></a>字符串令牌解析(TODO 未看)</h3><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p18_tokenizing_text.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p18_tokenizing_text.html</a></p><h2 id="数字日期和时间"><a href="#数字日期和时间" class="headerlink" title="数字日期和时间"></a>数字日期和时间</h2><h3 id="数字的四舍五入"><a href="#数字的四舍五入" class="headerlink" title="数字的四舍五入"></a>数字的四舍五入</h3><h4 id="简单的四舍五入"><a href="#简单的四舍五入" class="headerlink" title="简单的四舍五入"></a>简单的四舍五入</h4><p>使用内置的 <code>round(value, ndigits)</code> 函数即可。</p><p><strong>一、关于保留的位数</strong></p><p>传给 <code>round()</code> 函数的 <code>ndigits</code> 参数可以是<strong>负数</strong>，这种情况下， 舍入运算会作用在十位、百位、千位等上面。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1627731</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(a, <span class="number">-1</span>)</span><br><span class="line"><span class="number">1627730</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(a, <span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p><strong>二、关于四舍五入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## python2 ##</span><br><span class="line">round(0.5)</span><br><span class="line">1.0</span><br><span class="line"></span><br><span class="line">## python3 ##</span><br><span class="line">round(0.5)</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>在python2.7的doc中，<code>round()</code>的最后写着保留值将保留到离上一位更近的一端（四舍六入），如果距离两端一样远，则保留到<strong>离0远的一边</strong>。所以round(0.5)会近似到1，而round(-0.5)会近似到-1。</p><blockquote><p>  Values are rounded to the closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are equally close, rounding is done away from 0</p></blockquote><p>但是到了python3.5的doc中，文档变成了如果距离两边一样远，会<strong>保留到偶数的一边</strong>。比如round(0.5)和round(-0.5)都会保留到0，而round(1.5)会保留到2。</p><blockquote><p>  values are rounded to the closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are equally close, rounding is done toward the even choice</p></blockquote><p><strong>三、关于精度问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(2.675, 2)</span><br><span class="line">2.67</span><br></pre></td></tr></table></figure><p><code>round(2.675, 2)</code>的结果，不论我们从python2还是3来看，结果都应该是2.68的，结果它偏偏是2.67，为什么？这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串1和0后可能是无限位数的，机器已经做出了截断处理。那么在<strong>机器中保存的2.675这个数字就比实际数字要小那么一点点</strong>。这一点点就导致了它离2.67要更近一点点，所以保留两位小数时就近似到了2.67。</p><p> <strong>总结</strong></p><p>以上。除非对精确度没什么要求，否则尽量避开用<code>round()</code>函数。近似计算我们还有其他的选择：</p><ol><li>使用math模块中的一些函数，比如<code>math.ceiling</code>（天花板除法）。</li><li>python自带整除，python2中是<code>/</code>，3中是<code>//</code>，还有<code>div</code>函数。</li><li>字符串格式化可以做截断使用，例如 <code>&quot;%.2f&quot; % value</code>（保留两位小数并变成字符串，如果还想用浮点数请披上<code>float()</code>的外衣）。</li><li>当然，对浮点数精度要求如果很高的话，请用decimal模块。</li></ol><p>参考 <a href="https://www.cnblogs.com/anpengapple/p/6507271.html" target="_blank" rel="noopener">https://www.cnblogs.com/anpengapple/p/6507271.html</a></p><h3 id="数值格式化指令"><a href="#数值格式化指令" class="headerlink" title="数值格式化指令"></a>数值格式化指令</h3><p>定宽度和精度的一般形式是 <code>&#39;[&lt;&gt;^]?width[,]?(.digits)?&#39;</code> ， 其中 <code>width</code> 和 <code>digits</code> 为整数，<code>？</code>代表可选部分。 同样的格式也被用在字符串的 <code>format()</code> 方法中。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;The value is &#123;:0,.2f&#125;&apos;.format(x)</span><br><span class="line">&apos;The value is 1,234.57&apos;</span><br></pre></td></tr></table></figure><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h4 id="10-进制—-gt-其他"><a href="#10-进制—-gt-其他" class="headerlink" title="10 进制—&gt;其他"></a>10 进制—&gt;其他</h4><p><strong>带前缀的</strong></p><p>使用 <code>bin()</code> , <code>oct()</code> 或 <code>hex()</code> 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 1234</span><br><span class="line">&gt;&gt;&gt; bin(x)</span><br><span class="line">&apos;0b10011010010&apos;</span><br><span class="line">&gt;&gt;&gt; oct(x)</span><br><span class="line">&apos;0o2322&apos;</span><br><span class="line">&gt;&gt;&gt; hex(x)</span><br><span class="line">&apos;0x4d2&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>没有前缀的</strong></p><p>如果不想输出 <code>0b</code> , <code>0o</code> 或者 <code>0x</code> 的前缀的话，可以使用 <code>format()</code> 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; format(x, &apos;b&apos;)</span><br><span class="line">&apos;10011010010&apos;</span><br><span class="line">&gt;&gt;&gt; format(x, &apos;o&apos;)</span><br><span class="line">&apos;2322&apos;</span><br><span class="line">&gt;&gt;&gt; format(x, &apos;x&apos;)</span><br><span class="line">&apos;4d2&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="其他—-gt-10-进制"><a href="#其他—-gt-10-进制" class="headerlink" title="其他—&gt;10 进制"></a>其他—&gt;10 进制</h4><p>其他的进制转换整数，简单的使用带有进制的 <code>int()</code> 函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'4d2'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'10011010010'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>字节到大整数的打包与解包</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p05_pack_unpack_large_int_from_bytes.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p05_pack_unpack_large_int_from_bytes.html</a></p><h3 id="无穷大与-NaN"><a href="#无穷大与-NaN" class="headerlink" title="无穷大与 NaN"></a>无穷大与 NaN</h3><p><strong>定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = float(&apos;inf&apos;)</span><br><span class="line">&gt;&gt;&gt; b = float(&apos;-inf&apos;)</span><br><span class="line">&gt;&gt;&gt; c = float(&apos;nan&apos;)</span><br></pre></td></tr></table></figure><p><strong>检测</strong></p><p>测试是否为这些值，使用 <code>math.isinf()</code> 和 <code>math.isnan()</code> 函数。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.isinf(a)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; math.isnan(c)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>传播</strong></p><p>无穷大数在执行数学计算的时候会传播</p><p>NaN值会在所有操作中传播，而不会产生异常</p><p>NaN值的一个特别的地方时它们之间的比较操作总是返回False。因此唯一安全的方法就是使用 <code>math.isnan()</code> </p><h3 id="分数运算"><a href="#分数运算" class="headerlink" title="分数运算"></a>分数运算</h3><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p08_calculating_with_fractions.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p08_calculating_with_fractions.html</a></p><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><h4 id="随机小数"><a href="#随机小数" class="headerlink" title="随机小数"></a>随机小数</h4><p><code>random.random()</code>方法用于生成一个0到1的随机浮点数：<code>0&lt;=n&lt;1.0</code></p><p><code>random.uniform()</code> 计算均匀分布随机数,<code>0&lt;=n&lt;1.0</code></p><h4 id="随机整数"><a href="#随机整数" class="headerlink" title="随机整数"></a>随机整数</h4><p><code>random.randint(a,b)</code>：用于生成一个指定范围内的整数。其中生成的随机数n：a&lt;=n&lt;=b</p><p><code>random.randrange([start],stop[, step])</code>：从指定范围内，按指定基数递增的集合中获取一个随机数。如：<code>random.randrange(10,100,2)</code>，结果相当于从[10,12,14,16,…,96,98]序列中获取一个随机数。<code>random.randrange(10,100,2)</code>在结果上与<code>random.choice(range(10,100,2))</code>等效。</p><h4 id="随机选择数组中的1个"><a href="#随机选择数组中的1个" class="headerlink" title="随机选择数组中的1个"></a>随机选择数组中的1个</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> random.choice([<span class="string">"JGood"</span>,<span class="string">"is"</span>,<span class="string">"a"</span>,<span class="string">"handsome"</span>,<span class="string">"body"</span>])</span><br><span class="line"><span class="keyword">is</span></span><br></pre></td></tr></table></figure><h4 id="随机选择数组中的-N个"><a href="#随机选择数组中的-N个" class="headerlink" title="随机选择数组中的 N个"></a>随机选择数组中的 N个</h4><p><code>random.sample(sequence,k)</code>：从指定序列中随机获取指定长度的片段，sample函数不会修改原有序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> random.sample(list,<span class="number">5</span>) <span class="comment">#从list中随机获取5个元素，作为一个片段返回</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/chamie/p/4917820.html" target="_blank" rel="noopener">https://www.cnblogs.com/chamie/p/4917820.html</a></p><h3 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h3><h4 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h4><p><code>datetime</code> 模块，可以进行常规的加减计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">a = datetime(2012, 9, 23)</span><br><span class="line">b = datetime(2012, 9, 20)</span><br><span class="line">print(a - b)</span><br><span class="line"># 3 days, 0:00:00</span><br></pre></td></tr></table></figure><p>为了表示一个时间段，可以创建一个 <code>timedelta</code> 实例，就像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line">a = timedelta(days=<span class="number">2</span>, hours=<span class="number">6</span>)</span><br><span class="line">b = timedelta(hours=<span class="number">4.5</span>)</span><br><span class="line">c = a + b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.days</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.seconds</span><br><span class="line"><span class="number">37800</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.total_seconds() / <span class="number">3600</span></span><br><span class="line"><span class="number">58.5</span></span><br></pre></td></tr></table></figure><p>在计算的时候，需要注意的是 <code>datetime</code> 会自动处理闰年。</p><p><strong>高级库</strong></p><p>如果你需要执行更加复杂的日期操作，比如处理时区，模糊时间范围，节假日计算等等， 可以考虑使用 <a href="http://pypi.python.org/pypi/python-dateutil" target="_blank" rel="noopener">dateutil模块</a></p><h4 id="循环时间"><a href="#循环时间" class="headerlink" title="循环时间"></a>循环时间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> d <span class="keyword">in</span> date_range(datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">1</span>), datetime(<span class="number">2012</span>,<span class="number">10</span>,<span class="number">1</span>),</span><br><span class="line">                        timedelta(hours=<span class="number">6</span>)):</span><br><span class="line"><span class="meta">... </span>    print(d)</span><br><span class="line">...</span><br><span class="line"><span class="number">2012</span><span class="number">-09</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2012</span><span class="number">-09</span><span class="number">-01</span> <span class="number">06</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>这种实现之所以这么简单，还得归功于Python中的日期和时间能够使用标准的数学和比较操作符来进行运算。</p><h4 id="字符串与时间对象"><a href="#字符串与时间对象" class="headerlink" title="字符串与时间对象"></a>字符串与时间对象</h4><p><strong>字符串—&gt;时间：strptime</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'2012-09-20'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = datetime.strptime(text, <span class="string">'%Y-%m-%d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff = z - y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff</span><br><span class="line">datetime.timedelta(<span class="number">3</span>, <span class="number">77824</span>, <span class="number">177393</span>)</span><br></pre></td></tr></table></figure><p><strong>时间—&gt;字符串：strftime</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">datetime.datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">37</span>, <span class="number">4</span>, <span class="number">177393</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nice_z = datetime.strftime(z, <span class="string">'%A %B %d, %Y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nice_z</span><br><span class="line"><span class="string">'Sunday September 23, 2012'</span></span><br></pre></td></tr></table></figure><h4 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h4><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p16_manipulate_dates_involving_timezone.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p16_manipulate_dates_involving_timezone.html</a></p><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="next函数"><a href="#next函数" class="headerlink" title="next函数"></a>next函数</h3><p>一、默认会抛出异常 <code>StopIteration</code> 用来指示迭代的结尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                line = next(f)</span><br><span class="line">                print(line, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>二、通过返回一个指定值来标记结尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        line = next(f, <span class="keyword">None</span>)   <span class="comment"># 设置为不抛出异常，返回 None 的方式</span></span><br><span class="line">        <span class="keyword">if</span> line <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(line, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="文件与-IO"><a href="#文件与-IO" class="headerlink" title="文件与 IO"></a>文件与 IO</h2><h3 id="TODO-5-4，5-6，-5-8，5-9，5-10，5-18-5-20-略"><a href="#TODO-5-4，5-6，-5-8，5-9，5-10，5-18-5-20-略" class="headerlink" title="TODO 5.4，5.6， 5.8，5.9，5.10，5.18, 5.20(略)"></a>TODO 5.4，5.6， 5.8，5.9，5.10，5.18, 5.20(略)</h3><h3 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h3><h4 id="rt-wt-at模式"><a href="#rt-wt-at模式" class="headerlink" title="rt,wt,at模式"></a><code>rt,wt,at</code>模式</h4><p>使用带<code>t</code>的模式，文件的读写操作默认使用系统编码，可以通过调用 <code>sys.getdefaultencoding()</code> 来得到。 在大多数机器上面都是utf-8编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment"># process line</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text1)</span><br><span class="line">    f.write(text2)</span><br></pre></td></tr></table></figure><h4 id="x模式，文件不存在才能写入"><a href="#x模式，文件不存在才能写入" class="headerlink" title="x模式，文件不存在才能写入"></a><code>x</code>模式，文件不存在才能写入</h4><blockquote><p>  x模式是一个Python3对 <code>open()</code> 函数特有的扩展。 在Python的旧版本或者是Python实现的底层C函数库中都是没有这个模式的。</p></blockquote><p>可以在 <code>open()</code> 函数中使用 <code>x</code> 模式来代替 <code>w</code> 模式的方法来解决这个问题。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&apos;somefile&apos;, &apos;wt&apos;) as f:</span><br><span class="line">...     f.write(&apos;Hello\n&apos;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; with open(&apos;somefile&apos;, &apos;xt&apos;) as f:</span><br><span class="line">...     f.write(&apos;Hello\n&apos;)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">FileExistsError: [Errno 17] File exists: &apos;somefile&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果文件是二进制的，使用 <code>xb</code> 来代替 <code>xt</code></p><h4 id="文件对象的属性"><a href="#文件对象的属性" class="headerlink" title="文件对象的属性"></a>文件对象的属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"1.txt"</span>,<span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">print(f.name) <span class="comment"># 读取的文件名</span></span><br><span class="line">print(f.mode) <span class="comment"># 读取模式</span></span><br><span class="line">print(f.encoding) <span class="comment"># 读取编码</span></span><br><span class="line">print(f.errors) <span class="comment"># 编码错误时的处理方式，默认是‘strict’</span></span><br></pre></td></tr></table></figure><h4 id="python3-中的newline"><a href="#python3-中的newline" class="headerlink" title="python3 中的newline"></a>python3 中的<code>newline</code></h4><p>默认情况下，Python会以统一模式处理换行符，识别所有的普通换行符并将其转换为单个 <code>\n</code> 字符。</p><p>如果你不想要这种默认的处理方式，可以给 <code>open()</code> 函数传入参数 <code>newline=&#39;&#39;</code>，<strong>注意，这不是清除换行符的作用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 启用 Newline 转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'hello.txt'</span>, <span class="string">'rt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'hello world!\n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 禁用 Newline 转换 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = open(<span class="string">'hello.txt'</span>, <span class="string">'rt'</span>, newline=<span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.read()</span><br><span class="line"><span class="string">'hello world!\r\n'</span></span><br></pre></td></tr></table></figure><h3 id="打印到文件中-参数file"><a href="#打印到文件中-参数file" class="headerlink" title="打印到文件中,参数file"></a>打印到文件中,参数<code>file</code></h3><p>在 <code>print()</code> 函数中指定 <code>file</code> 关键字参数，像下面这样，文件必须是<strong>以文本模式打开</strong>。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'d:/work/test.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'Hello World!'</span>, file=f)</span><br></pre></td></tr></table></figure><h3 id="指定打印分隔符或行终止符"><a href="#指定打印分隔符或行终止符" class="headerlink" title="指定打印分隔符或行终止符"></a>指定打印分隔符或行终止符</h3><p>可以使用在 <code>print()</code> 函数中使用 <code>sep</code> 和 <code>end</code> 关键字参数，以你想要的方式输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.5</span>)</span><br><span class="line">ACME <span class="number">50</span> <span class="number">91.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.5</span>, sep=<span class="string">','</span>)</span><br><span class="line">ACME,<span class="number">50</span>,<span class="number">91.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.5</span>, sep=<span class="string">','</span>, end=<span class="string">'!!\n'</span>)</span><br><span class="line">ACME,<span class="number">50</span>,<span class="number">91.5</span>!!</span><br></pre></td></tr></table></figure><p>有时候你会看到一些程序员会使用 <code>str.join()</code> 来完成同样的事情。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">','</span>.join((<span class="string">'ACME'</span>,<span class="string">'50'</span>,<span class="string">'91.5'</span>)))</span><br><span class="line">ACME,<span class="number">50</span>,<span class="number">91.5</span></span><br></pre></td></tr></table></figure><p><code>str.join()</code> 的问题在于它仅仅适用于字符串，如果列表中有数值，就需要另外的转换。</p><p>你当然可以不用那么麻烦，只需要像下面这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(*row, sep=<span class="string">','</span>)</span><br><span class="line">ACME,<span class="number">50</span>,<span class="number">91.5</span></span><br></pre></td></tr></table></figure><h3 id="读写压缩文件"><a href="#读写压缩文件" class="headerlink" title="读写压缩文件"></a>读写压缩文件</h3><p>如下，所有的I/O操作都使用文本模式并执行Unicode的编码/解码。 类似的，如果你想操作二进制数据，使用 <code>rb</code> 或者 <code>wb</code> 文件模式即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gzip compression</span></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">with</span> gzip.open(<span class="string">'somefile.gz'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># bz2 compression</span></span><br><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line"><span class="keyword">with</span> bz2.open(<span class="string">'somefile.bz2'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br></pre></td></tr></table></figure><blockquote><p>  如果你不指定模式，那么默认的就是二进制模式。</p></blockquote><p><strong>参数</strong></p><p><code>gzip.open()</code> 和 <code>bz2.open()</code> 接受跟内置的 <code>open()</code> 函数一样的参数， 包括 <code>encoding</code>，<code>errors</code>，<code>newline</code> 等等。</p><p>当写入压缩数据时，可以使用 <code>compresslevel</code> 这个可选的关键字参数来指定一个压缩级别。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> gzip.open(<span class="string">'somefile.gz'</span>, <span class="string">'wt'</span>, compresslevel=<span class="number">5</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text)</span><br></pre></td></tr></table></figure><p>默认的等级是9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。</p><p><strong>特性</strong></p><p>最后一点，  它们可以作用在一个已存在并以二进制模式打开的文件上。比如，下面代码是可行的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line">f = open(<span class="string">'somefile.gz'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">with</span> gzip.open(f, <span class="string">'rt'</span>) <span class="keyword">as</span> g:</span><br><span class="line">    text = g.read()</span><br></pre></td></tr></table></figure><p>这样就允许 <code>gzip</code> 和 <code>bz2</code> 模块可以工作在许多类文件对象上，比如套接字，管道和内存中文件等。</p><h3 id="文件、路径操作"><a href="#文件、路径操作" class="headerlink" title="文件、路径操作"></a>文件、路径操作</h3><h4 id="路径名操作"><a href="#路径名操作" class="headerlink" title="路径名操作"></a>路径名操作</h4><p>请看 <a href="http://localhost:4000/2019/08/06/python小模块/#os-path" target="_blank" rel="noopener">Python 小模块的 os.path</a></p><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><p>请看 <a href="http://localhost:4000/2019/08/06/python小模块/#os-path" target="_blank" rel="noopener">Python 小模块的 os.path</a></p><h4 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h4><p>列出指定目录下的全部文件和目录，非递归获取。</p><blockquote><p>  函数 <code>os.listdir()</code> 返回的实体列表会根据系统默认的文件名编码来解码。 但是有时候也会碰到一些不能正常解码的文件名，请参考下一节</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line">names = os.listdir(<span class="string">'somedir'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件</span></span><br><span class="line">filenames = [name <span class="keyword">for</span> name <span class="keyword">in</span> names</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(os.path.join(<span class="string">'somedir'</span>, name))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目录</span></span><br><span class="line">dirnames = [name <span class="keyword">for</span> name <span class="keyword">in</span> names</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(os.path.join(<span class="string">'somedir'</span>, name))]</span><br></pre></td></tr></table></figure><p>获取某类文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法 1：字符串简单匹配</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">names = os.listdir(<span class="string">'somedir'</span>)</span><br><span class="line">pyfiles = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">'somedir'</span>)</span><br><span class="line">            <span class="keyword">if</span> name.endswith(<span class="string">'.py'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 2：fnmatch 模块</span></span><br><span class="line"><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch</span><br><span class="line">pyfiles = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">'somedir'</span>)</span><br><span class="line">            <span class="keyword">if</span> fnmatch(name, <span class="string">'*.py'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 3：glob 模块 推荐</span></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">pyfiles = glob.glob(<span class="string">'somedir/*.py'</span>)</span><br></pre></td></tr></table></figure><h3 id="文件名编码"><a href="#文件名编码" class="headerlink" title="文件名编码"></a>文件名编码</h3><p>通常来讲，你不需要担心文件名的编码和解码，普通的文件名操作应该就没问题了。</p><p><strong>字符串表示文件名（默认情况）</strong></p><p>默认情况下，所有的文件名都会根据 <code>sys.getfilesystemencoding()</code> 返回的文本编码来编码或解码</p><p><strong>原始字节字符串表示文件名</strong></p><p>如果因为某种原因你想忽略这种编码，可以使用一个<strong>原始字节字符串来指定一个文件名</strong>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 创建一个unicode编码的文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'jalape\xf1o.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    f.write(<span class="string">'Spicy!'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 打印目录 (默认进行解码ecoded)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">'.'</span>)</span><br><span class="line">[<span class="string">'jalapeño.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 打印目录 (使用原始字节字符串)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">b'.'</span>) <span class="comment"># 通过传递 字节字符串 来提示 Python 不要解码</span></span><br><span class="line">[<span class="string">b'jalapen\xcc\x83o.txt'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Open file with raw filename</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">b'jalapen\xcc\x83o.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    print(f.read())</span><br><span class="line">...</span><br><span class="line">Spicy!</span><br></pre></td></tr></table></figure><h4 id="打印不合法的文件名"><a href="#打印不合法的文件名" class="headerlink" title="打印不合法的文件名"></a>打印不合法的文件名</h4><p>默认情况下，Python假定所有文件名都已经根据 <code>sys.getfilesystemencoding()</code> 的值编码过了。 但是，有一些文件系统并没有强制要求这样做，因此允许创建文件名没有正确编码的文件。 </p><p>操作不合法的文件名或者将文件名传递给 <code>open()</code> 这样的函数时，一切都能正常工作。 <strong>只有当你想要输出文件名时才会碰到些麻烦</strong>(比如打印输出到屏幕或日志文件等)。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files = os.listdir(<span class="string">'.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files</span><br><span class="line">[<span class="string">'spam.py'</span>, <span class="string">'b\udce4d.txt'</span>, <span class="string">'foo.txt'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line"><span class="meta">... </span>    print(name)</span><br><span class="line">...</span><br><span class="line">spam.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: <span class="string">'utf-8'</span> codec can<span class="string">'t encode character '</span>\udce4<span class="string">' in</span></span><br><span class="line"><span class="string">position 1: surrogates not allowed</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p><strong>解决方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法 1，简单处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_filename</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> repr(filename)[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 方法 2，以正确的编码进行解码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_filename</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="comment"># filename 是 unicode 码，因此先进行编码，最后再解码</span></span><br><span class="line">    temp = filename.encode(sys.getfilesystemencoding(), errors=<span class="string">'surrogateescape'</span>)</span><br><span class="line">    <span class="keyword">return</span> temp.decode(<span class="string">'latin-1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">     <span class="keyword">try</span>:</span><br><span class="line">         print(name)</span><br><span class="line">     <span class="keyword">except</span> UnicodeEncodeError:</span><br><span class="line">         print(bad_filename(name))</span><br><span class="line"></span><br><span class="line">spam.py</span><br><span class="line">bäd.txt</span><br><span class="line">foo.txt</span><br></pre></td></tr></table></figure><blockquote><p>  <code>surrogateescape</code>:<br>  这种是Python在绝大部分面向OS的API中所使用的错误处理器，<br>  它能以一种优雅的方式处理由操作系统提供的数据的编码问题。<br>  在解码出错时会将出错字节存储到一个很少被使用到的Unicode编码范围内。<br>  在编码时将那些隐藏值又还原回原先解码失败的字节序列。<br>  它不仅对于OS API非常有用，也能很容易的处理其他情况下的编码错误。</p></blockquote><h3 id="文件对象的层次结构"><a href="#文件对象的层次结构" class="headerlink" title="文件对象的层次结构"></a>文件对象的层次结构</h3><p>I/O系统由一系列的层次构建而成。你可以试着运行下面这个操作一个文本文件的例子来查看这种层次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'sample.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">'sample.txt'</span> mode=<span class="string">'w'</span> encoding=<span class="string">'UTF-8'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.buffer</span><br><span class="line">&lt;_io.BufferedWriter name=<span class="string">'sample.txt'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.buffer.raw</span><br><span class="line">&lt;_io.FileIO name=<span class="string">'sample.txt'</span> mode=<span class="string">'wb'</span>&gt;</span><br></pre></td></tr></table></figure><ol><li><p><code>io.TextIOWrapper</code> 是一个编码和解码Unicode的文本处理层，增加或改变文本编码会涉及这一层。</p></li><li><p><code>io.BufferedWriter</code> 是一个处理二进制数据的带缓冲的I/O层。</p></li><li><code>io.FileIO</code> 是一个表示操作系统底层文件描述符的原始文件。</li></ol><p>如果你想<strong>修改一个已经打开的文本模式的文件的编码方式</strong>(暂时不知道有什么用途)，可以先使用 <code>detach()</code> 方法移除掉已存在的文本编码层， 并使用新的编码方式代替。<code>detach()</code> 方法会断开文件的最顶层并返回第二层，之后最顶层就没什么用了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'sample.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="comment"># &lt;_io.TextIOWrapper name='sample.txt' mode='w' encoding='UTF-8'&gt;</span></span><br><span class="line">b = f.detach() <span class="comment"># 返回的第2层</span></span><br><span class="line"><span class="comment"># &lt;_io.BufferedWriter name='sample.txt'&gt;</span></span><br><span class="line">f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#    File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># ValueError: underlying buffer has been detached</span></span><br><span class="line">  </span><br><span class="line">f = io.TextIOWrapper(b, encoding=<span class="string">'latin-1'</span>)</span><br><span class="line"><span class="comment"># &lt;_io.TextIOWrapper name='sample.txt' encoding='latin-1'&gt;</span></span><br></pre></td></tr></table></figure><h4 id="将字节写入文本文件"><a href="#将字节写入文本文件" class="headerlink" title="将字节写入文本文件"></a>将字节写入文本文件</h4><p>如果你想在文本模式打开的文件中写入原始的字节数据，可以将字节数据直接写入文件的缓冲区即可，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">b'Hello\n'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: must be str, <span class="keyword">not</span> bytes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.buffer.write(<span class="string">b'Hello\n'</span>)</span><br><span class="line">Hello</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>类似的，能够通过读取文本文件的 <code>buffer</code> 属性来读取二进制数据。</p><p>原理：I/O系统以<strong>层级结构的形式</strong>构建而成。 文本文件是通过在一个拥有缓冲的二进制模式文件上增加一个Unicode编码/解码层来创建。 <code>buffer</code> 属性指向对应的底层文件。如果你<strong>直接访问它的话就会绕过文本编码/解码层</strong>。</p><h3 id="创建临时文件和文件夹"><a href="#创建临时文件和文件夹" class="headerlink" title="创建临时文件和文件夹"></a>创建临时文件和文件夹</h3><p><code>tempfile</code> 模块中有很多的函数可以完成这任务。</p><p><strong>临时文件</strong>：<code>tempfile.TemporaryFile</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">'w+t'</span>，encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># Read/write to the file</span></span><br><span class="line">    f.write(<span class="string">'Hello World\n'</span>)</span><br><span class="line">    f.write(<span class="string">'Testing\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Seek back to beginning and read the data</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Temporary file is destroyed</span></span><br></pre></td></tr></table></figure><ul><li>通常来讲文本模式使用 <code>w+t</code> ，二进制模式使用 <code>w+b</code> 。 这个模式同时支持读和写操作，在这里是很有用的</li><li>结果文件关闭时会被自动删除掉。 如果你不想这么做，传递关键字参数 <code>delete=False</code> </li><li>所有和临时文件相关的函数都允许通过使用关键字参数 <code>prefix</code> 、<code>suffix</code> 和 <code>dir</code> 来自定义目录以及命名规则</li></ul><p><strong>带名字的临时文件</strong>：<code>tempfile.NamedTemporaryFile</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> NamedTemporaryFile(<span class="string">'w+t'</span>, delete=<span class="keyword">False</span>, prefix=<span class="string">'mytemp'</span>, suffix=<span class="string">'.txt'</span>, dir=<span class="string">'/tmp'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'filename is:'</span>, f.name)</span><br><span class="line"><span class="comment"># '/tmp/mytemp8ee899.txt'</span></span><br></pre></td></tr></table></figure><p><strong>临时目录</strong>： <code>tempfile.TemporaryDirectory()</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> dirname:</span><br><span class="line">    print(<span class="string">'dirname is:'</span>, dirname)</span><br><span class="line">    <span class="comment"># Use the directory</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># Directory and all contents destroyed</span></span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>12.10~12.14 TODO</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ing </tag>
            
            <tag> time </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>推荐网站</title>
      <link href="/2019/10/28/%E6%8E%A8%E8%8D%90%E7%BD%91%E7%AB%99/"/>
      <url>/2019/10/28/%E6%8E%A8%E8%8D%90%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>推荐一些发现的高质量学习网站</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ul><li><p><a href="http://www.pythondoc.com/pythontutorial3/" target="_blank" rel="noopener">python 3.6 入门指南</a></p></li><li><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">python cookbook</a> 非常多的实践经验</p></li><li><p><a href="https://learnku.com/docs/pymotw" target="_blank" rel="noopener">Python 3 标准库实例教程</a></p></li><li><p><a href="https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html" target="_blank" rel="noopener">pandas 10 分钟快速入门（官方文档）</a></p></li></ul><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul><li><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/" target="_blank" rel="noopener">PyTorch版《动手学深度学习》</a> |<a href="https://github.com/ShusenTang/Dive-into-DL-PyTorch" target="_blank" rel="noopener">相关代码</a></li><li><a href="https://trickygo.github.io/Dive-into-DL-TensorFlow2.0/#/" target="_blank" rel="noopener">TensorFlow2.0版《动手学深度学习》</a> </li><li><a href="https://nndl.github.io" target="_blank" rel="noopener">神经网络与深度学习-邱锡鹏</a></li><li><a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="noopener">Neural Networks and Deep Learning-入门</a></li><li><a href="https://github.com/ageron/handson-ml2" target="_blank" rel="noopener">Hands-on Machine Learning with Scikit-Learn, Keras and TensorFlow 源码</a></li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul><li><a href="https://www.junmajinlong.com/shell/index/" target="_blank" rel="noopener">骏马金龙的Shell系列文章</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7048359.html#blogshell" target="_blank" rel="noopener">骏马金龙的Shell脚本、bash特性系列</a></li><li><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html" target="_blank" rel="noopener">Bash Reference Manual — gnu 官方英文</a></li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li><a href="http://textbooks.math.gatech.edu/ila/index.html" target="_blank" rel="noopener">交互式线性代数</a></li><li><a href="http://immersivemath.com/ila/index.html" target="_blank" rel="noopener">沉浸式线性代数</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>算法 python shell 网站</p><p><a href="http://ddrv.cn/" target="_blank" rel="noopener">http://ddrv.cn/</a></p></the></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> python </tag>
            
            <tag> shell </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python技巧</title>
      <link href="/2019/10/25/python%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/10/25/python%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = sorted(a.iteritems(), key = <span class="keyword">lambda</span> kv:(kv[<span class="number">1</span>], kv[<span class="number">0</span>]),reverse=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h4 id="多字段排序"><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h4><p>其实就是将要排序的字段组成一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [(<span class="number">12</span>, <span class="number">12</span>), (<span class="number">34</span>, <span class="number">13</span>), (<span class="number">32</span>, <span class="number">15</span>), (<span class="number">12</span>, <span class="number">24</span>), (<span class="number">32</span>, <span class="number">64</span>), (<span class="number">32</span>, <span class="number">11</span>)]</span><br><span class="line">L.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p><code>Operator</code> 模块功能允许多级排序。 例如，按 <em>grade</em> 排序，然后按 <em>age</em> 排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter, attrgetter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组、字典类型，使用itemgetter</span></span><br><span class="line">student_tuples = [ (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>)]  <span class="comment"># 元组类型</span></span><br><span class="line">student_dicts = [&#123;<span class="string">'name'</span>:<span class="string">'dave'</span>,<span class="string">'grade'</span>:<span class="string">'B'</span>,<span class="string">'age'</span>:<span class="number">10</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'john'</span>,<span class="string">'grade'</span>:<span class="string">'A'</span>,<span class="string">'age'</span>:<span class="number">15</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'jane'</span>,<span class="string">'grade'</span>:<span class="string">'B'</span>,<span class="string">'age'</span>:<span class="number">12</span>&#125;] <span class="comment"># 字典类型</span></span><br><span class="line"></span><br><span class="line">sorted(student_tuples, key=itemgetter(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">sorted(student_tuples, key=itemgetter(<span class="string">'grade'</span>, <span class="string">'age'</span>))</span><br><span class="line"><span class="comment"># [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 考虑 Student 对象，使用attrgetter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, grade, age)</span>:</span></span><br><span class="line">            self.name = name</span><br><span class="line">            self.grade = grade</span><br><span class="line">            self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> repr((self.name, self.grade, self.age))</span><br><span class="line"></span><br><span class="line">student_objects = [</span><br><span class="line">    Student(<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">    Student(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">12</span>),</span><br><span class="line">    Student(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line">sorted(student_objects, key=attrgetter(<span class="string">'grade'</span>, <span class="string">'age'</span>))</span><br><span class="line"><span class="comment"># [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]</span></span><br></pre></td></tr></table></figure><h4 id="显示字符串原始内容，不进行转义"><a href="#显示字符串原始内容，不进行转义" class="headerlink" title="显示字符串原始内容，不进行转义"></a>显示字符串原始内容，不进行转义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=[<span class="string">"s\nsdf\r"</span>,<span class="string">"s\n"</span>,<span class="string">"d\r\n"</span>,<span class="string">"sdf\n\r"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">print</span> repr(i)</span><br></pre></td></tr></table></figure><h4 id="默认字典-带数据的初始化"><a href="#默认字典-带数据的初始化" class="headerlink" title="默认字典 带数据的初始化"></a>默认字典 带数据的初始化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>, &#123;<span class="string">"1"</span>:<span class="number">1</span> , <span class="string">"0"</span>:<span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure><h4 id="python从后向前遍历"><a href="#python从后向前遍历" class="headerlink" title="python从后向前遍历"></a>python从后向前遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(arr)-1, -1, -1):</span><br><span class="line">    print(arr[i])</span><br></pre></td></tr></table></figure><p>最后个<code>-1</code>表示逆向，从<code>len(arr)-1</code>也就是数组最后一位开始，到<code>0</code>，因为 range 是开始区间，因此为了取到 0，用<code>-1</code>表示结束位置。</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="删除特定的字符"><a href="#删除特定的字符" class="headerlink" title="删除特定的字符"></a>删除特定的字符</h4><p><strong>问题：</strong></p><ol><li><p>过滤用户输入中前后多余的空白字符：<code>++++abc123---</code></p></li><li><p>过滤某windows下编辑文本中的<code>\r</code>：<code>hello world \r\n</code></p></li><li>去掉文本中unicode组合字符、音调：<code>Zhào Qián Sūn Lǐ Zhōu Wú Zhèng Wáng</code></li></ol><p><strong>解决方案</strong>：</p><ol><li><p>去掉两端字符串： <code>strip(), rstrip(), lstrip()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'  -----abc123++++       '</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除两边空字符</span></span><br><span class="line">print(s.strip())</span><br><span class="line"><span class="comment"># 删除左边空字符</span></span><br><span class="line">print(s.rstrip())</span><br><span class="line"><span class="comment"># 删除右边空字符</span></span><br><span class="line">print(s.lstrip())</span><br><span class="line"><span class="comment"># 删除两边 - + 和空字符</span></span><br><span class="line">print(s.strip().strip(<span class="string">'-+'</span>))</span><br><span class="line"> </span><br><span class="line">print(<span class="string">"北门吹雪:http://www.cnblogs.com/2bjiujiu/"</span>)</span><br></pre></td></tr></table></figure></li><li><p>删除单个固定位置字符： 切片 + 拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'abc:123'</span></span><br><span class="line"><span class="comment"># 字符串拼接方式去除冒号</span></span><br><span class="line">new_s = s[:<span class="number">3</span>] + s[<span class="number">4</span>:]</span><br><span class="line">print(new_s)</span><br></pre></td></tr></table></figure></li><li><p>删除任意位置字符同时删除多种不同字符：<code>replace(), re.sub()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去除字符串中相同的字符</span></span><br><span class="line">s = <span class="string">'\tabc\t123\tisk'</span></span><br><span class="line">print(s.replace(<span class="string">'\t'</span>, <span class="string">''</span>))</span><br><span class="line"> </span><br><span class="line">print(<span class="string">"北门吹雪: http://www.cnblogs.com/2bjiujiu/"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 去除\r\n\t字符</span></span><br><span class="line">s = <span class="string">'\r\nabc\t123\nxyz'</span></span><br><span class="line">print(re.sub(<span class="string">'[\r\n\t]'</span>, <span class="string">''</span>, s))</span><br></pre></td></tr></table></figure></li><li><p>多种不同字符映射转换：<code>translate()</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'abc123xyz'</span></span><br><span class="line"><span class="comment"># a _&gt; x, b_&gt; y, c_&gt; z，字符映射加密</span></span><br><span class="line">print(str.maketrans(<span class="string">'abcxyz'</span>, <span class="string">'xyzabc'</span>))</span><br><span class="line"><span class="comment"># translate把其转换成字符串</span></span><br><span class="line">print(s.translate(str.maketrans(<span class="string">'abcxyz'</span>, <span class="string">'xyzabc'</span>)))</span><br></pre></td></tr></table></figure></li><li><p>去掉unicode字符中音调</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line">s = <span class="string">"Zhào Qián Sūn Lǐ Zhōu Wú Zhèng Wáng"</span></span><br><span class="line">remap = &#123;</span><br><span class="line">    <span class="comment"># ord返回ascii值</span></span><br><span class="line">    ord(<span class="string">'\t'</span>): <span class="string">''</span>,</span><br><span class="line">    ord(<span class="string">'\f'</span>): <span class="string">''</span>,</span><br><span class="line">    ord(<span class="string">'\r'</span>): <span class="keyword">None</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 去除\t, \f, \r</span></span><br><span class="line">a = s.translate(remap)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">　　通过使用dict.fromkeys() 方法构造一个字典，每个Unicode 和音符作为键，对于的值全部为None</span></span><br><span class="line"><span class="string">　　然后使用unicodedata.normalize() 将原始输入标准化为分解形式字符</span></span><br><span class="line"><span class="string">　　sys.maxunicode : 给出最大Unicode代码点的值的整数，即1114111（十六进制的0x10FFFF）。</span></span><br><span class="line"><span class="string">　　unicodedata.combining:将分配给字符chr的规范组合类作为整数返回。 如果未定义组合类，则返回0。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">cmb_chrs = dict.fromkeys(c <span class="keyword">for</span> c <span class="keyword">in</span> range(sys.maxunicode) <span class="keyword">if</span> unicodedata.combining(chr(c))) <span class="comment">#此部分建议拆分开来理解</span></span><br><span class="line">b = unicodedata.normalize(<span class="string">'NFD'</span>, a)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">　　　调用translate 函数删除所有重音符</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(b.translate(cmb_chrs))</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/2bjiujiu/p/7257744.html" target="_blank" rel="noopener">https://www.cnblogs.com/2bjiujiu/p/7257744.html</a></p></li></ol><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="读取多个文件"><a href="#读取多个文件" class="headerlink" title="读取多个文件"></a>读取多个文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file1'</span>) <span class="keyword">as</span> f1, open(<span class="string">'file2'</span>) <span class="keyword">as</span> f2, open(<span class="string">'file3'</span>) <span class="keyword">as</span> f3:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f1:</span><br><span class="line">        j = f2.readline()</span><br><span class="line">        k = f3.readline()</span><br><span class="line">        print(i,j,k)</span><br></pre></td></tr></table></figure><p>还有一种优雅一点的写法（已过时）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> nested</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> nested(open(<span class="string">'file1'</span>), open(<span class="string">'file2'</span>), open(<span class="string">'file3'</span>)) <span class="keyword">as</span> (f1,f2,f3):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f1:</span><br><span class="line">        j = f2.readline()</span><br><span class="line">        k = f3.readline()</span><br><span class="line">        print(i,j,k)</span><br></pre></td></tr></table></figure><h4 id="readline报错-Unicode-error"><a href="#readline报错-Unicode-error" class="headerlink" title="readline报错 Unicode error"></a>readline报错 Unicode error</h4><p>The default for errors is ‘strict’, meaning that encoding errors raise a UnicodeError. Other possible values are ‘ignore’, ‘replace’, ‘xmlcharrefreplace’, ‘backslashreplace’ and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings.</p><p>In Python 3, pass an appropriate <code>errors=</code> value (such as <code>errors=ignore</code> or <code>errors=replace</code>) on creating your file object (presuming it to be a subclass of <code>io.TextIOWrapper</code> – and if it isn’t, consider wrapping it in one!); also, consider passing a more likely encoding than <code>charmap</code> (when you aren’t sure, <code>utf-8</code> is always a good place to start).</p><p>For instance:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'misc-notes.txt'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><hr><p>In Python 2, the <code>read()</code> operation simply returns bytes; the trick, then, is decoding them to get them into a string (if you do, in fact, want characters as opposed to bytes). If you don’t have a better guess for their real encoding:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_string.decode(<span class="string">'utf-8'</span>, <span class="string">'replace'</span>)</span><br></pre></td></tr></table></figure><p>…to replace unhandled characters, or</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_string.decode(<span class="string">'utf-8'</span>, <span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><p>to simply ignore them.</p><h4 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source</span><br><span class="line">  -- dir</span><br><span class="line">     -- 文件3.txt</span><br><span class="line">  -- 文件1.txt</span><br><span class="line">  -- 文件2.txt</span><br></pre></td></tr></table></figure><p><code>listdir</code>：罗列出指定目录下的<strong>一级文件以及目录</strong>，<strong>不递归</strong>进入子文件夹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">filesystemencoding = sys.getfilesystemencoding() <span class="comment"># 获取文件系统的编码</span></span><br><span class="line">files = os.listdir(<span class="string">"source/"</span>)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    file = file.decode(filesystemencoding).encode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">print</span> file</span><br></pre></td></tr></table></figure><p><code>walk</code>：罗列出指定目录下<strong>全部的文件、文件夹</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">filesystemencoding = sys.getfilesystemencoding()</span><br><span class="line"><span class="keyword">for</span> pwd, dirs, files <span class="keyword">in</span> os.walk(<span class="string">"source/"</span>):</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        f = f.decode(filesystemencoding).encode(<span class="string">"utf-8"</span>)</span><br><span class="line">        <span class="keyword">print</span> f</span><br></pre></td></tr></table></figure><h4 id="写入文件头部"><a href="#写入文件头部" class="headerlink" title="写入文件头部"></a>写入文件头部</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_data = <span class="string">"ssss"</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"1.txt"</span>, <span class="string">'r+'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">    old_data = fw.read()    <span class="comment"># 读取全部文本内容，此时指针会到文件尾部</span></span><br><span class="line">    fw.seek(<span class="number">0</span>)        <span class="comment"># 通过seek回到文件头部</span></span><br><span class="line">    fw.write(new_data)</span><br><span class="line">    fw.write(old_data)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/junbujianwpl/article/details/73194846" target="_blank" rel="noopener">https://blog.csdn.net/junbujianwpl/article/details/73194846</a></p><h3 id="打印显示"><a href="#打印显示" class="headerlink" title="打印显示"></a>打印显示</h3><h4 id="在一行内显示进度"><a href="#在一行内显示进度" class="headerlink" title="在一行内显示进度"></a>在一行内显示进度</h4><p>Python3版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    print(<span class="string">"\r"</span> + <span class="string">"#"</span> * i, end=<span class="string">""</span>)</span><br><span class="line">    sys.stdout.flush()</span><br></pre></td></tr></table></figure><p>python2版本，逗号是重点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\r"</span>+<span class="string">"#"</span>*i,   <span class="comment"># 重点是这个逗号</span></span><br><span class="line">    sys.stdout.flush()</span><br></pre></td></tr></table></figure><h4 id="format-函数的格式化语言"><a href="#format-函数的格式化语言" class="headerlink" title="format 函数的格式化语言"></a>format 函数的格式化语言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]</span><br><span class="line">fill            ::=  &lt;any character&gt;</span><br><span class="line">align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;</span><br><span class="line">sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;</span><br><span class="line">width           ::=  digit+</span><br><span class="line">grouping_option ::=  &quot;_&quot; | &quot;,&quot;</span><br><span class="line">precision       ::=  digit+</span><br><span class="line">type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="python-查看所有模块"><a href="#python-查看所有模块" class="headerlink" title="python 查看所有模块"></a>python 查看所有模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help()</span><br><span class="line">Welcome to Python <span class="number">3.7</span><span class="string">'s help utility!...........</span></span><br><span class="line"><span class="string">help&gt; modules</span></span><br></pre></td></tr></table></figure><h4 id="使用其他目录的模块"><a href="#使用其他目录的模块" class="headerlink" title="使用其他目录的模块"></a>使用其他目录的模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_PATH = path.dirname(path.dirname(path.abspath(__file__))) <span class="comment"># 当前文件所在目录的前两级目录</span></span><br><span class="line">sys.path.append(PROJECT_PATH)  <span class="comment"># 添加在环境变量中</span></span><br><span class="line"><span class="keyword">from</span> conf <span class="keyword">import</span> config        <span class="comment"># 就可以使用conf目录中的config.py文件了</span></span><br></pre></td></tr></table></figure><h4 id="sys-exit-与-exit、quit-的区别"><a href="#sys-exit-与-exit、quit-的区别" class="headerlink" title="sys.exit 与 exit、quit 的区别"></a>sys.exit 与 exit、quit 的区别</h4><p><strong>exit和quit函数</strong></p><p>这两个函数的作用，就是直接退出程序，可以带一个参数作为程序的返回码，如果不带参数，默认就是返回0.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xinlin@ubuntu:~/test$ python3 -q</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit(<span class="number">111</span>)</span><br><span class="line">xinlin@ubuntu:~/test$ echo $?</span><br><span class="line"><span class="number">111</span></span><br><span class="line">xinlin@ubuntu:~/test$ python3 -q</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quit(<span class="number">222</span>)</span><br><span class="line">xinlin@ubuntu:~/test$ echo $?</span><br><span class="line"><span class="number">222</span></span><br><span class="line">xinlin@ubuntu:~/test$ python3 -q</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</span><br><span class="line">xinlin@ubuntu:~/test$ echo $?</span><br><span class="line"><span class="number">0</span></span><br><span class="line">xinlin@ubuntu:~/test$ python3 -q</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quit()</span><br><span class="line">xinlin@ubuntu:~/test$ echo $?</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>sys.exit()函数</strong></p><p><strong><code>sys.exit()</code>函数会抛出一个SystemExit异常，Python代码可以捕获这个异常来进行一些程序退出前的清理工作</strong>。<code>sys.exit</code>函数同样可以带一个参数来作为程序的退出码，默认是0.</p><p>实践中，完整的使用<code>sys.exit</code>函数的逻辑应该是如下这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    sys.exit(<span class="number">123</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> SystemExit <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> str(e) == <span class="string">'123'</span>:</span><br><span class="line">            print(<span class="string">'---123---'</span>)</span><br><span class="line">            exit(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>使用sys.exit函数退出程序，可以有个异常捕获机制来做清理扫尾的工作，程序会更加灵活健壮。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开发环境搭建与效率技巧</title>
      <link href="/2019/10/25/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%95%88%E7%8E%87%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/10/25/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%95%88%E7%8E%87%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>Mac、linux、window这 3 大系统的开发环境搭建推荐、遇到的相关问题的解决方案记录</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="通用环境"><a href="#通用环境" class="headerlink" title="通用环境"></a>通用环境</h2><h3 id="Python-环境"><a href="#Python-环境" class="headerlink" title="Python 环境"></a>Python 环境</h3><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><h5 id="安装-anaconda"><a href="#安装-anaconda" class="headerlink" title="安装 anaconda"></a>安装 anaconda</h5><ol><li><p>下载最新python版本对应的<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">anaconda</a>，这样这个环境中默认的python就是最新的</p></li><li><p>根据提示完成安装，这时命令行中<code>conda --version</code> 无法执行，</p><p><strong>for anaconda 3 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=~/anaconda3/bin:$PATH</span><br></pre></td></tr></table></figure><p>然后通过<code>conda --version</code> 确认</p></li><li><p><code>export PATH=~/anaconda3/bin:$PATH</code>  <strong>有效时间为这次终端结束</strong>，因此应该通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nano ~/.bashrc   # bash</span><br><span class="line">或者</span><br><span class="line">sudo nano ~/.zshrc    # zsh</span><br></pre></td></tr></table></figure><p>修改配置文件，将命令复制保存在文件中，最后通过<code>source .bashrc</code>加载新的配置信息，使得配置立即生效。</p></li><li><p>在pycharm设置中搜索 interpreter，添加解释器，选择conda 环境，如果想让新项目默认使用该解释器，勾选【 <strong>make available to all projects</strong>】</p></li></ol><h5 id="卸载官方安装包"><a href="#卸载官方安装包" class="headerlink" title="卸载官方安装包"></a>卸载官方安装包</h5><p>不建议自己安装 官网的Python，因为这是典型的安装容易，删除麻烦。提供了安装器，但没有卸载器</p><p>我们首先要知道其具体都安装了什么，实际上，在安装 Python 时，其自动生成:</p><ul><li><p>Python framework，即 Python 框架; </p></li><li><p>Python 应用目录; </p></li><li><p>指向 Python 的连接。 </p></li></ul><p>对于 Mac 自带的 Python，其框架目录为：<code>/System/Library/Frameworks/Python.framework</code></p><p>而我们安装的 Python，其(默认)框架目录为：<code>/Library/Frameworks/Python.framework</code></p><p>接下来，我们就分别(在 Mac 终端进行)删除上面所提到的三部分，其中x.x为 Python 的版本号。</p><ol><li><p>删除框架:<code>sudo rm -rf /Library/Frameworks/Python.framework/Versions/x.x</code></p></li><li><p>删除应用目录:<code>sudo rm -rf &quot;/Applications/Python x.x&quot;</code></p></li><li><p>删除指向 Python 的连接:<code>ls -l /usr/local/bin | grep &#39;../Library/Frameworks/Python.framework/Versions/x.x&#39; | awk &#39;{print $9}&#39; | tr -d @ | xargs rm</code></p></li><li><p>删除环境变量<code>$PATH</code></p></li></ol><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><ol><li><p>下载最新python版本对应的<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">anaconda</a>，这样这个环境中默认的python就是最新的</p></li><li><p>右键我的电脑—属性—高级系统设置—-高级选项里面有一个环境变量，点击环境变量——系统变量里面 找path——双击path，添加路径，路径间用<code>;</code>隔开，需要添加的路径有三个：<code>F:\Anaconda3;F:\Anaconda3\Scripts;F:\Anaconda3\Library\bin</code></p></li></ol><h4 id="anaconda-的使用"><a href="#anaconda-的使用" class="headerlink" title="anaconda 的使用"></a>anaconda 的使用</h4><p>请看<a href="http://jizx.top/2019/08/04/anaconda与jupyter使用与设置" target="_blank" rel="noopener">anaconda与jupyter使用与设置</a></p><h3 id="IDE-配置"><a href="#IDE-配置" class="headerlink" title="IDE 配置"></a>IDE 配置</h3><h4 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h4><h5 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h5><p>编辑<br><code>Shift + Enter</code>：在下方新建行并移到新行行首<br><code>Ctrl + /</code>：注释(取消注释)选择的行<br><code>Ctrl + Alt + L</code>：格式化代码(与QQ锁定热键冲突，关闭QQ的热键)</p><p>查找<br><code>alt+F7</code>  查找变量、函数、方法在项目中被使用的位置<br><code>Ctrl + Shift + F</code>：高级查找</p><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p>打开设置，Editor-&gt;Code Style</p><blockquote><p>  可以看到，默认是System-Dependent，修改为<code>\n</code></p></blockquote><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>换行符问题</p><p>这个问题与<code>git-config</code>里面的相关设置有关，主要涉及到三个参数：</p><ul><li><code>core.autocrlf</code></li><li><code>core.safecrlf</code></li><li><code>core.eol</code></li></ul><p><code>core.autocrlf</code>设置是否进行自动转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 当添加到暂存区时，自动将CRLF转换成LF；反之，当检出时，自动将LF转换成CRLF</span><br><span class="line">git config --global core.autocrlf true   </span><br><span class="line"></span><br><span class="line"># 提交时转换为LF，检出时不转换</span><br><span class="line">git config --global core.autocrlf input   </span><br><span class="line"></span><br><span class="line"># 提交检出均不转换</span><br><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure><p><code>core.safecrlf</code> 设置是否检查换行符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 拒绝提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf true   </span><br><span class="line"></span><br><span class="line"># 允许提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf false   </span><br><span class="line"></span><br><span class="line"># 提交包含混合换行符的文件时给出警告</span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure><p><code>core.eol</code></p><p>当<code>core.autocrlf</code>是<code>false</code>时，设置行结束符的类型，可以是</p><ul><li><code>lf</code></li><li><code>crlf</code></li><li><code>native</code>三种，其中<code>native</code>是指平台默认的行结束符。默认的类型是<code>native</code></li></ul><h4 id="个人建议方案"><a href="#个人建议方案" class="headerlink" title="个人建议方案"></a>个人建议方案</h4><h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br><span class="line">git config --global core.safecrlf true  </span><br><span class="line"># 并且把所有文件转换为Linux编码（即LF\n），开启safecrlf检查</span><br></pre></td></tr></table></figure><p>也就是让代码仓库使用统一的换行符(LF)，如果代码中包含 CRLF 类型的文件时将无法提交，需要用 <code>dos2unix</code> 或者其他工具手动转换文件类型。</p><h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><p>添加<code>.gitattributes</code></p><p>首先要在项目里添加.gitattributes文件，可以参考<a href="https://link.jianshu.com?t=https%3A%2F%2Fhelp.github.com%2Farticles%2Fdealing-with-line-endings%2F" target="_blank" rel="noopener">Github help-Dealing with line endings</a>和<a href="https://git-scm.com/docs/gitattributes" target="_blank" rel="noopener">gitattributes</a></p><p>推荐的现成模板<a href="https://github.com/alexkaratarakis/gitattributes" target="_blank" rel="noopener">gitattributes</a></p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 设置默认行为, in case people don&apos;t have core.autocrlf set.</span><br><span class="line">* text=auto</span><br><span class="line"></span><br><span class="line"># 显示声明想要进行规范化的文本类型。Explicitly declare text files you want to always be normalized and converted to native line endings on checkout.</span><br><span class="line">#*.c text</span><br><span class="line">#*.h text</span><br><span class="line">*.md text</span><br><span class="line">*.js text</span><br><span class="line">*.json text</span><br><span class="line">*.wxss text</span><br><span class="line">*.wxml text</span><br><span class="line"></span><br><span class="line"># 保持CRLF的文件。Declare files that will always have CRLF line endings on checkout.</span><br><span class="line">#*.sln text eol=crlf</span><br><span class="line"></span><br><span class="line"># 指定哪些文件是二进制文件，禁止转换。Denote all files that are truly binary and should not be modified.</span><br><span class="line">*.png binary</span><br><span class="line">*.jpg binary</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.jianshu.com/p/2a46dfd3705a" target="_blank" rel="noopener">https://www.jianshu.com/p/2a46dfd3705a</a></p><p><a href="https://www.jianshu.com/p/fa4d5963b6c8" target="_blank" rel="noopener">https://www.jianshu.com/p/fa4d5963b6c8</a></p><p><a href="http://kuanghy.github.io/2017/03/19/git-lf-or-crlf" target="_blank" rel="noopener">http://kuanghy.github.io/2017/03/19/git-lf-or-crlf</a></p><h2 id="window-1"><a href="#window-1" class="headerlink" title="window"></a>window</h2><h3 id="cmd的乱码"><a href="#cmd的乱码" class="headerlink" title="cmd的乱码"></a>cmd的乱码</h3><p>打开设置——&gt; Startup-Environment——&gt; 添加 set LANG=zh_CN.UTF-8</p><h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><p>TODO</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="30个高效alias"><a href="#30个高效alias" class="headerlink" title="30个高效alias"></a>30个高效alias</h3><p>临时取消alias</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/clear ## 命令完整路径</span><br><span class="line">\c    ## call alias 前添加\</span><br><span class="line">command ls  ## 或使用command</span><br></pre></td></tr></table></figure><p>删除别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unalias aliasname</span><br><span class="line">unalias foo</span><br></pre></td></tr></table></figure><p><a href="https://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html" target="_blank" rel="noopener">参考</a></p><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><h4 id="设置sudo文件排除某些命令"><a href="#设置sudo文件排除某些命令" class="headerlink" title="设置sudo文件排除某些命令"></a>设置sudo文件排除某些命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">visudo  <span class="comment"># 之后找到如下，修改为如下</span></span><br><span class="line">work    ALL=ALL,!/bin/chown,!/bin/chgrp,!/sbin/,!/usr/sbin/visudo</span><br></pre></td></tr></table></figure><h4 id="sudo免密"><a href="#sudo免密" class="headerlink" title="sudo免密"></a>sudo免密</h4><p>让普通用户work具有所有超级用户的权限而又不用输入密码，同时排除一些命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># visudo</span></span><br><span class="line">work ALL=（ALL)NOPASSWD:ALL, !/usr/bin/reboot, !/sbin/reboot, !/sbin/ifconfig, !/sbin/shutdown, !/sbin/route, !/sbin/ip</span><br></pre></td></tr></table></figure><blockquote></blockquote></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> linux </tag>
            
            <tag> 环境 </tag>
            
            <tag> window </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hive</title>
      <link href="/2019/10/12/hive/"/>
      <url>/2019/10/12/hive/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>hive 的读书笔记，ing</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li style="list-style: none"><input type="checkbox" checked> 第 3 章</li><li style="list-style: none"><input type="checkbox" checked> 第 4 章<ul><li style="list-style: none"><input type="checkbox"> 4.4.2 自定义表的存储格式</li><li style="list-style: none"><input type="checkbox"> 4.6.7 </li></ul></li><li style="list-style: none"><input type="checkbox" checked> 第 5 章</li><li style="list-style: none"><input type="checkbox" checked> 第 6 章<ul><li style="list-style: none"><input type="checkbox" checked> 6.9.2 分桶表的输入裁剪</li></ul></li><li style="list-style: none"><input type="checkbox" checked> 第 7 章 视图</li><li style="list-style: none"><input type="checkbox"> 第 8 章 粗略看了</li><li style="list-style: none"><input type="checkbox" checked> 第 9 章<ul><li style="list-style: none"><input type="checkbox"> 9.5</li></ul></li></ul><p>头部寻址</p><p>Hadoop 每次指定的文件输入和输出路径都是<strong>文件夹</strong></p><h3 id="hive-变量空间"><a href="#hive-变量空间" class="headerlink" title="hive 变量空间"></a>hive 变量空间</h3><table><thead><tr><th>命名空间</th><th>使用权限</th><th>详细描述</th></tr></thead><tbody><tr><td>hivevar</td><td>rw</td><td>用户自定义变量（v0.8.0+）</td></tr><tr><td>hiveconf</td><td>rw</td><td>hive相关配置属性</td></tr><tr><td>system</td><td>rw</td><td>java定义的配置属性</td></tr><tr><td>env</td><td>r</td><td>Shell环境属性</td></tr></tbody></table><p>通常我们可以使用hive -e查看有关hivevar与hiveconf的描述：</p><p><strong>2、hivevar与hiveconf的作用域</strong></p><p>之前项目中涉及两个hive作业同时执行并需要传入相同key的参数，因此顾虑不清楚是否是线程安全。</p><p>结论先行：<code>hivevar</code>与<code>hiveconf</code>作用域都<strong>是会话级别</strong>的，言外之意就是如果两个并发同时跑的作业同时传入一个相同key但是value不相同的值的参数，<strong>不会发生线程安全问题</strong>。</p><p><strong>3、对于hivevar与hiveconf的使用</strong></p><p><code>hiveconf</code> 变量取值必须要使用<code>hiveconf</code>作为前缀参数，具体格式如下:<code>${hiveconf:key}</code></p><p>但是对于<code>hivevar</code>取值可以不使用前缀<code>hivevar</code>，具体格式如下：</p><ul><li><p>使用前缀:   <code>${hivevar:key}</code></p></li><li><p>不使用前缀:<code>${key}</code></p></li></ul><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>注意：cli中 tab 会进行自动补全，而且输入流后面的字符会被认为是对提示的回复，因此会导致执行失败</p><p><code>!</code>， 不用退出 hive CLI 即可使用shell 命令，在命令前加上感叹号即可：<code>! pwd ;</code></p><p>注意：不支持交互式命令、管道命令、文件名模糊匹配功能，如<code>! ls *.hql</code>，查找的是<code>*.hql</code>文件而不是以<code>.hql</code>结尾的所有文件。</p><p>hive 中使用 hadoop 命令，只需要去掉<code>hadoop</code>这个关键字即可。而且更加高效，因此 hive 会在同一进程中执行这些命令，而不需要重新启动一个 JVM 实例。</p><p>以<code>--</code>开头的字符串是注释。</p><h2 id="数据类型与定义"><a href="#数据类型与定义" class="headerlink" title="数据类型与定义"></a>数据类型与定义</h2><h3 id="hive-数据类型"><a href="#hive-数据类型" class="headerlink" title="hive 数据类型"></a>hive 数据类型</h3><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th><th style="text-align:left">字面量示例</th></tr></thead><tbody><tr><td style="text-align:left">原始类型</td><td style="text-align:left">BOOLEAN</td><td style="text-align:left">true/false</td><td style="text-align:left">TRUE</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">TINYINT</td><td style="text-align:left">1字节的有符号整数 -128~127</td><td style="text-align:left">1Y</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">SMALLINT</td><td style="text-align:left">2个字节的有符号整数，-32768~32767</td><td style="text-align:left">1S</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">INT</td><td style="text-align:left">4个字节的带符号整数</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">BIGINT</td><td style="text-align:left">8字节带符号整数</td><td style="text-align:left">1L</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">FLOAT</td><td style="text-align:left">4字节单精度浮点数1.0</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">DOUBLE</td><td style="text-align:left">8字节双精度浮点数</td><td style="text-align:left">1.0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">DEICIMAL</td><td style="text-align:left">任意精度的带符号小数</td><td style="text-align:left">1.0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">STRING</td><td style="text-align:left">字符串，变长</td><td style="text-align:left">“a”，’b’</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">VARCHAR</td><td style="text-align:left">变长字符串</td><td style="text-align:left">“a”，’b’</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">CHAR</td><td style="text-align:left">固定长度字符串</td><td style="text-align:left">“a”，’b’</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">BINARY</td><td style="text-align:left">字节数组（v0.8.0+）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">TIMESTAMP</td><td style="text-align:left">时间戳，纳秒精度（v0.8.0+）</td><td style="text-align:left">122327493795</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">DATE</td><td style="text-align:left">日期</td><td style="text-align:left">‘2016-03-29’</td></tr><tr><td style="text-align:left">复杂类型</td><td style="text-align:left">ARRAY</td><td style="text-align:left">有序的的同类型的集合</td><td style="text-align:left">array(1,2)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">MAP</td><td style="text-align:left">key-value,key必须为原始类型，value可以任意类型</td><td style="text-align:left">map(‘a’,1,’b’,2)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">STRUCT</td><td style="text-align:left">字段集合,类型可以不同</td><td style="text-align:left">struct(‘1’,1,1.0), named_stract(‘col1’,’1’,’col2’,1,’clo3’,1.0)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">UNION</td><td style="text-align:left">在有限取值范围内的一个值</td><td style="text-align:left">create_union(1,’a’,63)</td></tr></tbody></table><p>不存在最大长度限制的“字符串”，hive 支持无限长度的字符串</p><p>进行比较时，hive 会隐式地将类型转为较大的，因此是同类型间的比较</p><p>集合类型的问题可能会增大数据冗余的风险，也可能导致数据不一致，当数据发生改变时，冗余的拷贝数据可能无法进行相应的同步。优点是提升更高的吞吐量的数据。</p><h3 id="文本文件的保存形式"><a href="#文本文件的保存形式" class="headerlink" title="文本文件的保存形式"></a>文本文件的保存形式</h3><h3 id="分隔符在HIVE中的用途"><a href="#分隔符在HIVE中的用途" class="headerlink" title="分隔符在HIVE中的用途"></a>分隔符在HIVE中的用途</h3><table><thead><tr><th>分隔符</th><th>描述</th></tr></thead><tbody><tr><td>\n</td><td>对于文本文件来说，每行都是一条记录，因此换行符可以分隔记录</td></tr><tr><td>^A(Ctrl+A)</td><td>用于分隔字段(列)。在CREATE TABLE语句中可以使用八进制编码\001表示</td></tr><tr><td>^B(Ctrl+B)</td><td>用于分隔ARRAY或者STRUCT中的元素，或用于MAP中键-值对之间的分隔。在CREATE TABLE语句中可以使用八进制编码\002表示</td></tr><tr><td>^C(Ctrl+C)</td><td>用于MAP中键和值之间的分隔。在CREATE TABLE语句中可以使用八进制编码\003表示</td></tr></tbody></table><blockquote><p>  Hive 中没有定义专门的数据格式，数据格式可以由用户指定，用户定义数据格式需要指定三个属性：列分隔符（通常为空格、”\t”、”\x001″）、行分隔符（”\n”）以及读取文件数据的方法。由于在加载数据的过程中，不需要从用户数据格式到 Hive 定义的数据格式的转换，因此，Hive 在加载的过程中不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的 HDFS 目录中。</p></blockquote><p>在创建 table 的时候，table 加载文件的时候就会按照下面格式匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">row format delimited </span><br><span class="line">fields terminated by &apos;\001&apos; </span><br><span class="line">collection items terminated by &apos;\002&apos; </span><br><span class="line">map keys terminated by &apos;\003&apos;</span><br><span class="line">lines terminated by &apos;\n&apos; </span><br><span class="line">stored as textfile;</span><br></pre></td></tr></table></figure><p><code>row format delimited</code>必须写在其他子句（不包括<code>lines terminated by</code>与<code>stored as textfile</code>）之前。</p><p>其实，<code>line terminated by</code>目前只支持<code>\n</code>，<code>stored as textfile</code>也很少用到。</p><h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>传统数据库是<strong>写时模式</strong>，即 数据在写入数据库的时候对模式（数据格式）进行检查</p><p>hive 不会在 数据加载时进行验证，而是在查询时进行，也就是<strong>读时模式</strong></p><p>如果模式和文件内容不匹配，hive 容忍性非常好。</p><ul><li>如果每行记录中字段个数少于对应的模式中定义的字段个数的话，缺失的字段以 null 填充</li><li>如果字段是数值型，但 hive 读取时发现存在非数值类型的字符串值的话，那些字段将会返回 null 值</li></ul><h2 id="HiveQL基本语句"><a href="#HiveQL基本语句" class="headerlink" title="HiveQL基本语句"></a>HiveQL基本语句</h2><p>hive 不支持行级插入、更新、删除操作，也不支持事务。</p><p>hive   数据库的概念本质上只是表的一个目录或者命名空间。这样可以避免表名冲突。</p><p>如果没有显指定数据库，默认使用 default 数据库</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br><span class="line">show databases like &apos;h.*&apos;;   # 支持正则</span><br><span class="line">create database name LOCATION ‘/my/dir/’;   # 指定数据库目录</span><br></pre></td></tr></table></figure><p>数据库可以的内容很少，只有<code>DBPROPERTIES</code>可以设置键值对属性，来描述这个数据库的属性信息，其他都是不可改的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert database name SET DBPROPERTIES (&apos;edited-by&apos;=&apos;jizx&apos;);</span><br></pre></td></tr></table></figure><h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>通过载入数据的方式创建分区。将<code>$HOME/california-employees</code>   目录下的文件拷贝到分区目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &apos;$&#123;env:HOME&#125;/california-employees&apos;</span><br><span class="line">into table emplyees</span><br><span class="line">partition (country = &apos;US&apos;, state = &apos;CA&apos;)</span><br></pre></td></tr></table></figure><p>也可以t通过 insert 的方法，也可以通过 <code>alert table...add partition</code>的方法</p><h4 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show partitions table_name;</span><br><span class="line">describe extended table_name;   # 更详细的表信息</span><br><span class="line">describe extended table_name PARTITION  (year=2019,month=1,day=2);   # 更详细的分区信息，可以看到 location 信息</span><br></pre></td></tr></table></figure><h3 id="外部分区表（最常见）"><a href="#外部分区表（最常见）" class="headerlink" title="外部分区表（最常见）"></a>外部分区表（最常见）</h3><p>使用的目录组织习惯完全由我们自己定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert table name ADD PARTITION(year=2019,month=9,day=2)</span><br><span class="line">LOCATITION &apos;hdfs://master_server/data/log_messages/2012/01/02&apos;;</span><br></pre></td></tr></table></figure><p>这种灵活性的优点是：我们可以用像 amazon s3 这样的廉价存储设备存储<strong>旧的数据</strong>，在 HDFS 中存储较新的数据。</p><p><img src="/2019/10/12/hive/./image1.png" alt="image-20191012145614833"></p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists table_name;</span><br></pre></td></tr></table></figure><p>对于管理表，表的元数据和表内的数据都会被删除。</p><p>回收站功能</p><p>/user/$USER/.Trash目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.trash.interval=</span><br></pre></td></tr></table></figure><p>检查点的时间间隔，单位是分钟。</p><p>如果不小心删除了管理表的话，先重建表，然后重建所需要的分区，再从<code>.Trash</code>目录中将误删的文件移动到正确的文件目录下。</p><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>会修改元数据，但不会修改数据本身</p><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert table log_messages RENAME TO logmsgs;</span><br></pre></td></tr></table></figure><h4 id="分区操作"><a href="#分区操作" class="headerlink" title="分区操作"></a>分区操作</h4><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert table log_messages ADD IF NOT EXISTS</span><br><span class="line">PARTITION (year=2019,month=1,day=1) LOCATITION &apos;/logs/2019/09/01&apos;</span><br><span class="line">PARTITION (year=2019,month=1,day=2) LOCATITION &apos;/logs/2019/09/02&apos;</span><br><span class="line">PARTITION (year=2019,month=1,day=3) LOCATITION &apos;/logs/2019/09/03&apos;</span><br></pre></td></tr></table></figure><blockquote><p>  0.8.0以上的 hive 可以在一个查询内同时增加多个分区</p></blockquote><p>修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert table log_messages PARTITION (year=2019,month=1,day=3)</span><br><span class="line">SET LOCATION &apos;s3n://ourbucket/logs/2011/01/02&apos;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert table log_messages DROP IF EXISTs PARTITION (year=2019,month=1,day=3);</span><br></pre></td></tr></table></figure><h4 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h4><p><strong>修改列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert table log</span><br><span class="line">CHANGE COLUMN hms new_hms INT</span><br><span class="line">COMMENT &apos;注释&apos;</span><br><span class="line">AFTER other_column;</span><br></pre></td></tr></table></figure><p>想放在第一列的话，使用<code>FIRTST</code>代替<code>AFTER other_column</code>即可</p><p><strong>添加</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert table log ADD COLUMN (</span><br><span class="line">app_name STRING COMMENT &apos;注释&apos;,</span><br><span class="line">session STRING COMMENT &apos;注释&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>删除或替换列</strong></p><p>其实就是将原本的全部的列信息删除掉，然后重新定义列信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert table log REPLACE COLUMN (</span><br><span class="line">app_name STRING COMMENT &apos;注释&apos;,</span><br><span class="line">session STRING COMMENT &apos;注释&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>修改表属性</strong></p><p>可以修改或添加，但是无法删除</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert table log SET TBLPROPERTIES(</span><br><span class="line">&apos;note&apos; = &apos;笔记内容&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="查看表详细信息"><a href="#查看表详细信息" class="headerlink" title="查看表详细信息"></a>查看表详细信息</h3><p> <code>desc formatted test_table;</code></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>limit在CLI 中非常经常用到，为了避免执行整个查询语句，有一个配置属性可开启，对原数据进行抽样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive.limit.optimize.enable=true</span><br><span class="line">hive.limit.row.max.size=1000000    # how much size we need to gurantee each row to have at least</span><br><span class="line">hive.limit.optimize.limit.file=10  # 最多采样的文件数</span><br></pre></td></tr></table></figure><p>缺点：有可能输入中有用的数据永远不会被处理到。</p><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line">&gt; create table supply(id int, part string, quantity int) </span><br><span class="line">&gt; partitioned by (int day);</span><br><span class="line"></span><br><span class="line"># 添加分区</span><br><span class="line">&gt; alert table supply add partiton (day=20190909);</span><br><span class="line"></span><br><span class="line"># 通过 where 选择分区</span><br><span class="line">&gt; select part,quantity from supply</span><br><span class="line">&gt; where day&gt;=20190909 and quantity &lt; 4;</span><br></pre></td></tr></table></figure><p>多分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ...</span><br><span class="line">&gt; partition by (day int, state string, city string);</span><br></pre></td></tr></table></figure><p>理想的分区方案不应该导致产生太多的分区和文件夹目录。</p><p>一个分区对应着包含多个文件的文件夹。因此如果存在数百个分区，每天就会创建好几万个文件。默认情况下，MapReduce 会将每个 job转为多个 task，每个 task 都是一个新的 JVM 实例，每个文件都会对应一个 task，因此 JVM 的开启和销毁可能会比实际处理数据的时间还要久。</p><p>好的分区方案应该保证分区数量的增长是<strong>均匀的</strong>。</p><h3 id="分桶表TODO"><a href="#分桶表TODO" class="headerlink" title="分桶表TODO"></a>分桶表TODO</h3><h3 id="为表增加列"><a href="#为表增加列" class="headerlink" title="为表增加列"></a>为表增加列</h3><p>SerDe 非常宽松，通过指定的分隔符从左向右将行分解成列</p><ul><li>如果字段数比预期少，那么缺失的字段将返回 null</li><li>如果字段数比预期多，那么多出的字段将会被忽略</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert table student add columns (score string);</span><br></pre></td></tr></table></figure><p>通过这种方法，无法在已有字段的开始或者中间增加字段</p><h3 id="使用列存储表-TODO"><a href="#使用列存储表-TODO" class="headerlink" title="使用列存储表 TODO"></a>使用列存储表 TODO</h3><p>以下两种情况适合列存储表</p><h4 id="重复数据，如-age，省市"><a href="#重复数据，如-age，省市" class="headerlink" title="重复数据，如 age，省市"></a>重复数据，如 age，省市</h4><h4 id="多列"><a href="#多列" class="headerlink" title="多列"></a>多列</h4><h3 id="Map-join"><a href="#Map-join" class="headerlink" title="Map join"></a>Map join</h3><p>以下几种情况无法使用map join</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Union Followed by a MapJoin</span><br><span class="line">Lateral View Followed by a MapJoin</span><br><span class="line">Reduce Sink (Group By/Join/Sort By/Cluster By/Distribute By) Followed by MapJoin</span><br><span class="line">MapJoin Followed by Union</span><br><span class="line">MapJoin Followed by Join</span><br><span class="line">MapJoin Followed by MapJoin</span><br></pre></td></tr></table></figure><p>相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--是否自动转换为mapjoin</span><br><span class="line">set hive.auto.convert.join = true;</span><br><span class="line">--小表的最大文件大小，默认为25000000，即25M</span><br><span class="line">set hive.mapjoin.smalltable.filesize = 25000000;</span><br><span class="line">--是否将多个mapjoin合并为一个</span><br><span class="line">set hive.auto.convert.join.noconditionaltask = true;</span><br><span class="line">--多个mapjoin转换为1个时，所有小表的文件大小总和的最大值。</span><br><span class="line">set hive.auto.convert.join.noconditionaltask.size = 10000000;</span><br></pre></td></tr></table></figure><h4 id="确保多张小表使用-mapjoin"><a href="#确保多张小表使用-mapjoin" class="headerlink" title="确保多张小表使用 mapjoin"></a>确保多张小表使用 mapjoin</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+MAPJOIN(smallTableTwo)*/</span> idOne, idTwo, <span class="keyword">value</span> <span class="keyword">FROM</span></span><br><span class="line">  ( <span class="keyword">select</span> <span class="comment">/*+MAPJOIN(smallTableOne)*/</span> idOne, idTwo, <span class="keyword">value</span> <span class="keyword">FROM</span></span><br><span class="line">    bigTable <span class="keyword">JOIN</span> smallTableOne <span class="keyword">on</span> (bigTable.idOne = smallTableOne.idOne)                             </span><br><span class="line">  ) firstjoin                                                            </span><br><span class="line">  <span class="keyword">JOIN</span>                                                                 </span><br><span class="line">  smallTableTwo <span class="keyword">ON</span> (firstjoin.idTwo = smallTableTwo.idTwo)</span><br></pre></td></tr></table></figure><p>除了添加 mapjoin提示，还需要设置两个参数</p><ul><li><p>hive.auto.convert.join.noconditionaltask=true</p><blockquote><p>  如果启用此参数，并且n向连接的表/分区的n-1个大小的总和&lt;指定的大小，则该连接将直接转换为mapjoin（没有条件任务）。</p></blockquote></li><li><p>hive.auto.convert.join.noconditionaltask.size=1000000</p><blockquote><p>  如果n路联接的n个表/分区的n-1个大小的总和小于此大小，该连表将直接转换为mapjoin（没有条件任务）。 默认值为10MB。</p></blockquote></li></ul><p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins</a></p><h2 id="导入导出数据"><a href="#导入导出数据" class="headerlink" title="导入导出数据"></a>导入导出数据</h2><h3 id="动态分区插入"><a href="#动态分区插入" class="headerlink" title="动态分区插入"></a>动态分区插入</h3><p>可以基于查询参数推断出需要创建的分区名称。SELECT 语句中的最后 2 列会对应到 PARTITION 中的分区名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT OVERWRITE TSBLE employees</span><br><span class="line">PARTITION(country, state)</span><br><span class="line">SELECT ..., se.cnty,se.st</span><br><span class="line">FROM staged_employees se;</span><br></pre></td></tr></table></figure><p>动静结合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT OVERWRITE TSBLE employees</span><br><span class="line">PARTITION(country = &apos;US&apos;, state)   # 静态分区键必须出现在动态分区键之前</span><br><span class="line">SELECT ..., se.cnty,se.st</span><br><span class="line">FROM staged_employees se</span><br><span class="line">WHERE se.cnty = &apos;US&apos;;</span><br></pre></td></tr></table></figure><h3 id="单个查询语句中创建表并加装数据"><a href="#单个查询语句中创建表并加装数据" class="headerlink" title="单个查询语句中创建表并加装数据"></a>单个查询语句中创建表并加装数据</h3><p>这个功能不能用于外部表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ca_employees</span><br><span class="line">AS SELECT name, salary, address</span><br><span class="line">FROM employees</span><br><span class="line">WHERE se.state = &apos;CA&apos;;</span><br></pre></td></tr></table></figure><h3 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT OVERWRITE LOCAL DIRECTORY &apos;/tmp/employees&apos;</span><br><span class="line">select name</span><br><span class="line">from employee</span><br><span class="line">where se.state = &apos;CA&apos;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>select sub[0] from table_name;</code> 查询<strong>数组</strong>类型的字段的第一个元素</p><p><code>select ded[“state taxes”] from table_name;</code> 查询<strong>map</strong>类型的字段</p><p><code>select address.city from table_name;</code> 查询<strong>struct</strong>类型的字段</p><p>使用正则表达式来指定列，所有以 price 开头的列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `price.*` from stocks;</span><br></pre></td></tr></table></figure><p>不允许使用多个 DISTINCT 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(DISTINCT ymd),count (DISTINCT volume) from stocks;</span><br></pre></td></tr></table></figure><p>存在的 bug <code>count(DISTINCT col)</code>同时 col 是分区列时，会出现 bug</p><p>表生成函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, sub </span><br><span class="line">FROM udtf_test</span><br><span class="line">LATERAL VIEW explode(subordinates) subView AS sub;</span><br></pre></td></tr></table></figure><p>在这里LATERAL VIEW 是将 explode结果转换成一个视图subView,在视图中的单列列名定义为sub，然后在查询的时候引用这个列名就能够查到。</p><p>与时间相关的函数 ，输入可以是整数或者字符串类型。对于 0.8.0，可以接受 TIMESTAMP 类型的参数。</p><p>列别名 <code>SELECT  col as new_col FROM table_name</code></p><p>对列的进一步处理，进行条件判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Select  </span><br><span class="line">    CASE </span><br><span class="line">     WHEN salary &gt; 7 AND salary &lt;10 THEN &apos;high&apos;</span><br><span class="line">     ELSE &apos;very high&apos;</span><br><span class="line">    END AS bracket </span><br><span class="line">FROM employees</span><br></pre></td></tr></table></figure><p>最好将下面的设置添加到 hiverc 中，避免不必要的 <code>MapReduce</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  hive.exec.mode.local.auto=true</span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where 语句使用<strong>谓词表达式</strong>，谓词表达式结果为 true 时，相应的行将被保留和输出。</p><p>where 语句中并不能使用 select 语句中的别名，解决办法是使用嵌套 select 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.* FROM</span><br><span class="line">  ( select salary*(1- ded[&quot;Taxes&quot;]) as new_salary</span><br><span class="line">    FROM employees) e</span><br><span class="line">WHERE round(e.new_salary) &gt; 7000</span><br></pre></td></tr></table></figure><h4 id="关于浮点数比较的陷阱"><a href="#关于浮点数比较的陷阱" class="headerlink" title="关于浮点数比较的陷阱"></a>关于浮点数比较的陷阱</h4><p>hive无法精确的表示 0.2，如果转为 float，实际数值是：0.2000001。如果转为 double，实际数值是：0.200000000001。</p><p>sql 语句中的浮点数，默认是 Double 类型的，比如下面的0.2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from name wheren high&gt; 0.2</span><br></pre></td></tr></table></figure><p>如果表的字段定义时是 Float 类型，就会出现比较上的问题。输出中会有=0.2 的。</p><p>Float字段会隐式转为 Double 类型，变成：0.20000001000000，因此会比 0.2 的double 类型0.200000000001大。 </p><p>因此会出现 <code>&gt;0.2</code>的效果与<code>&gt;=0.2</code>相同。</p><p>解决办法：</p><ol><li>将字段类型保存为 double，缺点是查询时内存消耗增多</li><li>sql 中的数字显示指定类型<code>WHERE high &gt; cast(0.2 AS FLOAT)</code></li><li>与钱相关的都避免使用浮点数</li></ol><h3 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h3><p>having 语句用于聚合后再进行的条件过滤，避免了子查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select avg(salary) From stocks</span><br><span class="line">where ...</span><br><span class="line">GROUP BY year(ymd)</span><br><span class="line">HAVING avg(salary) &gt; 50.0   # 对上面的聚合后的内容进行过滤</span><br></pre></td></tr></table></figure><h3 id="join-语句"><a href="#join-语句" class="headerlink" title="join 语句"></a>join 语句</h3><ul><li><p>join on 只支持等值连接，也就是<code>a.col=b.col</code> ，不支持<code>a.col&lt; b.col</code></p></li><li><p>不支持在 on 子句中的谓词使用 OR</p></li><li><p>hive 假定从左到右边表依次变大，也可以在 SELECT 中添加<code>/*+STREAMTABLE(s)*/</code></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT /*+STREAMTABLE(s)*/   s.ymd,s.symbol</span><br><span class="line">FROM stocks s JOIN dividends d ON ...</span><br></pre></td></tr></table></figure></li><li><p>ON语句中的分区过滤条件在 OUTER JOIN 中是无效的，在 INNER JOIN 中是有效的 TODO（不太明白）</p></li><li><p>full outer join 将会返回所有表中符合 WHERE 语句条件的所有记录。如果任一张表的指定字段没有符合条件的值的话，那么就是用 NULL 值代替。</p></li></ul><h4 id="LEFT-SEMI-JOIN"><a href="#LEFT-SEMI-JOIN" class="headerlink" title="LEFT SEMI-JOIN"></a>LEFT SEMI-JOIN</h4><p>左半开连接会返回左边表的记录，前提是其记录对于满足 ON 语句中的判定条件。</p><p><img src="/2019/10/12/hive/2019-10-12-hive/image2.png" alt="image-20191015111109600"></p><h4 id="map-join"><a href="#map-join" class="headerlink" title="map  join"></a>map  join</h4><p>0.7之前的需要在 SELECT 中添加标记来进行触发，如下面的内连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT /*+MAPJOIN(d)*/ s.ymd, s.symbol, d.dividend </span><br><span class="line">FROM stocks s JOIN dividends d ON s.ymd=d.ymd</span><br><span class="line">WHERE s.symbol = &apos;AAPL&apos;</span><br></pre></td></tr></table></figure><p>0.7之后的版本，废弃这种标记，不过添加后同样是有效的。如果没有该标记，需要用户设置属性<code>hive.auto.convert.JOIN=true</code>，也可以配置小表的大小<code>hive.mapjoin.smalltable.filesize=25000000</code> 单位是字节</p><h3 id="ORDER-BY-和-SORT-BY"><a href="#ORDER-BY-和-SORT-BY" class="headerlink" title="ORDER BY 和 SORT BY"></a>ORDER BY 和 SORT BY</h3><p>sort by 是局部的，order by 是全局的，比较费时。</p><h3 id="DISTRIBUTE-BY与-CLUSTER-BY"><a href="#DISTRIBUTE-BY与-CLUSTER-BY" class="headerlink" title="DISTRIBUTE BY与 CLUSTER BY"></a>DISTRIBUTE BY与 CLUSTER BY</h3><p>Distribute by 用来保证相同指定列的记录会分发到同一个 reducer 中。</p><p>如果DISTRIBUTE 与 SORT 语句中都涉及到相同的列，而且采用的是升序排序方式，那么这时 CLUSTER BY 等价于前面的两个语句。</p><p>CLUSTER BY 剥夺了 SORT BY 的并行性，但是这样可以实现输出的数据是全局排序的。</p><h3 id="抽样查询"><a href="#抽样查询" class="headerlink" title="抽样查询"></a>抽样查询</h3><p>方式1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from numbers TABLESAMPLE(BUCKET 1 OUT OF 2 ON col1) s;</span><br></pre></td></tr></table></figure><p>2表示将数据分散成几桶，1 表示选择第几桶</p><p>方式 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from numbersflat TABLESAMPLE(0.1 PERCENT) s;</span><br></pre></td></tr></table></figure><p>基于行数的，按照输入路径下的数据块百分比进行抽样。</p><ul><li>不一定适合所有文件格式</li><li>抽样最小单元是一个 HDFS 数据块，如果标的数据大小 &lt; 普通的块大小 128MB 的话，将返回所有行</li></ul><h3 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h3><p>hive中比较低的版本没有 union，只有 union all</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li>将复杂的多层子嵌套进行封装，类似于使用函数一样。</li><li>安全机制，不直接给用户访问敏感数据的原始表，而是提供给用户通过 where 限制了的视图。（目前 hive 并不支持，用户必须具有原始表的权限，视图才能工作）</li><li>可以理解为：hive 会先解析视图，然后使用解析结果来解析整个查询语句，不过查询优化器<strong>可能会将视图和查询语句合并成一个单一的实际查询语句。</strong>如果视图中包含 ORDER BY 或者 LIMIT，则会先解析视图。</li><li>通过 show tables 来查询视图，没有 show views 这样的语句</li></ul><p>describe 和describe extended 可以显示视图的元数据信息</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="数据的导入与导出"><a href="#数据的导入与导出" class="headerlink" title="数据的导入与导出"></a>数据的导入与导出</h3><p>1）加载到普通表</p><p>加载本地文本文件内容（要与hive表字段分隔符顺序都要一致）</p><pre><code>load data local inpath &apos;/home/hadoop/orders.csv&apos; overwrite into table orders;</code></pre><p>如果数据源在HDFS上，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data inpath &apos;hdfs://master:9000/user/orders&apos; overwrite into table orders;  数据源在HDFS上</span><br></pre></td></tr></table></figure><p>2) 加载到分区表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &apos;/home/hadoop/test.txt&apos; overwrite into table test partition (dt=&apos;2017-09-09&apos;);</span><br></pre></td></tr></table></figure><p>partition 是指定这批数据放入分区2017-09-09中；</p><p>3）加载分桶表<br>先创建普通临时表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orders_tmp</span><br><span class="line">(</span><br><span class="line">user_id <span class="built_in">int</span>,</span><br><span class="line">user_name <span class="keyword">string</span>,</span><br><span class="line">create_time <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure><p>数据载入临时表</p><pre><code>load data local inpath &apos;/home/hadoop/lead.txt&apos; overwrite into table orders_tmp; </code></pre><p>导入分桶表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set hive.enforce.bucketing = true;</span><br><span class="line">insert overwrite table orders select * from orders_tmp;</span><br></pre></td></tr></table></figure><p>4) 导出数据</p><p>将hive表中的数据导出到本地文件中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert overwrite local directory &apos;/home/hadoop/orders.bak2017-12-28&apos; select * from orders;</span><br></pre></td></tr></table></figure><p>【去掉local关键字，也可以导出到HDFS上】</p><h3 id="JOIN-ON中的-and-与-where-子句"><a href="#JOIN-ON中的-and-与-where-子句" class="headerlink" title="JOIN ON中的 and 与 where 子句"></a>JOIN ON中的 and 与 where 子句</h3><p>HiveQL与标准SQL的区别：</p><p>陷阱1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> first_table t1</span><br><span class="line"><span class="keyword">JOIN</span> second_table t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id</span><br><span class="line"><span class="keyword">where</span> t1.date = <span class="string">"2016-06-01"</span></span><br></pre></td></tr></table></figure><p>在hive里面，没有SQL优化器，则这样些的后果是，直接将t1表与t2表全量连接，产生大量的MapReduce操作再进行过滤</p><p>正确写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">( <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> first_table <span class="keyword">WHERE</span> <span class="built_in">date</span> = <span class="string">"2016-06-01"</span>) t1</span><br><span class="line"><span class="keyword">JOIN</span> second_table t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id;</span><br></pre></td></tr></table></figure><p>其实上面的语句还不是最好的,因为hive通常处理的都是大数据表,上亿至少小case。<strong>hive sql里不推荐用嵌套子查询语句</strong>，就是为了减小查询负担。</p><p>更优的写法是join…on 后面，用and代替where。为什么？用and的话，查询是先过滤条件，得到一个较小的表，然后再跟其他表联合。这样，无形中，就能节省下不小的运算量，自然就更快了！</p><p>更优的写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> first_table t1</span><br><span class="line"><span class="keyword">JOIN</span> second_table t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id</span><br><span class="line"><span class="keyword">and</span> t1.date = <span class="string">"2016-06-01"</span>;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/ad64b953dc67" target="_blank" rel="noopener">https://www.jianshu.com/p/ad64b953dc67</a></p><h3 id="合并小文件"><a href="#合并小文件" class="headerlink" title="合并小文件"></a>合并小文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -cat hdfs://cdh5/tmp/lxw1234/*.txt | hadoop fs -appendToFile - hdfs://cdh5/tmp/hdfs_largefile.txt</span><br></pre></td></tr></table></figure><p>这种处理方法在<strong>数据量非常大的情况下不适合</strong>，最好使用MapReduce来合并。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hive </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux知识点</title>
      <link href="/2019/10/11/linux%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/10/11/linux%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间（swap space）。</p><h3 id="系统的运行级别"><a href="#系统的运行级别" class="headerlink" title="系统的运行级别"></a>系统的运行级别</h3><p>运行级为1时，只启动基本的系统进程以及一个控制台终端进程。我们称之为单用户模式。</p><p>标准的启动运行级是3。在这个运行级上，大多数应用软件，比如网络支持程序，都会启动。 </p><p>另一个Linux中常见的运行级是5。在这个运行级上系统会启动图形化的X Window系统，允许用 户通过图形化桌面窗口登录系统。</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>每个内容区域都分配了一个数字， 从1开始，一直到9，如表所示。</p><table><thead><tr><th style="text-align:left">区号</th><th style="text-align:left">所涵盖的内容</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">可执行程序或shell命令</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">系统调用</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">库调用</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">特殊文件</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">文件格式与约定</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">游戏</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">概览、约定及杂项</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">超级用户和系统管理员命令</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">内核例程</td></tr></tbody></table><p>工具通常提供的是命令所对应的<strong>最低编号</strong>的内容。</p><h3 id="常见Linux目录名称"><a href="#常见Linux目录名称" class="headerlink" title="常见Linux目录名称"></a>常见Linux目录名称</h3><table><thead><tr><th style="text-align:left">目 录</th><th style="text-align:left">用处</th></tr></thead><tbody><tr><td style="text-align:left">/</td><td style="text-align:left">虚拟目录的根目录。通常不会在这里存储文件</td></tr><tr><td style="text-align:left">/bin</td><td style="text-align:left">二进制目录，存放许多用户级的GNU工具</td></tr><tr><td style="text-align:left">/boot</td><td style="text-align:left">启动目录，存放启动文件</td></tr><tr><td style="text-align:left">/dev</td><td style="text-align:left">设备目录， Linux在这里创建设备节点</td></tr><tr><td style="text-align:left">/etc</td><td style="text-align:left">系统配置文件目录</td></tr><tr><td style="text-align:left">/home</td><td style="text-align:left">主目录， Linux在这里创建用户目录</td></tr><tr><td style="text-align:left">/lib</td><td style="text-align:left">库目录，存放系统和应用程序的库文件</td></tr><tr><td style="text-align:left">/media</td><td style="text-align:left">媒体目录，可移动媒体设备的常用挂载点</td></tr><tr><td style="text-align:left">/mnt</td><td style="text-align:left">挂载目录，另一个可移动媒体设备的常用挂载点</td></tr><tr><td style="text-align:left">/opt</td><td style="text-align:left">可选目录，常用于存放第三方软件包和数据文件</td></tr><tr><td style="text-align:left">/proc</td><td style="text-align:left">进程目录，存放现有硬件及当前进程的相关信息</td></tr><tr><td style="text-align:left">/root</td><td style="text-align:left">root用户的主目录</td></tr><tr><td style="text-align:left">/sbin</td><td style="text-align:left">系统二进制目录，存放许多GNU管理员级工具</td></tr><tr><td style="text-align:left">/run</td><td style="text-align:left">运行目录，存放系统运作时的运行时数据</td></tr><tr><td style="text-align:left">/srv</td><td style="text-align:left">服务目录，存放本地服务的相关文件</td></tr><tr><td style="text-align:left">/sys</td><td style="text-align:left">系统目录，存放系统硬件信息的相关文件</td></tr><tr><td style="text-align:left">/tmp</td><td style="text-align:left">临时目录，可以在该目录中创建和删除临时工作文件</td></tr><tr><td style="text-align:left">/usr</td><td style="text-align:left">用户二进制目录，<strong>大量用户级的GNU工具</strong>和数据文件都存储在这里</td></tr><tr><td style="text-align:left">/var</td><td style="text-align:left">可变目录，用以存放经常变化的文件，比如日志文件</td></tr></tbody></table><p>常见的目录名均基于文件系统层级标准（filesystem hierarchy standard，FHS）。<a href="http://www.pathname.com/fhs。" target="_blank" rel="noopener">http://www.pathname.com/fhs。</a></p><h3 id="虚拟目录与挂载点"><a href="#虚拟目录与挂载点" class="headerlink" title="虚拟目录与挂载点"></a>虚拟目录与挂载点</h3><p>Linux虚拟目录中比较复杂的部分是它如何协调管理各个存储设备。在Linux PC上安装的<strong>第一块硬盘称为根驱动器</strong>。根驱动器包含了虚拟目录的核心，其他目录都是从那里开始构建的。Linux会在根驱动器上创建一些特别的目录，我们称之为<strong>挂载点</strong>（mountpoint）。挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上它们却存储在另外一个驱动器中。</p><p>通常系统文件会存储在根驱动器中，而用户文件则存储在另一驱动器中。</p><h3 id="glob-模式匹配"><a href="#glob-模式匹配" class="headerlink" title="glob 模式匹配"></a>glob 模式匹配</h3><ul><li>问号（?）代表一个字符； </li><li>星号（*）代表零个或多个字符。 问号可用于过滤器字符串中替代任意位置的单个字符。</li><li>使用中括号<code>[ai]pt</code>，字母范围<code>[a – i]</code>，感叹号<code>[!a]</code>将不需要的内容排除在外。</li></ul><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><ul><li>软链接(符号链接)：类似window 的快捷方式，<code>ln -s</code>选项来创建符号链接。软链接<code>sl_data_file</code>仅仅只是指向<code>data_file</code>而已。它们的内容并不相同，是两个完全不同的文件。</li><li>硬链接：<code>ln</code>，硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们<strong>从根本上而言是同一个文件</strong>（带有硬链接的文件<strong>共享inode编号</strong>）。引用硬链接文件等同于引用了源文件。</li></ul><blockquote><p>  只能对处于同一存储媒体的文件创建<strong>硬链接</strong>。要想在不同存储媒体的文件之间创建链接， 只能使用<strong>符号链接</strong>。</p><p>  用不着复制链接文件，可以创建原始文件的另一个链接。</p><p>  千万别创建软链接文件的软链接。</p></blockquote><h3 id="shell配置文件加载顺序"><a href="#shell配置文件加载顺序" class="headerlink" title="shell配置文件加载顺序"></a>shell配置文件加载顺序</h3><p><a href="http://ddrv.cn/a/173848/" target="_blank" rel="noopener">http://ddrv.cn/a/173848/</a></p><h3 id="通配符（Wildcard）"><a href="#通配符（Wildcard）" class="headerlink" title="通配符（Wildcard）"></a>通配符（Wildcard）</h3><p>在 Shell 中命令中，通常会使用通配符表达式来匹配一些文件，如以下命令可以查找当前目录下所有后缀为 .xml 的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.xml&quot;</span><br></pre></td></tr></table></figure><p>Shell 中可以使用的通配符如下：</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">匹配 0 或多个字符</td><td style="text-align:left"><code>a*b</code>，a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如 aabcb, axyzb, a012b, ab</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配任意单个字符</td><td style="text-align:left"><code>a?b</code>，a与b之间有且只有一个字符, 可以是任意字符, 如 aab, abb, acb, a0b</td></tr><tr><td style="text-align:left">[list]</td><td style="text-align:left">匹配 list 中的任意单个字符</td><td style="text-align:left"><code>a[xyz]b</code>，a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如 axb, ayb, azb。</td></tr><tr><td style="text-align:left">[!list]</td><td style="text-align:left">匹配除 list 中的任意单一字符</td><td style="text-align:left"><code>a[!0-9]b</code>，a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如 axb, aab, a-b。</td></tr><tr><td style="text-align:left">[c1-c2]</td><td style="text-align:left">匹配 c1-c2 中的任意单一字符</td><td style="text-align:left"><code>a[0-9]b</code>，匹配0与9之间其中一个字符，如 a0b, a1b… a9b</td></tr><tr><td style="text-align:left">{s1,s2,…}</td><td style="text-align:left">匹配 s1 或 s2 (或更多)中的一个字符串</td><td style="text-align:left"><code>a{abc,xyz,123}b</code>，a与b之间只能是abc或xyz或123这三个字符串之一</td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>有的时候，我们匹配的内容里面会存在 <code>*</code>，<code>?</code>，<code>[</code>等通配符中的符号。为了表示他们原来的意思，我们需要使用转义字符 <code>\</code>，如 <code>a\[ac\]c</code> 表示匹配 <code>a[a]c</code> 或 <code>a[c]c</code>。<code>\</code> 本身用 <code>\\</code> 表示。</p><h3 id="分清楚通配符表达式和正则表达式"><a href="#分清楚通配符表达式和正则表达式" class="headerlink" title="分清楚通配符表达式和正则表达式"></a>分清楚通配符表达式和正则表达式</h3><p>通配符看起来和正则表达式很像，但他们并不是同一种东西。<strong>正则表达式中的那些量词的匹配规则和这里提到的几个通配符的匹配规则并不相同。</strong>如正则表达式中 <code>*</code> 表示重复前一个字符任意次，<code>ab*</code> 表示的是那些 <code>a</code> 后面跟 0 个或多个 <code>b</code> 的字符串， 而通配符表达式中 <code>*</code> 表示 0 或多个任意字符， <code>ab*</code> 表示的是那些 <code>ab</code> 后面跟任意个字符的字符串。</p><p>而且<strong>正则表达式一般是部分匹配的</strong>，用来匹配内容中的一部分，如用正则表达式 <code>a</code> 去匹配 <code>bac</code> 这段字符串时，匹配是成功的，匹配到的内容是 <code>a</code>。但是<strong>通配符表达式的话是全部匹配的</strong>，表达式要匹配整个字符串才算匹配成功，如用通配符表达式 <code>a</code> 取匹配 <code>bac</code> 这段字符串时，匹配是失败的。</p><p>在 Shell 命令中，通常<strong>用通配符表达式来匹配文件名</strong>，而<strong>用正则表达式来匹配一段文本内容</strong>。以 <code>grep</code> 命令为例，<code>grep</code> 命令可以在指定的文件中，挑选出和表达式匹配的那些行，其中指定文件是用的通配符表达式，而文本内容的匹配用的是正则表达式。</p><p>今天使用 <code>grep</code> 时，就因为没分清楚他们，忙活了半天。情况是这样的，我想看一个 jar 包里是不是有 pom 相关的文件，所以就输入了下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tf maven-model-builder-3.5.3.jar | grep &apos;pom*&apos;  # 这里是正则表达式，匹配有po、pom、pom+子串的字符串</span><br></pre></td></tr></table></figure><p>结果输入了一堆文件，而且很多文件都没有 pom 这串字符串的。输出内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">org/apache/maven/model/composition/</span><br><span class="line">org/apache/maven/model/interpolation/</span><br><span class="line">org/apache/maven/model/superpom/</span><br><span class="line">org/apache/maven/model/composition/DependencyManagementImporter.class</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这就是因为我把通配符表达式和正则表达式搞混了，后来知道原因后，用下面的命令才得到想要的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tf maven-model-builder-3.5.3.jar | grep &apos;pom.*&apos;</span><br></pre></td></tr></table></figure><p>使用 Shell 命令时，要分清楚哪里用的是通配符表达式，哪里用的是正则表达式。</p><p>链接：<a href="https://www.jianshu.com/p/25f3d0cd5fdc" target="_blank" rel="noopener">https://www.jianshu.com/p/25f3d0cd5fdc</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>文本命令行界面（command line interface，CLI）</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim技巧</title>
      <link href="/2019/10/10/vim%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/10/10/vim%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h4 id="行尾添加字符串"><a href="#行尾添加字符串" class="headerlink" title="行尾添加字符串"></a>行尾添加字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-v&gt;G$   &quot; 全选</span><br><span class="line">A;        &quot; 进入插入模式，添加;</span><br><span class="line">&lt;Esc&gt;     &quot; 完成插入</span><br></pre></td></tr></table></figure><p>或者使用替换命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/$/;/g</span><br></pre></td></tr></table></figure><h4 id="统计当前模式的匹配个数"><a href="#统计当前模式的匹配个数" class="headerlink" title="统计当前模式的匹配个数"></a>统计当前模式的匹配个数</h4><p><strong>方法一</strong>、使用 substitute</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➾ /\&lt;buttons\&gt; </span><br><span class="line">➾ :%s///gn </span><br><span class="line">《 5 matches on 4 lines</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>、使用 vimgrep</p><p>可以知道当前匹配文本所处的位置，例如共5个匹配，当前 是第3个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➾ /\&lt;buttons\&gt; </span><br><span class="line">➾ :vimgrep //g % </span><br><span class="line">《(1 of 5) var buttons = viewport.buttons;</span><br></pre></td></tr></table></figure><p>该命令会把当前文件中所有找到的匹配放进quickfix列表。用 <code>:cnext</code>和 <code>:cprev</code>命令可以正向和反向遍历quickfix列表。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bash命令提示符个性化</title>
      <link href="/2019/09/04/bash%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%E4%B8%AA%E6%80%A7%E5%8C%96/"/>
      <url>/2019/09/04/bash%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%E4%B8%AA%E6%80%A7%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>详细介绍了如何配置 bashrc，使得命令行的提示符更美观，包括当前路径、时间、用户、服务器名称等</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="常用显示参数"><a href="#常用显示参数" class="headerlink" title="常用显示参数"></a>常用显示参数</h3><p><code>\d</code>：代表日期，格式为weekday month date，例如：”Mon Aug 1”<br><code>\H</code>：完整的主机名称<br><code>\h</code>：仅取主机的第一个名字<br><code>\t</code> ：显示时间为24小时格式，如：HH：MM：SS<br><code>\T</code>：显示时间为12小时格式<br><code>\A</code> ：显示时间为24小时格式：HH：MM<br><code>\u</code> ：当前用户的账号名称<br><code>\v</code> ：BASH的版本信息<br><code>\w</code>：完整的工作目录名称<br><code>\W</code> ：利用basename取得工作目录名称，所以只会列出最后一个目录<br><code>\#</code> ：下达的第几个命令<br><code>\$</code> ：提示字符，如果是root时，提示符为：<code>#</code> ，普通用户则为：<code>$</code><br><code>\n</code> ：换行符</p><p>可以在 bash 的 man 手册 PROMPTING 章节中查阅</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p><strong>PS1中设置字符颜色的格式为：<code>\[\e[F;Bm\]</code>，其中“F“为字体颜色，编号为30到37，“B”为背景颜色，编号为40到47。可以只设置前景色或背景色。颜色表如下：</strong></p><table><thead><tr><th style="text-align:left">F</th><th style="text-align:right">B</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:left">30</td><td style="text-align:right">40</td><td style="text-align:center">黑色</td></tr><tr><td style="text-align:left">31</td><td style="text-align:right">41</td><td style="text-align:center">红色</td></tr><tr><td style="text-align:left">32</td><td style="text-align:right">42</td><td style="text-align:center">绿色</td></tr><tr><td style="text-align:left">33</td><td style="text-align:right">43</td><td style="text-align:center">黄色</td></tr><tr><td style="text-align:left">34</td><td style="text-align:right">44</td><td style="text-align:center">蓝色</td></tr><tr><td style="text-align:left">35</td><td style="text-align:right">45</td><td style="text-align:center">紫红色</td></tr><tr><td style="text-align:left">36</td><td style="text-align:right">46</td><td style="text-align:center">青蓝色</td></tr><tr><td style="text-align:left">37</td><td style="text-align:right">47</td><td style="text-align:center">白色</td></tr></tbody></table><p>颜色格式后面跟着的就是<code>\u</code>、<code>\w</code>这样的显示参数，颜色格式后面的字符串都将使用该颜色，为了实现不同字段不同颜色，建议使用<code>指定的颜色 显示参数 None颜色</code> 这样进行划分。见下例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">COLOR_GRAY=<span class="string">'\[\e[1;30m\]'</span>    还有一种写法是将\e写成\033</span><br><span class="line">COLOR_RED=<span class="string">'\[\e[1;31m\]'</span></span><br><span class="line">COLOR_GREEN=<span class="string">'\[\e[1;32m\]'</span></span><br><span class="line">COLOR_YELLOW=<span class="string">'\[\e[1;33m\]'</span></span><br><span class="line">COLOR_BLUE=<span class="string">'\[\e[1;34m\]'</span></span><br><span class="line">COLOR_MAGENTA=<span class="string">'\[\e[1;35m\]'</span></span><br><span class="line">COLOR_CYAN=<span class="string">'\[\e[1;36m\]'</span></span><br><span class="line">COLOR_WHITE=<span class="string">'\[\e[1;37m\]'</span></span><br><span class="line">COLOR_NONE=<span class="string">'\[\e[m\]'</span></span><br><span class="line"></span><br><span class="line">PS1_USER=<span class="string">"<span class="variable">$&#123;COLOR_MAGENTA&#125;</span>\u<span class="variable">$&#123;COLOR_NONE&#125;</span>"</span></span><br><span class="line">PS1_HOST=<span class="string">"<span class="variable">$&#123;COLOR_CYAN&#125;</span>\h<span class="variable">$&#123;COLOR_NONE&#125;</span>"</span></span><br><span class="line">PS1_PWD=<span class="string">"<span class="variable">$&#123;COLOR_YELLOW&#125;</span>\w<span class="variable">$&#123;COLOR_NONE&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">"<span class="variable">$&#123;PS1_USER&#125;</span>@<span class="variable">$&#123;PS1_HOST&#125;</span>:<span class="variable">$&#123;PS1_PWD&#125;</span>\\\$ "</span></span><br></pre></td></tr></table></figure><p>在颜色定制文本(例如： <code>COLOR_GRAY=&#39;\[\033[1;30m\]&#39;</code>)中，开始的<code>\[</code>和结尾的<code>\]</code>是必须的，否则当输入的命令很长的时候，就会回车但不换行,于是覆盖了行首的有颜色的字符串</p><p>通过Bash编程在Terminal上输出彩色的字符串，是不能添加<code>\[</code>和<code>\]</code>的。 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">print</span> &#123; <span class="built_in">printf</span> -- <span class="string">"$*\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> _isatty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">typeset</span> -l isatty=<span class="variable">$&#123;ISATTY:-"auto"&#125;</span></span><br><span class="line">    [[ <span class="variable">$isatty</span> == <span class="string">"yes"</span> ]] &amp;&amp; <span class="built_in">return</span> 0         <span class="comment"># yes</span></span><br><span class="line">    [[ <span class="variable">$isatty</span> == <span class="string">"no"</span> ]] &amp;&amp; <span class="built_in">return</span> 1          <span class="comment"># no</span></span><br><span class="line">    [[ -t 1 &amp;&amp; -t 2 ]] &amp;&amp; <span class="built_in">return</span> 0 || <span class="built_in">return</span> 1 <span class="comment"># auto</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> str2gray    &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;30m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2red     &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;31m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2green   &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;32m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2yellow  &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;33m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2blue    &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;34m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2magenta &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;35m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2cyan    &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;36m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2white   &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;37m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="在线网站"><a href="#在线网站" class="headerlink" title="在线网站"></a>在线网站</h3><p>更多颜色参数，请参考：<a href="https://misc.flogisoft.com/bash/tip_colors_and_formatting" target="_blank" rel="noopener">https://misc.flogisoft.com/bash/tip_colors_and_formatting</a></p><p>如果上面的方法觉得麻烦，可以使用推荐的在线制作网站：<a href="http://ezprompt.net/" target="_blank" rel="noopener">http://ezprompt.net/</a></p><p>参考：</p><p><a href="https://www.jianshu.com/p/426d0eeee671" target="_blank" rel="noopener">https://www.jianshu.com/p/426d0eeee671</a></p><p><a href="https://www.cnblogs.com/idorax/p/8270025.html" target="_blank" rel="noopener">https://www.cnblogs.com/idorax/p/8270025.html</a></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>awk</title>
      <link href="/2019/09/02/awk/"/>
      <url>/2019/09/02/awk/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>linux 三剑客之一 awk 的详细介绍</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="awk英文文档"><a href="#awk英文文档" class="headerlink" title="awk英文文档"></a>awk英文文档</h3><p><a href="https://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">https://www.gnu.org/software/gawk/manual/gawk.html</a></p><h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>基本组成形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk options program file1 </span><br><span class="line">awk options program file1 file2</span><br><span class="line">awk options program <span class="comment"># 进入交互模式，直到ctrl+d结束输入</span></span><br></pre></td></tr></table></figure><p>由于gawk命令行假定脚本是单个文本字符串，你<strong>必须将脚本放到单引号中</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; print "start";command2 &#125; pattern &#123; command1;command2 &#125; END&#123; print "end";command2 &#125;'</span> file</span><br></pre></td></tr></table></figure><ul><li>一个命令就是一个以新行或者分号分隔的语句序列。</li><li>由于模式和命令两者任一都是可选的，所以需要使用大括号包围动作以区分于其他模式。</li><li>多条语句之间用<code>;</code>分隔<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; print $1,$6 &#125;'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="/2019/09/02/awk/./awk_workflow.jpg" alt="img"></p><ol><li><p>awk以<strong>逐行的形式</strong>处理文件</p></li><li><p><code>BEGIN</code>之后的命令会先于公共语句块执行</p><blockquote><p>  BEGIN语句块在awk开始从输入流中读取行之前被执行（除非调用了 <code>getline</code>）。这是一个<strong>可选的</strong>语句块，诸如变量初始化、打印输出表格的表头等语句通常都可以放在BEGIN语句块中。</p></blockquote></li><li><p>对于匹配PATTERN的行，awk会对其执行<code>PATTERN</code>之后的命令</p><blockquote><p>  这个语句块是<strong>可选的</strong>。如果不提供，则默认执行<code>{ print }</code>，即打印所读取到的每一行。 如果提供，则每个pattern依次测试每个输入行。对于匹配到行的模式，其对应的命令（也许包含多步）得到执行，然后读取下一行并继续匹配，直到所有的输入读取完毕。</p></blockquote></li><li><p>最后，在处理完整个文件之后，awk会执行<code>END</code>之后的命令</p><blockquote><p>  END语句块和BEGIN语句块类，也是<strong>可选的</strong>语句块。它在awk读取完输入流中所有的行之后被执行。像打印所有行的分析结果这种常见任务都是在END语句块中实现的。</p></blockquote></li></ol><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a><code>print</code>输出</h4><p><code>print</code>接受的变量之间以<strong>逗号分隔</strong>，在输出时会<strong>以空格作为变量之间的分隔符</strong>。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $3,$4&#125;&apos; marks.txt</span><br></pre></td></tr></table></figure><p><strong><code>print</code>之间的空格不会影响输出格式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $3 "\t" $4&#125;'</span> marks.txt <span class="comment"># $3与\t之间的空格不会显示在输出中</span></span><br><span class="line">awk <span class="string">'&#123;print $3 , $4&#125;'</span> marks.txt <span class="comment"># 逗号表示最终会以空格分分隔两个字段</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><p>在awk的<code>print</code>语句中，<strong>双引号被当作拼接操作符</strong>（concatenation operator）使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; var1="v1"; var2="v2"; var3="v3"; \</span></span><br><span class="line"><span class="string">print var1 "-" var2 "-" var3 ; &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># v1-v2-v3</span></span><br></pre></td></tr></table></figure><p><strong>省略<code>print</code></strong></p><p>如果没有主体块——默认的动作是输出行。因此比如搜索字符串<code>Tom</code>可以使用下面简略方式实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/Tom/'</span> marks.txt</span><br></pre></td></tr></table></figure><p><strong>打印一行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; print &#125;</span><br><span class="line"># 或者，由于 $0 表示整行,</span><br><span class="line">&#123; print $0 &#125;</span><br></pre></td></tr></table></figure><p><strong>打印特定列</strong></p><p>使用一个 print 语句可以在同一行中输出不止一个字段. 下面的程序输出了每 行输入中的第一和第三个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $1, $3 &#125;</span><br></pre></td></tr></table></figure><p><strong>NF</strong> 列总数</p><p>该变量表示一共有多少列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print NF, $1, $NF &#125; # 打印第一列 和最后一列</span><br></pre></td></tr></table></figure><p><strong>计算和打印</strong></p><p>你也可以对字段的值进行计算后再打印出来. 下面的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $1, $2 * $3 &#125;</span><br></pre></td></tr></table></figure><p><strong>NR 打印行号</strong></p><p>存储当前已经读取了多少行的计数。给每一行加上行号:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print NR, $0 &#125;</span><br></pre></td></tr></table></figure><p><strong>在输出中添加内容</strong></p><p>双引号内的文字将会在字段和计算的值中插入输出.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print &quot;total pay for&quot;, $1, &quot;is&quot;, $2 * $3 &#125;</span><br></pre></td></tr></table></figure><p><strong>排序输出</strong></p><p>最简单的方式是使用awk将每位员工的总薪酬置于其记录之前，然后利用<strong>sort</strong>命令来处理awk的输出。Unix上，命令行如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123; printf(&quot;%6.2f    %s\n&quot;, $2 * $3, $0) &#125;&apos; emp.data | sort</span><br></pre></td></tr></table></figure><p><strong>打印表头，表尾</strong></p><p> BEGIN 用于匹配第一个输入文件的第一行之前的位置， END 则用于匹配处理过的最后一个文件的最后一行之后的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;print &quot;Name Rate Hour&quot;;print &quot;=========&quot;&#125; &#123;print $0&#125;&apos; file</span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><ul><li>在命令中使用<strong>空格</strong>进行变量拼接</li><li>在<code>print</code>语句块中使用<strong>双引号</strong>拼接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将names变量与当前行的的$1以及空格进行拼接，赋值给names</span><br><span class="line"> &#123; names = names $1 &quot; &quot;&#125;</span><br><span class="line">END &#123; print names &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>只打印最后一行</strong></p><p><strong>打印最后一个输入行</strong></p><p>虽然在 END 动作中 NR 还保留着它的值，但 $0 没有。程序是打印最后一个输入行的一种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#123; last = $0 &#125;</span><br><span class="line">END &#123; print last &#125;</span><br></pre></td></tr></table></figure><h4 id="printf高级输出"><a href="#printf高级输出" class="headerlink" title="printf高级输出"></a><code>printf</code>高级输出</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>printf 语句的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(format, value1, value2, ..., valuen)</span><br></pre></td></tr></table></figure><p>其中 format 是字符串，包含要逐字打印的文本，穿插着 format 之后的每个值该如何打印的规格(specification)。一个规格是一个 % 符，后面跟着一些字符，用来控制一个 value 的格式。第一个规格说明如何打印 value1 ，第二个说明如何打印 value2 ，… 。因此，有多少 value 要打印，在 format 中就要有多少个 % 规格。（与C语言很像）</p><p>这里有个程序使用 printf 打印每位员工的总薪酬：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; printf(&quot;total pay for %s is $%.2f\n&quot;, $1, $2 * $3) &#125;</span><br></pre></td></tr></table></figure><h5 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h5><p><strong>退格符</strong><code>\b</code></p><p><strong>换页符</strong><code>\f</code></p><p><strong>换行符</strong><code>\n</code> ，进入下一行</p><p><strong>回车符</strong><code>\r</code> ，光标移动到第一列</p><blockquote><p>  这与以前的打字机相关，以前的打字机达打完一行后，机械上需要2步，先将指针移动到下一行（换行），然后将指针回到行首（回车）</p></blockquote><p>我们在每个域输出后输出一个回车符<code>\r</code>，随后输出的域会覆盖之前输出的内容。也就是说，我们只能看到最后输出的 Field 4。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; printf "Field 1\rField 2\rField 3\rField 4\n" &#125;'</span></span><br><span class="line"><span class="comment"># Field 4</span></span><br></pre></td></tr></table></figure><p><strong>垂直制表符</strong></p><p>如下示例，使用垂直制表符输出不同域：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; printf "Sr No\vName\vSub\vMarks\n" &#125;'</span></span><br><span class="line"><span class="comment"># 执行上面的命令可以得到如下的结果</span></span><br><span class="line">Sr No</span><br><span class="line">    Name</span><br><span class="line">        Sub</span><br><span class="line">            Marks</span><br></pre></td></tr></table></figure><h5 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符%"></a>格式说明符%</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>%c</td><td>输出<strong>单个字符</strong>。如果参数是个数值，那么数值也会被当作字符然后输出。如果参数是字符串，那么只会输出第一个字符。</td></tr><tr><td>%d 与 %i</td><td>输出十进制数的整数部分。</td></tr><tr><td>%f</td><td>输出浮点数，以 [-]ddd.dddddd 的格式</td></tr><tr><td>%e 与 %E</td><td>输出浮点数，以 [-]d.dddddde[+-]dd 的格式。区别就是输出<code>8.066000e+01</code>与<code>8.066000E+01</code>的<code>e</code>的大小写</td></tr><tr><td>%g 与 %G</td><td>输出浮点数，使用 %e 或 %E 转换。但它们会<strong>删除那些对数值无影响的 0</strong>。（推荐）</td></tr><tr><td>%o</td><td>无符号八进制输出。</td></tr><tr><td>%u</td><td>无符号十进制数输出。</td></tr><tr><td>%x 与 %X</td><td>输出十六进制无符号数。%X 中使用大写字母，%x 使用小写字母。</td></tr><tr><td>%%</td><td>输出百分号（%），不需要输入参数。</td></tr></tbody></table><h5 id="格式说明符-的可选参数"><a href="#格式说明符-的可选参数" class="headerlink" title="格式说明符% 的可选参数"></a>格式说明符% 的可选参数</h5><p><strong>列宽</strong></p><p><code>%8d</code>表示用空格填充占8列，如果紧接在 % 后是以0开头的数字<code>%08d</code>，表示输出应该使用0填充而不是空格字符。</p><p><strong>对齐</strong></p><p>默认是右边对齐，在 % 之后数字之前使用减号（-）即可指定输出左对齐</p><p><strong>符号前缀</strong></p><p>但是<code>+</code>不是表示右对齐，是表示输出数值的符号，正号也输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; num = -10; printf "Num = %-+10d\n", num &#125;'</span> | cat -vte</span><br></pre></td></tr></table></figure><p><strong>哈希<code>#</code></strong></p><p>将<code>#</code>放在<code>%</code>后， 可以为 %o 的结果前添加0，为 %x 或 %X 输出的结果前添加 0x 或 0X （结果不为零时），为 %e，%E，%f，%F添加小数点；对于 %g 或 %G，使用哈希可以保留尾部的零</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123; printf &quot;Octal representation = %#o\nHexadecimal representaion = %#X\n&quot;, 10, 10&#125;&apos;</span><br></pre></td></tr></table></figure><h4 id="重定向、管道、双向管道"><a href="#重定向、管道、双向管道" class="headerlink" title="重定向、管道、双向管道"></a>重定向、管道、双向管道</h4><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>AWK 重定向操作符重定向数据到文件 message.txt 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "Hello, World !!!" &gt; "/tmp/message.txt" &#125;'</span></span><br><span class="line">cat /tmp/message.txt</span><br></pre></td></tr></table></figure><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>下面的例子中我们使用 <code>tr</code> 命令将小写字母转换成大写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "hello, world !!!" | "tr [a-z] [A-Z]" &#125;'</span></span><br><span class="line"><span class="comment"># HELLO, WORLD !!！</span></span><br></pre></td></tr></table></figure><h5 id="双向通信通道"><a href="#双向通信通道" class="headerlink" title="双向通信通道"></a>双向通信通道</h5><p>（TODO 还不知道怎么用）</p><p>AWK 允许使用 <code>|&amp;</code> 与一个外部进程通信，并且可以双向通信。下面的例子中，使用 <code>tr</code> 命令将字母转换为大写字母。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    cmd = <span class="string">"tr [a-z] [A-Z]"</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"hello, world !!!"</span> |&amp; cmd</span><br><span class="line">    close(cmd, <span class="string">"to"</span>)</span><br><span class="line">    cmd |&amp; getline out</span><br><span class="line">    <span class="built_in">print</span> out;</span><br><span class="line">    close(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的命令可以得到如下的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELLO, WORLD !!!</span><br></pre></td></tr></table></figure><p>脚本的内容看上去很神秘吗？让我们一步一步揭开它神秘的面纱。</p><ul><li>第一条语句 cmd = “tr [a-z][A-Z]” 在AWK 中建立了一个双向的通信通道。</li><li>第二条语句 print 为 tr 命令提供输入。&amp;| 表示双向通信。</li><li>第三条语句 close(cmd, “to”) 执行后关闭 to 进程。</li><li>第四条语句 cmd |&amp; getline out 使用 getline 函数将输出存储到 out 变量中。</li><li>接下来的输出语句打印输出的内容，最后 close 函数关闭 cmd。</li></ul><h4 id="保存到不同文件中"><a href="#保存到不同文件中" class="headerlink" title="保存到不同文件中"></a>保存到不同文件中</h4><p>跳过表头，第6列是文件名，因此这样就可以将每一行分别保存在不同的文件中，进行了分类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'NR!=1&#123;print $4,$5 &gt; $6&#125;' netstat.txt</span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td></td><td><strong>标准参数</strong></td></tr><tr><td>-F fs</td><td>fs是分隔符，默认是空白符（空格、制表符），fs可以是字符串或正则表达式。<br>如<code>-F:</code> 表示冒号为分隔符；<br>如果想指定空格为分隔符，请看下面例子。</td></tr><tr><td>-v var=value</td><td>赋值一个用户定义变量，将外部变量传递给awk</td></tr><tr><td>-f scripfile</td><td>从脚本文件中读取awk命令</td></tr><tr><td>-p[file]</td><td>用于格式化 awk 脚本文件。默认输出文件是 <strong>awkprof.out</strong>。</td></tr><tr><td></td><td><strong>gawk 参数</strong></td></tr><tr><td>-mf N</td><td>指定要处理的数据文件中的最大字段数</td></tr><tr><td>-mr N</td><td>指定数据文件中的最大数据行数</td></tr></tbody></table><blockquote><p>  在BEGIN语句块中可以用OFS=”delimiter”设置输出字段分隔符。<code>awk &#39;BEGIN { FS=&quot;:&quot; }{ print }</code></p></blockquote><p><strong>指定空格为分隔符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc d"</span>|awk -F<span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span>   <span class="comment"># 无效，还是会将\t进行分割</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc d"</span>|awk -F<span class="string">'[ ]'</span> <span class="string">'&#123;print $2&#125;'</span> <span class="comment"># 推荐</span></span><br></pre></td></tr></table></figure><p><strong>同时使用多个分隔符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 使用多个分隔符, 遇到";"或者","就进行分割，因此下面的例子会得到 5 列</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1;2,3;4,5"</span>|awk -F <span class="string">'[;,]'</span> <span class="string">'&#123;print $1,$2,$3,$4,$5&#125;'</span></span><br><span class="line"><span class="comment"># 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>或者使用<code>|</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F&quot;\t|,&quot; &apos;&apos; file   # 以\t 或者逗号分隔</span><br></pre></td></tr></table></figure><p>参考：<a href="https://ipcmen.com/awk" target="_blank" rel="noopener">https://ipcmen.com/awk</a></p><p><strong>格式化脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk --profile <span class="string">'BEGIN&#123;printf"---|Header|--\n"&#125; &#123;print&#125; END&#123;printf"---|Footer|---\n"&#125;'</span> marks.txt &gt; /dev/null </span><br><span class="line">[jerry]$ cat awkprof.out</span><br></pre></td></tr></table></figure><p>执行上面的命令可以得到如下的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># gawk profile, created Sun Oct 26 19:50:48 2014</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BEGIN block(s)</span></span><br><span class="line"></span><br><span class="line">    BEGIN &#123;</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"---|Header|--\n"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rule(s)</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># END block(s)</span></span><br><span class="line"></span><br><span class="line">    END &#123;</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"---|Footer|---\n"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="模式-pattern-种类"><a href="#模式-pattern-种类" class="headerlink" title="模式(pattern)种类"></a>模式(pattern)种类</h3><p><strong>BEGIN { 语句 }</strong></p><p>在读取任何输入前执行一次语句</p><p><strong>END { 语句 }</strong></p><p>读取所有输入之后执行一次语句</p><p><strong>表达式 { 语句 }</strong></p><p>对于表达式为真（即，非零或非空）的行，执行语句</p><p><strong>/正则表达式/ { 语句 }</strong></p><p>如果输入行包含字符串与正则表达式相匹配，则执行语句</p><p><strong>组合模式 { 语句 }</strong></p><p>一个 组合模式 通过与（<code>&amp;&amp;</code>），或（<code>||</code>），非（<code>!</code>），以及括弧来组合多个表达式；对于组合模式为真的每个输入行，执行 语句</p><p><strong>模式1，模式2 { 语句 }</strong></p><p>范围模式(range pattern)匹配从与模式1相匹配的行到与模式2相匹配的行（包含该行）之间的所有行，对于这些输入行，执行语句。</p><blockquote><p>  BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。BEGIN和END是仅有的必须搭配动作的模式。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;NR &lt; 5&apos;        # 行号小于5的行</span><br><span class="line">awk &apos;NR==1,NR==4&apos;   # 行号在1到5之间的行 </span><br><span class="line">awk &apos;/linux/&apos;       # 包含模式为linux的行（可以用正则表达式来指定模式）</span><br><span class="line">awk &apos;!/linux/&apos;      # 不包含模式为linux的行</span><br></pre></td></tr></table></figure><h3 id="选择、过滤"><a href="#选择、过滤" class="headerlink" title="选择、过滤"></a>选择、过滤</h3><p><strong>数值判断</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$2</span> * <span class="variable">$3</span> &gt; 50 &#123; <span class="built_in">printf</span>(<span class="string">"$%.2f for %s\n"</span>, <span class="variable">$2</span> * <span class="variable">$3</span>, <span class="variable">$1</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>文本内容选择，支持正则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">1 == <span class="string">"Susie"</span> &#123; <span class="built_in">print</span> &#125;  <span class="comment"># 比较字段是否等于字符串时，要使用双引号包起来</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">1~/正则内容/ &#123; <span class="built_in">print</span> <span class="variable">$1</span>&#125; <span class="comment"># 对某一列进行正则</span></span></span><br><span class="line">/正则内容/ &#123; print $1&#125;  # 对整行进行匹配</span><br><span class="line">/条件1/,/条件2/ &#123; print $1&#125;  # 对整行进行多条件匹配</span><br></pre></td></tr></table></figure><p>匹配中文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$1 ~/[一-龥]/'  匹配中文</span><br><span class="line">awk '$1 ~/[\u4e00-\u9fa5]/'  这样反而不行，要不unicode转成对应的中文</span><br></pre></td></tr></table></figure><p><strong>多条件组合</strong></p><p>逻辑操作符与 &amp;&amp; ， 或 || ， 以及非 ! 对模式进行组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$2 &gt;= 4 || $3 &gt;= 20 &#123;print&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>!</code>是在括号前的，第1种其实与第2种一模一样，正确的是第3种</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline )&#123;dict[c]=1&#125;&#125; ! $2 in dict&#123;print&#125;' some.txt |wc</span><br><span class="line">      0       0       0</span><br><span class="line">      </span><br><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline c)&#123;dict[c]=1&#125;&#125; (! $2 in dict)&#123;print&#125;' some.txt |wc</span><br><span class="line">      0       0       0</span><br><span class="line">      </span><br><span class="line">awk -F"\t" 'BEGIN&#123;while("cat file"|getline )&#123;dict[c]=1&#125;&#125; !($2in dict)&#123;print&#125;' some.txt |wc</span><br><span class="line">1296838 14273901 226060062</span><br></pre></td></tr></table></figure><h3 id="多条命令"><a href="#多条命令" class="headerlink" title="多条命令"></a>多条命令</h3><p>要在命令行上的程序脚本中使用多条命令，</p><ul><li>只要在命令之间放个<strong>分号</strong>即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"My name is Rich"</span> | gawk <span class="string">'&#123;$4="Christine"; print $0&#125;'</span> My name is Christine</span><br></pre></td></tr></table></figure><ul><li>也可以用次提示符一次一行地输入程序脚本命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; \</span></span><br><span class="line"><span class="string">&gt; $4="Christine"</span></span><br><span class="line"><span class="string">&gt; print $0&#125;'</span> </span><br><span class="line">My name is Rich </span><br><span class="line"></span><br><span class="line">$ My name is Christine</span><br></pre></td></tr></table></figure><h3 id="将命令保存在文件中"><a href="#将命令保存在文件中" class="headerlink" title="将命令保存在文件中"></a>将命令保存在文件中</h3><p>当引号内的程序过长时，可以单独保存在文件中，假设存在文件 progfile ，输入命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f progfilefile</span><br></pre></td></tr></table></figure><p>文件中不用引号包起来，但是中括号还是需要的，多条指令在同一行中用分号分分隔，或者以多行形式书写</p><h4 id="读取命令的输出"><a href="#读取命令的输出" class="headerlink" title="读取命令的输出"></a>读取命令的输出</h4><p>awk可以调用命令并读取输出。把命令放入引号中，然后利用管道将命令输出传入getline：<code>&quot;command&quot; | getline output ;</code></p><p>下面的代码从<code>/etc/passwd</code>文件中读入一行，然后显示出用户登录名及其主目录。在BEGIN语 句块中将字段分隔符设置为:，在主语句块中调用了<code>grep</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; print $1,$6 &#125;'</span> </span><br><span class="line"><span class="comment"># root /root</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><table><thead><tr><th style="text-align:left">变量</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left"></td><td><strong>标准 AWK 变量</strong></td></tr><tr><td style="text-align:left">ARGC</td><td>命令行提供的参数的个数</td></tr><tr><td style="text-align:left">ARGV</td><td>存储命令行输入参数的数组。数组的有效索引是从 0 到 ARGC-1。</td></tr><tr><td style="text-align:left">ARGIND</td><td>命令行中当前文件的位置(从0开始算)</td></tr><tr><td style="text-align:left">CONVFMT</td><td>数据转换为字符串的格式，其默认值为 %.6g</td></tr><tr><td style="text-align:left">OFMT</td><td>数值输出的格式，它的默认值为 %.6g。</td></tr><tr><td style="text-align:left">OFS</td><td>输出域之间的分割符，其默认为空格。</td></tr><tr><td style="text-align:left">ORS</td><td>输出记录（行）之间的分割符，其默认值是换行符。</td></tr><tr><td style="text-align:left">RS</td><td>输入记录的分割符，其默认值为换行符。</td></tr><tr><td style="text-align:left">NR</td><td>表示记录编号，当awk将行作为记录时，该变量相当于当前行号。全局行数（第二个文件的第一行接着第一个文件尾行数顺序计数）</td></tr><tr><td style="text-align:left">FNR</td><td>当前文件自身的行数（不考虑前几个输入文件的自身行数及总数。NR  的值依次为：1，2……40，41，42……90。FNR的值依次为：1，2……40， 1， 2……50</td></tr><tr><td style="text-align:left">NF</td><td>表示字段数量，在处理当前记录时，相当于字段数量。默认的字段分隔符是空格。</td></tr><tr><td style="text-align:left">FS</td><td>定义分隔符，可以用在 BEGIN 语句块中，这样你就不用依靠脚本用户在命令行选项中定义字段分隔符了。</td></tr><tr><td style="text-align:left">$0</td><td>该变量包含当前记录的文本内容。</td></tr><tr><td style="text-align:left">$n</td><td>该变量包含第n个字段的文本内容。</td></tr><tr><td style="text-align:left">ENVIRON</td><td>与环境变量相关的关联数组变量，<code>awk &#39;BEGIN { print ENVIRON[&quot;USER&quot;] }&#39;</code></td></tr><tr><td style="text-align:left">FILENAME</td><td>此变量表示当前文件名称</td></tr><tr><td style="text-align:left">RLENGTH</td><td>表示 match 函数匹配的字符串长度</td></tr><tr><td style="text-align:left">RSTART</td><td>表示由 match 函数匹配的字符串的第一个字符的位置</td></tr><tr><td style="text-align:left"></td><td><strong>GNU AWK 特定的变量</strong></td></tr><tr><td style="text-align:left">IGNORECASE</td><td>GAWK将变得大小写不敏感，<code>awk &#39;BEGIN{IGNORECASE=1} /amit/&#39; marks.txt</code></td></tr></tbody></table><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><p>变量不用初始化即可使用</p><h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><p>用作数字的awk<strong>变量的默认初始值为0</strong>，所以我们不需要初始化 emp 。</p><p>这个程序使用一个变量 emp 来统计工作超过15个小时的员工的数目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$3 &gt; 15 &#123; emp = emp + 1 &#125;</span><br><span class="line">END     &#123; print emp, &quot;employees worked more than 15 hours&quot; &#125;</span><br></pre></td></tr></table></figure><p>对于第三个字段超过15的每行， emp 的前一个值加1。该程序输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 employees worked more than 15 hours</span><br></pre></td></tr></table></figure><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>awk变量可以保存数字也<strong>可以保存字符串</strong>。这个程序会找出时薪最高的员工：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 如果$2大于最大值，则更新为当前行的信息</span><br><span class="line">$2 &gt; maxrate &#123; maxrate = $2; maxemp = $1 &#125;</span><br><span class="line">END &#123; print &quot;highest hourly rate:&quot;, maxrate, &quot;for&quot;, maxemp &#125;</span><br></pre></td></tr></table></figure><h4 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h4><p>awk 中其实并不存在数组类型，所谓的关联数组是一种使用字符串作为索引的字典。因此并不是 <code>[&quot;value1&quot;, &quot;value2&quot;]</code>这样，而是<code>{0: &quot;value1&quot;, 1: &quot;value2&quot;}</code>。在awk中数组之间是无序的，一个数组的key值是数值，例如1，2，3，并不代表该数组元素在数组中的出现的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123;nam[$1]=$5&#125; END &#123;for （i in nam）  &#123;print i,nam[i]&#125;&#125;'</span> /etc/passwd </span><br><span class="line"><span class="comment"># root root </span></span><br><span class="line"><span class="comment"># ftp FTP User </span></span><br><span class="line"><span class="comment"># userj Joe User</span></span><br></pre></td></tr></table></figure><p><strong>awk没有not in语法</strong></p><p>请使用下面的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!($1 in dict) # 通用情况</span><br><span class="line">!dict[$1]     # 适用于判断在不在字典里进行过滤的情况</span><br></pre></td></tr></table></figure><p><a href="http://blog.chinaunix.net/uid-10540984-id-323936.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-10540984-id-323936.html</a></p><p><strong>判断一个元素是否在数组中</strong></p><p>awk 支持<code>in</code>操作，但是<code>in</code> 判断的是键 <code>key</code>，awk 自身是没有判断是否在值<code>value</code>中的方法。</p><p>因此为了实现判断是否在数组中，要将<code>value</code>转为<code>key</code>，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    split(<span class="string">"value1 value2"</span>, valuesAsValues)</span><br><span class="line">    <span class="comment"># valuesAsValues = &#123;0: "value1", 1: "value2"&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> valuesAsValues) valuesAsKeys[valuesAsValues[i]] = <span class="string">""</span></span><br><span class="line">    <span class="comment"># valuesAsKeys = &#123;"value1": "", "value2": ""&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now you can use `in`</span></span><br><span class="line">(<span class="variable">$1</span> <span class="keyword">in</span> valuesAsKeys) &#123;<span class="built_in">print</span>&#125;</span><br></pre></td></tr></table></figure><p>一行的写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"A:B:C:D:E:F"</span> | tr <span class="string">':'</span> <span class="string">'\n'</span> | \</span><br><span class="line">awk <span class="string">'BEGIN&#123; split("A D F", parts); for (i in parts) dict[parts[i]]=""&#125;  $1 in dict'</span></span><br></pre></td></tr></table></figure><p><strong>遍历数组</strong></p><p>awk支持列表形式的<strong><code>for</code>循环</strong>，是对 key 进行遍历，然后显示出数组的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> array) &#123; <span class="built_in">print</span> array[k]; &#125;</span><br></pre></td></tr></table></figure><p><strong>数组排序</strong></p><p>使用 asort 完成数组元素的排序，或者使用 asorti 实现数组索引的排序等等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits[<span class="string">"mango"</span>]=<span class="string">"yellow"</span>;</span><br><span class="line">fruits[mango]=<span class="string">"yellow"</span>; <span class="comment"># 这种写法也可以</span></span><br><span class="line">value必须加双引号</span><br><span class="line"></span><br><span class="line">delete array_name[index]</span><br></pre></td></tr></table></figure><p><strong>删除数组元素</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete arr[key]</span><br></pre></td></tr></table></figure><p>例子：<strong>按行逆序打印</strong></p><p>第一个动作将输入行存为数组 line 的连续元素；即第一行放在 line[1] ，第二行放在 line[2] , 依次继续。 END 动作使用一个 while 语句从后往前打印数组中的输入行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 反转 - 按行逆序打印输入</span><br><span class="line">    &#123; line[NR] = $0 &#125;  # 记下每个输入行</span><br><span class="line">END &#123; i = NR           # 逆序打印</span><br><span class="line">      while (i &gt; 0) &#123;</span><br><span class="line">        print line[i]</span><br><span class="line">        i = i - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以 emp.data 为输入，输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Susie    4.25   18</span><br><span class="line">Mary     5.50   22</span><br><span class="line">Mark     5.00   20</span><br><span class="line">Kathy    4.00   10</span><br><span class="line">Dan      3.75   0</span><br><span class="line">Beth     4.00   0</span><br></pre></td></tr></table></figure><h4 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h4><p>方法一（推荐）：</p><p>借助选项<code>-v</code>，我们可以将一个外部值（并非来自stdin）传递给awk：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VAR=10000  </span><br><span class="line">echo | awk -v VARIABLE=$VAR &apos;&#123; print VARIABLE &#125;&apos;  [filename]</span><br><span class="line"># 10000</span><br></pre></td></tr></table></figure><blockquote><p>  gawk 程序在引用变量值时并未像shell脚本一样使用美元符。</p></blockquote><p><strong>可以不用加引号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk -v name=<span class="string">"Jerry"</span> <span class="string">'&#123;print name&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> | awk -v name=Jerry <span class="string">'&#123;print name&#125;'</span>    <span class="comment"># 等价   </span></span><br><span class="line"><span class="built_in">echo</span> | awk -v path=<span class="variable">$PATH</span> <span class="string">'&#123;print path&#125;'</span>    <span class="comment"># 如果是环境变量，需要添加$</span></span><br></pre></td></tr></table></figure><p>可以将<strong>多个</strong>外部变量传递给awk。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1=<span class="string">"Variable1"</span></span><br><span class="line">var2=<span class="string">"Variable2"</span></span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line"><span class="comment"># Variable1 Variable2</span></span><br></pre></td></tr></table></figure><p>在上面的方法中，变量以键值对的形式给出，使用空格分隔（<code>v1=$var1 v2=$var2</code>），作为awk 的命令行参数紧随在<code>BEGIN</code>、<code>{}</code>和<code>END</code>语句块之后。</p><p>方法二：用引号括起来直接用，是<code>&quot;&#39;$var&#39;&quot;</code>的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;abc&quot;</span><br><span class="line">awk &apos;BEGIN&#123;print &quot;&apos;$var&apos;&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>方法三：方法二类似，但使用<code>&quot;&#39;&quot;</code>把shell变量包起来，即<code>&quot;&#39;&quot;$var&quot;&#39;&quot;</code></p><p>如果变量的<strong>值中包含空格</strong>，为了shell不把空格作为分隔符，则应使用方法二。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;this a test&quot;</span><br><span class="line">awk &apos;BEGIN&#123;print &quot;&apos;&quot;$var&quot;&apos;&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>方法四：export变量，然后在awk中使用<code>ENVIRON[&quot;var&quot;]</code>形式(大写)获取环境变量的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;this a test&quot;; export var;</span><br><span class="line">awk &apos;BEGIN&#123;print ENVIRON[&quot;var&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><a href="https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html" target="_blank" rel="noopener">https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html</a></p><p>基本与C语言的操作相同</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">= += -= *= /= %= ^= **=</td><td style="text-align:left">赋值</td></tr><tr><td style="text-align:left">?:</td><td style="text-align:left">C条件表达式</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">\</td><td></td><td>逻辑或</td></tr><tr><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">逻辑与</td></tr><tr><td style="text-align:left">~ ~!</td><td style="text-align:left">匹配正则表达式和不匹配正则表达式</td></tr><tr><td style="text-align:left">&lt; &lt;= &gt; &gt;= != ==</td><td style="text-align:left">关系运算符</td></tr><tr><td style="text-align:left">空格</td><td style="text-align:left">拼接字符串</td></tr><tr><td style="text-align:left">+ –</td><td style="text-align:left">加，减</td></tr><tr><td style="text-align:left">* / %</td><td style="text-align:left">乘，除与求余</td></tr><tr><td style="text-align:left">+ – !</td><td style="text-align:left">一元加，减和逻辑非</td></tr><tr><td style="text-align:left">^ ***</td><td style="text-align:left">求幂</td></tr><tr><td style="text-align:left">++ —</td><td style="text-align:left">增加或减少，作为前缀或后缀</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">字段引用</td></tr><tr><td style="text-align:left">in</td><td style="text-align:left">字典成员</td></tr></tbody></table><p><code>+=</code>, 等于<code>==</code>，不等于<code>!=</code></p><p>逻辑与运算符为 <code>&amp;&amp;</code>。逻辑或运算符为 <code>||</code>。逻辑非 <code>!</code> 。</p><p>逻辑非将 expr1 的真值取反。如果 expr1 为真，则返回 0。否则返回 1。下面的示例判断字符串是否为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; name = &quot;&quot;; if (! length(name)) print &quot;name is empty string.&quot; &#125;&apos;</span><br></pre></td></tr></table></figure><p>三元运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; a = 10; b = 20; (a &gt; b) ? max = a : max = b; print &quot;Max =&quot;, max&#125;&apos;</span><br></pre></td></tr></table></figure><p>字符串连接操作符</p><p>空格 (space) 操作符可以完成两个字符串的连接操作。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; str1=&quot;Hello, &quot;; str2=&quot;World&quot;; str3 = str1 str2; print str3 &#125;&apos;</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure><p>数组成员操作符</p><p>数组成员操作符为 in。该操作符用于访问数组元素 。下面的示例用于此操作符输出数组中所有元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; arr[0] = 1; arr[1] = 2; arr[2] = 3; for (i in arr) printf &quot;arr[%d] = %d\n&quot;, i, arr[i] &#125;&apos;</span><br><span class="line"></span><br><span class="line">arr[0] = 1</span><br><span class="line">arr[1] = 2</span><br><span class="line">arr[2] = 3</span><br></pre></td></tr></table></figure><p>awk中并没有数组对象，其实是字典，因此<code>i</code> 遍历的是arr的key，而不是value</p><p>匹配（Match）</p><p>匹配运算符为 ~。不匹配操作符为 !~。 它用于搜索包含匹配模式字符串的域。下面的示例中将输出包括 9 的行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;$0 ~ 9&apos; marks.txt    # 这种写法只对数字有效，如果是字母，就会失效</span><br><span class="line">[jerry]$ awk &apos;$0 ~ /9/&apos; marks.txt  # 推荐正则写法</span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><blockquote><p>  仅可以在动作中使用</p></blockquote><p>一定要加<code>{}</code>与其他语言一样的用法，括号内的为同一语句块</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">    action-1</span><br><span class="line">    action-1</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    action-n</span><br><span class="line">&#125;</span><br><span class="line">else if (a == 30)</span><br><span class="line">  print &quot;a = 30&quot;;</span><br><span class="line">else</span><br><span class="line">  print &quot;a = 30&quot;;</span><br></pre></td></tr></table></figure><p>例子：将每隔几行就拼接在一起输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"cat\nbat\nfun\nfin\nfan\nend"</span> | awk <span class="string">'&#123;str=str $0&#125;;NR %2==0&#123;print str;str=""&#125;'</span></span><br></pre></td></tr></table></figure><p>if-else 语句中，if 后的条件会被计算。如果为真，执行第一个 print 语句。否则，执行第二个 print 语句。注意我们可以使用一个逗号将一个长语句截断为多行来书写。</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>一个 while 语句有一个条件和一个执行体。条件为真时执行体中的语句会被重复执行。这个程序使用公式 value=amount(1+rate)yearsvalue=amount(1+rate)years</p><p>来演示以特定的利率投资一定量的钱，其数值是如何随着年数增长的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># interest1 - 计算复利</span><br><span class="line">#   输入: 钱数    利率    年数</span><br><span class="line">#   输出: 复利值</span><br><span class="line"></span><br><span class="line">&#123;   i = 1</span><br><span class="line">    while (i &lt;= $3) &#123;</span><br><span class="line">        printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">        i = i + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件是 while 后括弧包围的表达式；循环体是条件后大括号包围的两个表达式。 printf 规格字符串中的 \t 代表制表符； ^ 是指数操作符。从 # 开始到行尾的文本是注释，会被awk忽略，但能帮助程序的读者理解程序做的事情。</p><p>你可以为这程序输入三个一组的数字，看看不一样的钱数、利率、以及年数会产生什么。例如，如下事务演示了1000美元，利率为6%与12%，5年的复利分别是如何增长的：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk -f interest1</span><br><span class="line">1000 .06 5</span><br><span class="line">        1060.00</span><br><span class="line">        1123.60</span><br><span class="line">        1191.02</span><br><span class="line">        1262.48</span><br><span class="line">        1338.23</span><br><span class="line">1000 .12 5</span><br><span class="line">        1120.00</span><br><span class="line">        1254.40</span><br><span class="line">        1404.93</span><br><span class="line">        1573.52</span><br><span class="line">        1762.34</span><br></pre></td></tr></table></figure><h4 id="do-while"><a href="#do-while" class="headerlink" title="do -while"></a>do -while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;i = 1; do &#123; print i; ++i &#125; while (i &lt; 6) &#125;&apos;</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p> for ，将大多数循环都包含的初始化、测试、以及自增压缩成一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; for (i = 1; i &lt;= $3; ++i)</span><br><span class="line">    printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 i = 1 只执行一次。接下来，测试条件 i &lt;= $3 ；如果为真，则执行循环体的 printf 语句。循环体执行结束后执行自增 i = i + 1 ，接着由另一次条件测试开始下一个循环迭代。代码更加紧凑，并且由于循环体仅是一条语句，所以不需要大括号来包围它。</p><h4 id="跳出循环（break、continue、exit、next）"><a href="#跳出循环（break、continue、exit、next）" class="headerlink" title="跳出循环（break、continue、exit、next）"></a>跳出循环（break、continue、exit、next）</h4><p>break、continue、exit都支持</p><p>next </p><p>等价于<code>continue</code>,next 停止处理当前记录，并且进入到下一条记录的处理过程。下面的例子中，当模式串匹配成功后程序并不执行任何操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;if ($0 ~/Shyam/) next; print $0&#125;'</span> marks.txt</span><br></pre></td></tr></table></figure><p>nextfile</p><p>nextfile 停止处理当前文件，从下一个文件第一个记录开始处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; if ($0 ~ /file1:str2/) nextfile; print $0 &#125;'</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><a href="https://man.linuxde.net/awk" target="_blank" rel="noopener"><a href="https://man.linuxde.net/awk" target="_blank" rel="noopener">更多的函数说明</a></a></p><h4 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h4><h5 id="match"><a href="#match" class="headerlink" title="match"></a>match</h5><p>返回正则表达式在字符串 str 中第一个最长匹配的位置。如果能够找到，返回非0值；否则，返回0。match()有两个<strong>相关的特殊变量</strong>，分别是<code>RSTART</code>和<code>RLENGTH</code>。变量<code>RSTART</code>包含了匹配内容的起始位置，而变量<code>RLENGTH</code>包含了匹配内容的长度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "One Two Three"</span></span><br><span class="line"><span class="string">    subs = "Two"</span></span><br><span class="line"><span class="string">    ret = match(str, subs)</span></span><br><span class="line"><span class="string">    printf "Substring \"%s\" found at %d location.\n", subs, ret</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Substring "Two" found at 5 location.</span></span><br></pre></td></tr></table></figure><h5 id="asort-数组排序"><a href="#asort-数组排序" class="headerlink" title="asort 数组排序"></a>asort 数组排序</h5><p>asort(arr,[, d [,how] ])</p><p>asort 函数使用 GAWK 值比较的一般规则排序 arr 中的value，然后用以 1 开始的有序整数替换排序内容的索引。</p><p>大写的会排在前面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;</span><br><span class="line">    arr[0] = &quot;Three&quot;</span><br><span class="line">    arr[1] = &quot;One&quot;</span><br><span class="line">    arr[2] = &quot;two&quot;</span><br><span class="line"></span><br><span class="line">    print &quot;Array elements before sorting:&quot;</span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asort(arr)</span><br><span class="line"></span><br><span class="line">    print &quot;Array elements after sorting:&quot;</span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><h5 id="asorti-数组排序"><a href="#asorti-数组排序" class="headerlink" title="asorti 数组排序"></a>asorti 数组排序</h5><p>asorti(arr,[, d [,how] ])</p><p>asorti 函数的行为与 asort 函数的行为很相似，二者的差别在于 aosrt 对数组的value排序，而 asorti 对数组的index排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    arr["Two"] = 1</span></span><br><span class="line"><span class="string">    arr["One"] = 2</span></span><br><span class="line"><span class="string">    arr["Three"] = 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    asorti(arr)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    print "Array indices after sorting:"</span></span><br><span class="line"><span class="string">    for (i in arr) &#123;</span></span><br><span class="line"><span class="string">        print arr[i]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h5 id="sub、gsub-替换"><a href="#sub、gsub-替换" class="headerlink" title="sub、gsub 替换"></a>sub、gsub 替换</h5><p>sub</p><p>将正则表达式regex匹配到的第一处内容<strong>替换</strong>成replacment_str。</p><p>gsub(regx,sub, string)</p><p>gsub 是全局替换( global substitution )的缩写。它将出现的子串（sub）替换为 regx。第三个参数 string 是可选的，<strong>默认值为 $0</strong>，表示在整个输入记录中搜索子串。进行一次替换的有sub(regex,sub,string)函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "Hello, World"</span></span><br><span class="line"><span class="string">    print "String before replacement = " str</span></span><br><span class="line"><span class="string">    gsub("World", "Jerry", str)</span></span><br><span class="line"><span class="string">    print "String after replacement = " str</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h5 id="index-判断子串包含"><a href="#index-判断子串包含" class="headerlink" title="index 判断子串包含"></a>index 判断子串包含</h5><p>index(str,sub)</p><p>index 函数用于检测字符串 sub 是否是 str 的子串。如果 sub 是 str 的子串，则返回子串 sub 在字符串 str 的开始位置；若不是其子串，则返回 0。str 的字符位置索引从 1 开始计数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "One Two Three"</span></span><br><span class="line"><span class="string">    subs = "Two"</span></span><br><span class="line"><span class="string">    ret = index(str, subs)</span></span><br><span class="line"><span class="string">    printf "Substring \"%s\" found at %d location.\n", subs, ret</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h5 id="split-分割字符串"><a href="#split-分割字符串" class="headerlink" title="split 分割字符串"></a>split 分割字符串</h5><p><code>split(str, arr, regex)</code></p><p>split 函数使用正则表达式 regex 分割字符串 str。分割后的所有结果存储在数组 arr 中。如果没有指定 regex 则使用 FS 切分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123;</span><br><span class="line">    str = &quot;One,Two,Three,Four&quot;</span><br><span class="line"></span><br><span class="line">    split(str, arr, &quot;,&quot;)</span><br><span class="line"></span><br><span class="line">    print &quot;Array contains following values&quot;</span><br><span class="line"></span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><h5 id="substr-字符串截取"><a href="#substr-字符串截取" class="headerlink" title="substr 字符串截取"></a>substr 字符串截取</h5><p><code>substr(str, start, length)</code></p><p>substr 函数返回 str 字符串中从第 start 个字符开始长度为 length 的子串。如果没有指定 length 的值，返回 str 从第 start 个字符开始的后缀子串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "Hello, World !!!"</span></span><br><span class="line"><span class="string">    subs = substr(str, 1, 5)</span></span><br><span class="line"><span class="string">    print "Substring = " subs</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Substring = Hello</span></span><br></pre></td></tr></table></figure><h5 id="strtonum字符串转数字"><a href="#strtonum字符串转数字" class="headerlink" title="strtonum字符串转数字"></a>strtonum字符串转数字</h5><p>strtonum(str)</p><p>strtonum 将字符串 str 转换为数值。 如果字符串以 0 开始，则将其当作八进制数；如果字符串以 0x 或 0X 开始，则将其当作十六进制数；否则，将其当作浮点数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    print "Decimal num = " strtonum("123")</span></span><br><span class="line"><span class="string">    print "Octal num = " strtonum("0123")</span></span><br><span class="line"><span class="string">    print "Hexadecimal num = " strtonum("0x123")</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line">Decimal num = 123</span><br><span class="line">Octal num = 83</span><br><span class="line">Hexadecimal num = 291</span><br></pre></td></tr></table></figure><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><p><code>tolower(str)</code>、<code>toupper(str)</code></p><p>将字符串 str 进行大小写字母转换，然后返回。注意，字符串 str 本身不被改变。</p><h4 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h4><p>getline：得到行，但是注意，<strong>得到的并不是当前行，而是当前行的下一行</strong>。原因如下：</p><p>从整体上来说，应这么理解它的用法：</p><ul><li><code>getline var</code> 读取一行内容给 <code>var</code>，没有变量时等价于 <code>getline $0</code></li><li>当其左右无重定向符 | 或 &lt; 时，getline作用于当前文件，读入当前文件的一行给其后跟的变量  <code>var</code> 或<code>$0</code>（无变量时）；由于<code>awk</code>在处理<code>getline</code>之前已经读入了一行，所以<code>getline</code>得的是下一行（第二行开始）。</li><li><p>当其左右有重定向符 | 或 &lt; 时，<code>getline</code>则作用于定向输入文件（用重定向符从另外一个文件中读取内容、管道符号获得UNIX命令的输出）赋值给<code>$0</code> 或<code>getline</code>后面的变量。由于该文件是刚打开，并没有被<code>awk</code>读入一行，那么<code>getline</code>返回的是该文件的第一行，而不是隔行，并赋值。</p><blockquote><p>  <code>getline</code> 会记住重定向的文件读取到哪一行了，并不会重复执行<code>getline var &lt; file</code>  重复读取文件，而是一次读取一行</p></blockquote></li><li><code>getline</code>执行后会更新<code>NF</code>，<code>NR</code>，<code>FNR</code>等这些内部变量。</li></ul><p>例子：</p><p>比较 <code>getline</code>后有无变量的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 显示奇数</span><br><span class="line">$ seq 10 | awk &apos;&#123;getline var;  print $0&#125;&apos;  # getline var 后，内部变量不变，因此$0仍然是第1行</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line"># 显示偶数</span><br><span class="line">$ seq 10 | awk &apos;&#123;getline;  print $0&#125;&apos;   # getline 等价于 getline $0 ，处理getline之前$0是第一行，因此$0变为第2行</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>同时读取2个文件，不用担心<code>getline &lt; &quot;b.txt&quot;</code>重复读取文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;&#123;printf &quot;%s &quot;, $0; getline &lt; &quot;b.txt&quot;; print $0&#125;&apos; a.txt </span><br><span class="line"># 记住 getline 等价于 getline $0 ，因此$0变成了 b 文件的内容</span><br><span class="line">1 6</span><br><span class="line">2 7</span><br><span class="line">3 8</span><br><span class="line">4 9</span><br><span class="line">5 10</span><br><span class="line"></span><br><span class="line"># 交替打印</span><br><span class="line">awk &apos;&#123;getline var &lt; &quot;a.txt&quot;;print var;print $0&#125;&apos; b.txt   # var 是文件a的行，$0是文件b的内容</span><br></pre></td></tr></table></figure><p>获取命令输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;&quot;date&quot; | getline; close(&quot;date&quot;); print $0&#125;&apos;</span><br><span class="line">Tue May 10 07:50:51 PDT 2016</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，使用管道符号时，<code>getline</code> 中这样是无法获取环境变量<code>FILE</code>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F&quot;\t&quot; &apos;BEGIN&#123;while(&quot;cat $FILE&quot;|getline c)&#123;dict[c]=1&#125;&#125; ($2 in dict)&#123;print&#125;&apos; file</span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> find_min(num1, num2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2)</span><br><span class="line">    <span class="built_in">return</span> num1</span><br><span class="line">  <span class="built_in">return</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Script execution starts here</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">  main(10, 20) <span class="comment"># 使用自定义函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h3><h4 id="匹配中文"><a href="#匹配中文" class="headerlink" title="匹配中文"></a>匹配中文</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$1 ~/[一-龥]/'  匹配中文</span><br><span class="line">awk '$1 ~/[\u4e00-\u9fa5]/'  这样反而不行，要不unicode转成对应的中文</span><br></pre></td></tr></table></figure><h4 id="awk对换行敏感"><a href="#awk对换行敏感" class="headerlink" title="awk对换行敏感"></a>awk对换行敏感</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123;while(&quot;cat company.txt&quot;|getline)&#123;dict[$1]=1&#125;&#125; &#123;if($3 in dict)print NR&#125;&apos; target.txt</span><br></pre></td></tr></table></figure><p>company.txt的文件是<code>\r\n</code>结尾时，无法匹配</p><h4 id="shell使用awk批量创建变量"><a href="#shell使用awk批量创建变量" class="headerlink" title="shell使用awk批量创建变量"></a>shell使用awk批量创建变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval $(awk &apos;BEGIN&#123;print &quot;v1=&apos;str1&apos;;v2=&apos;str2&apos;&quot;&#125;&apos;)   # 相当于执行了  v1=&apos;str1&apos;;v2=&apos;str2&apos;</span><br><span class="line">echo &quot;v1=$var1&quot;</span><br><span class="line">echo &quot;v2=$var2&quot;</span><br></pre></td></tr></table></figure></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> awk </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux shell编程</title>
      <link href="/2019/08/13/linux-shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/08/13/linux-shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="Shell-进程"><a href="#Shell-进程" class="headerlink" title="Shell 进程"></a>Shell 进程</h3><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><p>在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。 这个shell程序被称为子shell（child shell）。</p><p>在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中。这会对包括变量在内的一些东西造成影响。</p><h4 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h4><p>可以在一行内指定依次运行的一系列指令，通过<strong>命令列表</strong>来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> ; ls ; <span class="built_in">cd</span> /etc ; <span class="built_in">pwd</span> ; <span class="built_in">cd</span> ; <span class="built_in">pwd</span> ; ls</span><br></pre></td></tr></table></figure><p>命令列表要想成为<strong>进程列表</strong>，这些命令必须包含在括号里。括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令。</p><blockquote><p>  进程列表是一种命令分组（command grouping） 。另一种命令分组是将命令放入花括号中， 并在命令列表尾部加上分号（;）。语法为 <code>{ command; }</code>但是不会像进程列表那样创建出子shell。</p></blockquote><p>要想知道是否生成了子shell，得借助一个使用了环境变量的命令<code>echo $BASH_SUBSHELL</code>。如果该命令返回0，就表明没有子shell。如果返回 1或者其他更大的数字，就表明存在子shell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> ;  <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span></span><br><span class="line">/Users/admin</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">$ &#123; <span class="built_in">pwd</span> ; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>; &#125;</span><br><span class="line">/Users/admin</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">$ (<span class="built_in">pwd</span> ; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>)</span><br><span class="line">/Users/admin</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">$ ( <span class="built_in">pwd</span> ; (<span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>))</span><br><span class="line">/Users/admin</span><br><span class="line">2</span><br></pre></td></tr></table></figure><blockquote><p>  在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢处理速度。</p><p>  在交互式的CLI shell会话中，子shell同样存在问题。它并<strong>非真正的多进程</strong>处理，因为终端控制着子shell的I/O。</p><p>  在CLI中运用子shell的创造性方法之一就是将进程列表置入<strong>后台模式</strong>。你既可以在子shell中 进行繁重的处理工作，同时也不会让子shell的I/O受制于终端。</p></blockquote><h4 id="高效子进程"><a href="#高效子进程" class="headerlink" title="高效子进程"></a>高效子进程</h4><h5 id="后台模式"><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 3000&amp; </span><br><span class="line">[1] 2396</span><br></pre></td></tr></table></figure><p>在命令末尾加上字符<code>&amp;</code>，在shell CLI提示符返回之前，会出现一条信息，代表后台作业（background job）号（1）与后台作业的进程ID（2396）。</p><p>可以通过<code>ps -f</code> 或者 <code>jobs -l</code> 来查看</p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>协程 协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。 要进行协程处理，得使用coproc命令，还有要在子shell中执行的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coproc sleep 10</span><br><span class="line">coproc My_Job &#123; sleep 10; &#125; # 指定协程名</span><br></pre></td></tr></table></figure><blockquote><p>  通过使用扩展语法，协程的名字被设置成My_Job。这里要注意的是，扩展语法写起来有点 麻烦。必须确保在第一个花括号<code>{</code>和命令名之间有一个空格。还必须保证命令以分号<code>;</code>结 尾。另外，分号和闭花括号<code>}</code>之间也得有一个空格。</p></blockquote><h3 id="shell-内建命令"><a href="#shell-内建命令" class="headerlink" title="shell 内建命令"></a>shell 内建命令</h3><h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h4><p>外部命令，是存在于bash shell之外的程序。外部命令程序通常位于<code>/bin</code>、<code>/usr/bin</code>、<code>/sbin</code>或<code>/usr/sbin</code>中。</p><p>当外部命令执行时，会创建出一个子进程。这种操作被称为<strong>衍生</strong>（forking）。</p><p>当进程必须执行衍生操作时，它需<strong>要花费时间和精力来设置新子进程的环境</strong>。所以说，外部命令多少还是有代价的。</p><h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>内建命令和外部命令的区别在于前者<strong>不需要使用子进程来执行</strong>。它们已经和shell编译成了一体，作为shell工具的组成部分存在。比如<code>cd</code>和<code>exit</code></p><p>利用<code>type</code>命令来了解某个命令是否是内建的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ type cd</span><br><span class="line">cd is a shell builtin</span><br></pre></td></tr></table></figure><p>有些命令有多种实现。例如<code>echo</code>和<code>pwd</code>既有内建命令也有外部命令，要查看命令的不同实现，使用type命令的-a选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ type -a echo </span><br><span class="line">echo is a shell builtin </span><br><span class="line">echo is /bin/echo</span><br></pre></td></tr></table></figure><p>要使用外部命令 <code>pwd</code> ，可以输入<code>/bin/pwd</code> </p><h5 id="内建命令之-history"><a href="#内建命令之-history" class="headerlink" title="内建命令之 history"></a>内建命令之 history</h5><p>设置保存在bash历史记录中的命令数。要想实现这一点，你需要修改名为 <code>HISTSIZE</code> 的环境变量</p><p>输入<code>!!</code>可以重新执行上一条命令，<code>!编号</code>即可执行历史列表中的对应编号的命令</p><p>bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件<code>~/.bash_history</code>中。</p><p><code>~/.bash_history</code>文件只有在打开首个终端会话时才会被读取。</p><p>可以在退出shell会话之前强制将命令历史记录写入<code>.bash_history</code>文件。要实现强制写入，需要使用<code>history -a</code></p><p>要想强制重新读 取.bash_history文件，更新终端会话的历史记录，可以使用 <code>history -n</code> 命令。</p><h5 id="内建命令之-alias"><a href="#内建命令之-alias" class="headerlink" title="内建命令之 alias"></a>内建命令之 alias</h5><p>要查看当前可用 的别名，使用<code>alias</code>或者<code>alias -p</code>。</p><p>使用alias命令创建属于自己的别名。</p><p><code>alias li=&#39;ls -li&#39;</code></p><h3 id="shell-配置文件-TODO"><a href="#shell-配置文件-TODO" class="headerlink" title="shell 配置文件(TODO)"></a>shell 配置文件(TODO)</h3><p><a href="http://ddrv.cn/a/173848/" target="_blank" rel="noopener">http://ddrv.cn/a/173848/</a></p><p><code>Shell</code> 启动方式（TODO 到底是几种）</p><ul><li>交互式登录</li><li>交互式非登录</li><li>非交互式登录</li><li>非交互式非登录</li></ul><p>启动bash shell有3种方式：</p><ul><li>登录时作为默认登录shell</li><li>作为非登录shell的交互式shell </li><li>作为运行脚本的非交互shell</li></ul><blockquote><p>  <code>交互式</code>：一个个地输入命令并及时查看它们的输出结果，整个过程都在跟 Shell 不停地互动。<br>  <code>非交互式</code>：运行一个 <code>Shell 脚本</code> 文件，让所有命令批量化、一次性地执行。<br>  <code>登录式</code>：需要输入用户名和密码才能使用。<br>  <code>非登录式</code>：直接可以使用。</p></blockquote><h4 id="判断-shell-类型"><a href="#判断-shell-类型" class="headerlink" title="判断 shell 类型"></a>判断 shell 类型</h4><p><strong>如何判断是否为交互式 Shell? 有两种方式</strong></p><ol><li>查看特殊变量 <code>-</code> ，如果值包含 <code>i</code>，则是交互式，否则是非交互式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $-</span><br></pre></td></tr></table></figure><ol><li>查看变量 <code>PS1</code> 是否为空，如果不为空，则是交互式，否则为非交互式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PS1</span><br></pre></td></tr></table></figure><p><strong>如何判断是否为登录式 Shell ?</strong><br>执行命令 <code>shopt login_shell</code>，如果 <code>login_shell</code> 的值为 <code>on</code>表示登录式，为 <code>off</code>表示非登录式。</p><h5 id="登录-shell"><a href="#登录-shell" class="headerlink" title="登录 shell"></a>登录 shell</h5><p>当你登录Linux系统时，bash shell会作为登录shell启动。（对于没有图形化界面来说）</p><p>登录shell会从5个不同的启动文件里 读取命令：</p><ul><li><code>/etc/profile</code> ——&gt;会去读取<code>/etc/profile.d</code>目录下的配置文件</li><li><code>$HOME/.bash_profile</code></li><li><code>$HOME/.bashrc</code></li><li><code>$HOME/.bash_login</code></li><li><code>$HOME/.profile</code></li></ul><p><code>$HOME</code>目录下的启动文件 </p><p>剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环 境变量。大多数Linux发行版只用这四个启动文件中的1、2个：</p><ul><li><code>$HOME/.bash_profile</code></li><li><code>$HOME/.bashrc</code></li><li><code>$HOME/.bash_login</code></li><li><code>$HOME/.profile</code></li></ul><p>shell会按照按照下列顺序，运行第一个被找到的文件，忽略其他文件：</p><ul><li><code>$HOME/.bash_profile</code></li><li><code>$HOME/.bash_login</code></li><li><code>$HOME/.profile</code></li></ul><p>这个列表中没有<code>$HOME/.bashrc</code>文件是因为该文件<strong>通常通过其他文件运行</strong>的。比如 <code>.bash_profile</code>会先去检查HOME目录中是不是还有一个叫<code>.bashrc</code>的启动文件。如果有的话，会先执行启动文件里面的命令。因此<code>.bashrc</code>顺序最先，但是并不是优先级最高，因为<code>.bash_profile</code>设置的变量会覆盖 <code>.bashrc</code> 中的变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile </span></span><br><span class="line"><span class="comment"># Get the aliases and functions </span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span> </span><br><span class="line">. ~/.bashrc </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="comment"># User specific environment and startup programs </span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin </span><br><span class="line"><span class="built_in">export</span> PATH </span><br><span class="line">$</span><br></pre></td></tr></table></figure><h5 id="交互式-shell-进程"><a href="#交互式-shell-进程" class="headerlink" title="交互式 shell 进程"></a>交互式 shell 进程</h5><p>如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那 么你启动的shell叫作交互式shell。</p><p>作为交互式shell启动的，就<strong>不会访问<code>/etc/profile</code>文件</strong>，只会检查用户HOME目录中的<code>.bashrc</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bashrc # Source global definitions </span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span> </span><br><span class="line">. /etc/bashrc </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br></pre></td></tr></table></figure><p><code>.bashrc</code>文件有两个作用：</p><ol><li>查看/etc目录下通用的bashrc文件</li><li>为用户提供一个定制自 己的命令别名和私有脚本函数的地方。</li></ol><h5 id="非交互式-shell"><a href="#非交互式-shell" class="headerlink" title="非交互式 shell"></a>非交互式 shell</h5><p>系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。</p><blockquote><p>  脚本能以不同的方式执行。只有其中的某一些方式能够启动子shell。</p></blockquote><p>bash shell提供了BASH_ENV环境变量。当shell启动一个非交互式shell进 程时，它会检查BASH_ENV来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。</p><p>但是 CentoS 与 Ubuntu 都没有该变量，shell脚本到哪里去获得它们的环境变量呢？</p><ul><li>有些 shell脚本是通过启动一个子shell来执行的。子shell可以继承父shell导出过的变量。</li><li>对于那些不启动子shell的脚本， 变量已经存在于当前shell中了。 所以就算没有设置 BASH_ENV，也可以使用当前shell的局部变量和全局变量。</li></ul><h4 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h4><p><a href="https://blog.csdn.net/bjnihao/article/details/51775854" target="_blank" rel="noopener">参考网站</a></p><p>正常启动</p><p><img src="/2019/08/13/linux-shell编程/./shell配置文件加载顺序1.png" alt=""></p><p>su 切换用户</p><p><img src="/2019/08/13/linux-shell编程/./shell配置文件加载顺序2.png" alt=""></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的 shell可见。</p><p>查看环境变量的命令有<code>set</code>、<code>env</code>、<code>printenv</code></p><blockquote><p>  它们的区别：</p><p>  set 命令会显示出全局变量、局部变量以 及用户定义变量。它还会按照字母顺序对结果进行排序。</p><p>  env 和 printenv 命令不会对变量排序，也不会输出局部变量和用户定义变量。</p><p>  TODO env 与 printenv</p></blockquote><p>要显示个别环境变量的值，可以使用<code>printenv</code> 或者 <code>echo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ printenv HOME </span><br><span class="line">/home/Christine</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$HOME</span> </span><br><span class="line">/home/Christine</span><br></pre></td></tr></table></figure><h4 id="设置局部变量"><a href="#设置局部变量" class="headerlink" title="设置局部变量"></a>设置局部变量</h4><p>变量名区分大小写。所有的环境变量名均使用大写字母，自己创建的局部变量或是shell脚本，请使用小写字母。</p><p>记住，变量名、等号和值之间<strong>没有空格</strong>：如果在赋值表达式中加上了空格， bash shell就会把值当成一个单独的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable = <span class="string">"Hello World"</span> </span><br><span class="line">-bash: my_variable: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><h4 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h4><p>创建全局环境变量的方法是先创建一个局部环境变量，然后通过<code>export</code>命令把它导出到全局环境中。变量名前面不需要加$。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=<span class="string">"I am Global now"</span> </span><br><span class="line">$ my_variable2=<span class="string">"I am Global now"</span> </span><br><span class="line">$ <span class="built_in">export</span> my_variable my_variable2  <span class="comment"># 可以同时导出多个变量</span></span><br></pre></td></tr></table></figure><p>修改<em>子shell</em>中全局环境变量并<strong>不会影响到父shell中该变量的值</strong>。这种改变仅在子shell中有效，并不会被反映到父shell中。甚至无法使用export命令改变父shell中全局环境变量的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=<span class="string">"I am Global now"</span> </span><br><span class="line">$ <span class="built_in">export</span> my_variable </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> I am Global now </span><br><span class="line">$ </span><br><span class="line"><span class="variable">$bash</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$ </span><br><span class="line">$ my_variable=<span class="string">"Null"</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">export</span> my_variable  <span class="comment"># 导出变量也没用</span></span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span></span><br><span class="line">Null </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">exit</span> </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="shell-编程"><a href="#shell-编程" class="headerlink" title="shell 编程"></a>shell 编程</h2><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><p>在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：</p><p><code>#!/bin/bash</code></p><p>在通常的shell脚本中，井号（#）用作注释行。然而， shell脚本文件的第一行是个例外。</p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>默认情况下，不需要使用引号将要显示的文本字符串划定出来</p><p>可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在 文本中使用其中一种引号，而用另外一种来将字符串划定起来。</p><p>不换行<code>echo -n &quot;The time and date are: &quot;</code></p><blockquote><p>  反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p><p>  单引号（’’）：全局转义，转义其中所有的变量为单纯的字符串。</p><p>  双引号（””）：保留其中的变量属性，不进行转义处理。</p><p>  反引号（<code></code>）：把其中的命令执行后返回结果，等价于$(命令)</p></blockquote><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>通常别名定义在 <strong>$HOME/.bashrc</strong> 或者 <strong>$HOME/bash_aliases</strong> (在 <strong>$HOME/.bashrc</strong>被加载).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -e $HOME/.bash_aliases ]; then</span><br><span class="line">    source $HOME/.bash_aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>推荐的别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">alias ls='ls -F'   # 目录名后面加上/</span><br><span class="line">alias ll='ls -lh'  # 人类可读的方式显示容量，KB、GB</span><br><span class="line">alias gh='history|grep' # 查找历史命令</span><br><span class="line">alias count='find . -type f | wc -l' # 计算当前目录下文件总数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义函数最好保存在 bash_functions 文件中</span></span><br><span class="line">if [ -e $HOME/.bash_functions ]; then</span><br><span class="line">    source $HOME/.bash_functions</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换目录同时展示目录下的内容</span></span><br><span class="line">function cl() &#123;</span><br><span class="line">    DIR="$*";</span><br><span class="line">        # if no DIR given, go current dir</span><br><span class="line">        if [ $# -lt 1 ]; then</span><br><span class="line">                DIR=".";</span><br><span class="line">    fi;</span><br><span class="line">    builtin cd "$&#123;DIR&#125;" &amp;&amp; \</span><br><span class="line">    # use your preferred ls command</span><br><span class="line">        ls -F --color=auto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h4><p>在 shell 中<code>set</code>命令来显示一份完整的当前环境变量列表</p><p>在脚本中，你可以在环境变量名称之前加上美元符<code>$</code>来使用这些环境变量，或者<code>${variable}</code> 形式引用的变量。变量名两侧额外的花括号通常用来帮助识别美元符后的变量名</p><h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><ul><li><p>由字母、数字或下划线组成的文本字符串，长度不超过20个</p></li><li><p>用户变量 区分大小写</p></li><li>使用等号将值赋给用户变量。在变量、等号和值之间<strong>不能出现空格</strong></li><li>在shell脚本结束时会被删除掉</li><li>用户变量可通过美元符引用</li></ul><h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 <strong>readonly</strong> 下面的例子尝试更改只读变量，结果报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">myUrl=&quot;http://c.biancheng.net/shell/&quot;</span><br><span class="line">readonly myUrl</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="字符串的3种形式"><a href="#字符串的3种形式" class="headerlink" title="字符串的3种形式"></a>字符串的3种形式</h5><ol><li><p>由单引号<code>&#39; &#39;</code>包围的字符串：<br>任何字符都会原样输出，在其中使用<strong>变量是无效的</strong>。<br>字符串中<strong>不能出现单引号</strong>，即使对单引号进行转义也不行。</p></li><li><p>由双引号<code>&quot;</code> “包围的字符串：<br>如果其中包含了某个变量，那么该<strong>变量会被解析</strong>（得到该变量的值），而不是原样输出。<br>字符串中<strong>可以出现双引号</strong>，只要它被转义了就行。</p></li><li><p>不被引号包围的字符串<br>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号” “包围的字符串一样。<br>字符串中<strong>不能出现空格</strong>，否则空格后边的字符串会作为其他变量或者命令解析。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n=74</span><br><span class="line">str1=c.biancheng.net$n </span><br><span class="line">str2="shell \"script\" $n"</span><br><span class="line">str3='C语言中文网 $n'</span><br><span class="line"></span><br><span class="line">echo $str1</span><br><span class="line">echo $str2</span><br><span class="line">echo $str3</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">c.biancheng.net74</span><br><span class="line">shell "script" 74</span><br><span class="line">C语言中文网 $n</span><br></pre></td></tr></table></figure><h5 id="变量-字符串-拼接"><a href="#变量-字符串-拼接" class="headerlink" title="变量(字符串)拼接"></a>变量(字符串)拼接</h5><p>直接将两个变量写在一起就是拼接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="variable">$name</span><span class="variable">$url</span>      <span class="comment">#中间不能有空格，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析，</span></span><br><span class="line">str2=<span class="string">"<span class="variable">$name</span> <span class="variable">$url</span>"</span>   <span class="comment">#如果被双引号包围，那么中间可以有空格</span></span><br><span class="line">str3=<span class="variable">$name</span><span class="string">": "</span><span class="variable">$url</span>  <span class="comment">#中间可以出现别的字符串</span></span><br><span class="line">str4=<span class="string">"<span class="variable">$name</span>: <span class="variable">$url</span>"</span>  <span class="comment">#这样写也可以</span></span><br><span class="line">str5=<span class="string">"<span class="variable">$&#123;name&#125;</span>Script: <span class="variable">$&#123;url&#125;</span>index.html"</span>  <span class="comment">#这个时候需要给变量名加上大括号 加&#123; &#125;是为了帮助解释器识别变量的边界</span></span><br></pre></td></tr></table></figure><h5 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#string_name&#125;</span></span></span><br></pre></td></tr></table></figure><h5 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h5><p>假设有变量 <code>var=http://www.aaa.com/123.htm</code></p><p><strong>1. # 号截取，删除左边字符，保留右边字符。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var#*//&#125;</span><br></pre></td></tr></table></figure><p> 其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符<br>即删除<code>http://</code><br>结果是 ：<code>www.aaa.com/123.htm</code></p><p><strong>2. ## 号截取，贪心地删除左边字符，保留右边字符。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var##*/&#125;</span><br></pre></td></tr></table></figure><p><code>##*/</code>表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符<br>即删除 <code>http://www.aaa.com/</code></p><p>结果是 <code>123.htm</code></p><p><strong>3. %号截取，删除右边字符，保留左边字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var%/*&#125;</span><br></pre></td></tr></table></figure><p> <code>%/*</code> 表示从右边开始，删除第一个 / 号及右边的字符</p><p>结果是：<a href="http://www.aaa.com" target="_blank" rel="noopener">http://www.aaa.com</a></p><p><strong>4. %% 号截取，贪心地删除右边字符，保留左边字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var%%/*&#125;</span><br></pre></td></tr></table></figure><p> <code>%%/*</code> 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符<br>结果是：<code>http:</code></p><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>记住不要使用<code>$</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset my_variable</span><br></pre></td></tr></table></figure><p>在处理<strong>全局环境变量</strong>时，如果你是在子进程中删除了一个全局环境变量， 这只对子进程有效。该全局环境变量在<strong>父进程中依然可用</strong>。</p><h4 id="变量前的-符号"><a href="#变量前的-符号" class="headerlink" title="变量前的 $ 符号"></a>变量前的 $ 符号</h4><p>记住一点就行了：如果要用到变量，使用<code>$</code>；如果要操作变量，不使用<code>$</code>。这条规则的一个例外就是使用 <code>printenv</code> 显示某个变量的值。</p><h4 id="与"><a href="#与" class="headerlink" title="$* 与$@"></a><code>$*</code> 与<code>$@</code></h4><p><code>$*</code> 和<code>$@</code> 都表示传递给函数或脚本的所有参数， 当 <code>$*</code> 和 <code>$@</code> 不被<strong>双引号<code>&quot;&quot;</code></strong>包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。</p><p>但是当它们被双引号<code>&quot; &quot;</code>包含时，就会<strong>有区别</strong>了：</p><ul><li><code>&quot;$*&quot;</code>会将所有的参数从<strong>整体上看做一份数据</strong>，而不是把每个参数都看做一份数据。</li><li><code>&quot;$@&quot;</code>仍然将每个参数都看作一份数据，彼此之间是独立的。</li></ul><p>比如传递了 5 个参数，那么对于<code>$*</code>来说，这 5 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于<code>$@</code>来说，这 5 个参数是相互独立的，它们是 5 份数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">echo "脚本的名字是："$0</span><br><span class="line">n=1</span><br><span class="line">echo "使用\$@的参数列表为："$@</span><br><span class="line">for temstr in "$@"</span><br><span class="line">do</span><br><span class="line">  echo "第$n个参数是：" $temstr</span><br><span class="line">  let n+=1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">n=1</span><br><span class="line">echo "使用\$*的参数列表为："$*</span><br><span class="line">for temstr in "$*"</span><br><span class="line">do</span><br><span class="line">  echo "第$n个参数是：" $temstr</span><br><span class="line">  let n+=1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### 结果 #####</span></span></span><br><span class="line"></span><br><span class="line">脚本的名字是：test.sh</span><br><span class="line">使用$@的参数列表为：1 2 3 4 5</span><br><span class="line">第1个参数是： 1</span><br><span class="line">第2个参数是： 2</span><br><span class="line">第3个参数是： 3</span><br><span class="line">第4个参数是： 4</span><br><span class="line">第5个参数是： 5</span><br><span class="line">使用$*的参数列表为：1 2 3 4 5</span><br><span class="line">第1个参数是： 1 2 3 4 5</span><br></pre></td></tr></table></figure><h4 id="0的含义"><a href="#0的含义" class="headerlink" title="$0的含义"></a><code>$0</code>的含义</h4><p>第一种情况：直接命令调用一个shell，比如bash，会打开一个新的bash子shell，这时<code>echo $0</code>显示 shell的名称，比如<code>sh</code>，或者<code>bash</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># bash</span><br><span class="line"># echo &apos;$0&apos; is $0</span><br><span class="line"># $0 is bash</span><br></pre></td></tr></table></figure><p>第二种情况：shell 调用脚本文件，那么在脚本文件中<code>echo $0</code>就是脚本的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bash  main.sh</span><br><span class="line"># $0 is main.sh</span><br></pre></td></tr></table></figure><h4 id="环境变量持久化"><a href="#环境变量持久化" class="headerlink" title="环境变量持久化"></a>环境变量持久化</h4><p>对全局环境变量来说<strong>不要将变量、设置放在<code>/etc/profile</code></strong>文件中，因为在你升级了所用的发行版后， 这个文件也会跟着更新，那所有定制过的变量设置可就都没有了。</p><p><strong>最好</strong>是在<code>/etc/profile.d</code>目录中创建一个以<code>.sh</code>结尾的文件。把所有新的或修改过的全局环境变 量设置放在这个文件中。</p><p>在大多数发行版中，存储个人用户永久性bash shell变量的地方是<code>~/.bashrc</code>文件。这一点适用于所有类型的shell进程。 但如果设置了 BASH_ENV 变量， 那么记住， 除非它指向的是<code>~/.bashrc</code>，否则你应该将非交互式shell的用户变量放在别的地方。</p><h4 id="命令输出赋给变量、命令替换"><a href="#命令输出赋给变量、命令替换" class="headerlink" title="命令输出赋给变量、命令替换"></a>命令输出赋给变量、命令替换</h4><ul><li>反引号字符（`）</li><li><code>$()</code>格式</li></ul><blockquote><p>   原理：命令替换会创建一个子shell来运行对应的命令。子shell（ subshell）是由运行该脚本的shell 所创建出来的一个独立的子shell（child shell） 。正因如此，由该子shell所执行命令是无法 使用脚本中所创建的变量的。</p></blockquote><p>TODO 没明白</p><p>在命令行提示符下使用路径 ./ 运行命令的话，也会创建出子shell；要是运行命令的时候 不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。 在命令行提示符下运行脚本时一定要留心！</p><h4 id="变量截取"><a href="#变量截取" class="headerlink" title="变量截取"></a>变量截取</h4><p>假设我们定义了一个变量为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码如下:</span><br><span class="line">file=<span class="regexp">/dir1/</span>dir2/dir3/my.file.txt</span><br></pre></td></tr></table></figure><p>可以用<code>${ }</code>分别替换得到不同的值：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;file<span class="comment">#*/&#125;：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt</span></span><br><span class="line">$&#123;file<span class="comment">##*/&#125;：删掉最后一个 /  及其左边的字符串：my.file.txt</span></span><br><span class="line">$&#123;file<span class="comment">#*.&#125;：删掉第一个 .  及其左边的字符串：file.txt</span></span><br><span class="line">$&#123;file<span class="comment">##*.&#125;：删掉最后一个 .  及其左边的字符串：txt</span></span><br><span class="line">$&#123;file<span class="string">%/*&#125;：删掉最后一个  /</span>  及其右边的字符串：/dir1/dir2/dir3</span><br><span class="line">$&#123;file<span class="string">%%/*&#125;：删掉第一个 /  及其右边的字符串：(空值)</span></span><br><span class="line"><span class="string">$&#123;file%</span>.*&#125;：删掉最后一个  .  及其右边的字符串：/dir1/dir2/dir3/my.file</span><br><span class="line">$&#123;file<span class="string">%%.*&#125;：删掉第一个  .   及其右边的字符串：/dir1/dir2/dir3/my</span></span><br></pre></td></tr></table></figure><p>记忆的方法为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码如下<span class="symbol">:</span></span><br><span class="line"><span class="comment"># 是 去掉左边（键盘上#在 $ 的左边）</span></span><br><span class="line">%是去掉右边（键盘上% 在$ 的右边）</span><br><span class="line">单一符号是最小匹配；两个符号是最大匹配</span><br><span class="line">$&#123;<span class="symbol">file:</span><span class="number">0</span><span class="symbol">:</span><span class="number">5</span>&#125;：提取最左边的 <span class="number">5</span> 个字节：/dir1</span><br><span class="line">$&#123;<span class="symbol">file:</span><span class="number">5</span><span class="symbol">:</span><span class="number">5</span>&#125;：提取第 <span class="number">5</span> 个字节右边的连续<span class="number">5</span>个字节：/dir2</span><br></pre></td></tr></table></figure><p>也可以对变量值里的字符串作替换：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">代码如下<span class="symbol">:</span></span><br><span class="line">$&#123;file/dir/path&#125;：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt</span><br><span class="line">$&#123;file/<span class="regexp">/dir/path</span>&#125;：将全部dir 替换为 path：/path1/path2/path3/my.file.txt</span><br><span class="line"></span><br><span class="line">利用 $&#123; &#125; 还可针对不同的变数状态赋值(沒设定、空值、非空值)：</span><br><span class="line"></span><br><span class="line">$&#123;file-my.file.txt&#125; ：假如 $file 沒有设定，則使用 my.file.txt 作传回值。(空值及非空值時不作处理) </span><br><span class="line">$&#123;<span class="symbol">file:</span>-my.file.txt&#125; ：假如 $file 沒有設定或為空值，則使用 my.file.txt 作傳回值。 (非空值時不作处理)</span><br><span class="line">$&#123;file+my.file.txt&#125; ：假如 $file 設為空值或非空值，均使用 my.file.txt 作傳回值。(沒設定時不作处理)</span><br><span class="line">$&#123;<span class="symbol">file:</span>+my.file.txt&#125; ：若 $file 為非空值，則使用 my.file.txt 作傳回值。 (沒設定及空值時不作处理)</span><br><span class="line">$&#123;file=my.file.txt&#125; ：若 $file 沒設定，則使用 my.file.txt 作傳回值，同時將 $file 賦值為 my.file.txt 。 (空值及非空值時不作处理)</span><br><span class="line">$&#123;<span class="symbol">file:</span>=my.file.txt&#125; ：若 $file 沒設定或為空值，則使用 my.file.txt 作傳回值，同時將 $file 賦值為my.file.txt 。 (非空值時不作处理)</span><br><span class="line">$&#123;file?my.file.txt&#125; ：若 $file 沒設定，則將 my.file.txt 輸出至 STDERR。 (空值及非空值時不作处理)</span><br><span class="line"></span><br><span class="line">$&#123;<span class="symbol">file:</span>?my.file.txt&#125; ：若 $file 没设定或为空值，则将 my.file.txt 输出至 STDERR。 (非空值時不作处理)</span><br><span class="line">$&#123;<span class="comment">#var&#125; 可计算出变量值的长度：</span></span><br><span class="line"></span><br><span class="line">$&#123;<span class="comment">#file&#125; 可得到 27 ，因为/dir1/dir2/dir3/my.file.txt 是27个字节</span></span><br></pre></td></tr></table></figure><p><a href="https://www.jb51.net/article/64804.htm" target="_blank" rel="noopener">参考来源</a></p><h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><ul><li>Bash Shell 只支持一维数组（不支持多维数组）。</li><li>初始化时不需要定义数组大小（与 PHP 类似）。</li><li>数组元素的下标由0开始。</li></ul><h4 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h4><p>Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 value2 … valuen)</span><br></pre></td></tr></table></figure><p>例如：my_array=(A B “C” D)</p><p>我们也可以使用下标来定义数组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure><h4 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h4><p>这样是行不通的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$mytest</span>      <span class="comment"># 打印数组只会显示第一个值</span></span></span><br><span class="line">one</span><br></pre></td></tr></table></figure><p>一般格式是：<code>${array_name[index]}</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br><span class="line">echo "第一个元素为: $&#123;my_array[0]&#125;"</span><br><span class="line">echo "第二个元素为: $&#123;my_array[1]&#125;"</span><br><span class="line">echo "第三个元素为: $&#123;my_array[2]&#125;"</span><br><span class="line">echo "第四个元素为: $&#123;my_array[3]&#125;"</span><br></pre></td></tr></table></figure><p><strong>获取数组中的所有元素</strong></p><p>使用<code>@</code> 或 <code>*</code> 可以获取数组中的所有元素，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br><span class="line">echo "数组的元素为: $&#123;my_array[*]&#125;"</span><br><span class="line">echo "数组的元素为: $&#123;my_array[@]&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数组的元素为: A B C D 数组的元素为: A B C D</span></span><br></pre></td></tr></table></figure><p><strong>获取数组的长度</strong></p><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br><span class="line">echo "数组元素个数为: $&#123;#my_array[*]&#125;"</span><br><span class="line">echo "数组元素个数为: $&#123;#my_array[@]&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数组元素个数为: 4 数组元素个数为: 4</span></span><br></pre></td></tr></table></figure><h4 id="删除某个值"><a href="#删除某个值" class="headerlink" title="删除某个值"></a>删除某个值</h4><p>unset命令删除数组中的某个值，但是要小心，这可能会有点复杂。看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">unset</span> mytest[2]  </span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;mytest[*]&#125;  <span class="comment"># 遍历时会跳过被删除的索引位置</span></span><br><span class="line">one two four five </span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[2]&#125;</span> <span class="comment"># 但是该索引位置还占用着</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;mytest[3]&#125; </span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>这个例子用unset命令删除在索引值为2的位置上的值。显示整个数组时，看起来像是索引 里面已经没这个索引了。但当专门显示索引值为2的位置上的值时，就能看到这个位置是空的。 最后，可以在unset命令后跟上数组名来删除整个数组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> mytest   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;mytest[*]&#125;</span></span><br></pre></td></tr></table></figure><h4 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h4><p>首先创建一个数组 array=( A B C D 1 2 3 4)</p><h5 id="标准的for循环"><a href="#标准的for循环" class="headerlink" title="标准的for循环"></a><strong>标准的for循环</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(( i=0;i&lt;$&#123;#array[@]&#125;;i++)) #$&#123;#array[@]&#125;获取数组长度用于循环</span><br><span class="line">do    </span><br><span class="line">echo $&#123;array[i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h5 id="for-…-in"><a href="#for-…-in" class="headerlink" title="for … in"></a><strong>for … in</strong></h5><p>不带数组下标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for element in $&#123;array[@]&#125;    #也可以写成for element in $&#123;array[*]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $element</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>带数组下标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in $&#123;!array[@]&#125;  </span><br><span class="line">do   </span><br><span class="line">   echo $i $&#123;array[$i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h5 id="while循环法"><a href="#while循环法" class="headerlink" title="while循环法"></a><strong>while循环法</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=0  </span><br><span class="line">while [ $i -lt $&#123;#array[@]&#125; ]    #当变量（下标）小于数组长度时进入循环体</span><br><span class="line">do  </span><br><span class="line">    echo $&#123;array[$i]&#125;   #按下标打印数组元素</span><br><span class="line">    let i++  </span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="shell-展开"><a href="#shell-展开" class="headerlink" title="shell 展开"></a>shell 展开</h3><p>Bash 有七种扩展格式。本文只介绍其中五种：<code>~</code> 扩展、算术扩展、路径名称扩展、大括号扩展和命令替换。</p><p><img src="/2019/08/13/linux-shell编程/./shell展开.png" alt="shell 展开"></p><h4 id="花括号"><a href="#花括号" class="headerlink" title="{}花括号"></a><code>{}</code>花括号</h4><p>从一个包含花括号的模式中创建多个文本字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 逗号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span></span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 序列</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> Num_&#123;1..5&#125;</span></span><br><span class="line">Num_1 Num_2 Num_3 Num_4 Num_5</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> Num_&#123;1..10..2&#125;  <span class="comment"># 间隔</span></span></span><br><span class="line">Num_1 Num_3 Num_5 Num_7 Num_9</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;Z..A&#125;          <span class="comment"># 倒序</span></span></span><br><span class="line">Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b <span class="comment">#嵌套</span></span></span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></table></figure><h4 id="扩展"><a href="#扩展" class="headerlink" title="~扩展"></a><code>~</code>扩展</h4><p>Bash shell 把这个快捷方式展开成用户的完整的家目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ~</span></span><br><span class="line">/home/student</span><br></pre></td></tr></table></figure><h4 id="路径名称扩展"><a href="#路径名称扩展" class="headerlink" title="路径名称扩展"></a>路径名称扩展</h4><p>路径名称扩展是展开文件通配模式为匹配该模式的完整路径名称的另一种说法，匹配字符使用 <code>?</code> 和 <code>*</code></p><ul><li><p><code>?</code> — 匹配字符串中特定位置的一个任意字符</p></li><li><p><code>*</code> — 匹配字符串中特定位置的 0 个或多个任意字符</p></li></ul><h4 id="展开"><a href="#展开" class="headerlink" title="$展开"></a><code>$</code>展开</h4><p>‘$’ 符号引入了三种 shell 展开，包括 “参数展开”，“命令替换” 和 “算术表达式”。</p><h5 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$USER</span></span></span><br></pre></td></tr></table></figure><p>参数展开的基本的形式是 <code>${PARAMETER}</code>，整体被替换为 PARAMETER 的值。花括号如果 PARAMETER 是位置参数，而且由两个及以上的数字表示，这时必须使用花括号：<code>${10}</code>。另外当 PARAMETER 与其它字符相邻连接时，也必须使用花括号：<code>${Var}lala</code>。</p><h5 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h5><p>命令替换是让一个命令的标准输出数据流被当做参数传给另一个命令的扩展形式。</p><p>命令替换有两种格式：<code>command</code> 和 <code>$(command)</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Todays date is <span class="variable">$(date)</span>"</span></span></span><br><span class="line">Todays date is Sun Apr  7 14:42:59 EDT 2019</span><br></pre></td></tr></table></figure><h5 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h5><p>数字扩展的语法是 <code>$((arithmetic-expression))</code> ，分别用两个括号来打开和关闭表达式。算术扩展在 shell 程序或脚本中<strong>类似命令替换</strong>；表达式结算后的结果替换了表达式，用于 shell 后续的计算。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> Var1=5 ; Var2=7 ; Var3=$((Var1*Var2)) ; <span class="built_in">echo</span> <span class="string">"Var 3 = <span class="variable">$Var3</span>"</span></span></span><br><span class="line">Var 3 = 35</span><br></pre></td></tr></table></figure><h4 id="禁用展开"><a href="#禁用展开" class="headerlink" title="禁用展开"></a>禁用展开</h4><h5 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h5><p>把文本放在双引号中后，shell 使用的特殊字符，除了 <code>$</code>，<code>\</code> ，和 `（倒引号）之外， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割、路径名展开、波浪线展开、花括号展开都被禁止，<strong>然而参数展开，算术展开，命令替换仍然有效。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 多余的空格会被压缩</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a    <span class="built_in">test</span></span></span><br><span class="line">this is a test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 双引号关闭了单词分割功能</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"this is a    test"</span></span></span><br><span class="line">this is a    test</span><br></pre></td></tr></table></figure><p>案例2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 没有引用的命令替换导致命令行包含 38 个参数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(cal)</span></span><br><span class="line">January 2019 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 命令行只有一个参数，参数中包括嵌入的空格和换行符。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$(cal)</span>"</span></span></span><br><span class="line">    January 2019</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">       1  2  3  4  5</span><br><span class="line"> 6  7  8  9 10 11 12</span><br><span class="line">13 14 15 16 17 18 19</span><br><span class="line">20 21 22 23 24 25 26</span><br><span class="line">27 28 29 30 31</span><br></pre></td></tr></table></figure><h5 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h5><p>如果需要禁止所有的展开，需要使用单引号，包括转义符号<code>\</code></p><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><p>在文件名中可能使用一些对于 shell 来说，有特殊含义的字符。这些字符包括 “$”, “!”, “ “ 等字符。在文件名中包含特殊字符，你可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv bad\&amp;filename good_filename</span><br></pre></td></tr></table></figure><p>注意在<strong>单引号</strong>中，反斜杠<strong>失去它的特殊含义</strong>，它会被看作普通字符。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>覆盖原本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 正常信息写入</span><br><span class="line">2&gt; 错误信息写入</span><br><span class="line">&amp;&gt; 不论是正确还是错误信息，都写入文件中</span><br></pre></td></tr></table></figure><p>追加文本文件，多一个<code>&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 正常信息写入</span><br><span class="line">2&gt;&gt; 错误信息写入</span><br><span class="line">&amp;&gt;&gt; 不论是正确还是错误信息，都写入文件中</span><br></pre></td></tr></table></figure><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;   # 输入重定向</span><br><span class="line">&lt;&lt;  # 内联输入重定向</span><br></pre></td></tr></table></figure><p>内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，你必须指定一个文本标记来划分输 入数据的开始和结尾。它的用途请看 数学运算那一章节的 bc 计算器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wc &lt;&lt; EOF</span><br><span class="line">&gt; test string 1</span><br><span class="line">&gt; test string 2</span><br><span class="line">&gt; test string 3</span><br><span class="line">&gt; EOF</span><br><span class="line">$ 3  9  42</span><br></pre></td></tr></table></figure><h4 id="重定向绑定-gt-amp"><a href="#重定向绑定-gt-amp" class="headerlink" title="重定向绑定&gt;&amp;"></a>重定向绑定<code>&gt;&amp;</code></h4><p><strong>原理</strong>：linux在执行shell命令之前，就<strong>会确定好所有的输入输出位置</strong>，并且<strong>从左到右依次执行重定向的命令</strong></p><p><code>command 2&gt;&amp;1</code></p><p>这条命令用到了<strong>重定向绑定</strong>，采用<code>&amp;</code>可以将两个输出绑定在一起，即错误输出将和标准输出共用一个文件描述符。</p><p>可以这样记住这条写法（虽然并不完全正确）首先，<code>2&gt;1</code> 会被解释成将<code>stderr</code> 重定向到一个名为 <code>1</code>的文件中。 因此加入<code>&amp;</code>来表示紧跟着的是文件描述符（file descriptor)而不是文件名，因此最终就是这样的形式： <code>2&gt;&amp;1</code></p><p>理解上面的原理后，就可以明白下面的例子了：</p><p><strong>标准输出和标准错误重定向到不同log文件中</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh mr_add_test.sh &gt;log.log 2&gt;log_err.log</span><br></pre></td></tr></table></figure><p><strong>将标准输出和标准错误重定向到同一log文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo &gt;file 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><code>&gt;file</code> 将标准输出重定向到文件中<br><code>2&gt;&amp;1</code>  将错误绑定到标准输出上，此时标准输出已经重定向到file了</p><p><strong>输出标准输出和标准错误，同时保存到文件logfile</strong></p><p>方法一： <code>&lt;command&gt; 2&gt;&amp;1 | tee &lt;logfile&gt;</code></p><p>管道符号把一个进程的标准输出作为另一个进程的标准输入。<code>2&gt;&amp;1</code>是把标准错误重定向到标准输出的副本一起输出。上面的命令，把标准输出和标准错误都输出作为tee命令的标准输入，tee的作用为把标准输入的内容拷贝到文件，并输出。</p><p>方法二：<code>&lt;command&gt;  2&gt; logfile | cat - logfile</code></p><p>cat可以带多个文件参数，同时显示多个文件的内容。 <code>-</code>代表标准输入，logfile是管道前保存的标准错误文本。</p><p><strong>只输出错误，并保存到文件中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;command&gt; 2&gt;&amp;1 &gt;/dev/null | tee logfile</span><br></pre></td></tr></table></figure><p>这条命令其实分为两命令，一个是<code>&gt;/dev/null</code>，另一个是<code>2&gt;&amp;1</code>。</p><ol><li><code>2&gt;&amp;1</code>  将标准错误重定向到标准输出，注意，<strong>此时标准输出还没有被重定向</strong></li><li><code>/dev/null</code>文件是一个空设备，类似于windows内的回收站，使用<code>&gt;/dev/null</code>将标准输出重定向到<code>/dev/null</code>，即不显示标准输出的内容。所以这时的标准输出就仅变为重定向过来的标准错误了。</li></ol><p>相反，如果两者颠倒顺序，那标准输出连同它的副本都会被重定向到/dev/null，这是一个逻辑问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make 2&gt;&amp;1 &gt;/dev/null     # 顺序1，错误还是输出到屏幕</span><br><span class="line">make: *** No targets specified and no makefile found.  Stop.</span><br><span class="line"></span><br><span class="line">make &gt;/dev/null 2&gt;&amp;1     # 顺序2，不输出错误</span><br></pre></td></tr></table></figure><p><strong><code>&gt;/dev/null 2&gt;&amp;1</code> 与 <code>&gt;/dev/null 2&gt;/dev/null</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls a.txt b.txt &gt;out 2&gt;out</span><br><span class="line">cat out</span><br><span class="line"># a.txt</span><br><span class="line"># txt: No such file or directory</span><br></pre></td></tr></table></figure><p><code>out</code>中出现了丢失。采用这种写法，标准输出和错误输出会抢<strong>占往out文件的管道</strong>，所以可能会导致输出内容的时候出现缺失、覆盖等情况。有时候也有可能出现只有error信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。</p><p>而且，由于out文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体IO效率不如<code>&gt;/dev/null 2&gt;&amp;1</code>来得高。</p><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><h4 id="expr-不推荐"><a href="#expr-不推荐" class="headerlink" title="expr (不推荐)"></a>expr (不推荐)</h4><p>标准操作符在expr命令中工作得很好，但在脚本或命令行上使用它们时仍有问题出现。 许多expr命令操作符在shell中另有含义（比如星号）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ expr 5 * 2 </span><br><span class="line">expr: syntax error </span><br><span class="line"></span><br><span class="line"># 需要进行转义</span><br><span class="line">$ expr 5 \* 2</span><br></pre></td></tr></table></figure><h4 id="方括号-只支持整数"><a href="#方括号-只支持整数" class="headerlink" title="方括号(只支持整数)"></a>方括号(只支持整数)</h4><p>用<code>$[ operation ]</code>将数学表达式围起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var1=$[1 + 5]</span><br><span class="line">$ echo $var1 </span><br><span class="line"># 6</span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：bash shell数学运算符<strong>只支持整数运算</strong>。若要进行任何实际的数学计算，这是一个巨大的限制。z shell（zsh）提供了完整的浮点数算术操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var1=100</span><br><span class="line">var2=45</span><br><span class="line">var3=$[$var1 / $var2]</span><br><span class="line">echo $var3</span><br><span class="line"># 2</span><br></pre></td></tr></table></figure><h4 id="bc计算器-浮点数计算"><a href="#bc计算器-浮点数计算" class="headerlink" title="bc计算器(浮点数计算)"></a>bc计算器(浮点数计算)</h4><p><strong>命令行</strong></p><p>bash计算器支持变量print语句允许你打印 变量和数字，<code>-q</code> 命令行选项可以不显示bash计算器冗长的欢迎信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bc  -q</span><br><span class="line">res=12 * 5.4 <span class="comment"># 变量</span></span><br><span class="line"><span class="built_in">print</span> res</span><br><span class="line">64.8</span><br><span class="line">1+res</span><br><span class="line">65.8    <span class="comment"># 计算结果</span></span><br><span class="line">quit<span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><p>浮点运算是由内建变量scale控制的。必须将这个值设置为你希望在计算结果中保留的小数 位数，否则无法得到期望的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bc -q</span><br><span class="line">3.44 / 5 </span><br><span class="line">0 </span><br><span class="line">scale=4</span><br><span class="line">3.44 / 5 </span><br><span class="line">.6880 </span><br><span class="line">quit </span><br><span class="line">$</span><br></pre></td></tr></table></figure><p><strong>脚本</strong></p><p>基本格式如下：</p><p><code>variable=$(echo &quot;options; expression&quot; | bc)</code></p><ul><li><p>options 允许你设置变量。 如果你需要不止一个变量， 可以用分号将其分开</p></li><li><p>expression参数定义了通过bc执行的数学表达式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat test10 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">var1=100 </span><br><span class="line">var2=45 </span><br><span class="line">var3=$(<span class="built_in">echo</span> <span class="string">"scale=4; <span class="variable">$var1</span> / <span class="variable">$var2</span>"</span> | bc) </span><br><span class="line"><span class="built_in">echo</span> The answer <span class="keyword">for</span> this is <span class="variable">$var3</span> </span><br><span class="line">$</span><br></pre></td></tr></table></figure><p> <strong>大量运算</strong></p><p>最好的办法是使用内联输入重定向，当然，必须用命令替换符号标识出用来给变量赋值的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat test12</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">var1=10.46</span><br><span class="line">var2=43.67</span><br><span class="line">var3=33.2</span><br><span class="line">var4=71</span><br><span class="line">var5=$(bc &lt;&lt; EOF </span><br><span class="line">scale = 4 </span><br><span class="line">a1 = ( <span class="variable">$var1</span> * <span class="variable">$var2</span>) </span><br><span class="line">b1 = (<span class="variable">$var3</span> * <span class="variable">$var4</span>) </span><br><span class="line">a1 + b1 </span><br><span class="line">EOF </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> The final answer <span class="keyword">for</span> this mess is <span class="variable">$var5</span> </span><br><span class="line">s$</span><br></pre></td></tr></table></figure><p>你可以在bash计算器中赋值给变量。这一点很重要：在bash 计算器中创建的变量只在bash计算器中有效，<strong>不能在shell脚本中使用</strong>。</p><h4 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h4><table><thead><tr><th style="text-align:left">运算操作符/运算命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>((a=10+66) ((b=a-15)) ((c=a+b))</code></td><td style="text-align:left">在 (( )) 中使用变量无需加上<code>$</code>前缀，(( )) 会自动解析变量名</td></tr><tr><td style="text-align:left"><code>a=$((10+66)</code><br> <code>b=$((a-15))</code><br> <code>c=$((a+b))</code></td><td style="text-align:left">使用<code>$</code>获取 (( )) 命令的结果</td></tr><tr><td style="text-align:left"><code>((a&gt;7 &amp;&amp; b==c))</code></td><td style="text-align:left">(( )) 也可以进行逻辑运算，在 if 语句中常会使用逻辑运算。</td></tr><tr><td style="text-align:left"><code>echo $((a+10))</code></td><td style="text-align:left">需要立即输出表达式的运算结果时，可以在 (( )) 前面加<code>$</code>符号。</td></tr><tr><td style="text-align:left"><code>c=$((a=3+5, b=a+10))</code></td><td style="text-align:left">多个表达式之间以逗号<code>,</code>分隔。以最后一个表达式的值作为整个 (( )) 命令的执行结果。</td></tr></tbody></table><p><strong>数字高级比较</strong> （双括号）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure><p>双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。但还是<strong>只支持整数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val++     # 后增 </span><br><span class="line">val--     # 后减</span><br><span class="line">++val     # 先增</span><br><span class="line">--val     # 先减</span><br><span class="line">!         # 逻辑求反</span><br><span class="line">~         # 位求反</span><br><span class="line">**        # 幂运算</span><br><span class="line">&lt;&lt;        # 左位移 </span><br><span class="line">&gt;&gt;        # 右位移</span><br><span class="line">&amp;         # 位布尔和</span><br><span class="line">|         # 位布尔或 </span><br><span class="line">&amp;&amp;        # 逻辑和 </span><br><span class="line">||        # 逻辑或</span><br></pre></td></tr></table></figure><p>注意，<strong>不需要将双括号中表达式里的大于号转义</strong>。这是双括号命令提供的另一个高级特性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> using double parenthesis </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">val1=10 </span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">if (( $val1 ** 2 &gt; 90 )) </span><br><span class="line">then</span><br><span class="line">    (( val2 = $val1 ** 2 ))</span><br><span class="line">    echo "The square of $val1 is $val2" </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p>shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。退出状态码是一个<strong>0～255</strong>的整数值，在命令结束运行时执行<code>exit code</code>传给shell。</p><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>成功结束</td></tr><tr><td>1</td><td>一般性未知错误</td></tr><tr><td>2</td><td>不合适的 shell 命令</td></tr><tr><td>126</td><td>命令不可执行，比如没有权限</td></tr><tr><td>127</td><td>没有找到命令</td></tr><tr><td>128</td><td>无效的退出参数</td></tr><tr><td>128+x</td><td>与 Linux 信号 x 相关的严重错误</td></tr><tr><td>130</td><td>通过 Ctrl+C 终止的命令</td></tr><tr><td>255</td><td>正常范围之外的退出状态码</td></tr></tbody></table><h3 id="脚本的健壮性"><a href="#脚本的健壮性" class="headerlink" title="脚本的健壮性"></a>脚本的健壮性</h3><p>要写出健壮性更好的脚本，下面是一些相关的技巧：</p><ul><li>使用 <code>-e</code> 参数，如：<code>set -e</code> 或是 <code>#!/bin/sh -e</code>，这样设置会让你的脚本出错就会停止运行，这样一来可以防止你的脚本在出错的情况下还在拼拿地干活停不下来。</li><li>使用 <code>-u</code> 参数，如： <code>set -eu</code>，这意味着，如果你代码中有变量没有定义，就会退出。</li><li>你可以使用 <code>set -x</code> 来debug输出。</li><li>考虑使用 <code>set -o pipefail</code> 来限制错误。还可以使用trap来截获信号（如截获ctrl+c）。</li><li>对一些变理，你可以使用默认值。如：<code>${FOO:-&#39;default&#39;}</code></li><li>处理你代码的退出码。这样方便你的脚本跟别的命令行或脚本集成。</li><li>尽量使用 <code>&amp;&amp;</code> 来执行多个命令，而不是 <code>;</code>，这样会在出错的时候停止运行后续的命令。</li><li>对于一些字符串变量，使用引号括起，避免其中有空格或是别的什么诡异字符。</li><li>如果你的脚有参数，你需要检查脚本运行是否带了你想要的参数，或是，你的脚本可以在没有参数的情况下安全的运行。</li><li>为你的脚本设置 <code>-h</code> 和 <code>--help</code> 来显示帮助信息。千万不要把这两个参数用做为的功能。</li><li>使用 <code>$()</code> 而不是 “ 来获得命令行的输出，主要原因是易读。</li><li>小心不同的平台，尤其是 MacOS 和 Linux 的跨平台。</li><li>对于 <code>rm -rf</code> 这样的高危操作，需要检查后面的变量名是否为空，比如：<code>rm -rf $MYDIDR/*</code> 如果 <code>$MYDIR</code>为空，结果是灾难性的。</li><li>考虑使用 <code>find/while</code>而不是 <code>for/find</code>。如：<code>for F in $(find . -type f) ; do echo $F; done</code> 写成 <code>find . -type f | while read F ; do echo $F ; done</code> 不但可以容忍空格，而且还更快。</li><li>防御式编程，在正式执行命令前，把相关的东西都检查好，比如，文件目录有没有存在。</li></ul><p>你还可以使用网站<a href="https://www.shellcheck.net/" target="_blank" rel="noopener">ShellCheck</a>来帮助你检查你的脚本。</p><p>转至：<a href="https://coolshell.cn/articles/19219.html" target="_blank" rel="noopener">https://coolshell.cn/articles/19219.html</a></p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h4><p><code>command1 &amp;&amp; command2</code> ：如果 command1 执行成功，那么接着执行 command2。如果 command1 失败，就跳过 command2。</p><p><code>command1 || command2</code>：如果 command1 失败，执行 command2。隐藏的逻辑是，如果 command1 成功，跳过 command2。</p><p><code>&amp;&amp;</code> 和 <code>||</code> 两种运算符结合起来才能发挥它们的最大功效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前置 commands ; command1 &amp;&amp; command2 || command3 ; 跟随 commands</span><br></pre></td></tr></table></figure><p>语法解释：假如 command1 退出时返回码为零，就执行 command2，否则执行 command3。<strong>类似于 if-else的逻辑</strong>。</p><p>用具体代码试试，在 root 的 home 目录下测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[student@studentvm1 ~]$ Dir=/root/testdir ; mkdir $Dir &amp;&amp; cd $Dir || echo "$Dir was not created."mkdir: cannot create directory '/root/testdir': Permission denied/root/testdir was not created.</span><br></pre></td></tr></table></figure><p>现在在你的家目录执行，你将会有权限创建这个目录了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[student@studentvm1 ~]$ Dir=~/testdir ; mkdir $Dir &amp;&amp; cd $Dir || echo "$Dir was not created."</span><br></pre></td></tr></table></figure><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if command </span><br><span class="line">then</span><br><span class="line">    commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 推荐</span><br><span class="line">if command; then </span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>  通过把分号放在待求值的命令尾部，就可以将 then 语句放在同一行上了，这样看起来更 像其他编程语言中的 if-then 语句。</p></blockquote><p>bash shell的if语句会运行<code>if</code>后面的那个命令。如果该命令的<strong>退出状态码是0</strong>，就执行<code>then</code>后的命令。在其他编程语言 中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。</p><p><strong>if else</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if command</span><br><span class="line">then</span><br><span class="line">    commands </span><br><span class="line">else</span><br><span class="line">    commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>if elif</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if command1 </span><br><span class="line">then</span><br><span class="line">    commands </span><br><span class="line">elif command2</span><br><span class="line">then</span><br><span class="line">    more commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>  注意：记住， 在 elif 语句中， 紧跟其后的 else 语句属于 elif 代码块。 它们并不属于之前的 if-then 代码块。</p></blockquote><h4 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h4><p>if-then语句是否能测试命令退出状态码之外的条件。答案是不能。</p><p><code>test</code>命令提供了在<code>if-then</code>语句中测试不同条件的途径。如果test命令中列出的条件成立， <code>test</code>命令就会退出并返回退出状态码<code>0</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if test condition </span><br><span class="line">then </span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="推荐写法"><a href="#推荐写法" class="headerlink" title="推荐写法"></a>推荐写法</h5><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ] </span><br><span class="line">then</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>方括号定义了测试条件。注意，</p><ul><li><strong>第一个方括号之后和第二个方括号之前必须加上一个空格</strong>， 否则就会报错。</li><li>括号内的大于号、小于号，需要进行转义，后面的双括号才不需要。</li></ul><p><strong>否定写法(感叹号)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -f $FILE ]; then  # !后有空格</span><br><span class="line">    echo &quot;source company doesn\&apos;t exist&quot;</span><br><span class="line">    exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h5><p>test命令可以判断三类条件：</p><ol><li>数值比较 </li><li>字符串比较</li><li>文件比较</li></ol><h6 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h6><p>我们不能在 test命令中使用浮点值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n1 -eq n2    # 检查n1是否=n2 </span><br><span class="line">n1 -ge n2    # 检查n1是否&gt;=n2 </span><br><span class="line">n1 -gt n2    # 检查n1是否&gt;n2 </span><br><span class="line">n1 -le n2    # 检查n1是否&lt;=n2 </span><br><span class="line">n1 -lt n2    # 检查n1是否&lt;n2 </span><br><span class="line">n1 -ne n2    # 检查n1是否!=n2</span><br></pre></td></tr></table></figure><p>test命令只能在比较中使用简单的 算术操作。双括号命令提供了更多的数学符号。请看后面内容。</p><h6 id="字符串比较-有坑"><a href="#字符串比较-有坑" class="headerlink" title="字符串比较(有坑)"></a>字符串比较(有坑)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = str2   # 检查str1是否和str2相同 </span><br><span class="line">str1 != str2  # 检查str1是否和str2不同 </span><br><span class="line">str1 \&lt; str2   # 检查str1是否比str2小，注意一定要转义</span><br><span class="line">str1 \&gt; str2   # 检查str1是否比str2大，注意一定要转义</span><br><span class="line">-n str1       # 检查str1的长度是否非0</span><br><span class="line">-z str1       # 检查str1的长度是否为0，未在shell脚本中定义过，所以它的字符串长度仍然 为0</span><br></pre></td></tr></table></figure><p><strong>字符串长度比较</strong></p><p>计算字符串的长度没有简单的方法。有很多种方法可以计算，但是我认为使用 <code>expr</code>（求值表达式）命令是相对最简单的一种。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyVar="How long is this?" ; expr length "$MyVar"    # 注意 mac 中并没有 length 这个命令</span><br></pre></td></tr></table></figure><p>这里会出现经常困扰shell程序员的问题：</p><ul><li><p>大于号和小于号必须转义，否则shell会把它们当作<strong>重定向符号</strong>，把字符串值当作文件名；</p></li><li><p>大于和小于顺序和sort命令所采用的不同</p><blockquote><p>  这是因为 比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort 命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺 序中小写字母出现在大写字母前。</p></blockquote></li><li><p>未在shell脚本中定义过，<code>-z</code>认为它的字符串长度为0</p></li></ul><p><strong>字符串中有空格的情况处理</strong></p><p>有些人从在文件名或者命令行参数中使用空格，你需要在编写脚本时时刻记得这件事。你需要时刻记得用引号包围变量。</p><p><code>if [ $filename = &quot;foo&quot; ];</code></p><p>当$filename变量包含空格时就会挂掉。可以这样解决：</p><p><code>if [ &quot;$filename&quot; = &quot;foo&quot; ];</code></p><p>使用<code>$@</code>变量时，你也需要使用引号，因为空格隔开的两个参数会被解释成两个独立的部分。</p><h6 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h6><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-a filename</code></td><td style="text-align:left">如果文件存在，返回真值；文件可以为空也可以有内容，但是只要它存在，就返回真值</td></tr><tr><td style="text-align:left"><code>-b filename</code></td><td style="text-align:left">如果文件存在且是一个块设备，如 <code>/dev/sda</code> 或 <code>/dev/sda1</code>，则返回真值</td></tr><tr><td style="text-align:left"><code>-c filename</code></td><td style="text-align:left">如果文件存在且是一个字符设备，如 <code>/dev/TTY1</code>，则返回真值</td></tr><tr><td style="text-align:left"><code>-d filename</code></td><td style="text-align:left">如果文件存在且是一个目录，返回真值</td></tr><tr><td style="text-align:left"><code>-e filename</code></td><td style="text-align:left">如果文件存在，返回真值；与上面的 <code>-a</code> 相同，可用于文件和目录</td></tr><tr><td style="text-align:left"><code>-f filename</code></td><td style="text-align:left">如果文件存在且是一个一般文件，不是目录、设备文件或链接等的其他的文件，则返回 真值</td></tr><tr><td style="text-align:left"><code>-g filename</code></td><td style="text-align:left">如果文件存在且 <code>SETGID</code> 标记被设置在其上，返回真值</td></tr><tr><td style="text-align:left"><code>-h filename</code></td><td style="text-align:left">如果文件存在且是一个符号链接，则返回真值</td></tr><tr><td style="text-align:left"><code>-k filename</code></td><td style="text-align:left">如果文件存在且粘滞位已设置，则返回真值</td></tr><tr><td style="text-align:left"><code>-p filename</code></td><td style="text-align:left">如果文件存在且是一个命名的管道（FIFO），返回真值</td></tr><tr><td style="text-align:left"><code>-r filename</code></td><td style="text-align:left">如果文件存在且有可读权限（它的可读位被设置），返回真值</td></tr><tr><td style="text-align:left"><code>-s filename</code></td><td style="text-align:left">如果文件存在且大小大于 0，返回真值（存在并非空）；如果一个文件存在但大小为 0，则返回假值</td></tr><tr><td style="text-align:left"><code>-t fd</code></td><td style="text-align:left">如果文件描述符 <code>fd</code> 被打开且被关联到一个终端设备上，返回真值</td></tr><tr><td style="text-align:left"><code>-u filename</code></td><td style="text-align:left">如果文件存在且它的 <code>SETUID</code> 位被设置，返回真值</td></tr><tr><td style="text-align:left"><code>-w filename</code></td><td style="text-align:left">如果文件存在且有可写权限，返回真值</td></tr><tr><td style="text-align:left"><code>-x filename</code></td><td style="text-align:left">如果文件存在且有可执行权限，返回真值</td></tr><tr><td style="text-align:left"><code>-G filename</code></td><td style="text-align:left">如果文件存在且文件的组 ID 与当前用户相同，返回真值</td></tr><tr><td style="text-align:left"><code>-L filename</code></td><td style="text-align:left">如果文件存在且是一个符号链接，返回真值（同 <code>-h</code>）</td></tr><tr><td style="text-align:left"><code>-N filename</code></td><td style="text-align:left">如果文件存在且从文件上一次被读取后文件被修改过，返回真值</td></tr><tr><td style="text-align:left"><code>-O filename</code></td><td style="text-align:left">如果文件存在且你是文件的拥有者，返回真值</td></tr><tr><td style="text-align:left"><code>-S filename</code></td><td style="text-align:left">如果文件存在且文件是套接字，返回真值</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">在你尝试使用<code>ef</code>、<code>-nt</code>或 <code>-ot</code>比较文件之前，必须先确认文件是存在的。</td></tr><tr><td style="text-align:left"><code>file1 -ef file2</code></td><td style="text-align:left">如果文件 <code>file1</code> 和文件 <code>file2</code> 指向同一设备的同一 INODE 号，返回真值（即硬链接）</td></tr><tr><td style="text-align:left"><code>file1 -nt file2</code></td><td style="text-align:left">如果文件 <code>file1</code> 比 <code>file2</code> 新（根据修改日期），或 <code>file1</code> 存在而 <code>file2</code> 不存在，返回真值</td></tr><tr><td style="text-align:left"><code>file1 -ot file2</code></td><td style="text-align:left">如果文件 <code>file1</code> 比 <code>file2</code> 旧（根据修改日期），或 <code>file1</code> 不存在而 <code>file2</code> 存在</td></tr></tbody></table><p>判断文件存在并不为空的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File="TestFile1"</span><br><span class="line">echo "This is $File" &gt; $File</span><br><span class="line">if [ -s $File ]</span><br><span class="line">   then</span><br><span class="line">   echo "$File exists and contains data."</span><br><span class="line">elif [ -e $File ]</span><br><span class="line">   then</span><br><span class="line">   echo "$File exists and is empty."</span><br><span class="line">else</span><br><span class="line">   echo "$File does not exist."</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h6 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h6><p>这些杂项操作符展示一个 shell 选项是否被设置，或一个 shell 变量是否有值，但是它不显示变量的值，只显示它是否有值。</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-o optname</code></td><td style="text-align:left">如果一个 shell 选项 <code>optname</code> 是启用的（查看内建在 Bash 手册页中的 set <code>-o</code> 选项描述下面的选项列表），则返回真值</td></tr><tr><td style="text-align:left"><code>-v varname</code></td><td style="text-align:left">如果 shell 变量 <code>varname</code> 被设置了值（被赋予了值），则返回真值</td></tr><tr><td style="text-align:left"><code>-R varname</code></td><td style="text-align:left">如果一个 shell 变量 <code>varname</code> 被设置了值且是一个名字引用，则返回真值</td></tr></tbody></table><p><a href="https://linux.cn/article-11687-1.html" target="_blank" rel="noopener">https://linux.cn/article-11687-1.html</a></p><h5 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：  </span><br><span class="line">[ condition1 ] &amp;&amp; [ condition2 ] </span><br><span class="line">[ condition1 ] || [ condition2 ]</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing compound comparisons </span></span><br><span class="line"><span class="comment"># if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ] </span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The file exists and you can write to it"</span> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"I cannot write to the file"</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="双括号与双中括号-进阶"><a href="#双括号与双中括号-进阶" class="headerlink" title="双括号与双中括号(进阶)"></a>双括号与双中括号(进阶)</h4><h5 id="数字高级比较-（双括号）"><a href="#数字高级比较-（双括号）" class="headerlink" title="数字高级比较 （双括号）"></a>数字高级比较 （双括号）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure><p>双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。但还是<strong>只支持整数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val++     # 后增 </span><br><span class="line">val--     # 后减</span><br><span class="line">++val     # 先增</span><br><span class="line">--val     # 先减</span><br><span class="line">!         # 逻辑求反</span><br><span class="line">~         # 位求反</span><br><span class="line">**        # 幂运算</span><br><span class="line">&lt;&lt;        # 左位移 </span><br><span class="line">&gt;&gt;        # 右位移</span><br><span class="line">&amp;         # 位布尔和</span><br><span class="line">|         # 位布尔或 </span><br><span class="line">&amp;&amp;        # 逻辑和 </span><br><span class="line">||        # 逻辑或</span><br></pre></td></tr></table></figure><p>注意，<strong>不需要将双括号中表达式里的大于号转义</strong>。这是双括号命令提供的另一个高级特性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> using double parenthesis </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">val1=10 </span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">if (( $val1 ** 2 &gt; 90 )) </span><br><span class="line">then</span><br><span class="line">    (( val2 = $val1 ** 2 ))</span><br><span class="line">    echo "The square of $val1 is $val2" </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="字符串高级比较（双中括号）"><a href="#字符串高级比较（双中括号）" class="headerlink" title="字符串高级比较（双中括号）"></a>字符串高级比较（双中括号）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure><ul><li>不需要把变量名用双引号<code>&quot;&quot;</code>包围起来，即使变量是空值，也不会出错。</li><li>不需要、也不能对 &gt;、&lt; 进行转义，转义后反而会出错。</li></ul><blockquote><p>  双方括号在bashshell中工作良好。不过要小心，不是所有的shell都支持双方括号。</p></blockquote><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -z &quot;$str1&quot; ] || [ -z &quot;$str2&quot; ]</span><br></pre></td></tr></table></figure><p>你也可以借助选项把多个表达式写在一个 test 命令中，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -z &quot;$str1&quot; -o -z &quot;$str2&quot; ]</span><br></pre></td></tr></table></figure><p>但是，这两种写法都有点“别扭”，[[ ]]  支持在括号内直接使用 &amp;&amp;、|| 和 ! 三种逻辑运算符。 使用 [[ ]] 对上面的语句进行改进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z $str1 || -z $str2 ]]</span><br></pre></td></tr></table></figure><p>这种写法就比较简洁漂亮了。注意，[[ ]] 剔除了 test 命令的<code>-o</code>和<code>-a</code>选项，你只能使用 || 和 &amp;&amp;。这意味着，你不能写成下面的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z $str1 -o -z $str2 ]] ×</span><br></pre></td></tr></table></figure><p>当然，使用逻辑运算符将多个 [[ ]] 连接起来依然是可以的，因为这是 Shell 本身提供的功能，跟 [[ ]] 或者 test 没有关系，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z $str1 ]] || [[ -z $str2 ]]</span><br></pre></td></tr></table></figure><h5 id="支持正则表达式"><a href="#支持正则表达式" class="headerlink" title="[[ ]] 支持正则表达式"></a>[[ ]] 支持正则表达式</h5><p>在 Shell [[ ]] 中，可以使用<code>=~</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ str =~ regex ]]</span><br><span class="line">if [[ $tel =~ ^1[0-9]&#123;10&#125;$ ]]</span><br></pre></td></tr></table></figure><p>有了 <code>[[ ]]</code>，你还有什么理由使用 test 或者 <code>[ ]</code>，<code>[[ ]]</code> 完全可以替代之，而且更加方便，更加强大。</p><p>但是 <code>[[ ]]</code> 对数字的比较仍然不友好，所以我建议，以后大家使用 <code>if</code> 判断条件时，用 <code>(())</code>来处理整型数字，用<code>[[ ]]</code> 来处理字符串或者文件。  </p><h4 id="swtich-case"><a href="#swtich-case" class="headerlink" title="swtich case"></a>swtich case</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span> </span><br><span class="line">pattern1 | pattern2) </span><br><span class="line">    commands1;; </span><br><span class="line">pattern3) </span><br><span class="line">    commands2;; </span><br><span class="line">*) </span><br><span class="line">    default_commands;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$USER</span> <span class="keyword">in</span> </span><br><span class="line">rich | barbara)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Welcome, <span class="variable">$USER</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Please enjoy your visit"</span>;; </span><br><span class="line">testing)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Special testing account"</span>;; </span><br><span class="line">jessica)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Do not forget to log off when you're done"</span>;; </span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Sorry, you are not allowed here"</span>;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>Python 风格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in list </span><br><span class="line">do </span><br><span class="line">    $var commands </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list; <span class="keyword">do</span> </span><br><span class="line">    <span class="variable">$var</span> commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>类似于 python，执行到 <code>for</code>的时候，已经将数据加载到 list 中了，并不是每次加载一行，然后赋值给变量。list 的内容其实已经全部通过 <code>IFS</code> 分割然后加载进来了。</p><p><strong>list是以空格分割的</strong></p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> Alabama Alaska Arizona Arkansas California Colorado <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The next state is <span class="variable">$test</span>"</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The last state we visited was <span class="variable">$test</span>"</span></span><br></pre></td></tr></table></figure><p>使用<code>$var</code> 获取列表中的值，for循环假定每个值都是用空格分割的。 如果有包含空格的数据值，就必须用双引号将这些值圈起来。或者查看【字段分隔符】章节的解决方案</p><p><strong>list 中有引号的情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> I don<span class="string">'t know if this'</span>ll work </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"word:<span class="variable">$test</span>"</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line">$ ./badtest1 </span><br><span class="line">word:I </span><br><span class="line">word:dont know <span class="keyword">if</span> thisll </span><br><span class="line">word:work</span><br></pre></td></tr></table></figure><p>shell看到了列表值中的单引号并尝试使用它们来定义一个单独的数据值，这真是把事情搞得一团糟。 有两种办法可解决这个问题：</p><ul><li>使用转义字符（反斜线）来将单引号转义； </li><li>使用双引号来定义用到单引号的值:<code>&quot;this&#39;ll&quot;</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> I don\<span class="string">'t know if "this'</span>ll<span class="string">" work </span></span><br><span class="line"><span class="string">do </span></span><br><span class="line"><span class="string">    echo "</span>word:<span class="variable">$test</span><span class="string">" </span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure><p><strong>list添加</strong></p><p>用<code>&quot;</code>进行拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=&quot;Alabama Alaska Arizona Arkansas Colorado&quot; </span><br><span class="line">list=$list&quot; Connecticut&quot; # 拼接</span><br></pre></td></tr></table></figure><p><strong>循环命令结果</strong></p><p>使用命令替换符号可以对命令的结果进行循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for RPM in `rpm -qa | sort | uniq` ; do rpm -qi $RPM ; done</span><br></pre></td></tr></table></figure><h5 id="字段分隔符"><a href="#字段分隔符" class="headerlink" title="字段分隔符"></a>字段分隔符</h5><p>特殊的环境变量<code>IFS</code>，叫作内部字段分隔符（internal field separator）。 IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字 符当作字段分隔符： </p><ul><li>空格 </li><li>制表符 </li><li>换行符</li></ul><p>如果你想修改<code>IFS</code>的值，使其只能识别换行符，那就必须这么做：<code>IFS=$&#39;\n&#39;</code></p><p>指定多个IFS字符，只要将它们在赋值行串起来就行。<code>IFS=$&#39;\n&#39;:;&quot;</code>  ，这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。</p><blockquote><p>  一个可参考的安全实践是在改变 IFS 之前保存原 来的 IFS 值，之后再恢复它。 这种技术可以这样实现：</p><p>  <code>IFS.OLD=$IFS</code></p><p>  <code>IFS=$&#39;\n&#39;</code></p><p>  &lt;在代码中使用新的IFS值&gt;</p><p>  <code>IFS=$IFS.OLD</code></p><p>  这就保证了在脚本的后续操作中使用的是 IFS 的默认值。</p></blockquote><h5 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h5><p>目录名和文件名中包含空格当然是合法的。要适应这种情况，一种方法是将<code>$file</code>变量用双引号圈起来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for file in /home/rich/test/* </span><br><span class="line">do</span><br><span class="line">    if [ -d "$file" ] </span><br><span class="line">    then </span><br><span class="line">        echo "$file is a directory" </span><br><span class="line">    elif [ -f "$file" ] </span><br><span class="line">    then </span><br><span class="line">        echo "$file is a file" </span><br><span class="line">    fi </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>另一种方法是指定<code>IFS</code></p><p>典型的例子是处理/etc/passwd文件中的数据。这要求你逐行遍历/etc/passwd文件，并将IFS 变量的值改成冒号，这样就能分隔开每行中的各个数据段了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash # changing the IFS value</span></span><br><span class="line"></span><br><span class="line">IFS.OLD=<span class="variable">$IFS</span> </span><br><span class="line">IFS=$<span class="string">'\n'</span> <span class="comment"># 指定分隔符为换行</span></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> $(cat /etc/passwd) <span class="comment"># 这时数据已经通过\n加载在list中了</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Values in <span class="variable">$entry</span> –"</span></span><br><span class="line">    IFS=: <span class="comment"># 指定为冒号，后面不用恢复成\n，原因如上面的注释</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="variable">$entry</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">" <span class="variable">$value</span>"</span></span><br><span class="line">    <span class="keyword">done</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h5 id="c语言风格的-for"><a href="#c语言风格的-for" class="headerlink" title="c语言风格的 for"></a>c语言风格的 for</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( variable assignment ; condition ; iteration process ))</span><br></pre></td></tr></table></figure><p>这与之前的 bash shell 标准有些不同</p><ul><li>变量赋值可以有空格； </li><li>条件中的变量不以美元符开头； </li><li>迭代过程的算式未用expr命令格式；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"># multiple variables</span><br><span class="line"></span><br><span class="line">for ((i=1; i&lt;=100; i ++))</span><br><span class="line">do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (( a=1, b=10; a &lt;= 10 &amp;&amp; b&gt;=5; a++, b-- )) </span><br><span class="line">do </span><br><span class="line">    echo &quot;$a - $b&quot; </span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while-与-until"><a href="#while-与-until" class="headerlink" title="while 与 until"></a>while 与 until</h4><p>while命令的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while test_command </span><br><span class="line">do </span><br><span class="line">    other commands </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>例子1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while [ $var1 -gt 0 ]</span><br><span class="line">do</span><br><span class="line">    echo $var1</span><br><span class="line">    var1=$[ $var1 - 1 ] </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>while</code>命令允许你在while语句行定义多个测试命令：</p><ul><li>每个测试命令都出现在<strong>单独的一行</strong>上。</li><li>只有<strong>最后一个</strong>测试命令的退出状态码会被用来决定什么时候结束循环。</li><li>在每次迭代中所有的测试命令都会被执行，包括测试命令失败的最后一次迭代。要留心这种用法。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># multiple variables</span></span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">echo</span> <span class="variable">$var1</span> <span class="built_in">echo</span> “minglin2” <span class="comment"># 可以有多条命令，但是测试命令只能一行一条</span></span><br><span class="line">    [ <span class="variable">$var1</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"This is inside the loop"</span></span><br><span class="line">    var1=$[ <span class="variable">$var1</span> - 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>until命令和while命令工作的方式完全相反，只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。其他的与 <code>while</code> 相同</p><h4 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h4><p>默认 break 只跳出所在的最内层的循环。</p><p>有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值：</p><p><code>break n</code>其中n指定了要跳出的循环层级。</p><p>默认情况下，n为1，表明跳出的是当前的循环。如果你将 n设为2，break命令就会停止下一级的外部循环。</p><p>和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环：</p><p><code>continue n</code>其中n定义了要继续的循环层级。</p><p>默认情况下，n为1，表明当继续执行下一次循环。</p><p>例子：当 2&lt;a&lt;4时跳过循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">for (( a = 1; a &lt;= 5; a++ )) </span><br><span class="line">do</span><br><span class="line">    echo "Iteration $a:"</span><br><span class="line">    for (( b = 1; b &lt; 3; b++ )) </span><br><span class="line">    do</span><br><span class="line">        if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ]</span><br><span class="line">        then</span><br><span class="line">            continue 2 # 当 2&lt;a&lt;4时跳过循环</span><br><span class="line">        fi </span><br><span class="line">        var3=$[ $a * $b ] </span><br><span class="line">        echo " The result of $a * $b is $var3" </span><br><span class="line">    done</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test22 </span></span><br><span class="line">Iteration 1:</span><br><span class="line">    The result of 1 * 1 is 1 </span><br><span class="line">    The result of 1 * 2 is 2 </span><br><span class="line">Iteration 2:</span><br><span class="line">    The result of 2 * 1 is 2 </span><br><span class="line">    The result of 2 * 2 is 4 </span><br><span class="line">Iteration 3: # 跳过了第 3 次</span><br><span class="line">Iteration 4:</span><br><span class="line">    The result of 4 * 1 is 4 </span><br><span class="line">    The result of 4 * 2 is 8 </span><br><span class="line">Iteration 5:</span><br><span class="line">    The result of 5 * 1 is 5 </span><br><span class="line">    The result of 5 * 2 is 10</span><br></pre></td></tr></table></figure><h4 id="循环的重定向"><a href="#循环的重定向" class="headerlink" title="循环的重定向"></a>循环的重定向</h4><p>你可以对循环的输出使用管道或进行重定向。这可以通过在关键字<code>done</code>之后添加<code>&gt;</code>或 <code>|</code>命令来实现。</p><p>重定向到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /home/rich/* </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$file</span>"</span> ] </span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a directory"</span> </span><br><span class="line">    <span class="keyword">elif</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a file"</span> </span><br><span class="line">    <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span> &gt; output.txt  <span class="comment"># 重定向到文件</span></span><br></pre></td></tr></table></figure><p>从文件中循环读取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># process new user accounts</span></span><br><span class="line"></span><br><span class="line">input=<span class="string">"users.csv"</span> </span><br><span class="line"><span class="keyword">while</span> IFS=<span class="string">','</span> <span class="built_in">read</span> -r userid name </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"adding <span class="variable">$userid</span>"</span></span><br><span class="line">    useradd -c <span class="string">"<span class="variable">$name</span>"</span> -m <span class="variable">$userid</span> </span><br><span class="line"><span class="keyword">done</span> &lt; <span class="string">"<span class="variable">$input</span>"</span></span><br></pre></td></tr></table></figure><p>​          </p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>所有函数<strong>在使用前必须定义</strong>。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [ ] 中括号表示可选</span></span><br><span class="line"></span><br><span class="line">[ function ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line">    [return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "第十个参数为 $10 !"</span><br><span class="line">    echo "第十个参数为 $&#123;10&#125; !"</span><br><span class="line">    echo "第十一个参数为 $&#123;11&#125; !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>位置参数变量是标准的数字：<code>$0</code>是程序名，<code>$1</code>是第 一个参数，<code>$2</code>是第二个参数，依次类推，直到第九个参数<code>$9</code>。</p><h4 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h4><p>4个最常用的转义字符如下所示。</p><blockquote><p>  反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p><p>  单引号（’’）：全局转义，转义其中所有的变量为单纯的字符串。</p><p>  双引号（””）：保留其中的变量属性，不进行转义处理。</p><p>  反引号（<code></code>）：把其中的命令执行后返回结果，等价于$(命令)</p></blockquote><h4 id="获取文件的绝对路径"><a href="#获取文件的绝对路径" class="headerlink" title="获取文件的绝对路径"></a>获取文件的绝对路径</h4><p><strong>误区一</strong></p><p>是使用 <strong>pwd</strong> 命令，print name of current/working directory</p><p>你可以试试 <code>bash shell/a.sh</code>，<code>a.sh</code> 内容是 <code>pwd</code>，你会发现，显示的是执行命令的路径 <code>/home/june</code>，并不是<code>a.sh</code> 所在路径：<code>/home/june/shell/a.sh</code></p><p><strong>误区二</strong></p><p> <strong>$0</strong>，这个也是不对的，这个$0是Bash环境下的特殊变量，其真实含义是：</p><p>这个<code>$0</code>有可能是好几种值，跟调用的方式有关系：</p><ul><li>使用一个文件调用bash，那$0的值，是那个文件的名字(没说是绝对路径噢)</li><li>使用-c选项启动bash的话，真正执行的命令会从一个字符串中读取，字符串后面如果还有别的参数的话，使用从$0开始的特殊变量引用(跟路径无关了)</li><li>除此以外，$0会被设置成调用bash的那个文件的名字(没说是绝对路径)</li></ul><p><strong>正确方法：dirname 配合 readlink</strong></p><p><code>dirname</code> ：可以获取所在目录，输出已经去除了尾部的“/”字符部分的名称；如果名称中不包含“/”，则显示“.”(表示当前目录)。</p><blockquote><p>  取决于你传递给它的是不是绝对路径</p></blockquote><p><code>readlink</code> 可以获取文件的完整路径</p><p>最终形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(dirname $(readlink -f "$0"))</span><br></pre></td></tr></table></figure><p>例子</p><p>下面对比下正确答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Jun@VAIO 192.168.1.216 23:52:54 ~ &gt;</span><br><span class="line">cat shell/a.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &apos;$0: &apos;$0</span><br><span class="line">echo &quot;pwd: &quot;`pwd`</span><br><span class="line">echo &quot;=============================&quot;</span><br><span class="line">echo &quot;scriptPath1: &quot;$(cd `dirname $0`; pwd)</span><br><span class="line">echo &quot;scriptPath2: &quot;$(pwd)</span><br><span class="line">echo &quot;scriptPath3: &quot;$(dirname $(readlink -f $0))</span><br><span class="line">echo &quot;scriptPath4: &quot;$(cd $(dirname $&#123;BASH_SOURCE:-$0&#125;);pwd)</span><br><span class="line">echo -n &quot;scriptPath5: &quot; &amp;&amp; dirname $(readlink -f $&#123;BASH_SOURCE[0]&#125;)</span><br><span class="line"></span><br><span class="line">Jun@VAIO 192.168.1.216 23:53:17 ~ &gt;</span><br><span class="line">bash shell/a.sh</span><br><span class="line">$0: shell/a.sh</span><br><span class="line">pwd: /home/Jun</span><br><span class="line">=============================</span><br><span class="line">scriptPath1: /home/Jun/shell</span><br><span class="line">scriptPath2: /home/Jun</span><br><span class="line">scriptPath3: /home/Jun/shell</span><br><span class="line">scriptPath4: /home/Jun/shell</span><br><span class="line">scriptPath5: /home/Jun/shell</span><br></pre></td></tr></table></figure><p>在此解释下 scriptPath1 ：</p><ul><li><code>dirname $0</code>，取得当前执行的脚本文件的父目录</li><li><code>cd dirname $0</code>，进入这个目录(切换当前工作目录)</li><li><code>pwd</code>，显示当前工作目录(cd执行后的)</li><li>由此，我们获得了当前正在执行的脚本的存放路径。</li></ul><h4 id="检查命令是否存在"><a href="#检查命令是否存在" class="headerlink" title="检查命令是否存在"></a>检查命令是否存在</h4><p>用 <code>which</code> 吗？最好不要用，因为很多操作系统的 <code>which</code> 命令没有设置退出状态码，这样你不知道是否是有那个命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> POSIX 兼容:</span></span><br><span class="line">command -v [the_command]</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> bash 环境:</span></span><br><span class="line">hash [the_command]</span><br><span class="line">type [the_command]</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例：</span></span><br><span class="line">gnudate() &#123;</span><br><span class="line">    if hash gdate 2&gt; /dev/null; then</span><br><span class="line">        gdate "$@"</span><br><span class="line">    else</span><br><span class="line">        date "$@"</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径中获取文件"><a href="#路径中获取文件" class="headerlink" title="路径中获取文件"></a>路径中获取文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chengdan_file="dir/file.txt"</span><br><span class="line">echo $chengdan_file</span><br><span class="line">file_name=$&#123;chengdan_file##*/&#125;   # 去除目录</span><br><span class="line">file_name=$&#123;file_name%%.*&#125;       # 去除后缀</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bash3 Boilerplate. Copyright (c) 2014, kvz.io</span></span><br><span class="line"></span><br><span class="line">set -o errexit</span><br><span class="line">set -o pipefail</span><br><span class="line">set -o nounset</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> -o xtrace</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set magic variables <span class="keyword">for</span> current file &amp; dir</span></span><br><span class="line">__dir="$(cd "$(dirname "$&#123;BASH_SOURCE[0]&#125;")" &amp;&amp; pwd)"</span><br><span class="line">__file="$&#123;__dir&#125;/$(basename "$&#123;BASH_SOURCE[0]&#125;")"</span><br><span class="line">__base="$(basename $&#123;__file&#125; .sh)"</span><br><span class="line">__root="$(cd "$(dirname "$&#123;__dir&#125;")" &amp;&amp; pwd)" # &lt;-- change this as it depends on your app</span><br><span class="line"></span><br><span class="line">arg1="$&#123;1:-&#125;"</span><br></pre></td></tr></table></figure><ol><li>使用长的参数名，以便增加可读写，除非在命令行中简短的参数更快速 (<code>logger --priority</code> vs <code>logger -p</code>).</li><li><code>set -o errexit</code> (a.k.a <code>set -e</code>) 让脚本在<strong>运行出错</strong>时退出，而不会继续执行下去</li><li><code>set -o nounset</code> (a.k.a. <code>set -u</code>)让脚本在使用了<strong>未声明变量</strong>时退出.</li><li><code>set -o xtrace</code> (a.k.a <code>set -x</code>) 用于 debug</li><li><code>set -o pipefail</code> 用于捕获管道命令的出错，比如捕获 mysqldump 的在<code>mysqldump |gzip</code>中出现的错误</li><li><code>#!/usr/bin/env bash</code> 比 <code>#!/bin/bash</code>更有兼容性。</li><li>用<code>{}</code>括起你的变量</li><li>You don’t need two equal signs when checking <code>if [ &quot;${NAME}&quot; = &quot;Kevin&quot; ]</code>. TODO</li><li>在脚本的头部定义魔法变量、basename、目录等等。</li></ol><p>参考:<a href="https://kvz.io/bash-best-practices.html" target="_blank" rel="noopener">https://kvz.io/bash-best-practices.html</a></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python小模块</title>
      <link href="/2019/08/06/python%E5%B0%8F%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/08/06/python%E5%B0%8F%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>记录Python常用的一些标准库，以及第三方库</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="argpaser"><a href="#argpaser" class="headerlink" title="argpaser"></a>argpaser</h3><h4 id="add-argument说明"><a href="#add-argument说明" class="headerlink" title="add_argument说明"></a>add_argument说明</h4><ul><li><code>name=&quot;square&quot;</code><ul><li>没有<code>-</code>前缀的<code></code>verbose` 是<strong>位置参数</strong></li></ul></li><li><code>-a</code>短参数，<code>--arg</code>为长参数，是<strong>可选参数</strong>，短参数与长参数可以放一起</li><li><code>help=&quot;参数说明&quot;</code>， 参数的说明</li><li><code>type=int</code>，指定参数类型</li><li><code>action=&quot;store_true&quot;</code>，如果指定了参数就将True赋值给args.square，否则为False<ul><li>默认需要提供value，<code>--batch_size 2</code></li><li><code>store_true</code>，可以不传值：<code>--is_verbose</code></li><li><code>count</code>，当参数出现n次就赋值为n，比如<code>-vvv</code>时，就有<code>v=3</code> </li></ul></li><li><code>choices=[0, 1, 2]</code>，指定可以赋值的范围，与<code>action=&quot;store_true&quot;</code>不兼容</li><li><code>default=0</code>，指定默认值，否则是<code>None</code></li></ul><h4 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h4><h5 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h5><blockquote><p>positional arguments</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"square"</span>, help=<span class="string">"display a square of a given number"</span>, type=int)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.square**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##################用法################</span></span><br><span class="line">python3 prog.py <span class="number">4</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><blockquote><p>Optional arguments</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"--verbosity"</span>, help=<span class="string">"increase output verbosity"</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">if</span> args.verbosity:</span><br><span class="line">    print(<span class="string">"verbosity turned on"</span>)</span><br><span class="line"><span class="comment">##################用法################</span></span><br><span class="line">python3 prog.py --verbosity <span class="number">1</span></span><br><span class="line">verbosity turned on</span><br></pre></td></tr></table></figure><p>默认情况，可选参数后面必须跟一个value，<code>--verbosity any</code>，</p><p>如果需要只是标志类型的参数，可以设置<code>action=&quot;store_true&quot;</code></p><h4 id="二者选其一参数"><a href="#二者选其一参数" class="headerlink" title="二者选其一参数"></a>二者选其一参数</h4><p>使用<code>add_mutually_exclusive_group</code>可以实现两个参数只能设置其中一个的效果，比如想要设置打印日志为详细还是静默。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">group = parser.add_mutually_exclusive_group()</span><br><span class="line">group.add_argument(<span class="string">"-v"</span>, <span class="string">"--verbose"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">group.add_argument(<span class="string">"-q"</span>, <span class="string">"--quiet"</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"x"</span>, type=int, help=<span class="string">"the base"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"y"</span>, type=int, help=<span class="string">"the exponent"</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">answer = args.x**args.y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.quiet:</span><br><span class="line">    print(answer)</span><br><span class="line"><span class="keyword">elif</span> args.verbose:</span><br><span class="line">    print(<span class="string">"&#123;&#125; to the power &#123;&#125; equals &#123;&#125;"</span>.format(args.x, args.y, answer))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"&#123;&#125;^&#123;&#125; == &#123;&#125;"</span>.format(args.x, args.y, answer))</span><br><span class="line">    </span><br><span class="line"><span class="comment">##################使用###############</span></span><br><span class="line">$ python3 prog.py <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span>^<span class="number">2</span> == <span class="number">16</span></span><br><span class="line">$ python3 prog.py <span class="number">4</span> <span class="number">2</span> -q</span><br><span class="line"><span class="number">16</span></span><br><span class="line">$ python3 prog.py <span class="number">4</span> <span class="number">2</span> -v</span><br><span class="line"><span class="number">4</span> to the power <span class="number">2</span> equals <span class="number">16</span></span><br><span class="line">$ python3 prog.py <span class="number">4</span> <span class="number">2</span> -vq</span><br><span class="line">usage: prog.py [-h] [-v | -q] x y</span><br><span class="line">prog.py: error: argument -q/--quiet: <span class="keyword">not</span> allowed <span class="keyword">with</span> argument -v/--verbose</span><br><span class="line">$ python3 prog.py <span class="number">4</span> <span class="number">2</span> -v --quiet</span><br><span class="line">usage: prog.py [-h] [-v | -q] x y</span><br><span class="line">prog.py: error: argument -q/--quiet: <span class="keyword">not</span> allowed <span class="keyword">with</span> argument -v/--verbose</span><br></pre></td></tr></table></figure><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paser_arg</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数解析，以及默认参数设置</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">"说明该模块的功能"</span>)</span><br><span class="line">    add = parser.add_argument  <span class="comment">#将该函数赋值给add，方便后面定义参数</span></span><br><span class="line">    add(<span class="string">"--verbose"</span>,help=<span class="string">"是否显示详细日志内容"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    options = paser_arg()</span><br><span class="line">    <span class="keyword">if</span> options.verbose:</span><br><span class="line">        print(<span class="string">"verbose print"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"no verbose print"</span>)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://docs.python.org/3.8/howto/argparse.html" target="_blank" rel="noopener">官方argpaser</a></p><h3 id="profile-性能分析"><a href="#profile-性能分析" class="headerlink" title="profile 性能分析"></a>profile 性能分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> profile <span class="keyword">import</span> Profile</span><br><span class="line"><span class="keyword">from</span> pstats <span class="keyword">import</span> Stats</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(pair)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算最大公约数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    a, b = pair</span><br><span class="line">    low = min(a, b)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(low, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> a % i == <span class="number">0</span> <span class="keyword">and</span> b % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  被测试的函数</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;n:</span><br><span class="line">        gcd((<span class="number">1963309</span>, <span class="number">2265973</span>))</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = Profile()</span><br><span class="line">p.runcall(main, <span class="number">100</span>)    <span class="comment"># 函数，以及参数</span></span><br><span class="line"><span class="comment"># p.print_stats()    # 可以直接打印报告</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用stats可以更加自由的定义打印的报告内容</span></span><br><span class="line">stats = Stats(p)</span><br><span class="line">stats.strip_dirs()</span><br><span class="line">stats.sort_stats(<span class="string">'cumulative'</span>)</span><br><span class="line">stats.print_stats()   </span><br><span class="line">stats.print_callers()    <span class="comment"># 打印每个函数的调用者</span></span><br></pre></td></tr></table></figure><blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;   203 function calls in 22.478 seconds</span><br><span class="line">&gt;   </span><br><span class="line">&gt;      Ordered by: standard name</span><br><span class="line">&gt;   </span><br><span class="line">&gt;      ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">&gt;         100    0.001    0.000    0.001    0.000 :0(min)</span><br><span class="line">&gt;           1    0.000    0.000    0.000    0.000 :0(setprofile)</span><br><span class="line">&gt;           1    0.001    0.001   22.477   22.477 &lt;ipython-input-13-1e3e5803ef86&gt;:13(main)</span><br><span class="line">&gt;         100   22.476    0.225   22.476    0.225 &lt;ipython-input-13-1e3e5803ef86&gt;:3(gcd)</span><br><span class="line">&gt;           1    0.000    0.000   22.478   22.478 profile:0(&lt;function main at 0x107c720d0&gt;)</span><br><span class="line">&gt;           0    0.000             0.000          profile:0(profiler)</span><br><span class="line">&gt;           </span><br><span class="line">&gt;    Ordered by: cumulative time</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   Function                                   was called by...</span><br><span class="line">&gt;   profile:0(&lt;function main at 0x107dffbf8&gt;)  &lt;- profile:0(profiler)(1)    0.000</span><br><span class="line">&gt;   &lt;ipython-input-21-c6df0a564b27&gt;:13(main)   &lt;- profile:0(&lt;function main at 0x107dffbf8&gt;)(1)   22.548</span><br><span class="line">&gt;   &lt;ipython-input-21-c6df0a564b27&gt;:3(gcd)     &lt;- &lt;ipython-input-21-c6df0a564b27&gt;:13(main)(100)   22.547</span><br><span class="line">&gt;   :0(min)                                    &lt;- &lt;ipython-input-21-c6df0a564b27&gt;:3(gcd)(100)   22.546</span><br><span class="line">&gt;   :0(setprofile)                             &lt;- profile:0(&lt;function main at 0x107dffbf8&gt;)(1)   22.548</span><br><span class="line">&gt;   profile:0(profiler)                        &lt;- </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>报告说明：</p><ul><li>ncalls：该函数表调用的次数</li><li>cumtime：执行该函数的所花的时间，<strong>含</strong>函数内调用其他函数的时间</li><li>tottime：执行该函数的所花的时间，<strong>s</strong>函数内调用其他函数的时间</li><li>percall：平均每次调用消耗的时间</li></ul><h3 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h3><p>The <a href="https://docs.python.org/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> module 实现了二进制协议，用于serializing 和 de-serializing  Python object structure 并保存到磁盘中，并在需要的时候读取出来，任何对象（lambda除外）都可以执行序列化操作。</p><p>Pickle模块中最常用的函数为：</p><h4 id="保存为文件"><a href="#保存为文件" class="headerlink" title="保存为文件"></a>保存为文件</h4><ol><li><p><code>dump(obj, file, [,protocol])</code></p><p>功能：将obj对象序列化存入已经打开的file中。</p><ul><li>obj: 想要序列化的obj对象。</li><li>file: file对象</li><li>protocol: 序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 使用 highest protocol Pickle the 'data' dictionary </span></span><br><span class="line">    pickle.dump(data, file, pickle.HIGHEST_PROTOCOL)</span><br></pre></td></tr></table></figure></li><li><p><code>load(file)</code></p><p>功能：将file中的对象反序列化读出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># protocol版本会自动检测，不要指定</span></span><br><span class="line">    data = pickle.load(file)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>因为pickle是使用二进制保存文件，因此open的读写模式，要使用‘b’</p></blockquote><h4 id="保存为string"><a href="#保存为string" class="headerlink" title="保存为string"></a>保存为string</h4><ol><li><p><code>dumps(obj [, protocol])</code></p><p>功能：将obj对象<strong>序列化为<code>string</code>形式</strong>，而不是存入文件中。</p><ul><li>obj：想要序列化的obj对象。</li><li>protocol：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。</li></ul></li><li><p><code>loads(string)</code></p><p>函数的功能：从string中读出序列化前的obj对象。</p><ul><li>string：pickle序列化后的字符串对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># dumps</span></span><br><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line">r = pickle.dumps(li)</span><br><span class="line">print(r)</span><br><span class="line"><span class="comment">#(lp0</span></span><br><span class="line"><span class="comment"># I11</span></span><br><span class="line"><span class="comment"># aI22</span></span><br><span class="line"><span class="comment"># aI33</span></span><br><span class="line"><span class="comment"># a.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># loads</span></span><br><span class="line">result = pickle.loads(r)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># [11, 22, 33]</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="对函数、类、接口序列号"><a href="#对函数、类、接口序列号" class="headerlink" title="对函数、类、接口序列号"></a>对函数、类、接口序列号</h4><p>pickle 可以序列化函数，类，还有接口，但是结果数据<strong>仅仅将它们的名称编码成对应的代码对象</strong>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">import pickle.</span><br><span class="line">pickle.dumps(math.cos)</span><br><span class="line"># b&apos;\x80\x03cmath\ncos\nq\x00.&apos;</span><br></pre></td></tr></table></figure><p>当数据反序列化回来的时候，会先假定所有的源数据时可用的。 模块、类和函数会自动按需导入进来。对于Python数据被不同机器上的解析器所共享的应用程序而言， 数据的保存可能会有问题，因为所有的机器都必须访问同一个源代码。</p><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p><strong>千万不要对不信任的数据使用<code>pickle.load()</code>。</strong><br>pickle在加载时有一个副作用就是它会自动加载相应模块并构造实例对象。但是某个坏人如果知道pickle的工作原理，<br>他就可以创建一个恶意的数据导致Python执行随意指定的系统命令。因此，<strong>一定要保证<code>pickle</code>只在相互之间可以认证对方的解析器的内部使用</strong>。</p><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><h4 id="re-1"><a href="#re-1" class="headerlink" title="re"></a>re</h4><h5 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h5><ul><li><code>re.match</code>：查找字符串中是否有”从头开始”匹配的非空子串，返回match对象</li><li><code>re.search</code>：查找字符串中是否有匹配的非空子串，返回第一个匹配成功的match对象</li><li><p><code>re.finditer</code>：查找字符串中所有满足正则表达式的子串，返回全部match对象的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s=<span class="string">"she said: \"I love you\",and he replied 'me,too'"</span></span><br><span class="line">ms=re.finditer(<span class="string">r"(?P&lt;quote&gt;['\"]).*?(?P=quote)"</span>,s)</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> ms:</span><br><span class="line">    print(m.group(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># "I love you"</span></span><br><span class="line"><span class="comment"># 'me,too'</span></span><br></pre></td></tr></table></figure></li><li><p><code>re.fullmatch</code>：判断是否”整个字符串”满足正则表达式</p></li><li><code>re.findall</code>：查找所有满足正则表达式的子串，返回全部子串的数组</li></ul><h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5><ul><li><p><code>re.sub</code></p><p>函数调用：<code>text = sub(pattern,repl,string,count)</code></p><ul><li><code>pattern</code> ： 正则中的模式字符串</li><li><code>repl</code> ： 替换的字符串，sub() 函数除了接受替换字符串外，还能接受一个回调函数，(参数必须是 match 对象)</li><li><code>string</code>：要被查找替换的原始字符串</li><li><code>count</code> ： 模式匹配后替换的最大次数，默认 0 表示替换 全部的匹配</li></ul></li><li><p><code>re.subn</code></p><pre><code>函数调用：`newtext, n = re.subn()` ，`n`表示发生了多少次替换</code></pre></li></ul><h5 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h5><p><code>re.split</code>字符串分割，返回分割后的数组。注意括号的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">res=re.split(<span class="string">"\|"</span> , <span class="string">' runoob|runoob|runoob.'</span>)</span><br><span class="line"><span class="comment"># [' runoob', 'runoob', 'runoob.']</span></span><br><span class="line"></span><br><span class="line">res=re.split(<span class="string">"(\|)"</span> , <span class="string">' runoob|runoob|runoob.'</span>) <span class="comment"># 添加括号，会保留分割符</span></span><br><span class="line"><span class="comment"># [' runoob', '|', 'runoob', '|', 'runoob.']</span></span><br></pre></td></tr></table></figure><h4 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h4><p>为了重复利用正则表达式，将表达式编译好，保存在pattern中，用法与re的方法基本一致。<br>pattern = re.compile(“d”)<br>pattern.search(“dog”)</p><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；<br>    start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；<br>    end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；<br>    span([group]) 方法返回 (start(group), end(group))。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>注意：<strong>datetime 类型是不可变对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数代表：year,month,day,hour,minute,second</span></span><br><span class="line">t = datetime.datetime(<span class="number">2019</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">44</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别获取属性</span></span><br><span class="line">t.year</span><br><span class="line">t.hour</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取日期 datetime.date</span></span><br><span class="line">t.date()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取时间 datetime.time</span></span><br><span class="line">t.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改(产生新对象,因为t不可变)</span></span><br><span class="line">b = t.replace(munite=<span class="number">50</span>, second=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime对象 格式化时间</span></span><br><span class="line">t.strftime(<span class="string">"%m-%d %H:%M:%S"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转时间类型</span></span><br><span class="line">datetime.strptime(<span class="string">"2019-08-06"</span>, <span class="string">"%Y-%m-%d"</span>)  <span class="comment"># 第2个参数表示如何解析前面的字符串</span></span><br></pre></td></tr></table></figure><h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><p>注意：datetime 下的 time 与 time 模块不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.time())<span class="comment"># 返回的UTC时间，是从1970.1.1到现在的秒数</span></span><br><span class="line">print(time.ctime(time.time())) <span class="comment"># 接收一个以秒为单位的时间，然后转换成本地时间的字符串表示。</span></span><br><span class="line">print(time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">print(datetime.now())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1565268398.010132</span></span><br><span class="line"><span class="comment"># Thu Aug  8 20:46:38 2019</span></span><br><span class="line"><span class="comment"># 2019-08-08 20:46:38</span></span><br><span class="line"><span class="comment"># 2019-08-08 20:46:38.010703</span></span><br></pre></td></tr></table></figure><h4 id="时间的运算"><a href="#时间的运算" class="headerlink" title="时间的运算"></a>时间的运算</h4><p><code>datetime</code> 只能相减，得到 <code>tiemdelta</code> 对象：<code>datetime.timedelta(m, n)</code>表示相差m天n秒</p><p><code>tiemdelta</code>可以相加减，也可以与<code>datetime</code> 相加减得到新的 <code>datetime</code></p><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><ul><li><code>%y</code> 两位数的年份表示（00-99）</li><li><code>%Y</code> 四位数的年份表示（000-9999）</li><li><code>%m</code> 月份（01-12）</li><li><code>%d</code> 月内中的一天（0-31）</li><li><code>%H</code> 24小时制小时数（0-23）</li><li><code>%I</code> 12小时制小时数（01-12）</li><li><code>%M</code> 分钟数（00=59）</li><li><code>%S</code> 秒（00-59）</li><li><code>%F</code>  %Y-%m-%d的简写（2019-08-06）</li><li><code>%D</code>  %m/%d/%y的简写（08/06/19）</li><li><code>%a</code> 本地简化星期名称</li><li><code>%A</code> 本地完整星期名称</li><li><code>%b</code> 本地简化的月份名称</li><li><code>%B</code> 本地完整的月份名称</li><li><code>%c</code> 本地相应的日期表示和时间表示</li><li><code>%j</code> 年内的一天（001-366）</li><li><code>%p</code> 本地A.M.或P.M.的等价符</li><li><code>%U</code> 一年中的星期数（00-53）星期天为星期的开始</li><li><code>%w</code> 星期（0-6），星期天为星期的开始</li><li><code>%W</code> 一年中的星期数（00-53）星期一为星期的开始</li><li><code>%x</code> 本地相应的日期表示</li><li><code>%X</code> 本地相应的时间表示</li><li><code>%z</code> UTC 时区偏置，格式为+HHMM或-HHMM；如果是简单时区则为空</li><li><code>%Z</code> 当前时区的名称</li><li><code>%%</code> %号本身</li></ul><h3 id="tqdm"><a href="#tqdm" class="headerlink" title="tqdm"></a>tqdm</h3><p><a href="https://pypi.org/project/tqdm/#parameters" target="_blank" rel="noopener">https://pypi.org/project/tqdm/#parameters</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tqdm(self, iterable=<span class="keyword">None</span>, desc=<span class="keyword">None</span>, total=<span class="keyword">None</span>, leave=<span class="keyword">True</span>,file=<span class="keyword">None</span>, ncols=<span class="keyword">None</span>, mininterval=<span class="number">0.1</span>,maxinterval=<span class="number">10.0</span>, miniters=<span class="keyword">None</span>, ascii=<span class="keyword">None</span>, disable=<span class="keyword">False</span>,unit=<span class="string">'it'</span>, unit_scale=<span class="keyword">False</span>, dynamic_ncols=<span class="keyword">False</span>,smoothing=<span class="number">0.3</span>, bar_format=<span class="keyword">None</span>, initial=<span class="number">0</span>, position=<span class="keyword">None</span>,postfix=<span class="keyword">None</span>, unit_divisor=<span class="number">1000</span>):</span><br></pre></td></tr></table></figure><ul><li>desc：progressbar的前缀</li><li>leave : 默认True，结束后保留进度条</li><li>ascii：默认 False，如果True，进度条将以“123456789#”显示，而不是实线</li><li>ncols：整个消息的长度</li></ul><p>设置提示消息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pbar = tqdm([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>])</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> pbar:</span><br><span class="line">    time.sleep(<span class="number">0.25</span>)</span><br><span class="line">    pbar.set_description(<span class="string">"Processing %s"</span> % char)</span><br></pre></td></tr></table></figure><p>手动控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tqdm(total=<span class="number">100</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        pbar.update(<span class="number">10</span>) <span class="comment"># 每次进度增加10</span></span><br></pre></td></tr></table></figure><p>tqdm读取文件</p><p>​<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> codecs <span class="keyword">as</span> cs</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tqdm(cs.open(<span class="string">"1.txt"</span>),desc = <span class="string">"status: "</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pbar:</span><br><span class="line">        b+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> b % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">            pbar.update(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">print</span> b</span><br></pre></td></tr></table></figure></p><p>多重进度条</p><p><img src="/2019/08/06/python小模块/./多重进度条.gif" alt="Screenshot-Jupyter2"></p><p>除了 tqdm 构造函数之外，还有下面的构造函数可以用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tqdm</span><span class="params">(xrange<span class="params">(*args)</span>, **kwargs)</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">trange</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A shortcut for tqdm(xrange(*args), **kwargs).</span></span><br><span class="line"><span class="string">    On Python3+ range is used instead of xrange.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tqdm_gui</span><span class="params">(tqdm)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tgrange</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Experimental GUI version of trange!</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tnrange</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tqdm_notebook</span><span class="params">(tqdm)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Experimental IPython/Jupyter Notebook widget using tqdm!</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>用来处理Python运行时配置以及资源，从而可以与前当程序之外的系统环境交互，如：Python解释器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sys.argv     #命令行参数List，第一个元素是程序本身路径 </span><br><span class="line">sys.modules.keys()   #返回所有已经导入的模块列表 </span><br><span class="line">sys.exc_info()    #获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息 </span><br><span class="line">sys.exit(n)    #程序，正常退出时exit(0) </span><br><span class="line">sys.hexversion    #获取Python解释程序的版本值，16进制格式如：0x020403F0 </span><br><span class="line">sys.version    #获取Python解释程序的版本信息 </span><br><span class="line">sys.maxint     #最大的Int值 </span><br><span class="line">sys.maxunicode    #最大的Unicode值 </span><br><span class="line">sys.modules    #返回系统导入的模块字段，key是模块名，value是模块 </span><br><span class="line">sys.path     #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 </span><br><span class="line">sys.platform    #返回操作系统平台名称 </span><br><span class="line">sys.stdout     #标准输出  </span><br><span class="line">sys.stdin     #标准输入 </span><br><span class="line">sys.stderr     #错误输出  </span><br><span class="line">sys.exc_clear()   #用来清除当前线程所出现的当前的或最近的错误信息 </span><br><span class="line">sys.exec_prefix   #返回平台独立的python文件安装的位置 </span><br><span class="line">sys.byteorder    #本地字节规则的指示器，big-endian平台的值是&apos;big&apos;,little-endian平台的值是&apos;little&apos; </span><br><span class="line">sys.copyright    #记录python版权相关的东西 </span><br><span class="line">sys.api_version   #解释器的C的API版本 </span><br><span class="line">sys.version_info   #获取Python解释器的版本信息 </span><br><span class="line">sys.getwindowsversion  #获取Windows的版本</span><br><span class="line">sys.getdefaultencoding  #返回当前你所用的默认的字符编码格式</span><br><span class="line">sys.getfilesystemencoding #返回将Unicode文件名转换成系统文件名的编码的名字</span><br><span class="line">sys.setdefaultencoding(name) #用来设置当前默认的字符编码</span><br><span class="line">sys.builtin_module_names #Python解释器导入的模块列表 </span><br><span class="line">sys.executable    #Python解释程序路径 </span><br><span class="line">sys.stdin.readline   #从标准输入读一行，sys.stdout.write(&quot;a&quot;) 屏幕输出a</span><br></pre></td></tr></table></figure><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.remove()       <span class="comment">#删除文件 </span></span><br><span class="line">os.rename()       <span class="comment">#重命名文件</span></span><br></pre></td></tr></table></figure><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.chdir()       <span class="comment">#改变目录 </span></span><br><span class="line">os.mkdir/makedirs()   <span class="comment">#创建目录/多层目录 </span></span><br><span class="line">os.rmdir/removedirs   <span class="comment">#删除目录/多层目录 </span></span><br><span class="line">os.listdir()       <span class="comment">#列出目录下的文件名(不递归)</span></span><br><span class="line">os.walk()       <span class="comment">#列出目录下的所有文件名(递归)</span></span><br></pre></td></tr></table></figure><p><code>os.mkdir</code> 与<code>os.makedirs</code>的差别在于 <strong><code>os.makedirs</code> 会递归地去建立目录</strong>，也就是说连同中继的目录也会一起建立，就类似于 Linux 中的 <code>mkdir -p</code>．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;foo/bar&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">OSError: [Errno 2] No such file or directory: &apos;foo/bar&apos;</span><br><span class="line">&gt;&gt;&gt; os.makedirs(&apos;foo/bar&apos;)</span><br></pre></td></tr></table></figure><p>使用 <code>os.mkdir</code>时，如果你给定的 path 参数是个多层的 path，如果某个中继的目录不存在(比如说上例中的 foo), Python 将会报错．</p><p>但如果使用 <code>os.makedirs</code> 则 Python 会连同中间的目录一起建立．但有一点值得注意，当 path 末端的目录已经存在的话，os.makedirs 也是会引发例外．</p><h3 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h3><p><a href="https://docs.python.org/3/library/os.path.html#os.path.dirname" target="_blank" rel="noopener">https://docs.python.org/3/library/os.path.html#os.path.dirname</a></p><p>os模块包含普遍的操作系统功能。如果你希望你的程序能够与平台无关的话，这个模块是尤为重要的。</p><h4 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd()       <span class="comment"># 取得当前工作目录 </span></span><br><span class="line">os.path.abspath(path)<span class="comment"># 获取文件、目录的绝对路径</span></span><br><span class="line">os.path.basename()     <span class="comment"># 文件名 ，去掉目录路径</span></span><br><span class="line">os.path.dirname()     <span class="comment"># 目录路径 ，去掉文件名</span></span><br><span class="line"><span class="comment"># dirname 与 basename 组成完整的文件路径(绝对、相对路径都可以)</span></span><br><span class="line"></span><br><span class="line">os.path.join()      <span class="comment"># 将分离的各部分组合成一个路径名 </span></span><br><span class="line">os.path.split(path)     <span class="comment"># 返回(dirname(),basename())元组 </span></span><br><span class="line"><span class="comment"># 将路径名*path*分割为(head, tail) ， *tail* 路径名的最后部分，绝对不包含分隔符(/)  *head* 是 tail 之前的路径。如果*path* 以(/) 结尾, 那么*tail* 为空 </span></span><br><span class="line"></span><br><span class="line">os.path.splitdrive(path)<span class="comment"># 返回(盘符、远程地址,路径)元组</span></span><br><span class="line">os.path.splitext(path)<span class="comment"># 返回(剩余部分,扩展名)元组</span></span><br><span class="line"></span><br><span class="line">os.path.commonpath(paths) <span class="comment">#返回公共的父节点路径(有效路径)</span></span><br><span class="line">os.path.commonprefix(list) <span class="comment">#返回公共的路径前缀(字符串匹配，不一定是有效路径)</span></span><br><span class="line"><span class="comment"># commonprefix(['/usr/lib', '/usr/local/lib'])</span></span><br><span class="line"><span class="comment"># '/usr/l'</span></span><br><span class="line"><span class="comment"># commonpath(['/usr/lib', '/usr/local/lib'])</span></span><br><span class="line"><span class="comment"># '/usr'</span></span><br><span class="line"></span><br><span class="line">os.path.realpath(path) <span class="comment">#返回真实路径,消除符号链接，类似于abspath</span></span><br><span class="line">os.path.relpath(path, start=os.curdir)<span class="comment">#返回相对于指定的start的相对路径，默认是当前目录</span></span><br><span class="line"></span><br><span class="line">os.path.exists(path)        如果path存在，返回<span class="keyword">True</span>；如果path不存在，返回<span class="keyword">False</span>。</span><br><span class="line">os.path.isabs(path)     如果path是绝对路径，返回<span class="keyword">True</span>。</span><br><span class="line">os.path.isfile(path)      如果path是一个存在的文件，返回<span class="keyword">True</span>。否则返回<span class="keyword">False</span>。</span><br><span class="line">os.path.isdir(path)     如果path是一个存在的目录，则返回<span class="keyword">True</span>。否则返回<span class="keyword">False</span>。</span><br><span class="line">os.path.join(path1[, path2[, ...]])     将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。</span><br><span class="line"></span><br><span class="line">os.path.normcase(path)      在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。  </span><br><span class="line">os.path.normpath(path)      规范化路径。</span><br><span class="line"></span><br><span class="line">os.path.expanduser(path)<span class="comment"># 将路径中的~转义为真实的home目录地址，否则不做变化</span></span><br><span class="line">os.path.expandvars(path)<span class="comment"># 将路径中的环境变量转义为真实的值，否则不做变化</span></span><br></pre></td></tr></table></figure><p><code>os.path.normcase(path)</code></p><p>返回大小写正常化后的路径名。</p><p>对于 Mac、Unix，该操作没有效果（他们对<code>a.txt</code>,<code>A.txt</code>视为同一名称）</p><p>对于不区分大小写的文件系统，会将路径转为小写；</p><p>对于 window，前向斜杆<code>\</code> 会转为后向斜杆<code>/</code></p><h4 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">os.path.getatime\ctime\mtime   <span class="comment"># 分别返回最近访问、创建、修改时间 </span></span><br><span class="line">os.path.isfile(path)      <span class="comment"># 是否为文件</span></span><br><span class="line">os.path.isdir(path)      <span class="comment"># 是否为目录</span></span><br><span class="line">os.path.getsize()     <span class="comment"># 返回文件大小 </span></span><br><span class="line">os.path.exists(path)      <span class="comment"># 是否存在 </span></span><br><span class="line">os.path.isabs()      <span class="comment"># 是否为绝对路径 </span></span><br><span class="line">os.path.islink()<span class="comment"># 判断是否为连接符号，获取真实路径请看上面的realpath函数</span></span><br><span class="line">os.path.samefile(path1, path2)<span class="comment"># 是否是同一个文件</span></span><br><span class="line">os.path.sameopenfile(fp1, fp2)<span class="comment"># 是否指向同一个文件</span></span><br></pre></td></tr></table></figure><h3 id="configparser"><a href="#configparser" class="headerlink" title="configparser"></a>configparser</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#实例化ConfigParser</span><br><span class="line">cf = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">#获取当前的绝对路径</span><br><span class="line">current_path = os.path.abspath(__file__)</span><br><span class="line">#当前文件的目录</span><br><span class="line">now_cig = os.path.dirname(current_path)</span><br><span class="line">#拼接配置文件路径</span><br><span class="line">con_cig = os.path.join(now_cig + &quot;/config/config.ini&quot;)</span><br><span class="line">#读取配置文件</span><br><span class="line">cf.read(con_cig)</span><br><span class="line"></span><br><span class="line">#打印配置文件里面section名为&quot;people&quot;里面的options</span><br><span class="line">print(cf.options(section=&apos;people&apos;))</span><br><span class="line">#打印配置文件里面section里面的某个potions的value</span><br><span class="line">print(cf.get(&apos;people&apos;,&apos;name&apos;))</span><br><span class="line"></span><br><span class="line">#加添section</span><br><span class="line">cf.add_section(&apos;cc&apos;)</span><br><span class="line">#设置指定section的key=value</span><br><span class="line">cf.set(&apos;cc&apos;,&apos;aa&apos;,&apos;bb&apos;)</span><br><span class="line">print(cf.options(section=&apos;cc&apos;))</span><br></pre></td></tr></table></figure><h3 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h3><p><a href="https://docs.python.org/3/library/shutil.html#shutil.disk_usage" target="_blank" rel="noopener">https://docs.python.org/3/library/shutil.html#shutil.disk_usage</a></p><h4 id="从文件对象拷贝"><a href="#从文件对象拷贝" class="headerlink" title="从文件对象拷贝"></a>从文件对象拷贝</h4><p><code>copyfileobj(fsrc, fdst[, length])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with 可以同时 支持 多个上下文管理器</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./1.txt"</span>,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f1, open(<span class="string">'./2,txt'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    su.copyfileobj(f1,f2)</span><br></pre></td></tr></table></figure><h4 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p><code>copyfile(src, dst, *, follow_symlinks=True)</code></p><p>从 src复制的文件内容到 dst 文件中，<strong>只复制内容，不包含元数据</strong></p><p><strong>dst 必须是目标文件名，而不是目录</strong></p><p><code>copy(src, dst, *, follow_symlinks=True*)</code></p><p>复制文件数据、权限数据；其他的元数据（创建时间、修改时间）没有保留</p><p>dst允许是目录，或者文件名</p><p><code>copy2(src, dst, *, follow_symlinks=True)</code></p><p>与 copy 一样，除了<strong>会尽量保存文件的元数据</strong></p><h5 id="移动-文件-目录"><a href="#移动-文件-目录" class="headerlink" title="移动(文件/目录)"></a>移动(文件/目录)</h5><p><code>move(src, dst, copy_function=copy2)</code></p><p>将文件或者目录复制到 dst</p><h4 id="目录操作-1"><a href="#目录操作-1" class="headerlink" title="目录操作"></a>目录操作</h4><h5 id="复制-1"><a href="#复制-1" class="headerlink" title="复制"></a>复制</h5><p><code>copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)</code></p><p>将递归地将整个目录文件复制到 dst，dst 必须不存在</p><p>例子：跳过指定的文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure><p>利用 ignore 进行日志记录功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_logpath</span><span class="params">(path, names)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'Working in %s'</span>, path)</span><br><span class="line">    <span class="keyword">return</span> []   <span class="comment"># nothing will be ignored</span></span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=_logpath)</span><br></pre></td></tr></table></figure><h5 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h5><p>参考 <code>move</code></p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><code>rmtree(path, ignore_errors=False, onerror=None)</code></p><p>删除整个目录，<em>path</em> 必须指向目录 (不可以是指向目录的符号链接).</p><p>例子：处理只读的文件，尝试删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="string">"清除 readonly bit 并重新尝试删除"</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure><h5 id="ignore-patterns"><a href="#ignore-patterns" class="headerlink" title="ignore_patterns"></a>ignore_patterns</h5><p>This factory function creates a function that can be used as a callable for <a href="https://docs.python.org/3/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>’s <em>ignore</em> argument, ignoring files and directories that match one of the glob-style <em>patterns</em>provided.</p><h4 id="文件状态操作"><a href="#文件状态操作" class="headerlink" title="文件状态操作"></a>文件状态操作</h4><h5 id="复制文件权限"><a href="#复制文件权限" class="headerlink" title="复制文件权限"></a>复制文件权限</h5><p><code>copymode(src, dst, *, follow_symlinks=True)</code></p><p>从 src 复制 permission bits 到 <em>dst</em>。文件内容、拥有者、组都不受影响</p><h5 id="复制文件状态"><a href="#复制文件状态" class="headerlink" title="复制文件状态"></a>复制文件状态</h5><p><code>copystat(src, dst, *, follow_symlinks=True)</code></p><p>从 src 复制 permission bits、 last access time、last modification time、 flags 到 <em>dst</em>. 在 linux 中，还会尝试复制 “extended attributes” </p><p>文件内容、拥有者、组都不受影响 </p><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><p><code>chown(path, user=None, group=None)</code></p><p>修改 path 的用户或者组</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="磁盘使用情况"><a href="#磁盘使用情况" class="headerlink" title="磁盘使用情况"></a>磁盘使用情况</h5><p><code>disk_usage(path)</code></p><p>返回磁盘的使用情况统计结果元组：<em>total</em>, <em>used</em>,  <em>free</em>, 单位是 bytes.</p><h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><p><code>which(cmd, mode=os.F_OK | os.X_OK, path=None)</code></p><p>查看命令的执行程序名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutil.which(<span class="string">"python"</span>)</span><br><span class="line"><span class="comment"># '/Users/jizhongxian/anaconda3/bin/python'</span></span><br></pre></td></tr></table></figure><h4 id="Archiving-operations-压缩包操作"><a href="#Archiving-operations-压缩包操作" class="headerlink" title="Archiving operations(压缩包操作)"></a>Archiving operations(压缩包操作)</h4><p>用到再看</p><p><a href="https://docs.python.org/3/library/shutil.html#archiving-operations" target="_blank" rel="noopener">https://docs.python.org/3/library/shutil.html#archiving-operations</a></p><h3 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h3><p>glob 规则：<a href="http://www.man7.org/linux/man-pages/man7/glob.7.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man7/glob.7.html</a></p><h4 id="最常用的通配符是-、-、"><a href="#最常用的通配符是-、-、" class="headerlink" title="最常用的通配符是 *、?、[]"></a>最常用的通配符是 *、?、[]</h4><table><thead><tr><th>通配符</th><th>描述</th><th>例子</th><th>匹配</th><th>不匹配</th></tr></thead><tbody><tr><td>*</td><td>匹配任意数量的字符包括空字符</td><td>Law*</td><td>Law, Laws, or Lawyer</td><td></td></tr><tr><td></td><td></td><td>*Law*</td><td>Law, GrokLaw, or Lawyer.</td><td></td></tr><tr><td>?</td><td>匹配任意一个字符</td><td>?at</td><td>Cat, cat, Bat or bat</td><td>at</td></tr><tr><td>[abc]</td><td>匹配任意一个包含的字符</td><td>[CB]at</td><td>Cat or Bat</td><td>cat or bat</td></tr><tr><td>[a-z]</td><td>匹配任意一个给定范围的字符</td><td>Letter[0-9]</td><td>Letter0, Letter1 etc.</td><td>Letters or Letter</td></tr><tr><td>**</td><td>匹配任意的目录(包括当前目录)</td><td>*<em>/\</em>.js</td><td>ss.js, a/hh.js, a/b/c.js</td></tr></tbody></table><h4 id="在Linux和POSIX系统中-…-的扩展"><a href="#在Linux和POSIX系统中-…-的扩展" class="headerlink" title="在Linux和POSIX系统中[…]的扩展"></a>在Linux和POSIX系统中[…]的扩展</h4><table><thead><tr><th>通配符</th><th>描述</th><th>例子</th><th>匹配</th><th>不匹配</th></tr></thead><tbody><tr><td>[!abc]</td><td>不匹配任意一个包含的字符</td><td>[!C]at</td><td>Bat, bat, or cat</td><td>Cat</td></tr><tr><td>[!a-z]</td><td>不匹配任意一个给定范围的字符</td><td>Letter[!3-5]</td><td>Letter1, Letter2 etc.</td><td>Letter3, Letter4 or Letter5</td></tr></tbody></table><h4 id="与正则的比较："><a href="#与正则的比较：" class="headerlink" title="与正则的比较："></a>与正则的比较：</h4><table><thead><tr><th>Glob的通配符</th><th>等价正则的表达式</th></tr></thead><tbody><tr><td>?</td><td>.</td></tr><tr><td>*</td><td>.*</td></tr></tbody></table><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>Glob尝试匹配整个字符串，而不是片段</strong>。<code>S*.DOC</code>将匹配S.DOC和SA.DOC，但不匹配POST.DOC或SURREY.DOCKS，正则只匹配子串除非使用<code>^</code> 和<code>$</code>。所以<code>S*.DOC</code>的等价正则是<code>^S.*\.DOC$</code>。</li><li>路径分隔符（unix的/，windows的\）不会被<code>? *</code>匹配。如果要匹配，需要用<code>**</code>匹配任意层级的目录(包括当前目录)  <code>**/*.js  ==&gt;  a/b/c.js</code></li><li><code>[^...]</code>是无效的</li><li><code>.</code>开头的文件被 glob 视为特殊的文件，<code>*</code>匹配不到他，需要显式处理 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">[<span class="string">'card.gif'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'.c*'</span>) <span class="comment">#显式地指定.</span></span><br><span class="line">[<span class="string">'.card.gif'</span>]</span><br></pre></td></tr></table></figure></li></ul><h4 id="glob-1"><a href="#glob-1" class="headerlink" title="glob"></a>glob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.glob(pathname, *, recursive=False)</span><br></pre></td></tr></table></figure><p>返回符合 pathname 模式的路径列表，recursive会递归地查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">'./[0-9].*'</span>)</span><br><span class="line"><span class="comment"># ['./1.gif', './2.txt']</span></span><br><span class="line">glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line"><span class="comment"># ['1.gif', 'card.gif']</span></span><br><span class="line">glob.glob(<span class="string">'?.gif'</span>)</span><br><span class="line"><span class="comment"># ['1.gif']</span></span><br><span class="line">glob.glob(<span class="string">'**/*.txt'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># ['2.txt', 'sub/3.txt']</span></span><br><span class="line">glob.glob(<span class="string">'./**/'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># ['./', './sub/']</span></span><br></pre></td></tr></table></figure><h4 id="iglob"><a href="#iglob" class="headerlink" title="iglob"></a>iglob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.iglob(pathname, *, recursive=False)</span><br></pre></td></tr></table></figure><p>与 glob 作用相同，只不过返回的一个迭代器</p><h4 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.escape(pathname)</span><br></pre></td></tr></table></figure><p>转义所有的字符(<code>&#39;?&#39;</code>, <code>&#39;*&#39;</code> and <code>&#39;[&#39;</code>)。</p><p>比如<code>escape(&#39;//?/c:/Quo vadis?.txt&#39;)</code> 返回 <code>&#39;//?/c:/Quovadis[?].txt&#39;</code>.</p><h3 id="fnmatch"><a href="#fnmatch" class="headerlink" title="fnmatch"></a>fnmatch</h3><table><thead><tr><th style="text-align:left">Pattern</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">matches everything</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">matches any single character</td></tr><tr><td style="text-align:left"><code>[seq]</code></td><td style="text-align:left">matches any character in <em>seq</em></td></tr><tr><td style="text-align:left"><code>[!seq]</code></td><td style="text-align:left">matches any character not in <em>seq</em></td></tr></tbody></table><p>(<code>&#39;/&#39;</code> on Unix) <code>.</code>开头的文件，不是特殊文件</p><h4 id="fnmatch-1"><a href="#fnmatch-1" class="headerlink" title="fnmatch"></a>fnmatch</h4><ul><li><code>fnmatch.fnmatch(filename, pattern)</code></li></ul><p>测试 <em>filename</em> 是否匹配 <em>pattern</em> 字符串,  参数都是用 <a href="https://docs.python.org/3/library/os.path.html#os.path.normcase" target="_blank" rel="noopener"><code>os.path.normcase()</code></a>规范过了。 <a href="https://docs.python.org/3/library/fnmatch.html#fnmatch.fnmatchcase" target="_blank" rel="noopener"><code>fnmatchcase()</code></a> 用于 大小写敏感的比较, 不论那是否是该操作系统的标准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fnmatch</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>):</span><br><span class="line">    <span class="keyword">if</span> fnmatch.fnmatch(file, <span class="string">'*.txt'</span>):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure><h4 id="fnmatchcase"><a href="#fnmatchcase" class="headerlink" title="fnmatchcase"></a>fnmatchcase</h4><ul><li><code>fnmatch.fnmatchcase(filename, pattern)</code><br>大小写敏感的比较，函数中不使用<a href="https://docs.python.org/3/library/os.path.html#os.path.normcase" target="_blank" rel="noopener"><code>os.path.normcase()</code></a>.</li></ul><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><ul><li><code>fnmatch.filter(names, pattern)</code><br>返回列表 <em>names</em> 中符合 <em>pattern</em> 的子列表，等价于 <code>[n for n in namesif fnmatch(n, pattern)]</code>, 但内部更进行了高效地实现。</li></ul><h4 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h4><ul><li><code>fnmatch.translate(pattern)</code><br>将 shell-风格的 <em>pattern</em> 转为正则表达式 <a href="https://docs.python.org/3/library/re.html#re.match" target="_blank" rel="noopener"><code>re.match()</code></a>.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fnmatch, re</span><br><span class="line"></span><br><span class="line">regex = fnmatch.translate(<span class="string">'*.txt'</span>)</span><br><span class="line">print(regex)</span><br><span class="line"><span class="comment"># '(?s:.*\\.txt)\\Z'</span></span><br><span class="line">reobj = re.compile(regex)</span><br><span class="line">reobj.match(<span class="string">'foobar.txt'</span>)</span><br><span class="line"><span class="comment"># &lt;re.Match object; span=(0, 10), match='foobar.txt'&gt;</span></span><br></pre></td></tr></table></figure></li></ul></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 工具 </tag>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python模块-logging</title>
      <link href="/2019/08/06/python%E6%A8%A1%E5%9D%97-logging/"/>
      <url>/2019/08/06/python%E6%A8%A1%E5%9D%97-logging/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>python logging 模块的使用以及详细讲解</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>logging模块定义了以下几个日志等级，它允许开发人员自定义其他日志级别，但是这是不被推荐的，尤其是在开发供别人使用的库时，因为这会导致日志级别的混乱。</p><table><thead><tr><th>日志等级（level）</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>最详细的日志信息，典型应用场景是 问题诊断</td></tr><tr><td>INFO</td><td>信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作</td></tr><tr><td>WARNING</td><td>当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的</td></tr><tr><td>ERROR</td><td>由于一个更严重的问题导致某些功能不能正常运行时记录的信息</td></tr><tr><td>CRITICAL</td><td>当发生严重错误，导致应用程序不能继续运行时记录的信息</td></tr></tbody></table><p>默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明<strong>默认的日志级别设置为WARNING</strong>（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG）而日志的信息量是依次增多的；</p><p>开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试；</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>logging模块提供了两种记录日志的方式：</p><ul><li>第一种方式是使用logging提供的模块级别的函数</li><li>第二种方式是使用Logging日志系统的四大组件</li></ul><p>首先来看一下第一种，通过logging提供的模块级别的函数进行日志记录。</p><p>logging模块定义的模块级别的常用函数</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>logging.debug(msg, *args, **kwargs)</td><td>创建一条严重级别为DEBUG的日志记录</td></tr><tr><td>logging.info(msg, *args, **kwargs)</td><td>创建一条严重级别为INFO的日志记录</td></tr><tr><td>logging.warning(msg, *args, **kwargs)</td><td>创建一条严重级别为WARNING的日志记录</td></tr><tr><td>logging.error(msg, *args, **kwargs)</td><td>创建一条严重级别为ERROR的日志记录</td></tr><tr><td>logging.critical(msg, *args, **kwargs)</td><td>创建一条严重级别为CRITICAL的日志记录</td></tr><tr><td>logging.log(level, *args, **kwargs)</td><td>创建一条严重级别为level的日志记录</td></tr><tr><td>logging.basicConfig(**kwargs)</td><td>对root logger进行一次性配置</td></tr></tbody></table><p>其中<code>logging.basicConfig(**kwargs)</code>函数用于指定“要记录的日志级别”、“日志格式”、“日志输出位置”、“日志文件的打开模式”等信息，其他几个都是用于记录各个级别日志的函数。</p><p>具体例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,<span class="comment"># 控制台打印的日志级别</span></span><br><span class="line">                    filename=<span class="string">'new.log'</span>,</span><br><span class="line">                    filemode=<span class="string">'w'</span>,<span class="comment"># 写模式：a和w，w就是写模式，a是追加模式，默认是追加模式</span></span><br><span class="line">                    format= <span class="string">'%(asctime)s - %(pathname)s[line:%(lineno)d] - %(name)s - %(levelname)s: %(message)s'</span>, <span class="comment"># 日志格式</span></span><br><span class="line">                    datefmt=<span class="string">'%Y-%m-%d  %H:%M:%S %a '</span>    <span class="comment"># 日期格式</span></span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"info"</span>)</span><br><span class="line">logging.info(<span class="string">"info"</span>)</span><br><span class="line">logging.warning(<span class="string">"warning"</span>)</span><br><span class="line">logging.error(<span class="string">"error"</span>)</span><br><span class="line">logging.critical(<span class="string">"critical"</span>)</span><br></pre></td></tr></table></figure><h4 id="关于-basicConfig-说明"><a href="#关于-basicConfig-说明" class="headerlink" title="关于 basicConfig 说明"></a>关于 basicConfig 说明</h4><p>主要的配置是通过<code>basicConfig</code>来定制的：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">level</td><td style="text-align:left">指定日志器的日志级别，默认是 WARNING 级别，因此 DEBUG、INFO 都不会输出</td></tr><tr><td style="text-align:left">filename</td><td style="text-align:left">指定日志输出目标文件的文件名（可以写文件名也可以写文件的完整的绝对路径，写文件名日志放执行文件目录下，写完整路径按照完整路径生成日志文件），指定该设置项后日志信息就<strong>不会被输出到控制台了</strong>，如果需要同时显示，请看后面的组件用法。</td></tr><tr><td style="text-align:left">filemode</td><td style="text-align:left">指定日志文件的打开模式，默认为<code>a</code>,追加的方式，该选项要在filename指定时才有效</td></tr><tr><td style="text-align:left">stream</td><td style="text-align:left">指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 <code>ValueError</code>异常</td></tr><tr><td style="text-align:left">handlers</td><td style="text-align:left">Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。</td></tr><tr><td style="text-align:left">format</td><td style="text-align:left">指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段请看<strong>Formater</strong>一节</td></tr><tr><td style="text-align:left">datefmt</td><td style="text-align:left">指定日期/时间格式。需要注意的是，该选项要在format中<strong>包含时间字段%(asctime)s时才有效</strong></td></tr><tr><td style="text-align:left">style</td><td style="text-align:left">Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为’%’、’{‘和’$’，默认为’%’</td></tr></tbody></table><p>注意点：</p><ul><li><code>logging.basicConfig()</code>函数是一个一次性的简单配置工具使，也就是说<strong>只有在第一次调用该函数时会起作用</strong>，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作。</li><li>日志器（Logger）是有层级关系的，上面调用的logging模块级别的函数所使用的日志器是<code>RootLogger</code>类的实例，其名称为’root’，它是处于日志器层级关系最顶层的日志器，且<strong>该实例是以单例模式存在的</strong>。</li><li>如果要记录的日志中包含变量数据，可使用一个格式字符串作为这个事件的描述消息（<code>logging.debug</code>、<code>logging.info</code>等函数的第一个参数），然后将变量数据作为第二个参数<code>*args</code>的值进行传递，如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.warning(&apos;%s is %d years old.&apos;, &apos;Tom&apos;, 10)</span><br><span class="line"># WARNING:root:Tom is 10 years old.</span><br></pre></td></tr></table></figure></li></ul><p>其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已。这里其实创建了一个 名为<code>root</code>的日志器组件，是一个默认的、单例的 logger 组件。接下来我们看一下第二种。</p><h3 id="Logging-组件"><a href="#Logging-组件" class="headerlink" title="Logging 组件"></a>Logging 组件</h3><p>logging模块就是通过下面这些组件来完成日志处理的，上面所使用的logging模块级别的函数也是通过这些组件对应的类来实现的。</p><p>在介绍logging模块的日志处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>它们之间的合作关系如下：</p><ul><li>日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</li><li>不同的处理器（handler）可以将日志输出到不同的位置；</li><li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</li><li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</li><li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li></ul><p>简单点说就是：<strong>日志器（logger）是入口，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</strong></p><h3 id="日志流处理简要流程"><a href="#日志流处理简要流程" class="headerlink" title="日志流处理简要流程"></a>日志流处理简要流程</h3><ol><li><p>创建一个logger</p></li><li><p>设置下logger的日志的等级</p></li><li><p>创建合适的Handler(FileHandler要有路径)</p></li><li><p>设置下每个Handler的日志等级。</p></li><li><p>创建下日志的格式Formater</p></li><li><p>向Handler中添加上面创建的Formater</p></li><li><p>将上面创建的Handler注册到logger中</p></li><li><p>打印输出logger.debug\logger.info\logger.warning\logger.error\logger.critical</p></li></ol><blockquote><p>为什么会有两个<code>setLevel()</code>方法？logger 的级别决定了消息是否要传递给处理器。每个handler的级别决定了消息是否要分发到指定目标</p></blockquote><p>从“简单使用”一节中我们了解到了<code>logging.debug()</code>、<code>logging.info()</code>等函数分别用以记录不同级别的日志信息 ，<code>logging.basicConfig()</code>用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到 root logger 中。</p><p>接下来就按照上面的流程来介绍高级的用法，来满足各种需求。</p><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><h4 id="日志器的获取"><a href="#日志器的获取" class="headerlink" title="日志器的获取"></a>日志器的获取</h4><p>如何获取一个Logger对象呢？</p><ol><li>通过Logger类的实例化方法创建一个Logger类的实例，</li><li>但是我们通常都是用第二种方式：<code>logging.getLogger(&#39;name&#39;)</code>方法。</li></ol><p><code>logging.getLogger(&#39;name&#39;)</code>方法有一个可选参数name，该参数表示将要返回的日志器的名称标识， 默认为<code>root</code>。若以相同的name参数值多次调用<code>getLogger()</code>方法，将会返回指向<strong>同一个logger对象的引用</strong>。</p><h4 id="日志器的继承"><a href="#日志器的继承" class="headerlink" title="日志器的继承"></a>日志器的继承</h4><ul><li>logger的名称是以<code>.</code>分割的层级结构，每个<code>.</code>后面的logger都是<code>.</code>前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 <code>foo.bar</code>, <code>foo.bar.baz</code> 和 <code>foo.bam</code>都是 foo 的后代。</li><li>logger有一个”有效等级（effective level）”的概念。如果一个logger上没有被明确设置一个level，那么该logger就使用它parent的level。如果它的parent也没有明确设置level，则继续向上查找parent的parent的有效level，依次类推，直到找到个一个明确设置了level的祖先为止。需要说明的是，root logger总是会有一个明确的level设置（默认为 WARNING）。当决定是否去处理一个已发生的事件时，<strong>logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理</strong>。</li><li>child loggers在完成对日志消息的处理后，默认会将日志消息传递给与它们的祖先loggers相关的handlers。因此，我们不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。</li></ul><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>Handler对象的作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）。Logger对象可以通过addHandler()方法为自己添加0个或者更多个handler对象。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>1）把所有日志都发送到一个日志文件中；</li><li>2）把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>3）把所有严重级别为critical的日志发送到一个email邮件地址。这种场景就需要3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fh = logging.FileHandler(&quot;jizx_log.txt&quot;,encoding=&quot;utf-8&quot;) # 创建一个文件 handler 用于注册到 logger 中</span><br><span class="line">Handler.setLevel(lel):指定被处理的信息级别，低于lel级别的信息将被忽略</span><br><span class="line">Handler.setFormatter()：给这个handler选择一个格式</span><br><span class="line">Handler.addFilter(filt)、Handler.removeFilter(filt)：新增或删除一个filter对象</span><br></pre></td></tr></table></figure><p>应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了素有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些常用的Handler：</p><table><thead><tr><th style="text-align:left">Handler</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">logging.StreamHandler([strm])</td><td style="text-align:left">将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。默认是sys.stderr</td></tr><tr><td style="text-align:left">logging.FileHandler(filename[,mode])</td><td style="text-align:left">将日志消息发送到磁盘文件，默认<code>mode</code>是<code>a</code>,文件大小会无限增长。还可是<code>w</code></td></tr><tr><td style="text-align:left">logging.handlers.RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])</td><td style="text-align:left">将日志消息发送到磁盘文件，并支持日志文件按大小切割。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。<br>backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。</td></tr><tr><td style="text-align:left">logging.hanlders.TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])</td><td style="text-align:left">将日志消息发送到磁盘文件，并支持日志文件按时间切割。interval是时间间隔。when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：S 秒、M 分、H 小时、D 天、W 每星期（interval==0时代表星期一）、midnight 每天凌晨</td></tr><tr><td style="text-align:left">logging.handlers.HTTPHandler</td><td style="text-align:left">将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td style="text-align:left">logging.handlers.SMTPHandler</td><td style="text-align:left">将日志消息发送给一个指定的email地址</td></tr><tr><td style="text-align:left">logging.NullHandler</td><td style="text-align:left">该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免’No handlers could be found for logger XXX’信息的出现。</td></tr></tbody></table><h3 id="formater"><a href="#formater" class="headerlink" title="formater"></a>formater</h3><p>Formater对象用于配置日志信息的最终顺序、结构和内容。与logging.Handler基类不同的是，应用代码可以直接实例化Formatter类。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。</p><p>Formatter类的构造方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.Formatter.__init__(fmt=None, datefmt=None, style=&apos;%&apos;)</span><br></pre></td></tr></table></figure><p>该构造方法接收3个可选参数：</p><ul><li>fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</li><li>datefmt：指定日期格式字符串，如果不指定该参数则默认使用”%Y-%m-%d %H:%M:%S”</li><li>style：Python 3.2新增的参数，可取值为 ‘%’, ‘{‘和 ‘$’，如果不指定该参数则默认使用’%’</li></ul><p><strong>一般直接用<code>logging.Formatter(fmt, datefmt)</code></strong></p><h4 id="format格式字符串说明"><a href="#format格式字符串说明" class="headerlink" title="format格式字符串说明"></a>format格式字符串说明</h4><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>将日志的时间构造成可读的形式，默认情况下是‘2016-02-08 12:00:00,123’精确到毫秒</td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger</td></tr><tr><td>filename</td><td>%(filename)s</td><td>调用日志输出函数的模块的文件名； pathname的文件名部分，包含文件后缀</td></tr><tr><td>funcName</td><td>%(funcName)s</td><td>由哪个function发出的log， 调用日志输出函数的函数名</td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>日志的最终等级（被filter修改后的）</td></tr><tr><td>message</td><td>%(message)s</td><td>日志信息， 日志记录的文本内容</td></tr><tr><td>lineno</td><td>%(lineno)d</td><td>当前日志的行号， 调用日志输出函数的语句所在的代码行</td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td>完整路径 ，调用日志输出函数的模块的完整路径名，可能没有</td></tr><tr><td>process</td><td>%(process)s</td><td>当前进程， 进程ID。可能没有</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)s</td><td>当前线程， 线程ID。可能没有</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr><tr><td>module</td><td>%(module)s</td><td>调用日志输出函数的模块名， filename的名称部分，不包含后缀即不包含文件后缀的文件名</td></tr><tr><td>created</td><td>%(created)f</td><td>当前时间，用UNIX标准的表示时间的浮点数表示； 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>输出日志信息时的，自Logger创建以 来的毫秒数； 日志事件发生的时间相对于logging模块加载时间的相对毫秒数</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的毫秒部分。logging.basicConfig()中用了参数datefmt，将会去掉asctime中产生的毫秒部分，可以用这个加上</td></tr></tbody></table><h3 id="Filter类（暂时了解）"><a href="#Filter类（暂时了解）" class="headerlink" title="Filter类（暂时了解）"></a>Filter类（暂时了解）</h3><p>Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class logging.Filter(name=&apos;&apos;)</span><br><span class="line">    filter(record)</span><br></pre></td></tr></table></figure><p>比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。</p><p>filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。</p><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><p><strong>需求：</strong></p><p>输出log到控制台，并将日志写入log文件，保存2种类型的log：</p><ul><li><p>all.log 保存debug, info, warning, critical 信息</p></li><li><p>error.log则只保存error信息，同时按照时间自动分割日志文件</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging <span class="keyword">import</span> handlers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(object)</span>:</span></span><br><span class="line">    level_relations = &#123;</span><br><span class="line">        <span class="string">'debug'</span>: logging.DEBUG,</span><br><span class="line">        <span class="string">'info'</span>: logging.INFO,</span><br><span class="line">        <span class="string">'warning'</span>: logging.WARNING,</span><br><span class="line">        <span class="string">'error'</span>: logging.ERROR,</span><br><span class="line">        <span class="string">'crit'</span>: logging.CRITICAL</span><br><span class="line">    &#125;  <span class="comment"># 日志级别关系映射</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, level=<span class="string">'info'</span>, when=<span class="string">'D'</span>, backCount=<span class="number">3</span>, fmt=<span class="string">'%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s'</span>)</span>:</span></span><br><span class="line">        self.logger = logging.getLogger(filename)</span><br><span class="line">        self.logger.setLevel(self.level_relations.get(level))  <span class="comment"># 设置日志级别</span></span><br><span class="line">        format_str = logging.Formatter(fmt)  <span class="comment"># 设置日志格式</span></span><br><span class="line"></span><br><span class="line">        out_screen = logging.StreamHandler()  <span class="comment"># 往屏幕上输出</span></span><br><span class="line">        out_screen.setFormatter(format_str)  <span class="comment"># 设置屏幕上显示的格式</span></span><br><span class="line"></span><br><span class="line">        out_file = handlers.TimedRotatingFileHandler(filename=filename, when=when, backupCount=backCount, encoding=<span class="string">'utf-8'</span>)  <span class="comment"># 往文件里写入，指定间隔时间自动生成文件的处理器</span></span><br><span class="line">        out_file.setFormatter(format_str)  <span class="comment"># 设置文件里写入的格式</span></span><br><span class="line">        <span class="comment"># interval是时间间隔，backupCount是备份文件的个数，如果超过这个个数，就会自动删除，when是间隔的时间单位，单位有以下几种：</span></span><br><span class="line">        <span class="comment"># S 秒、M 分、H 小时、、D 天、、W 每星期（interval==0时代表星期一）、midnight 每天凌晨</span></span><br><span class="line"></span><br><span class="line">        self.logger.addHandler(out_screen)  <span class="comment"># 把对象加到logger里</span></span><br><span class="line">        self.logger.addHandler(out_file)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.debug(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.info(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warning</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.warning(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.error(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">critical</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.critical(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    log = Logger(<span class="string">'all.log'</span>,level=<span class="string">'debug'</span>)</span><br><span class="line">    log.logger.debug(<span class="string">'debug'</span>)</span><br><span class="line">    log.logger.info(<span class="string">'info'</span>)</span><br><span class="line">    log.logger.warning(<span class="string">u'警告'</span>)</span><br><span class="line">    log.logger.error(<span class="string">u'报错'</span>)</span><br><span class="line">    log.logger.critical(<span class="string">u'严重'</span>)</span><br><span class="line">    error_log= Logger(<span class="string">'error.log'</span>, level=<span class="string">'error'</span>)</span><br><span class="line">    error_log.logger.error(<span class="string">'error'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这种方法虽然调用简单，但是日志中“lineno”字段的信息就只会对应的到上面的 logger 类中的函数，而不是真正打印信息的行数(后期研究一下如何解决)</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    all_log = Logger(<span class="string">'all.log'</span>, level=<span class="string">'debug'</span>)</span><br><span class="line">    all_log.debug(<span class="string">'debug'</span>)</span><br><span class="line">    all_log.info(<span class="string">'info'</span>)</span><br><span class="line">    all_log.warning(<span class="string">u'警告'</span>)</span><br><span class="line">    all_log.error(<span class="string">u'报错'</span>)</span><br><span class="line">    all_log.critical(<span class="string">u'严重'</span>)</span><br><span class="line">    error_log=Logger(<span class="string">'error.log'</span>, level=<span class="string">'error'</span>)</span><br><span class="line">    error_log.error(<span class="string">'error'</span>)</span><br><span class="line">    error_log.critical(<span class="string">u'严重'</span>)</span><br></pre></td></tr></table></figure><p>参考:<a href="https://www.cnblogs.com/Nicholas0707/p/9021672.html" target="_blank" rel="noopener">https://www.cnblogs.com/Nicholas0707/p/9021672.html</a></p><p><a href="https://www.cnblogs.com/nancyzhu/p/8551506.html" target="_blank" rel="noopener">https://www.cnblogs.com/nancyzhu/p/8551506.html</a> 综合案例</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 工具 </tag>
            
            <tag> logging </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>anaconda与jupyter的使用和设置</title>
      <link href="/2019/08/04/anaconda%E4%B8%8Ejupyter%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/08/04/anaconda%E4%B8%8Ejupyter%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>jupyter 使用介绍、与 anaconda 的虚拟环境结合 、右键打开配置</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=D" target="_blank" rel="noopener">清华镜像站下载</a>   或者 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华镜像站anaconda首页</a></p></li><li><p>安装时，把Anaconda加入环境变量，这涉及到能否直接在cmd中使用conda、jupyter、ipython等命令，推荐打勾。如果没有打钩，后期请加入下面这些路径：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramData\Anaconda3;</span><br><span class="line">C:\ProgramData\Anaconda3\Library\mingw-w64\bin;</span><br><span class="line">C:\ProgramData\Anaconda3\Library\usr\bin;</span><br><span class="line">C:\ProgramData\Anaconda3\Library\bin;</span><br><span class="line">C:\ProgramData\Anaconda3\Scripts;</span><br></pre></td></tr></table></figure></li><li><p>配置镜像地址，否则从官方网站下载升级文件太慢</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure></li><li><p>推荐在默认环境下更新所有的包。打开 Anaconda Prompt （或者 Mac 下的终端），键入<code>conda upgrade —all</code></p></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy scipy pandas            <span class="comment"># 安装多个包</span></span><br><span class="line">conda install numpy=1.10                    <span class="comment"># 指定所需的包版本</span></span><br><span class="line">conda remove package_name                   <span class="comment"># 卸载包</span></span><br><span class="line">conda update package_name                   <span class="comment"># 更新包</span></span><br><span class="line">conda update --all                          <span class="comment"># 更新环境中的所有包（这样做常常很有用）</span></span><br><span class="line">conda list                                  <span class="comment"># 列出已安装的包</span></span><br><span class="line">conda search search_term                    <span class="comment"># 如果不知道要找的包的确切名称，可以尝试进行搜索</span></span><br></pre></td></tr></table></figure><h5 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看环境</span></span><br><span class="line">conda env list                              <span class="comment"># 列出你创建的所有环境</span></span><br><span class="line">conda info -e                               <span class="comment"># 列出你创建的所有环境</span></span><br><span class="line">conda info                                  <span class="comment"># 显示当前环境的全部相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑环境</span></span><br><span class="line">conda create -n env_name python=3.4 pandas  <span class="comment"># 创建环境 ，-n 是指名称</span></span><br><span class="line">conda env remove -n env_name --all          <span class="comment"># 删除指定的环境</span></span><br><span class="line">conda create -n new_env --<span class="built_in">clone</span> old_name    <span class="comment"># 克隆环境，实现重命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活/退出环境</span></span><br><span class="line">activate my_env                             <span class="comment"># 激活环境 window</span></span><br><span class="line">deactivate                                  <span class="comment"># 退出环境 window</span></span><br><span class="line">conda activate my_env                       <span class="comment"># 激活环境 OSX/Linux</span></span><br><span class="line">conda deactivate                            <span class="comment"># 退出环境 OSX/Linux</span></span><br><span class="line"><span class="built_in">source</span> activate my_env                      <span class="comment"># 激活环境 OSX/Linux(弃用)</span></span><br><span class="line"><span class="built_in">source</span> deactivate                           <span class="comment"># 退出环境 OSX/Linux(弃用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出环境信息文件，利用文件信息克隆环境</span></span><br><span class="line">conda env <span class="built_in">export</span> &gt; environment.yaml         <span class="comment"># 将包保存为YAML，共享此文件，而且其他人能够用于创建和你项目相同的环境</span></span><br><span class="line">conda env create -f environment.yaml        <span class="comment"># 利用环境文件创建相同环境</span></span><br></pre></td></tr></table></figure><blockquote><p>  对于不使用 conda 的用户，可以使用命令<code>pip freeze&gt; pip_requirements.txt</code>（<a href="https://pip.pypa.io/en/stable/reference/pip_freeze/" target="_blank" rel="noopener">详情</a>）将一个 pip_requirements.txt 文件导出并包括在其中。</p></blockquote><p>推荐 Mac/linux，在 <code>~/.bash_profile</code> 中添加别名，方便激活环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> activate=<span class="string">"source activate"</span></span><br><span class="line"><span class="built_in">alias</span> deactivate=<span class="string">"source deactivate"</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/python2webdata/p/10034528.html" target="_blank" rel="noopener">https://www.cnblogs.com/python2webdata/p/10034528.html</a></p><h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><p>激活环境后，输入<code>jupyter notebook</code>就打开了当前环境的 notebook（<strong>如果当前环境没有安装jupyter，那么会调用base的</strong>）</p><p>为了不用每次都先切换环境才能使用 jupyter，可以进行一下配置，直接在 jupyter 打开的网页中指定环境。</p><h4 id="使用anaconda的虚拟环境"><a href="#使用anaconda的虚拟环境" class="headerlink" title="使用anaconda的虚拟环境"></a>使用anaconda的虚拟环境</h4><ol><li><p>激活虚拟环境 <code>source activate 环境名称</code></p></li><li><p>安装 ipykernel，注意：在虚拟环境中安装 ipykernel</p><p> <code>conda install ipykernel</code></p></li><li><p>写入Jupyter 的 kernel中，还是在该虚拟环境中，运行命令 <code>python -m ipykernel install --user --name 环境名称 --display-name &quot;Python (环境名称)&quot;</code></p></li><li><p>打开Jupyter <code>jupyter notebook</code></p></li></ol><h4 id="右键打开Jupyter"><a href="#右键打开Jupyter" class="headerlink" title="右键打开Jupyter"></a>右键打开Jupyter</h4><ol><li><p>打开 regedit，定位到<code>HKEY_CLASSES_ROOT\Directory\Background\shell</code></p></li><li><p>右键新建“项”，输入名称“jupyter”，该名称将出现在右键的菜单上</p></li><li><p>然后在jupyter目录的右侧，新建一个字符串值<code>Icon</code>，设置为</p><p> <code>%USERPROFILE%\AppData\Local\Continuum\anaconda3\Menu\jupyter.ico</code>，该图标将出现在右键的菜单上</p></li><li><p>最后在jupyter目录下新建一个目录 “command”，点击command目录，修改右侧的值为<code>&quot;C:\Windows\System32\cmd.exe&quot; &quot;--working-dir&quot; &quot;%v.&quot; &quot;/k jupyter notebook&quot;</code></p><blockquote><p>cmd /c start dir：会打开一个新窗口后执行dir指令，原窗口会关闭；</p><p>cmd /k start dir：会打开一个新窗口后执行dir指令，原窗口不会关闭。</p></blockquote></li></ol><p><img src="/2019/08/04/anaconda与jupyter使用与设置/./jupyter注册表1.png" alt="jupyter注册表1"></p><p><img src="/2019/08/04/anaconda与jupyter使用与设置/./jupyter注册表2.png" alt="jupyter注册表2"></p><p>参考：<a href="https://blog.csdn.net/firing00/article/details/81866878" target="_blank" rel="noopener">https://blog.csdn.net/firing00/article/details/81866878</a></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 效率 </tag>
            
            <tag> anaconda </tag>
            
            <tag> jupyter </tag>
            
            <tag> 右键 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2019/08/04/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/04/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><code>ps -f</code>命令也能够表现子shell的嵌套关系</p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；</span><br><span class="line">-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；</span><br><span class="line"></span><br><span class="line">date [选项]... [+格式]</span><br><span class="line">　或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">Display the current time in the given FORMAT, or set the system date.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line">  -d, --date=STRING         显示由STRING 描述指定的时间, 不是默认的&apos;now&apos;</span><br><span class="line">  -f, --file=DATEFILE       like --date once for each line of DATEFILE</span><br><span class="line">  -I[TIMESPEC], --iso-8601[=TIMESPEC]  使用ISO 8601格式显示 date/time </span><br><span class="line">                            TIMESPEC可以设置为&apos;date&apos;, &apos;hours&apos;, &apos;minutes&apos;, &apos;seconds&apos;, &apos;ns&apos;  </span><br><span class="line">                            来指定显示的精度，默认是date</span><br><span class="line">  -r, --reference=文件   显示指定文件的最后修改时间</span><br><span class="line">  -R, --rfc-2822             以RFC 2822格式输出日期和时间</span><br><span class="line">                            例如：2006年8月7日，星期一 12:34:56 -0600</span><br><span class="line">      --rfc-3339=TIMESPEC   output date and time in RFC 3339 format.</span><br><span class="line">                            TIMESPEC=&apos;date&apos;, &apos;seconds&apos;, or &apos;ns&apos; for</span><br><span class="line">                            date and time to the indicated precision.</span><br><span class="line">                            Date and time components are separated by</span><br><span class="line">                            a single space: 2006-08-07 12:34:56-06:00</span><br><span class="line">  -s, --set=STRING          用描述时间的字符串 STRING 设置时间</span><br><span class="line">  -u, --utc, --universal    显示或设置 Coordinated Universal Time</span><br><span class="line">      --help显示此帮助信息并退出</span><br><span class="line">      --version显示版本信息并退出</span><br></pre></td></tr></table></figure><h4 id="格式化参数"><a href="#格式化参数" class="headerlink" title="格式化参数"></a>格式化参数</h4><p>给定的格式FORMAT 控制着输出，解释序列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  %%一个%</span><br><span class="line">  %a当前locale 的星期名缩写(例如： 日，代表星期日)</span><br><span class="line">  %A当前locale 的星期名全称 (如：星期日)</span><br><span class="line">  %b当前locale 的月名缩写 (如：一，代表一月)</span><br><span class="line">  %B当前locale 的月名全称 (如：一月)</span><br><span class="line">  %c当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)</span><br><span class="line">  %C世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)</span><br><span class="line">  %d按月计的日期(例如：01)</span><br><span class="line">  %D按月计的日期；等于%m/%d/%y</span><br><span class="line">  %e按月计的日期，添加空格，等于%_d</span><br><span class="line">  %F完整日期格式，等价于 %Y-%m-%d</span><br><span class="line">  %gISO-8601 格式年份的最后两位 (参见%G)</span><br><span class="line">  %GISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用</span><br><span class="line">  %h等于%b</span><br><span class="line">  %H小时(00-23)</span><br><span class="line">  %I小时(00-12)</span><br><span class="line">  %j按年计的日期(001-366)</span><br><span class="line">  %k   hour, space padded ( 0..23); same as %_H</span><br><span class="line">  %l   hour, space padded ( 1..12); same as %_I</span><br><span class="line">  %m   month (01..12)</span><br><span class="line">  %M   minute (00..59)</span><br><span class="line">  %n换行</span><br><span class="line">  %N纳秒(000000000-999999999)</span><br><span class="line">  %p当前locale 下的&quot;上午&quot;或者&quot;下午&quot;，未知时输出为空</span><br><span class="line">  %P与%p 类似，但是输出小写字母</span><br><span class="line">  %r当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)</span><br><span class="line">  %R24 小时时间的时和分，等价于 %H:%M</span><br><span class="line">  %s自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</span><br><span class="line">  %S秒(00-60)</span><br><span class="line">  %t输出制表符 Tab</span><br><span class="line">  %T时间，等于%H:%M:%S</span><br><span class="line">  %u星期，1 代表星期一</span><br><span class="line">  %U一年中的第几周，以周日为每星期第一天(00-53)</span><br><span class="line">  %VISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)</span><br><span class="line">  %w一星期中的第几日(0-6)，0 代表周一</span><br><span class="line">  %W一年中的第几周，以周一为每星期第一天(00-53)</span><br><span class="line">  %x当前locale 下的日期描述 (如：12/31/99)</span><br><span class="line">  %X当前locale 下的时间描述 (如：23:13:48)</span><br><span class="line">  %y年份最后两位数位 (00-99)</span><br><span class="line">  %Y年份</span><br><span class="line">  %z +hhmm数字时区(例如，-0400)</span><br><span class="line">  %:z +hh:mm数字时区(例如，-04:00)</span><br><span class="line">  %::z +hh:mm:ss数字时区(例如，-04:00:00)</span><br><span class="line">  %:::z数字时区带有必要的精度 (例如，-04，+05:30)</span><br><span class="line">  %Z按字母表排序的时区缩写 (例如，EDT)</span><br><span class="line"></span><br><span class="line">默认情况下，日期的数字区域以0填充。</span><br><span class="line">%后面可以加 下面这些标记：</span><br><span class="line">  -  (hyphen) do not pad the field</span><br><span class="line">  _  (underscore) pad with spaces</span><br><span class="line">  0  (zero) pad with zeros</span><br><span class="line">  ^  use upper case if possible</span><br><span class="line">  #  use opposite case if possible</span><br><span class="line"></span><br><span class="line">在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。</span><br><span class="line">作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的</span><br><span class="line">表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。</span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line">Convert seconds since the epoch (1970-01-01 UTC) to a date</span><br><span class="line">  $ date --date=&apos;@2147483647&apos;</span><br><span class="line"></span><br><span class="line">Show the time on the west coast of the US (use tzselect(1) to find TZ)</span><br><span class="line">  $ TZ=&apos;America/Los_Angeles&apos; date</span><br><span class="line"></span><br><span class="line">Show the local time for 9AM next Friday on the west coast of the US</span><br><span class="line">  $ date --date=&apos;TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri&apos;</span><br></pre></td></tr></table></figure><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +&quot;%Y-%m-%d&quot;</span><br></pre></td></tr></table></figure><h4 id="时间游走"><a href="#时间游走" class="headerlink" title="时间游走"></a>时间游走</h4><p>1.加减操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">date +%Y%m%d                   //显示前天年月日</span><br><span class="line">date -d &quot;+1 day&quot; +%Y%m%d       //显示前一天的日期</span><br><span class="line">date -d &quot;-1 day&quot; +%Y%m%d       //显示后一天的日期</span><br><span class="line">date -d &quot;-1 month&quot; +%Y%m%d     //显示上一月的日期</span><br><span class="line">date -d &quot;+1 month&quot; +%Y%m%d     //显示下一月的日期</span><br><span class="line">date -d &quot;-1 year&quot; +%Y%m%d      //显示前一年的日期</span><br><span class="line">date -d &quot;+1 year&quot; +%Y%m%d      //显示下一年的日期</span><br></pre></td></tr></table></figure><p>2.文字版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;1 day ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;               # 一天前</span><br><span class="line">date -d &quot;1 day&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;                   # 一天后</span><br><span class="line">date -d &quot;2009-12-12  1 year ago&quot; +&quot;%Y/%m/%d %H:%M.%S&quot;  # 指定时间的一年前</span><br><span class="line">date -d &quot;2009-12-12  1 year&quot; +&quot;%Y/%m/%d %H:%M.%S&quot;      # 指定时间的一年后</span><br></pre></td></tr></table></figure><p>设置时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date -s                        //设置当前时间，只有root权限才能设置，其他只能查看</span><br><span class="line">date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01               //设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2012-05-23&quot;  //这样可以设置全部时间</span><br></pre></td></tr></table></figure><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p><code>-e</code>：输出转义字符</p><p><code>-n</code>：不换行输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RCol='\e[0m'    # Text Reset</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds</span></span><br><span class="line">Bla='\e[0;30m';     BBla='\e[1;30m';    UBla='\e[4;30m';    IBla='\e[0;90m';    BIBla='\e[1;90m';   On_Bla='\e[40m';    On_IBla='\e[0;100m';</span><br><span class="line">Red='\e[0;31m';     BRed='\e[1;31m';    URed='\e[4;31m';    IRed='\e[0;91m';    BIRed='\e[1;91m';   On_Red='\e[41m';    On_IRed='\e[0;101m';</span><br><span class="line">Gre='\e[0;32m';     BGre='\e[1;32m';    UGre='\e[4;32m';    IGre='\e[0;92m';    BIGre='\e[1;92m';   On_Gre='\e[42m';    On_IGre='\e[0;102m';</span><br><span class="line">Yel='\e[0;33m';     BYel='\e[1;33m';    UYel='\e[4;33m';    IYel='\e[0;93m';    BIYel='\e[1;93m';   On_Yel='\e[43m';    On_IYel='\e[0;103m';</span><br><span class="line">Blu='\e[0;34m';     BBlu='\e[1;34m';    UBlu='\e[4;34m';    IBlu='\e[0;94m';    BIBlu='\e[1;94m';   On_Blu='\e[44m';    On_IBlu='\e[0;104m';</span><br><span class="line">Pur='\e[0;35m';     BPur='\e[1;35m';    UPur='\e[4;35m';    IPur='\e[0;95m';    BIPur='\e[1;95m';   On_Pur='\e[45m';    On_IPur='\e[0;105m';</span><br><span class="line">Cya='\e[0;36m';     BCya='\e[1;36m';    UCya='\e[4;36m';    ICya='\e[0;96m';    BICya='\e[1;96m';   On_Cya='\e[46m';    On_ICya='\e[0;106m';</span><br><span class="line">Whi='\e[0;37m';     BWhi='\e[1;37m';    UWhi='\e[4;37m';    IWhi='\e[0;97m';    BIWhi='\e[1;97m';   On_Whi='\e[47m';    On_IWhi='\e[0;107m';</span><br></pre></td></tr></table></figure><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat -A test   显示隐藏字符如^A,^B</span><br><span class="line">cat -n test   所有的行加上行号</span><br><span class="line">cat -b test  【有文本的行】 加上行号，【空白行】不算</span><br><span class="line">cat -T test   以^I显示制表符</span><br></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 2 -f log_file</span><br></pre></td></tr></table></figure><p><code>-f</code> 参数是 tail 命令的一个突出特性。它允许你在其他进程使用该文件时查看文件的内容。tail命令会保持活动状态，并不断显示添加到文件中的内容。这是实时监测系统日志的绝妙方式。</p><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>uniq命令用于报告或忽略文件中的重复行，<strong>查重复行的时候，只会检查相邻的行</strong>，因此一般与<a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort</a>命令结合使用，让重复的排在一起。比如下面：<code>aa</code> 统计结果是出现了 2 次，后面又有出现 1 次的 <code>aa</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 文本</span><br><span class="line">aa</span><br><span class="line">aa</span><br><span class="line">c</span><br><span class="line">aa</span><br><span class="line"></span><br><span class="line"># uniq 后</span><br><span class="line">uniq -c </span><br><span class="line">2 aa</span><br><span class="line">1 c</span><br><span class="line">1 aa</span><br></pre></td></tr></table></figure><p>常用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数；</span><br><span class="line">-u或——unique：仅显示出一次的行列；</span><br><span class="line">-d或--repeated：仅输出重复出现的行列，且重复的只输出一行；</span><br><span class="line">-D, --all-repeated   仅输出重复的行，有几行输出几行  </span><br><span class="line">-i, --ignore-case    不区分大小写  </span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;   指定要比较的前 n 个字符，忽略后面的内容</span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;         忽略前n列（空格分割），-f 1 忽略第一列</span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;   忽略前n个字符 -s 4 忽略前 4 个字符</span><br><span class="line">-z 忽略换行(不知道有什么用)</span><br></pre></td></tr></table></figure><p>提供的测试文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this is a test  </span><br><span class="line">this is a test  </span><br><span class="line">this is a test  </span><br><span class="line">i am tank  </span><br><span class="line">i love tank  </span><br><span class="line">i love tank  </span><br><span class="line">this is a test  </span><br><span class="line">whom have a try  </span><br><span class="line">WhoM have a try </span><br><span class="line">WhoM have a try1</span><br><span class="line">you  have a try  </span><br><span class="line">i want to abroad  </span><br><span class="line">those are good men  </span><br><span class="line">we are good men</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://blog.51yip.com/shell/1022.html" target="_blank" rel="noopener">http://blog.51yip.com/shell/1022.html</a></p><h4 id="两个文件的交并集"><a href="#两个文件的交并集" class="headerlink" title="两个文件的交并集"></a>两个文件的交并集</h4><p>如果你知道怎么用<code>sort/uniq</code>来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已经被uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat a b | sort | uniq &gt; c   # c is a union b 并集</span><br><span class="line">cat a b | sort | uniq -d &gt; c   # c is a intersect b 交集</span><br><span class="line">cat a b b | sort | uniq -u &gt; c   # c is set difference a - b 差集</span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h4><table><thead><tr><th style="text-align:left">选项</th><th></th><th>解释</th></tr></thead><tbody><tr><td style="text-align:left">-b</td><td>–ignore-leading-blanks</td><td>排序时忽略起始的空白，空格数量不固定时，该选项几乎是必须要使用的。”-n”选项隐含该选项。</td></tr><tr><td style="text-align:left">-c</td><td>–check</td><td>仅检查输入数据是不是已排序；未排序的话，会输出诊断信息，提示从哪一行开始乱序。</td></tr><tr><td style="text-align:left">-t</td><td>–field-separator=SEP</td><td>指定分隔符，如果是<code>\t</code>，需要这样<code>sort -t$&#39;\t&#39; file</code>。<strong>默认的分隔符为空白字符和非空白字符之间的空字符</strong>，<strong>并非网上众多文章所说的空格或制表符</strong>(By default, fields are separated by the empty string between a non-blank character and a blank character)。” foo bar”被分割为：`</td><td>foo</td><td>bar<code>（</code></td><td>`视为分割符）</td></tr><tr><td style="text-align:left">-u</td><td>–unique</td><td>在输出行中去除重复行，只识别用<code>-k</code>设定的域，发现都相同的才会删除，只要其中有一级不同都不会轻易删除的。</td></tr><tr><td style="text-align:left">-n</td><td>–numeric-sort</td><td>指定-n使用数值比较，默认是字符串比较，<strong>一遇到不可识别字符就会立即结束该字段的排序行为</strong>，<strong>无法跨域使用</strong>。”n”选项隐含”b”选项。</td></tr><tr><td style="text-align:left">-g</td><td>–general-number-sort</td><td>按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学 计数法表示的值）</td></tr><tr><td style="text-align:left">-r</td><td>–reverse</td><td>默认从小到大，指定后改为从大到小排序</td></tr><tr><td style="text-align:left">-f</td><td>–ignore-case</td><td>忽略大小写，未指定情况下，会将<strong>大写字母排在前面</strong>；在和”-u”选项一起使用时，如果排序字段的比较结果相等，则丢弃小写字母行。</td></tr><tr><td style="text-align:left">-o</td><td>–output=file</td><td>排序结果输出到指定文件，对于<strong>保存到原文件很有用</strong>，不然是可以用重定向的</td></tr><tr><td style="text-align:left">-m</td><td>–merge</td><td>对给定的多个已排序文件进行合并。在合并过程中不做任何排序动作。</td></tr><tr><td style="text-align:left">-k</td><td>–key=POS1[,POS2]</td><td>指定排序的列，排序从POS1位置开始；如果指定了POS2的话， 到POS2位置结 束</td></tr><tr><td style="text-align:left">-s</td><td>–stable</td><td>禁用”最终排序”。<strong>推荐大文件使用</strong>，能确认要排序的列后，不启用可以提高性能</td></tr><tr><td style="text-align:left">-z</td><td>–zero-terminated</td><td>NULL字符作为行尾，而不是用换行符</td></tr><tr><td style="text-align:left"></td><td>–debug</td><td>查看排序的过程和排序时所使用的列。注意，该选项只有CentOS 7上的sort才有。</td></tr></tbody></table><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p><strong>私有选项</strong>：紧跟在字段后的选项(如”-k3n”的”n”和”-k2r”的”r”)称为私有选项，使用短横线写在字段外的选项(如”-n”、”-r”)为全局选项。<strong>当没有为字段分配私有选项时，该排序字段将继承全局选项。</strong>当然，只有像”-n”、”-r”这样的排序性的选项才能继承和分配给字段，”-t”这样的选项则无法分配。</p><p>除了”b”选项外，其余选项无论是<strong>指定在POS1还是POS2中都是等价的</strong>，对于”b”选项，指定在POS1则作用于POS1，指定在POS2则作用于POS2。如果继承了全局选项”-b”，则作用于POS1和POS2。</p><blockquote><p>  因此，”-n -k3 -k4”、”-n -k3n -k4”和”-k3n -k4n”是等价的，”-r -k3n -k4”和”-k3nr -k4r”是等价的</p></blockquote><p><strong>排序规则</strong>：sort命令默认按照字符集的排序规则进行排序，可以指定”-d”选项按照字典顺序排序，指定”-n”按照数值排序，指定”-M”按照字符格式的月份规则排序，指定”-h”按照文件容量大小规则排序。</p><p><strong>分隔符</strong> ：sort使用<code>-t</code>选项指定的分隔符对每行进行分割，得到多个字段，<strong>分隔符不作为字段的内容，跨域时也没有，注意<code>-n</code>无法跨域，会造成分隔符在其中的错觉</strong>。默认的分隔符为空白字符和非空白字符之间的空字符，并非网上众多文章所说的空格或制表符(原文：By default, fields are separated by the empty string between a non-blank character and a blank character.)。</p><p>“ foo bar”默认将分隔为两个字段” foo”和” bar”，空格都保留着，可以视为”| foo| bar”，<code>|</code>为分割符。而使用空格作为分隔符时将分隔为三个字段：第一个字段为空，第二个字段和第三个字段为”foo”和”bar”。使用下面三个sort语句可以验证默认的分隔符并非空格。</p><blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">   $ <span class="built_in">echo</span> -e <span class="string">" 234 bar\n 323 aar"</span> | sort  -k2     <span class="comment"># 视为 2 列，对（aar,bar）排序</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    323 aar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    234 bar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   $ <span class="built_in">echo</span> -e <span class="string">" 234 bar\n 323 aar"</span> | sort  -t<span class="string">' '</span> -k2 <span class="comment"># 视为 3 列，对 (234,323)排序</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    234 bar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    323 aar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   $ <span class="built_in">echo</span> -e <span class="string">" 234 bar\n 323 aar"</span> | sort -b -t<span class="string">' '</span> -k1 <span class="comment"># 视为 2 列，因为全局选项-b 去除了开头的空格</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    123 aar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    234 bar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   $ <span class="built_in">echo</span> -e <span class="string">" 234  bar\n 323 aar"</span> | sort -t<span class="string">' '</span> -bk3  <span class="comment"># 视为 3 列，对（aar, bar）排序，私有选项忽略 bar 前的空格</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    323 aar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    234  bar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>分割后字段</strong>：分割字段后，<strong>分隔符不在排序目标中，跨域时也不包括（<code>-n</code>无法跨域，会造成分隔符在其中的错觉）</strong>，分割后两个字段A和B是紧靠在一起的。当排序的目标字段包含了B字段，那么sort会从字段左对齐处开始依次对字符排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]<span class="comment"># cat sort.txt</span></span><br><span class="line"><span class="number">11</span>:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"><span class="number">12</span>:<span class="number">1</span>:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>:<span class="number">0</span></span><br><span class="line">[root@xuexi ~]<span class="comment"># sort -t:  sort.txt</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>:<span class="number">0</span></span><br><span class="line"><span class="number">11</span>:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"><span class="number">12</span>:<span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面排序例子中，为什么”1:1:2”的1会在11和12中间，而”1:1:0”中的1却在11的前面？实际上，真正排序的时候，sort看到的内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1112</span><br><span class="line">112</span><br><span class="line">1211</span><br><span class="line">110</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：info sort 文档中说跨域时分隔符会保留感觉是错的。通过下面的例子进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat t</span></span><br><span class="line">a ae</span><br><span class="line">aa da</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sort -t<span class="string">" "</span> -k1,2 t   <span class="comment"># d &gt; e</span></span></span><br><span class="line">aa da</span><br><span class="line">a ae</span><br></pre></td></tr></table></figure><p><strong>最后排序</strong>：默认情况下，在命令行中指定的排序行为结束后，sort还会做最后一次排序，这最后一次排序是对整行按照完全默认规则进行排序的，也就是按字符集、升序排序。</p><p>考虑这样一种情况：两行在<strong>所有key的排序结果</strong>上都完全相同，应该如何决定这两行的先后顺序？</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# echo -e &quot;b 100 200\na 100 300&quot; | sort -t &apos; &apos; -k2n</span><br><span class="line">a 100 300</span><br><span class="line">b 100 200</span><br></pre></td></tr></table></figure><p>第一行为”b 100 200”，第二行为”a 100 300”。由于第2字段都是100，所以这两行在该key上的数值排序的结果相同，<strong>于是sort采取最后的手段，完全按照默认规则(即按字符集排序规则升序排序)对整行进行一次排序，这次排序称为”最后的排序”</strong>(info sort中称为last-resort comparison)。由于最后的排序过程中，第一个字符a&lt;b，所以最终结果将是第二行”a 100 300”在第一行”b 100 200”的前面。</p><p><strong>禁止”最后的排序”后，对那些排序key相同的行，将保留被读取时相对顺序。</strong>即，先读取的排在前面。</p><p>如果上面的例子中，第二字段不采用数值排序，而是默认排序规则排序呢？如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# echo -e &quot;b 100 200\na 100 300&quot; | sort -t &apos; &apos; -k2</span><br><span class="line">b 100 200</span><br><span class="line">a 100 300</span><br></pre></td></tr></table></figure><p>由于默认的排序规则是按照字符集排序规则进行排序，它能识别所有的字符，所以<code>-k2</code>等价于<code>-k2,3</code>，对整个key进行排序，由于第三字段的2小于3，所以结果中第一行排在第二行的前面。即使如此，sort还是进行了”最后的排序”，只不过”最后的排序”不影响排序结果。</p><p>如果未指定任何排序选项，其本身就是完全默认的，因此没必要再做最后的排序，所以将不会进行”最后的排序”。如果指定的是”-r”选项，由于”-r”是对最终结果进行反转排序，因此会影响这次的”最后的排序”的结果。</p><h4 id="排序对象"><a href="#排序对象" class="headerlink" title="排序对象"></a>排序对象</h4><p><strong>使用”-k”选项指定排序的key。不指定排序key时，整行将成为排序key，即对整行进行排序。</strong></p><ul><li>key由字段组成，格式为<code>POS1,[POS2]</code>，表示每行排序的起始和终止位置。也就是说，key才是排序的对象。</li><li>POS的格式为<code>F[.C][OPTS]</code>，其中F表示字段的序号，C表示该字段中字符的序号。字段和字符的位置都从1开始计算。如果POS2的字符位置指定为0，则表示POS2字段中的最后一个字符。如果POS1中省略<code>.C</code>，则默认值为1(字段的起始字符)，如果POS2中省略<code>.C</code>，默认值为0(字段的终止字符)。使用”-b”选项忽略前导空白字符时，C从第一个非空白字符开始计算。如果F或C超出了有效范围，则该key为空，例如一行只有3个字段，却指定了”-k4”，或者第2字段只有3个字符，却指定了”-k2.5”。</li><li>如果<strong>省略POS2，则key将自动扩展到行尾</strong>，即等价于”POS1,line_end”。如果不省略POS2，则该key可能会跨越多个字段。无论那种情况，跨越多个字段时，key中都不会保留字段间的分隔符。</li><li>OPTS指定的是该key的选项，包括但不限于<code>bfnrhM</code>，它们的作用和全局选项”-b”、”-f”、”-n”、”-r”、”-h”、”-M”相同。默认情况下，如果key中没有指定任何OPTS，则该<strong>key会继承全局选项</strong>。当key中单独指定了选项时，这些选项是该key的私有排序选项，将覆盖全局选项。除了”b”选项外，其余选项无论是指定在POS1还是POS2中都是等价的，对于”b”选项，指定在POS1则作用于POS1，指定在POS2则作用于POS2。如果继承了全局选项”-b”，则作用于POS1和POS2。<strong><code>-n</code>选项无法跨域</strong>。</li><li>字段前数量不固定的前导空白字符，将使得字段混乱，因此<strong>强烈建议总是忽略前导空白字符</strong>。数值排序时(即”n”选项)隐含”b”选项。</li><li>可以使用多个”-k”选项指定多个key，排序时将按照key的顺序进行排序。第一个key通常称为主排序key(primary key)。第二个key将在第一个key排序的基础上排序，同理，第三个key将在第二个key的排序基础上进行排序。</li></ul><p>以下是几个例子：例子中出现了选项”n”的，描述暂不严谨，但目前只能如此描述，在稍后的(4)中解释。</p><ul><li><p><code>-k 2</code>： 因为没有指定POS2，所以key扩展到了行尾。因此该key从第2字段第一个字符开始，到行尾结束。</p></li><li><p><code>-k 2,3</code> ：该key从第2字段第一个字符开始到第3字段最后一个字符结束。</p></li><li><p><code>-k 2,2</code>： 该key仅拥有第2字段。</p></li><li><p><code>-k 2,3n</code>和<code>-k 2n,3</code>和<code>-k 2n,3n</code>：这三者等价，因为除了”b”选项，OPTS指定在POS1或POS2的结果是一样的。</p></li><li><p><code>-k 2,3b</code>和<code>-k 2b,3</code>和<code>-k 2b,3b</code>：这三者互不等价。</p></li><li><p><code>-k 2n</code>： 该key从第2字段开始直到行尾，都按数值排序。</p></li><li><p><code>-k 2.2b,3.2n</code>： 该key从第2字段的第2个非空白字符开始，到第3字段第2字符(可能包含空白字符)结束，且该key按照数值排序。其实此处的b选项是多余的，因为n隐含了b选项。</p></li><li><p><code>-k 5b,5 -k 3,3n</code>： 定义了两个排序key，主排序key为第5字段不包含空白字符的部分，副key为第三个字段。主key按照默认规则排序，副key按照数值排序。副key在主key排序后的基础上再排序。</p></li><li><p><code>-k 5,5n -k 3b,6b</code>： 主key为第5字段，按照数值排序，副key从第3字段到第六字段，忽略前导空白字符，但是按照默认规则排序。副key在主key排序后的基础上再排序。</p></li></ul><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul><li>任何时候想对单个字段或单个字符排序时，都建议写出POS2，且POS2=POS1，这样能严格排序key的范围只为那个字段或字符。例如，使用<code>-k2,2</code>取代<code>-k2</code>。</li><li>想对多个字段或字符排序时，建议使用多个”-k”选项指定多个key，并按需求为每个key分配私有选项。之所以要如此，是防止无意中忽视了扩展到行尾或者范围。例如，想对第2列、第3列按数值排序，应该指定<code>-k2n -k3n</code>，而不应该写成<code>-k2,3n</code>。</li><li>应该总是使用<code>-b</code>选项去掉前导空白字符面，防止字段分割时混乱。<code>-n</code>隐含了<code>-b</code>，所以对数值排序时，可以省略<code>-b</code>。</li><li>对于大文件，建议写出满足需求的所有排序命令，然后使用<code>-s</code>关闭”最后的排序”。因为”最后的排序”对每个整行进行排序，性能非常低。</li></ul><h4 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h4><p>sort按照某列排序，一样的话再按某一列排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort  -k2,2 -k5,5 wide_table |grep <span class="string">"DD4486F320A7F0C112E2757C26609769"</span></span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ol><li><p>从公司英文名称的第二个字母开始进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 1.2 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure><p> 使用了<code>-k 1.2</code>，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。</p></li><li><p>按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -n -t &apos; &apos; -k 3r -k 2 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure><p>在-k 3后面偷偷加上了一个小写字母r。<strong>r和-r选项的作用是一样的，就是表示逆序，不过只对当前域有效</strong>，表示第三个域（员工平均工资）是按照降序排序。此处你还可以加上n，就表示对这个域进行排序时，要按照数值大小进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 3nr -k 2n facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure><p>我们去掉了最前面的-n选项，而是将它加入到了每一个-k选项中了。</p></li><li><p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 1.2,1.2 -k 3nr facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure><blockquote><p>  我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。</p></blockquote></li><li><p>最诡异的排序（跨域是不行的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -n -k 2.2,3.1 facebook.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure><p>以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。</p><p>第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。</p><p>又因为sort认为0小于00小于000小于0000….</p><p>因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢？（你可以自己做实验思考一下。）</p><p>答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了。</p></li></ol><p><a href="http://blog.chinaunix.net/uid-10540984-id-313479.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-10540984-id-313479.html</a></p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/7442886.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7442886.html</a></p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]</span><br></pre></td></tr></table></figure><p>任何位于表达式（expression）之前的字符串都将被视为欲查找的目录名。</p><p>默认路径为当前目录；默认表达式为<code>-print</code><br>表达式(expression)可能由下列成份组成：操作符、选项、测试表达式以及动作：</p><p>find会对每个文件评估从左向右的表达式，直到结果明确为真 或 表达式全部执行结束。</p><p>-H，-L和-P选项控制符号链接的处理。后面的命令行参数被视为要检查的文件或目录的名称，直到开始的第一个参数使用’ - ‘或参数’（’或’！’。该参数和任何后续参数被视为描述要搜索内容的表达式。</p><p>五个’真正的’选项-H，-L，-P， -D和-O必须出现在第一个路径名之前</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">操作符 (优先级递减；未做任何指定时默认使用 -and):</span><br><span class="line">      ( EXPR )  </span><br><span class="line">      ! EXPR   </span><br><span class="line">      -not EXPR  </span><br><span class="line">      EXPR1 -a EXPR2</span><br><span class="line">      EXPR1 -and EXPR2</span><br><span class="line">      EXPR1 -o EXPR2</span><br><span class="line">      EXPR1 -or EXPR2</span><br><span class="line">      EXPR1 , EXPR2</span><br><span class="line"></span><br><span class="line">位置选项 (总是真): </span><br><span class="line">      -daystart <span class="comment"># 从本日开始计算时间；TODO</span></span><br><span class="line">      -follow  废弃; 使用-L代替, 排除符号连接；</span><br><span class="line">      -regextype 普通选项 (总是真，在其它表达式前指定):</span><br><span class="line">      -depth  <span class="comment"># 从指定目录下最深层的子目录开始查找，不像默认的一层一层目录往下找，如下：</span></span><br><span class="line">          <span class="comment"># ./logs/hadoop.kylin.libdfs.log</span></span><br><span class="line">      <span class="comment"># ./logs</span></span><br><span class="line">      -maxdepth LEVELS  <span class="comment"># 设置最大目录层级;</span></span><br><span class="line">      -mindepth LEVELS  <span class="comment"># 搜索深度距离当前目录至少2个子目录的所有文件</span></span><br><span class="line">      -mount   <span class="comment"># 此参数的效果和指定“-xdev”相同；</span></span><br><span class="line">      -xdev    <span class="comment"># Don’t descend directories on other filesystems.TODO</span></span><br><span class="line">      -ignore_readdir_race</span><br><span class="line">      -noignore_readdir_race</span><br><span class="line">      --version </span><br><span class="line">      --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">比较测试 (N 可以是 +N 或 -N 或 N): </span><br><span class="line">       +N     <span class="keyword">for</span> greater than N,</span><br><span class="line">       -N     <span class="keyword">for</span> less than N,</span><br><span class="line">        N     <span class="keyword">for</span> exactly N.</span><br><span class="line">       </span><br><span class="line">      -amin N   <span class="comment"># 查找在指定时间曾被存取过的文件或目录，单位以分钟计算；</span></span><br><span class="line">      -mmin N   <span class="comment"># 查找在指定时间曾被更改过的文件或目录，单位以分钟计算；</span></span><br><span class="line">      -cmin N   <span class="comment"># 查找在指定时间之时被更改过的文件或目录,单位以分钟计算；</span></span><br><span class="line">      -atime N  <span class="comment"># 查找在指定时间曾被存取过的文件或目录，单位以24小时计算；</span></span><br><span class="line">      -mtime N  <span class="comment"># 查找在指定时间曾被更改过的文件或目录，单位以24小时计算;</span></span><br><span class="line">      -ctime N  <span class="comment"># 查找在指定时间之时被更改的文件或目录，单位以24小时计算；</span></span><br><span class="line">      -cnewer 文件  <span class="comment"># 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</span></span><br><span class="line">      -anewer 文件 <span class="comment"># 查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；</span></span><br><span class="line">      -empty </span><br><span class="line">      -<span class="literal">true</span>            <span class="comment"># 将find指令的回传值皆设为True;</span></span><br><span class="line">      -<span class="literal">false</span>            <span class="comment"># 将find指令的回传值皆设为False；</span></span><br><span class="line">      -fstype 类型      <span class="comment"># 只寻找该文件系统类型下的文件或目录；</span></span><br><span class="line">      -gid N            <span class="comment"># 查找符合指定之群组识别码的文件或目录；</span></span><br><span class="line">      -group 名称       <span class="comment"># 查找符合指定之群组名称的文件或目录；</span></span><br><span class="line">      -uid N           <span class="comment"># 查找符合用户uid的文件或目录</span></span><br><span class="line">      -user NAME       <span class="comment"># 查找符和指定的拥有者名称的文件或目录</span></span><br><span class="line">      <span class="comment"># 匹配模式使用的是shell的通配符（除了regex）</span></span><br><span class="line">      -name 匹配模式      <span class="comment"># *.py  最好配合*使用，精确指定可能得不到想要的结果</span></span><br><span class="line">      -regex 匹配模式     <span class="comment"># 需要较多的转义，请看后面的例子</span></span><br><span class="line">      -path 匹配模式      <span class="comment"># 与name很像，必须配合*使用，指定字符串作为寻找目录的范本样式，只要目录中包含匹配的模式，就输出</span></span><br><span class="line">      -perm [+-]访问模式  <span class="comment"># 查找符合指定的权限数值的文件或目录;</span></span><br><span class="line">      -lname 匹配模式     <span class="comment"># 查找是符号链接的文件，并且其内容匹配模式</span></span><br><span class="line">      -newer 文件或目录    <span class="comment"># 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录;</span></span><br><span class="line">      <span class="comment"># 忽略字符大小写的差别</span></span><br><span class="line">      -iname 匹配模式 -ipath 匹配模式 -iregex 匹配模式   -ilname 匹配模式</span><br><span class="line">      </span><br><span class="line">      -links N           <span class="comment"># 查找符合指定的硬连接数目的文件或目录；</span></span><br><span class="line">      -inum N            <span class="comment"># 查找符合指定的inode编号的文件或目录；</span></span><br><span class="line">      </span><br><span class="line">      -nouser -nogroup   <span class="comment"># 找出不属于本地主机[用户识别码/群组识别码]的文件或目录;</span></span><br><span class="line">      -noleaf            <span class="comment"># 不去考虑目录至少需拥有两个硬连接存在；</span></span><br><span class="line">      <span class="comment"># 可读写执行</span></span><br><span class="line">      -readable -writable -executable</span><br><span class="line">      </span><br><span class="line">      -wholename PATTERN  <span class="comment"># TODO</span></span><br><span class="line">      -size N[bcwkMG] <span class="comment"># 查找符合指定的文件大小的文件;</span></span><br><span class="line"></span><br><span class="line">      -<span class="built_in">type</span> [bcdpflsD] <span class="comment"># 只寻找符合指定的文件类型的文件；</span></span><br><span class="line">      -used N    <span class="comment"># 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算;</span></span><br><span class="line">     </span><br><span class="line">      -xtype [bcdpfls] <span class="comment"># 和指定“-type”参数类似，差别在于它针对符号连接检查。</span></span><br><span class="line"></span><br><span class="line">动作: -delete </span><br><span class="line">      -<span class="built_in">print</span>   <span class="comment"># 若回传值为Ture，就将符合的文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串;</span></span><br><span class="line">      -print0  <span class="comment"># 回传值为Ture，就将符合的文件或目录名称列出到标准输出。格式为全部的名称皆在同一行;</span></span><br><span class="line">      -<span class="built_in">printf</span> FORMAT <span class="comment"># 回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定;</span></span><br><span class="line">      -fprintf FILE FORMAT  <span class="comment"># 此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；</span></span><br><span class="line">      -fprint0 FILE         <span class="comment"># 指定“-print0”参数类似，但会把结果保存成指定的列表文件；</span></span><br><span class="line">      -fprint FILE          <span class="comment"># 和指定“-print”参数类似，但会把结果保存成指定的列表文件；</span></span><br><span class="line">      -ls <span class="comment"># 对符合条件的文件或目录执行ll命令，显示详细信息</span></span><br><span class="line">      -fls FILE             <span class="comment"># 和指定“-ls”参数类似，但会把结果保存为指定的列表文件；</span></span><br><span class="line">      -prune                <span class="comment"># 不打印符合条的文件或目录</span></span><br><span class="line">      -quit</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 执行的命令不支持你自定义的alias</span></span><br><span class="line">      -<span class="built_in">exec</span> COMMAND &#123;&#125; \;       <span class="comment"># find指令的回传值为True，就执行该指令;</span></span><br><span class="line">      -ok COMMAND &#123;&#125; \;         <span class="comment"># 与-exec相似，但是会给出提示，是否执行相应的操作。</span></span><br><span class="line">      -<span class="built_in">exec</span> COMMAND &#123;&#125; + -ok COMMAND ; <span class="comment"># &#123;&#125;是一个占位符，用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名</span></span><br><span class="line">      -execdir COMMAND ; </span><br><span class="line">      -execdir COMMAND &#123;&#125; + -okdir COMMAND ;</span><br></pre></td></tr></table></figure><p>在<code>/home</code>目录下查找以.txt结尾的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br></pre></td></tr></table></figure><p>匹配文件路径或者文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure><p>name与path的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ find . -ipath &quot;*match*&quot;</span><br><span class="line">./bin/match</span><br><span class="line">./bin/match/match.py</span><br><span class="line">./data/match_result.txt</span><br><span class="line">./data/match</span><br><span class="line">./data/match/20190910   # 这一行的差别</span><br><span class="line">./data/match/20190910/match_result_20190910.txt</span><br><span class="line">./data/match_result_20190910.txt</span><br><span class="line"></span><br><span class="line">$ find . -iname &quot;*match*&quot;</span><br><span class="line">./bin/match</span><br><span class="line">./bin/match/match.py</span><br><span class="line">./data/match_result.txt</span><br><span class="line">./data/match</span><br><span class="line">./data/match/20190910/match_result_20190910.txt</span><br><span class="line">./data/match_result_20190910.txt</span><br></pre></td></tr></table></figure><p>基于正则表达式匹配文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure><p><strong>否定参数</strong></p><p>找出/home下不是以.txt结尾的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><p>类型参数列表：</p><ul><li><strong>f</strong> 普通文件</li><li><strong>l</strong> 符号连接</li><li><strong>d</strong> 目录</li><li><strong>c</strong> 字符设备</li><li><strong>b</strong> 块设备</li><li><strong>s</strong> 套接字</li><li><strong>p</strong> Fifo</li></ul><p>UNIX/Linux文件系统每个文件都有三种时间戳：</p><ul><li><strong>访问时间</strong>（-atime/天，-amin/分钟）：用户最近一次访问时间。</li><li><strong>修改时间</strong>（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</li><li><strong>变化时间</strong>（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</li></ul><p>搜索最近七天内被访问过的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime -7</span><br></pre></td></tr></table></figure><p>搜索恰好在七天前被访问过的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime 7</span><br></pre></td></tr></table></figure><p>搜索超过七天内被访问过的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime +7</span><br></pre></td></tr></table></figure><p>搜索访问时间超过10分钟的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -amin +10</span><br></pre></td></tr></table></figure><p>找出比<a href="http://man.linuxde.net/file" target="_blank" rel="noopener">file</a>.log修改时间更长的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -newer file.log</span><br></pre></td></tr></table></figure><p><strong>根据文件大小进行匹配</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size 文件大小单元</span><br></pre></td></tr></table></figure><p>文件大小单元：</p><ul><li><strong>b</strong> —— 块（512字节）</li><li><strong>c</strong> —— 字节</li><li><strong>w</strong> —— 字（2字节）</li><li><strong>k</strong> —— 千字节</li><li><strong>M</strong> —— 兆字节</li><li><strong>G</strong> —— 吉字节</li></ul><p>搜索大于10KB的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +10k</span><br></pre></td></tr></table></figure><p>搜索小于10KB的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size -10k</span><br></pre></td></tr></table></figure><p>搜索等于10KB的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size 10k</span><br></pre></td></tr></table></figure><p><strong>删除匹配文件</strong></p><p>删除当前目录下所有.txt文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -delete</span><br></pre></td></tr></table></figure><p><strong>根据文件权限/所有权进行匹配</strong></p><p>当前目录下搜索出权限为777的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -perm 777</span><br></pre></td></tr></table></figure><p>找出当前目录下权限不是644的<a href="http://man.linuxde.net/php" target="_blank" rel="noopener">php</a>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.php&quot; ! -perm 644</span><br></pre></td></tr></table></figure><p>找出当前目录用户tom拥有的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -user tom</span><br></pre></td></tr></table></figure><p>找出当前目录用户组sunk拥有的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -group sunk</span><br></pre></td></tr></table></figure><p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure><p>要列出所有长度为零的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -empty</span><br></pre></td></tr></table></figure><p><strong>执行命令相关</strong></p><p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; all.txt</span><br></pre></td></tr></table></figure><p>将30天前的.log文件移动到old目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br></pre></td></tr></table></figure><p>单行命令中-exec参数中无法使用多个命令，可以将多条命令保存在shell文件中，在-exec执行该文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./text.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。例如： <code>grep -i &#39;hello world&#39; menu.h main.c</code></p><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep pattern filename  <span class="comment"># 默认支持正则</span></span><br><span class="line">grep -e pattern1 -e pattern2 filename</span><br></pre></td></tr></table></figure><p>默认情况下，grep命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。</p><p>需要注意的是：限定连续字符范围 的<code>{}</code>符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 <code>\{</code> 与<code>\}</code> 来让它失去特殊意义才行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grep --color=auto <span class="string">" 在输出行中着重标记出匹配到的模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-a  # 将 binary 文件以 text 文件的方式搜寻数据</span></span><br><span class="line"><span class="string">-e  # 如果要指定多个匹配模式，可用-e参数来指定每个模式,grep -e t -e f file 输出了含有字符t或字符f的所有行。</span></span><br><span class="line"><span class="string">-o # 只输出匹配到的文本，如果在同一行中，会分开显示</span></span><br><span class="line"><span class="string">-v  # 打印出不匹配match_pattern的所有行</span></span><br><span class="line"><span class="string">-c# 统计匹配行的数量，并不是匹配的次数。匹配次数需要与-o配合，请看后面的例子</span></span><br><span class="line"><span class="string">-n  # 打印出匹配字符串所在行的行号,以及该行的内容，如果涉及多个文件，该选项也会随输出结果打印出文件名</span></span><br><span class="line"><span class="string">-i # 忽略模式中的大小写</span></span><br><span class="line"><span class="string">-l # 多文件处理时，可以列出匹配模式所在的文件</span></span><br><span class="line"><span class="string">-L # 与-l相反，它会返回一个不匹配的文件列表</span></span><br><span class="line"><span class="string">-q # 静默模式（主要用于脚本中，，在命令行中没什么用），只判断是否匹配成功,不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。0表示匹配成功，非0表示匹配失败。</span></span><br><span class="line"><span class="string">-r # 递归搜索当前目录和子目录</span></span><br><span class="line"><span class="string">-w # 匹配整个英文单词，对中文不管用</span></span><br><span class="line"><span class="string">-x # 匹配整行，比较两个文件不同行时使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-f # 从文件中读取匹配模式，一行一个模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 显示前后几行</span></span><br><span class="line"><span class="string">-A # after，显示匹配到的行以及之后的 n 行</span></span><br><span class="line"><span class="string">-B # before，显示匹配到的行以及之前的 n 行</span></span><br><span class="line"><span class="string">-C # Center，显示匹配到的行以及前后的 n </span></span><br><span class="line"><span class="string"># 如果匹配到多行，为了区分匹配到的字符串，用"</span>--<span class="string">"进行区分，比如：</span></span><br><span class="line"><span class="string">echo -e "</span>a\nb\nc\na\nb\nc<span class="string">" | grep a -A 1</span></span><br><span class="line"><span class="string"># a匹配到第1次</span></span><br><span class="line"><span class="string"># b</span></span><br><span class="line"><span class="string"># --</span></span><br><span class="line"><span class="string"># a匹配到第2次</span></span><br><span class="line"><span class="string"># c</span></span><br></pre></td></tr></table></figure><p>统计匹配项的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">正则表达式选择与解释:</span><br><span class="line">  -E, --extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)</span><br><span class="line">  -F, --fixed-strings       PATTERN 是一组由断行符分隔的定长字符串。</span><br><span class="line">  -G, --basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)</span><br><span class="line">  -P, --perl-regexp         PATTERN 是一个 Perl 正则表达式</span><br><span class="line">  -e, --regexp=PATTERN      用 PATTERN 来进行匹配操作</span><br><span class="line">  -f, --file=FILE           从 FILE 中取得 PATTERN</span><br><span class="line">  -i, --ignore-case         忽略大小写</span><br><span class="line">  -w, --word-regexp         强制 PATTERN 仅完全匹配字词</span><br><span class="line">  -x, --line-regexp         强制 PATTERN 仅完全匹配一行</span><br><span class="line">  -z, --null-data           一个 0 字节的数据行，但不是空行</span><br><span class="line"></span><br><span class="line">杂项:</span><br><span class="line">  -s, --no-messages         不显示错误信息</span><br><span class="line">  -v, --invert-match        选中不匹配的行</span><br><span class="line">  -V, --version             显示版本信息并退出</span><br><span class="line">      --help                显示此帮助并退出</span><br><span class="line">      --mmap                忽略向后兼容性</span><br><span class="line"></span><br><span class="line">输出控制:</span><br><span class="line">  -m, --max-count=NUM       NUM 次匹配后停止</span><br><span class="line">  -b, --byte-offset         输出行的同时打印字节偏移</span><br><span class="line">  -n, --line-number         输出行的同时打印行号</span><br><span class="line">      --line-buffered       每行输出清空</span><br><span class="line">  -H, --with-filename       为每一匹配项打印文件名</span><br><span class="line">  -h, --no-filename         输出时不显示文件名前缀</span><br><span class="line">      --label=LABEL         标准输入将LABEL 打印为文件名</span><br><span class="line">  -o, --only-matching       只显示一行中匹配PATTERN 的部分</span><br><span class="line">  -q, --quiet, --silent     不显示所有输出</span><br><span class="line">      --binary-files=TYPE   假定二进制文件的TYPE 类型；</span><br><span class="line">                            TYPE 可以是`binary&apos;, `text&apos;, 或`without-match&apos;</span><br><span class="line">  -a, --text                等同于 --binary-files=text</span><br><span class="line">  -I                        等同于 --binary-files=without-match</span><br><span class="line">  -d, --directories=ACTION  操作目录的方式；</span><br><span class="line">                            ACTION 可以是`read&apos;, `recurse&apos;,或`skip&apos;</span><br><span class="line">  -D, --devices=ACTION      操作设备、先入先出队列、套接字的方式；</span><br><span class="line">                            ACTION 可以是`read&apos;或`skip&apos;</span><br><span class="line">  -r, --recursive       等同于 --directories=recurse</span><br><span class="line">  -R --dereference-recursive  likewise, but follow all symlinks</span><br><span class="line">      --include=FILE_PATTERN  只查找匹配FILE_PATTERN 的文件</span><br><span class="line">      --exclude=FILE_PATTERN  跳过匹配FILE_PATTERN 的文件和目录</span><br><span class="line">      --exclude-from=FILE   跳过所有除FILE 以外的文件</span><br><span class="line">      --exclude-dir=PATTERN  跳过所有匹配PATTERN 的目录。</span><br><span class="line">  -L, --files-without-match  只打印不匹配FILEs 的文件名</span><br><span class="line">  -l, --files-with-matches  只打印匹配FILES 的文件名</span><br><span class="line">  -c, --count               只打印每个FILE 中的匹配行数目</span><br><span class="line">  -T, --initial-tab         行首tabs 分隔（如有必要）</span><br><span class="line">  -Z, --null                在FILE 文件最后打印空字符</span><br><span class="line"></span><br><span class="line">文件控制:</span><br><span class="line">  -B, --before-context=NUM  打印以文本起始的NUM 行</span><br><span class="line">  -A, --after-context=NUM   打印以文本结尾的NUM 行</span><br><span class="line">  -C, --context=NUM         打印输出文本NUM 行</span><br><span class="line">  -NUM                      等同于 --context=NUM</span><br><span class="line">      --color[=WHEN],</span><br><span class="line">      --colour[=WHEN]       使用标志高亮匹配字串；</span><br><span class="line">                            WHEN 可以是`always&apos;, `never&apos;或`auto&apos;</span><br><span class="line">  -U, --binary              不要清除行尾的CR 字符(MSDOS 模式)</span><br><span class="line">  -u, --unix-byte-offsets   当CR 字符不存在，报告字节偏移(MSDOS 模式)</span><br></pre></td></tr></table></figure><h4 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h4><p>egrep命令是grep的一个衍生，支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更 多的可以用来指定匹配模式的字符，增加了额外的正则表达式元字符集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">"[a-z]+"</span> filename</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">egrep <span class="string">"[a-z]+"</span> filename</span><br></pre></td></tr></table></figure><h4 id="不使用正则表达式"><a href="#不使用正则表达式" class="headerlink" title="不使用正则表达式"></a>不使用正则表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -F &apos;str&apos;</span><br><span class="line">fgrep &apos;str&apos;</span><br></pre></td></tr></table></figure><p><code>fgrep</code> 查询速度比<code>grep</code>命令快，但是不够灵活：它<strong>只能找固定的文本，而不是正则表达式。</strong></p><p>如果你想在一个文件或者输出中找到包含星号字符的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fgrep  <span class="string">'*'</span> /etc/profile</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">grep -F <span class="string">'*'</span> /etc/profile</span><br></pre></td></tr></table></figure><p>fgrep则是另外一个版本，支持将匹配模式 指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后 在fgrep命令中用其在一个大型文件中搜索字符串了。</p><h4 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h4><h5 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h5><p>命令会打印出匹配任意一种模式的行，每个匹配对应一行输出。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a line of text | grep -o -e <span class="string">"this"</span> -e <span class="string">"line"</span> this</span><br></pre></td></tr></table></figure><h5 id="从文件中读取匹配模式"><a href="#从文件中读取匹配模式" class="headerlink" title="从文件中读取匹配模式"></a>从文件中读取匹配模式</h5><p>可以将多个模式定义在文件中。选项<code>-f</code>可以读取文件并使用其中的模式（一个模式一行，记得最后留一行空白行，不然最后一种模式匹配不到，很诡异）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat pat_file</span><br><span class="line"><span class="comment"># ^h.*</span></span><br><span class="line"><span class="comment"># co+l</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> hello \n this is cool | grep -f pat_file </span><br><span class="line"><span class="comment"># hello </span></span><br><span class="line"><span class="comment"># this is cool</span></span><br></pre></td></tr></table></figure><h5 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h5><p>grep 本身并不支持，所以需要通过管道符号或者与 find 组合使用</p><h4 id="检索文件内容"><a href="#检索文件内容" class="headerlink" title="检索文件内容"></a>检索文件内容</h4><p>递归搜索目录中的文件内容（不是文件名）<code>-R</code>，<strong>注意</strong>：支持相对路径、绝对路径，但<strong>不支持<code>~/work/</code>这样的路径</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"test_function()"</span> ./ -R -n </span><br><span class="line"><span class="comment"># ./miscutils/test.c:16:test_function(); 找到在test.c的第16行</span></span><br></pre></td></tr></table></figure><p>等价于<code>find . -type f | xargs grep &quot;test_function()&quot;</code></p><h4 id="指定或者排除文件"><a href="#指定或者排除文件" class="headerlink" title="指定或者排除文件"></a>指定或者排除文件</h4><p>使用<code>--include</code>选项在目录中递归搜索所有的 <code>.c</code>和<code>.cpp</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"main()"</span> . -r --include *.&#123;c,cpp&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  注意，<code>some{string1,string2,string3}</code> 会被扩展成 <code>somestring1 somestring2 somestring3</code>。</p></blockquote><p> 相反的就是<code>--exclude</code></p><p><code>--exclude-dir</code>可以排除目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep main . -r -exclude-dir CVS</span><br></pre></td></tr></table></figure><p><code>--exclude-from FILE</code>从文件中读取排除文件列表</p><h4 id="0值字节后缀的-xargs"><a href="#0值字节后缀的-xargs" class="headerlink" title="0值字节后缀的 xargs"></a>0值字节后缀的 xargs</h4><p>xargs命令可以为其他命令提供命令行参数列表。</p><p>当文件名作为命令行参数时，建议用0值字节作为文件名终结符，而非空格。因为一些文件名中会包含空格字符，一旦它被误解为终结符， 那么单个文件名就会被视为两个（例如，New file.txt被解析成New和file.txt两个文件名）。</p><p>这个问题可以利用0值字节后缀来避免。</p><p>grep和find命令可以生成带有0值字节后缀的输出，然后传递 给 xargs，让它产生文件名列表。为了指明输入中的文件名是以0值字节作为终结，需 要在xargs中使用选项-0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试文件：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; file1  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"cool"</span> &gt; file2 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出包含有 test 内容的文件名，并以0值字节作为终结符，然后传递给 xargs，让它生成文件名参数列表，之后传递（不用管道符号）给 rm 命令，删除这些文件</span></span><br><span class="line">grep <span class="string">"test"</span> file* -lZ | xargs -0 rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-l告诉grep只输出有匹配出现的文件名。选项-Z使得grep使用0值字节（\0）作为文 件名的终结符。这两个选项通常都是配合使用的。xargs的-0选项会使用0值字节作为输入的分隔符</span></span><br></pre></td></tr></table></figure><h4 id="比较两个文件相同的行与不同的行"><a href="#比较两个文件相同的行与不同的行" class="headerlink" title="比较两个文件相同的行与不同的行"></a>比较两个文件相同的行与不同的行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -Ff  file1 file2   <span class="comment"># 输出公共的行</span></span><br><span class="line">grep -vFf  file1 file2   <span class="comment"># 输出不在 file1 的行</span></span><br></pre></td></tr></table></figure><h4 id="查找满足条件的文件是否匹配到文字"><a href="#查找满足条件的文件是否匹配到文字" class="headerlink" title="查找满足条件的文件是否匹配到文字"></a>查找满足条件的文件是否匹配到文字</h4><p>查找包含”hello world”的文件清单，并从这些清单中查找出满足”mailx”的匹配情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方法1：直接利用管道</span></span><br><span class="line">grep -i "hello world" -rl /home/tyrone | xargs grep -i "mailx"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出结果</span></span><br><span class="line">/home/tyrone/test1.txt:mailx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方法2：使用find，适合于需要灵活判断条件的场景。例如查找指定路径下，同时匹配多个模式的txt文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意：本例中“mailx”后面的命令必须加上反引号 ` ，否则会被当作要查询的文件名。</span></span><br><span class="line">grep -i "mailx" `find /home/tyrone -type f -name "*.txt" -exec grep -l "hello world"  &#123;&#125; \;`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出结果</span></span><br><span class="line">/home/tyrone/test1.txt:mailx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方法3:同2</span></span><br><span class="line">find /home/tyrone -name "*.txt" -exec grep -l "hello world" &#123;&#125; \; | xargs grep -i "mailx"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出结果</span></span><br><span class="line">/home/tyrone/test1.txt:mailx</span><br></pre></td></tr></table></figure><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>tr是translate（转换）的简写，基本功能是将字符从一个字符集合映射到另一个集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr set1 set2</span><br></pre></td></tr></table></figure><blockquote><p>  注意： <code>tr</code>只能通过<code>stdin</code> 接收输入，无法通过命令行参数接收 ，如<code>tr -s &#39;&#39; file</code>，只能转为 <code>stdin</code> 形式，<code>tr -s &#39; &#39;&lt; file.txt</code></p></blockquote><p>如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1 相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;HELLO WHO IS THIS&quot; | tr &apos;A-Z&apos; &apos;a-z&apos;</span><br></pre></td></tr></table></figure><p>字符集合（字符组）可以使用“起始字符—终止字符”，如果不是有效的连续字符序列， 那么它就会被视为<code>起始字符</code>、<code>—</code>、<code>终止字符</code>这3个元素的集合。也可以使用像<code>\t</code>、<code>\n</code> 这种特殊字符或其他ASCII字符。可以按照需要追加字符或<strong>字符类</strong>来构造自己的字符组。</p><table><thead><tr><th>字符类</th><th>说明</th></tr></thead><tbody><tr><td>alnum</td><td>字母和数字</td></tr><tr><td>alpha</td><td>字母</td></tr><tr><td>cntrl</td><td>控制（非打印）字符</td></tr><tr><td>digit</td><td>数字</td></tr><tr><td>graph</td><td>图形字符</td></tr><tr><td>lower</td><td>小写字母</td></tr><tr><td>print</td><td>可打印字符</td></tr><tr><td>punct</td><td>标点符号</td></tr><tr><td>space</td><td>空白字符</td></tr><tr><td>upper</td><td>大写字母</td></tr><tr><td>xdigit</td><td>十六进制字符</td></tr></tbody></table><p>字符类的使用方法<code>tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code></p><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tr [options] set1  [set2]</span><br><span class="line">-d     # 删除(delete)set1 中的字符</span><br><span class="line">-c     # tr会将不在set1中的字符转换成set2中的字符,set2只能是一个字符</span><br><span class="line">-d -c  # 只保留set1的字符，不需要set2</span><br><span class="line">-s     # 删除重复字符，只留下一个</span><br></pre></td></tr></table></figure><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>tr命令可以用来加密。ROT13是一个著名的加密算法。在ROT13算法中，字符会被移动13 个位置，因此文本加密和解密都使用同一个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"tr came, tr saw, tr conquered."</span> | tr <span class="string">'a-zA-Z'</span> <span class="string">'n-za-mN-ZA-M'</span></span><br></pre></td></tr></table></figure><p>将制表符转换成单个空格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr <span class="string">'\t'</span> <span class="string">' '</span> &lt; file.txt</span><br></pre></td></tr></table></figure><p> 删除字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello 123 world 456&quot; | tr -d &apos;0-9&apos; </span><br><span class="line"># Hello world</span><br></pre></td></tr></table></figure><p>只保留set1 的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hello 1 char 2 next 4 | tr -d -c &apos;0-9 \n&apos;</span><br><span class="line"># 124</span><br></pre></td></tr></table></figure><p>压缩空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;GNU  is   not     UNIX.     Recursive       GNU is not UNIX. Recursive right ?&quot; | tr -s &apos; &apos;</span><br></pre></td></tr></table></figure><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、 CSV文件或是由空格分隔的文件。</p><blockquote><p>  如果空格的长度不一致，需要使结合<code>tr</code>命令，进行字符串转换</p></blockquote><p>每列被称为一个<strong>字段</strong>，默认分隔符是制表符<code>\t</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-d&quot;\t&quot;    # 指定分割符为&quot;\t&quot;，默认就是制表符，因此可以不写</span><br><span class="line">-f2,3     # 显示2,3列的内容,f2可以不用空格分开</span><br><span class="line">-f2-4     # 显示第2到4列(field)的内容，2-5 的用法看后面表格说明</span><br><span class="line">-c2-5     # 显示第2到5个字符(character)，注意不能与-d 组合</span><br><span class="line">-b2-5     # 显示第2到5个字节(byte)，注意不能与-d 组合</span><br><span class="line">--complement # 与-f 组合使用，显示f没有指定的列，就是取反</span><br><span class="line">--output-delimiter    指定输出时的列分隔符</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cut range_fields.txt -c1-3,6-9 --output-delimiter <span class="string">","</span> </span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选取方式</th><th>说明</th></tr></thead><tbody><tr><td>N-</td><td>从第N个字节、字符或字段开始到行尾</td></tr><tr><td>N-M</td><td>从第N个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</td></tr><tr><td>-M</td><td>从第1个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut -c -2 range_fields.txt    <span class="comment"># 打印前2个字符</span></span><br><span class="line">cut -c2-5 range_fields.txt    <span class="comment"># 打印第2个到第5个字符</span></span><br></pre></td></tr></table></figure><h3 id="文件分割-split"><a href="#文件分割-split" class="headerlink" title="文件分割 split"></a>文件分割 split</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split  [options] filename prefix.</span><br></pre></td></tr></table></figure><p>将文件分割成固定大小（bytes）或者固定行数的小文件，原文件不动，小文件为<code>prefix.aa prefix.ab</code>等形式，前缀后面最好要有<code>.</code>，如<code>file.</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d    使用数字后缀，file.01 file.02，默认为字符后缀</span><br><span class="line">-l    指定每个输出文件多少行内容，最后一个文件可能会小于n</span><br><span class="line">-b, --bytes=SIZE  指定每个输出文件的大小，如-b100K,大小可以是 KB、MB，GB</span><br><span class="line">-C，--line-bytes=SIZE  TODO</span><br><span class="line">-a    指定后缀长度，默认是2，不指定时程序会自适应</span><br><span class="line">--verbose  显示创建文件的信息</span><br></pre></td></tr></table></figure><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed是stream editor（流编辑器）的缩写。它最常见的用法是进行文本替换。<strong>默认不修改原文件，只显示修改后的结果。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br><span class="line"></span><br><span class="line">-e &apos;script1;script2&apos;</span><br><span class="line">-f script_file # 从文本中读取大量指令，一行一个，以换行结束</span><br><span class="line">-i # 保存到原文件</span><br><span class="line">-n或--quiet或--silent # 仅显示script处理后的结果。</span><br></pre></td></tr></table></figure><p>要是我们想就地（in place）修改文件内容，可以使用选项<code>-i</code>保存到原文件中。值得<strong>推荐的做法</strong>是</p><ul><li><p>先使用不带<code>-i</code>选项的<code>sed</code>命令，以确保正则表达式没有问题，如果结果符合要求，再加入-i选项将更改写入文件。</p></li><li><p>也可以使用<code>sed -i.bak &#39;s/abc/def/&#39; file</code>，这时的sed不仅替换文件内容，还会创建一个名为<code>file.bak</code>的文件，其中包含着原始文件内容的副本。</p></li></ul><h4 id="替换s"><a href="#替换s" class="headerlink" title="替换s"></a>替换<code>s</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s/old/new/          # 替换每行第1个匹配到的字符串</span><br><span class="line">s/old/new/2         # 替换每行第2个匹配到的字符串</span><br><span class="line">s/old/new/g         # 替换全部</span><br><span class="line">s/old/new/2g        # 只替换第2次及之后匹配到的字符串</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/2g'</span> </span><br><span class="line"><span class="comment"># thisTHISTHISTHIS</span></span><br></pre></td></tr></table></figure><h5 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s/pattern/replacement/flags</span><br></pre></td></tr></table></figure><p>有4种可用的替换标记： </p><ul><li>数字，表明新文本只替换每行第几处模式匹配的地方； </li><li>g，表明新文本将会替换所有匹配的文本； </li><li>p，表明原先行的内容要打印出来；</li><li>w file，将匹配到的行替换的结果写到指定的file中。</li></ul><p>p替换标记会打印与替换命令中指定的模式匹配的行替换后的结果。这通常会和sed的-n选项一起使用。-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是 只输出被替换命令修改过的行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat data5.txt </span><br><span class="line">This is a <span class="built_in">test</span> line.</span><br><span class="line">This is a different line.</span><br><span class="line"></span><br><span class="line">$ sed -n <span class="string">'s/test/trial/p'</span> data5.txt </span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure><p>w替换标记会产生与 p 模式同样的输出，不过会将输出保存到指定文件中。</p><h5 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h5><p><code>sed</code>命令会将<code>s</code>之后的字符视为命令分隔符。这允许我们更改默认的分隔符<code>/</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s:text:replace:g&apos; </span><br><span class="line">sed &apos;s|text|replace|g&apos;</span><br></pre></td></tr></table></figure><p>如果作为分隔符的字符出现在模式中，必须使用<code>\</code>对其进行转义</p><h5 id="指定行"><a href="#指定行" class="headerlink" title="指定行"></a>指定行</h5><p>方式1（数字）：</p><p>在<code>s</code>前添加行编辑即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2s/dog/cat/'</span> data1.txt   <span class="comment"># 只修改地址指定的第2行的文本</span></span><br><span class="line">sed <span class="string">'2,3s/dog/cat/'</span> data1.txt <span class="comment"># 只修改地址指定的第2，3行的文本</span></span><br><span class="line">sed <span class="string">'2,$s/dog/cat/'</span> data1.txt <span class="comment"># 修改从某行开始的所有行</span></span><br></pre></td></tr></table></figure><p>方式2（正则）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/pattern/s/bash/csh/'</span> /etc/passwd  <span class="comment"># 使用 pattern 正则表达式过滤</span></span><br></pre></td></tr></table></figure><p><strong>已匹配字符串标记（<code>&amp;</code>）</strong></p><p>在sed中，我们可以用&amp;指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹 配的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo this is an example | sed &apos;s/\w+/[&amp;]/g&apos;</span><br><span class="line"># [this] [is] [an] [example]</span><br></pre></td></tr></table></figure><p><strong>子串匹配标记（\num）</strong></p><p> 匹配正则中的子表达式，第1 个是<code>\1</code>，第 2 个是<code>\2</code>，以此类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo this is digit 7 in a number | sed &apos;s/digit \([0-9]\)/\1/&apos; </span><br><span class="line"># this is 7 in a number</span><br></pre></td></tr></table></figure><p><strong>多表达式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'expression; expression'</span></span><br><span class="line">sed <span class="string">'expression'</span> | sed <span class="string">'expression'</span></span><br><span class="line">sed -e <span class="string">'expression'</span> -e <span class="string">'expression'</span></span><br><span class="line">sed -e <span class="string">'expression; expression'</span></span><br><span class="line">sed -e <span class="string">'</span></span><br><span class="line"><span class="string">&gt; s/brown/green/</span></span><br><span class="line"><span class="string">&gt; s/fox/elephant/</span></span><br><span class="line"><span class="string">&gt; s/dog/cat/'</span> data1.txt</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo abc | sed &apos;s/a/A/;s/c/C/&apos;</span><br><span class="line">echo abc | sed &apos;s/a/A/&apos; | sed &apos;s/c/C/&apos;</span><br><span class="line">echo abc | sed -e &apos;s/a/A/&apos; -e &apos;s/c/C/&apos;</span><br><span class="line">echo abc | sed -e &apos;s/a/A/; s/c/C/&apos;</span><br><span class="line"># AbC</span><br></pre></td></tr></table></figure><p><strong>单引号与双引号的区别</strong></p><p>sed表达式<strong>通常用单引号来引用</strong>。如果想在sed表达式中使用变量，双引号就能派上用场了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text=hello </span><br><span class="line">echo hello world | sed &quot;s/$text/HELLO/&quot; </span><br><span class="line"># HELLO world</span><br></pre></td></tr></table></figure><h4 id="多命令"><a href="#多命令" class="headerlink" title="多命令"></a>多命令</h4><p>如果需要在匹配到的行上执行多条命令，可以用<code>{}</code>将多条命令组合在一起，同时指定过滤的行号，或者匹配模式。</p><p>多条命令之间用<code>;</code>分割，或者分成多行书写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行内多个命令</span></span><br><span class="line">sed -n <span class="string">'/root/&#123;s/bash/blueshell/;p;q&#125;'</span> /etc/passwd </span><br><span class="line"></span><br><span class="line"><span class="comment"># 分成多行执行多个命令</span></span><br><span class="line">sed <span class="string">'3,$&#123;</span></span><br><span class="line"><span class="string">&gt; s/brown/green/</span></span><br><span class="line"><span class="string">&gt; s/lazy/active/</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data1.txt</span><br></pre></td></tr></table></figure><h4 id="插入a与i"><a href="#插入a与i" class="headerlink" title="插入a与i"></a>插入<code>a</code>与<code>i</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'[address]command\</span></span><br><span class="line"><span class="string">new line'</span></span><br></pre></td></tr></table></figure><p>插入（insert）命令（i）会在指定行前插入文本，（插入的文本要带有换行，否则就直接插入在指定行的头部）</p><p>附加（append）命令（a）会在指定行后添加文本，（如果文本没换行，会与下一行在同一行）</p><p>可以指定一个行地址，匹配一个数字行号或文本模式</p><blockquote><p>  这两条命令的费解之处在于它们的格式。它们不能在一行内使用。你必须先输入<code>i</code>或者<code>a</code>，然后使用<code>\</code>进行换行，接着输入要插入或者附加的内容。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本中的写法</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'1i\   # 在第一行前插入</span></span><br><span class="line"><span class="string">Test Line 1\     # 换行，否则两行文本会在一同一行</span></span><br><span class="line"><span class="string">'</span> </span><br><span class="line">Test Line 1 </span><br><span class="line">Test Line 2</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'/Line/a\   # 在包含Line的一行添加</span></span><br><span class="line"><span class="string">Test Line 1\</span></span><br><span class="line"><span class="string">'</span> </span><br><span class="line"></span><br><span class="line">Test Line 2 </span><br><span class="line">Test Line 1</span><br></pre></td></tr></table></figure><h5 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h5><p>插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后 一行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1i\</span></span><br><span class="line"><span class="string">&gt; This is one line of new text.\</span></span><br><span class="line"><span class="string">&gt; This is another line of new text.'</span> data6.txt </span><br><span class="line"></span><br><span class="line">This is one line of new text.</span><br><span class="line">This is another line of new text.</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><h4 id="删除行-d"><a href="#删除行-d" class="headerlink" title="删除行 d"></a>删除行 <code>d</code></h4><p>删除命令<code>d</code>名副其实，它会删除匹配指定寻址模式的所有行。</p><p>支持指定行<code>sed &#39;2,3d&#39; data6.txt</code></p><p>通过特定行区间指定：<code>sed &#39;2,3d&#39; data6.txt</code></p><p>模式匹配特性也适用于删除命令<code>sed &#39;/number 1/d&#39; data6.txt</code></p><p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。</p><ul><li>sed编辑器会删除两个指定行之间 的所有行（包括指定的行）。<strong>如果没有找到停止模式，所以就将数据流中的剩余行全部删除了。</strong></li><li>你指定的第1个模式 会“打开”行删除功能，第2个模式会“关闭”行删除功能。之后<strong>再遇到第1个模式会再打开删除功能</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat data7.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is line number 1 again.   <span class="comment"># 再次触发删除功能</span></span><br><span class="line">This is text you want to keep. </span><br><span class="line">This is the last line <span class="keyword">in</span> the file. </span><br><span class="line"></span><br><span class="line">$ sed <span class="string">'/1/,/3/d'</span> data7.txt </span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><h4 id="字符转换y"><a href="#字符转换y" class="headerlink" title="字符转换y"></a>字符转换<code>y</code></h4><p>转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]y/inchars/outchars/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'y/123/789/'</span> data8.txt </span><br><span class="line">This is line number 7.</span><br><span class="line">This is line number 8.</span><br><span class="line">This is line number 9.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is line number 7 again.</span><br><span class="line">This is yet another line.</span><br><span class="line">This is the last line <span class="keyword">in</span> the file.</span><br></pre></td></tr></table></figure><p>转换命令会对inchars和outchars值进行一对一的映射。</p><p>如果inchars和outchars的长度不同，则sed编辑器会产生一 条错误消息。</p><p>转换命令是一个全局命令，你无法限定只转换在特定地方出现的字符。</p><h4 id="打印命令"><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h4><ol><li>p命令用来打印文本行； </li><li>等号（=）命令用来打印行号； </li><li>l（小写的L）命令用来列出行。</li></ol><h5 id="p-命令"><a href="#p-命令" class="headerlink" title="p 命令"></a>p 命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is a test"</span> | sed <span class="string">'p'</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>它所做的就是打印已有的数据文本</p><p>最常见的用法是与<code>-n</code>配合打印包含匹配文本模式的行。用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line"></span><br><span class="line">$ $ sed -n &apos;/number 3/p&apos; data6.txt </span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><p>修改前后对比</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'/3/&#123;</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; s/line/test/p</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data6.txt </span><br><span class="line">This is line number 3. </span><br><span class="line">This is <span class="built_in">test</span> number 3. $</span><br></pre></td></tr></table></figure><h5 id="等号"><a href="#等号" class="headerlink" title="=等号"></a><code>=</code>等号</h5><p>等号命令会打印行在<strong>数据流中的当前行号</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;=&apos; data1.txt </span><br><span class="line">1 </span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">2 </span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'/number 4/&#123;</span></span><br><span class="line"><span class="string">&gt; =</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data6.txt 4 </span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><h5 id="显示特殊字符l"><a href="#显示特殊字符l" class="headerlink" title="显示特殊字符l"></a>显示特殊字符<code>l</code></h5><p>命令（<code>l</code>）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印 字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\t，来代表制表符。</p><p>制表符的位置使用\t来显示。行尾的美元符表示换行符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat data10.txt </span><br><span class="line">This line contains an escapecharacter.</span><br><span class="line"></span><br><span class="line">$ sed -n <span class="string">'l'</span> data10.txt </span><br><span class="line">This line contains an escape\tcharacter. \a</span><br></pre></td></tr></table></figure><h4 id="保存命令w"><a href="#保存命令w" class="headerlink" title="保存命令w"></a>保存命令<code>w</code></h4><p>w命令用来向文件写入行。该命令的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]w filename</span><br></pre></td></tr></table></figure><p><code>filename</code>可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文 件的写权限。</p><p>地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat data11.txt </span><br><span class="line">Blum, R Browncoat </span><br><span class="line">McGuiness, A Alliance</span><br><span class="line">Bresnahan, C Browncoat </span><br><span class="line">Harken, C Alliance </span><br><span class="line"> </span><br><span class="line">$ sed -n <span class="string">'/Browncoat/w Browncoats.txt'</span> data11.txt </span><br><span class="line"></span><br><span class="line">$ cat Browncoats.txt </span><br><span class="line">Blum, R Browncoat </span><br><span class="line">Bresnahan, C Browncoat</span><br></pre></td></tr></table></figure><h4 id="读取命令"><a href="#读取命令" class="headerlink" title="读取命令"></a>读取命令</h4><p>读取（read）命令（r）允许你将另一个文件中的数据插入到数据流中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]r filename</span><br></pre></td></tr></table></figure><p>地址区间<strong>只能指定单独一个行号或文本模式地址</strong>。sed编辑器会将文件中的<strong>所有文本行</strong>插入到指定地址后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat data12.txt </span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line. </span><br><span class="line"></span><br><span class="line">$ sed <span class="string">'3r data12.txt'</span> data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line. </span><br><span class="line">This is line number 4.</span><br><span class="line"></span><br><span class="line">$ sed <span class="string">'/number 2/r data12.txt'</span> data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><p>另一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat notice.std </span><br><span class="line">Would the following people:</span><br><span class="line">LIST </span><br><span class="line">please report to the ship<span class="string">'s captain. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ sed '</span>/LIST/&#123;</span><br><span class="line">&gt; r data11.txt</span><br><span class="line">&gt; d</span><br><span class="line">&gt; &#125;<span class="string">' notice.std </span></span><br><span class="line"><span class="string">Would the following people:</span></span><br><span class="line"><span class="string">Blum, R Browncoat </span></span><br><span class="line"><span class="string">McGuiness, A Alliance </span></span><br><span class="line"><span class="string">Bresnahan, C Browncoat </span></span><br><span class="line"><span class="string">Harken, C Alliance </span></span><br><span class="line"><span class="string">please report to the ship'</span>s captain. $</span><br><span class="line"></span><br><span class="line">现在占位文本已经被替换成了数据文件中的名单。</span><br></pre></td></tr></table></figure><h3 id="文本编码转换-iconv"><a href="#文本编码转换-iconv" class="headerlink" title="文本编码转换 iconv"></a>文本编码转换 iconv</h3><p>对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv 命令（这个命令支持更高级的Unicode编码）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f ISO-8859-1 -t UTF-8  file</span><br></pre></td></tr></table></figure><h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp [-qu][文件名参数]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>-d</code>     创建临时目录</li><li><code>-q</code> 　执行时若发生错误，不会显示任何信息。</li><li><code>-u</code> 　暂存文件会在mktemp结束前先行删除，不推荐使用</li><li>[文件名参数] 　文件名参数必须是以”自订名称.XXXXXX”的格式，XXX 会被替换为随机字符串。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mktemp jizx.XXX</span><br><span class="line"><span class="meta">#</span><span class="bash"> jizx.ztI</span></span><br></pre></td></tr></table></figure><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>默认情况下，mount命令会输出当前系统上挂载的 设备列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -t type device directory      # 格式说明</span><br><span class="line">mount -t vfat /dev/sdb1 /media/disk</span><br></pre></td></tr></table></figure><p><code>umount [directory | device ]</code>，<code>umount</code>命令支持通过设备文件或者挂载点来指定要卸载的设备。</p><p>在卸载设备时，系统<strong>提示设备繁忙，无法卸载设</strong>备，可用<code>lsof</code>命令获得使用它的进程信息，在应用中停止使用该设备或停止该进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof /path/to/device/node</span><br><span class="line">lsof /path/to/mount/point</span><br></pre></td></tr></table></figure><h3 id="df与-du-TODO"><a href="#df与-du-TODO" class="headerlink" title="df与 du TODO"></a>df与 du TODO</h3><p>df命令很容易发现哪个磁盘的存储空间快没了</p><p>du TODO</p><p>du命令可以显示某个特定目录（默认情况下是当前目录）的 磁盘使用情况。</p><h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><p>压缩命令 linux 命令行与 shell 脚本编程大全 4.33 </p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p><code>file</code> 查看文件类型</p><h3 id="xarg"><a href="#xarg" class="headerlink" title="xarg"></a>xarg</h3><p>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p><p>它能够捕获一个命令的输出，然后传递给另外一个命令。</p><p>args 一般是和管道一起使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">somecommand |xargs -item  command</span><br></pre></td></tr></table></figure><p>参数的功能分类：</p><p>如何分割（xargs、xargs -d、xargs -0），分割后如何划批（xargs -n、xargs -L），参数如何传递（xargs -i）。另外xargs还提供询问交互式处理（-p选项）和预先打印一遍命令的执行情况（-t选项），传递终止符（-E选项）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</span><br><span class="line">-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</span><br><span class="line">-i 或者 I  配合&#123;&#125;使用，将参数替换到命令的占位符上，对每一个参数，命令都会被执行一次。个人理解：因为 xargs 默认将参数放在其他命令的最后，但是像 cp 这种需要在中间的位置时，就可以用-I选项。具体看下面的例子。</span><br><span class="line">-t 打印 xargs 后面那个命令拼上参数后的完整形式，然后再执行，用于debug</span><br><span class="line">-s num 指定 xargs 后面那个命令的最大命令行字符数。</span><br><span class="line">-0 将 \0 作为定界符。</span><br><span class="line">-p 当每次执行一个argument的时候询问一次用户。</span><br><span class="line">-l 或者 L num 从标准输入一次读取 num 行送给 command 命令。</span><br></pre></td></tr></table></figure><h4 id="实验文件准备"><a href="#实验文件准备" class="headerlink" title="实验文件准备"></a>实验文件准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line">cd tmp</span><br><span class="line">rm -fr *</span><br><span class="line">mkdir a b c d test logdir shdir</span><br><span class="line">touch &quot;one space.log&quot;</span><br><span class="line">touch logdir/&#123;1..10&#125;.log</span><br><span class="line">touch shdir/&#123;1..5&#125;.sh</span><br><span class="line">echo &quot;the second sh the second line&quot; &gt; shdir/2.sh </span><br><span class="line">cat &lt;&lt;eof&gt;shdir/1.sh  </span><br><span class="line">&gt; the first sh</span><br><span class="line">&gt; the second line</span><br><span class="line">&gt; eof</span><br></pre></td></tr></table></figure><h4 id="流程讲解"><a href="#流程讲解" class="headerlink" title="流程讲解"></a>流程讲解</h4><p><strong>先分割，再分批，然后传递到参数位</strong></p><h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>管道传递过来的<code>stdin</code>经过<code>xargs</code>处理后的：<strong>将所有空格(多个空格)、制表符和分行符都替换为(一个)空格并压缩到一行上显示，这一整行将作为一个整体，这个整体的所有空格属性继承xargs处理前的符号属性</strong>.</p><blockquote><p>  如果想要保存制表符、空格等特殊符号，需要将它们用单引号或双引号包围起来，<strong>但是被xargs处理后，一行的整体中单双引号（和反斜线）都会被去掉。</strong></p></blockquote><h5 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h5><p><strong>文本意义上的符号和标记意义上的符号</strong></p><p>在解释xargs和它的各种选项之前，先介绍一个贯穿xargs命令的符号分类：文本意义上的空格、制表符、反斜线、引号和非文本意义上的符号。我觉得<strong>理解它们是理解xargs分割和分批原理的关键。</strong></p><ul><li><p><strong>文本意义</strong>上的空格、制表符、反斜线、引号：未经处理就已经存在的符号，例如文本的内容中出现这些符号以及在文件名上出现了这些符号都是文本意义上的。</p></li><li><p>与之相对的是<strong>非文本意义</strong>的符号，由于在网上没找到类似的文章和解释，所以我个人称之为标记意义上的符号：处理后出现的符号，例如<code>ls</code>命令的结果中每个文件之间的制表符，它原本是不存在的，只是<code>ls</code>命令处理后的显示方式。还包括<strong>每个命令结果的最后的换行符，文件内容的最后一行结尾的换行符</strong>。</p></li></ul><p>两种分批可能：</p><ul><li>指定<code>-n</code>时按空格分段，然后划批，不管是文本意义的空格还是标记意义的空格，只要是空格都是<code>-n</code>的操作对象</li><li>指定<code>-L</code>或者<code>-i</code>时按段划批，文本意义的符号不被处理，比如<code>one space.txt</code>这个文件不会被分割。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls | xargs -n 2</span><br><span class="line">ls | xargs -L 2</span><br><span class="line">ls | xargs -i -p echo &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果在一个xargs中使用了多个分批选项，则它们之间必然会冲突，它们的规则是<strong>写在后面的生效，前面的分批选项被忽略</strong>。</p><p><strong>-d 整体执行的过程</strong>：</p><ol><li><p>替换：将所有标记符号替换为<code>\n</code>，完成后所有符号(空格、制表符、换行符)都是文本符号</p></li><li><p>分段：根据分隔符进行分段、并用空格分开每段。由于分段前所有符号都是文本符号，因此分段后的文本中可能包含空格、制表符、换行符。也就是说除了-d 导致的分段空格，其余的所有符号都是分段中的一部分</p></li><li>输出：最后根据<code>-n</code>、<code>-L</code>、<code>-i</code>指定的分批选项来输出。</li></ol><p><strong><code>-0</code>等价于<code>-d&quot;\0&quot;</code></strong>，<strong>-0可以处理接收的stdin中的null字符（\0）。如果不使用 -0选项或- -null选项，检测到\0后会给出警告提醒，并只向命令传递非\0段。</strong></p><h5 id="分批行为"><a href="#分批行为" class="headerlink" title="分批行为"></a>分批行为</h5><p>分批用于指定每次传递多少个分段。有三种分批选项：-n，-L和-i。</p><p>-n 默认以空格分段划分，与-d、-0一起时，按指定的分隔符分段划分</p><p>-L 永远是按段划分的</p><p>-i  如果不使用-i，则默认是将分割后处理后的结果整体传递到命令的最尾部。但是有时候需要传递到多个位置，不使用-i就不知道传递到哪个位置了。例如重命名备份的时候在每个传递过来的文件名加上后缀.bak，这需要两个参数位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls logdir/ | xargs -i mv ./logdir/&#123;&#125; ./logdir/&#123;&#125;.bak   # 将分段传递到多个参数位</span><br></pre></td></tr></table></figure><h5 id="分批的典型应用"><a href="#分批的典型应用" class="headerlink" title="分批的典型应用"></a>分批的典型应用</h5><p>分批选项有时特别有用，例如脚本规定每次只能传输三个参数。有时候rm -rf的文件数量特别多的时候会提示参数列表太长而导致失败，这时就可以分批来按批删除。</p><p>假设目前在/tmp/longshuai/下有29W个.log文件，如果直接删除将会提示参数列表过长。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | xargs -n 10000  rm -rf</span><br></pre></td></tr></table></figure><h5 id="终止行为之-：xargs-E"><a href="#终止行为之-：xargs-E" class="headerlink" title="终止行为之 ：xargs -E"></a>终止行为之 ：xargs -E</h5><ul><li><code>-E</code>会将结果空格、制表符、分行符替换为空格并压缩到一行上显示。据我测试，-E似乎只能和独立的xargs使用，和-0、-d配合使用时都会失效。</li><li><code>-E</code>优先于<code>-n</code>、<code>-L</code>和<code>-i</code>执行。如果是分批选项先执行，则下面的第二个结果将压缩在一行上。</li><li>指定的终止符必须是完整的，例如想在遇到“xyz.txt”的符号终止时，只能指定完整的xyz.txt符号，不能指定.txt或者txt这样的符号。<ul><li>分两种情况：如果没指定分批选项或者指定的分批选项是-n或者-L时，则段是以空格为分割符，两个空格之间的段都是完整的。</li><li>如果指定的分批选项是-i，则以段为分割符。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">a  b  c  d  logdir   one space.log  shdir  sh.txt  test  vmware-root  x.txt</span><br><span class="line"></span><br><span class="line">ls | xargs -E one     #不指定分批选项</span><br><span class="line">a b c d logdir</span><br><span class="line"></span><br><span class="line">ls | xargs -n 2 -E one      #指定-n，one后面的所有的都终止传递</span><br><span class="line">a b</span><br><span class="line">c d</span><br><span class="line">logdir</span><br><span class="line"></span><br><span class="line">ls | xargs -L 2 -E&quot;one&quot;      #同-n 选项</span><br><span class="line">a b</span><br><span class="line">c d</span><br><span class="line">logdir</span><br><span class="line"></span><br><span class="line">ls | xargs -i -E&quot;one space.log&quot; echo &#123;&#125;   #和-i配合使用时指定完整的段才可以</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">logdir</span><br><span class="line"></span><br><span class="line">ls | xargs -i -E&quot;one&quot;  -p echo &#123;&#125;         #非完整段终止失效</span><br><span class="line">echo a ?...</span><br><span class="line">echo b ?...</span><br><span class="line">echo c ?...</span><br><span class="line">echo d ?...</span><br><span class="line">echo logdir ?...</span><br><span class="line">echo one space.log ?...</span><br><span class="line">echo shdir ?...</span><br><span class="line">echo sh.txt ?...</span><br><span class="line">echo test ?...</span><br><span class="line">echo vmware-root ?...</span><br><span class="line">echo x.txt ?...</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>分割行为</th><th>标记符号处理方式</th><th>分段方法</th><th>分批方法</th></tr></thead><tbody><tr><td>xargs</td><td>空格、制表符、分行符替换为空格，引号和反斜线删除。处理完后只有空格。如果空格、制表符和分行符使用引号包围则可以保留</td><td>结果继承处理前的符号性质（文本符号还是标记符号）</td><td><code>-n</code>以分段结果中的每个空格分段，进而分批。不管是文本还是标记意义的空格.<br><code>-L -i</code>以标记意义上的空格分段，进而分批</td></tr><tr><td>xargs -d</td><td>不处理文本符号，所有标记符号替换为换行符<code>\n</code>，将<code>-d</code>指定的分割符替换为标记意义的空格。结果中除了最后的空行和<code>-d</code>指定的分割符位的分段空格，<strong>其余全是文本意义上的符号</strong></td><td>按照-d指定的符号进行分段，每个段中可包含文本意义上的空格、制表符、换行符。</td><td>以标记意义上的符号（即最后的空行和-d指定分隔符位的空格）分段，进而分批。分段结果中保留所有段中的符号，包括制表符和分行符。</td></tr><tr><td>xargs -0</td><td>不处理文本意义上的符号，将非<code>\0</code>的标记意义上的符号替换为<code>\n</code>，将<code>\0</code>替换为空格。</td><td>以替换<code>\0</code>位的空格分段，每个段中可能包含文本意义上的空格、制表符、换行符。</td><td>检测到<code>\0</code>时，以标记意义上的符号（即最后的空行和<code>\0</code>位的空格）分段，进而分批。分段结果中保留所有段中的符号，包括制表符和分行符。未检测到<code>\0</code>时，整个结果作为不可分割整体，使用分批选项是无意义的</td></tr></tbody></table><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>只要能分批的选项，都可以使用”-P”，包括”-n”、”-L”和”-i”。</p><p>使用xargs的分批行为，除了可以解决一些问题，还可以一次性将多个分批交给不同进程去处理，这些进程可以使用多个cpu执行，效率可谓大幅提高。</p><p>“-P N”选项可以指定并行处理的进程数量为N。不指定”-P”时，默认为1个处理进程，也就是串行执行。指定为0时，将尽可能多地开启进程数量。</p><h4 id="xargs的限制"><a href="#xargs的限制" class="headerlink" title="xargs的限制"></a>xargs的限制</h4><p>其实是xargs的限制和缺点，但因为通过”-i”选项方便演示，所以此处使用”-i”选项。注意，不是”-i”选项的缺陷。</p><p>由于xargs -i传递数据时是在shell执行xargs命令的时候，根据<a href="http://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">shell解析命令行的流程</a> ，xargs后的命令如果有依赖于待传递数据的表达式，则无法正确执行。</p><p>第一：无法通过xargs传递数值做正确的算术扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1  | xargs  -I &quot;x&quot; echo $((2*x))</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>第二：无法将数据传递到命令替换中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo /etc/fstab | xargs -i `cat &#123;&#125;`     </span><br><span class="line">cat: &#123;&#125;: No such file or directory</span><br></pre></td></tr></table></figure><p>参考下图的shell命令行解析过程。</p><p><img src="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/733013/201905/733013-20190521092610066-2092901095.png" alt="img"></p><p>这时要通过xargs正确实现目标，只能改变方法或寻找一些小技巧，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# echo 1  | xargs -i expr 2 \* &#123;&#125;    # 感谢楼下评论者提供的expr思路</span><br><span class="line">2</span><br><span class="line">[root@xuexi ~]# echo /etc/fstab | xargs -i cat $(echo &#123;&#125;)</span><br></pre></td></tr></table></figure><p>第三：xargs无法处理bash内置命令。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi ~]# echo /etc  | xargs -i cd &#123;&#125;</span><br><span class="line">xargs: cd: No such file or directory</span><br></pre></td></tr></table></figure><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>复制所有图片文件到 <code>/data/images</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls 出来的每一行文件名，都会通过 xargs 传递给 cp 命令</span></span><br></pre></td></tr></table></figure><p>统计一个源代码目录中所有 php 文件的行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l</span><br></pre></td></tr></table></figure><h5 id="删除带空格的文件"><a href="#删除带空格的文件" class="headerlink" title="删除带空格的文件"></a>删除带空格的文件</h5><p>删除带空格的文件名，思路是让找到的“one space.log”成为一个段，而不是两个段。我给出了常见的两种。</p><p>方法一：通过常用的find的-print0选项使用\0来分隔而不是\n分隔，再通过xargs -0来配对保证one space.log的整体性。因为-print0后one space.log的前后各有一个\0，但是文件名中间没有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi tmp]# find -name &quot;* *.log&quot; -print0 | xargs -0 rm -rf</span><br></pre></td></tr></table></figure><p>当然，能使用-0肯定也能使用-d了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi tmp]# find -name &quot;* *.log&quot; -print0 | xargs -d &quot;x&quot; rm -rf     #随意指定非文件名中的字符都行，不一定非要\0</span><br></pre></td></tr></table></figure><p>方法二：不在find上处理，在xargs上处理，只要通过配合-i选项，就能宣告它的整体性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi tmp]# find -name &quot;* *.log&quot; | xargs -i rm -rf &quot;&#123;&#125;&quot;</span><br></pre></td></tr></table></figure><p>相较而言，方法一使用的更广泛更为人所知，但是方法二更具有通用性，对于非find如ls命令也可以进行处理。</p><p>还可以使用tr将find的换行符换成其他符号再xargs分割配对也行。</p><p>除了find -print0可以输出\0字符，Linux中还有其他几个命令配合参数也可以实现：<strong>locate -0</strong>,<strong>grep -z</strong>或<strong>grep -Z</strong>,<strong>sort -z等</strong>。</p><p>其他小例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat test.txt | xargs -n3</span></span><br><span class="line"></span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"nameXnameXnameXname"</span> | xargs -dX</span></span><br><span class="line"></span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/f-ck-need-u/p/5925923.html#auto_id_4" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/5925923.html#auto_id_4</a></p><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p><strong>tee命令</strong>可以把数据重定向到<strong>给定文件</strong>和<strong>屏幕</strong>上，相当于分流了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a：向文件中重定向时使用追加模式；</span><br></pre></td></tr></table></figure><p><img src="/2019/08/04/linux常用命令/./tee.gif" alt="tee"></p><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>TODO scp 的完整命令</p><p><strong>scp免密码</strong></p><ol><li>在A中执行命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &quot;&quot;</span><br></pre></td></tr></table></figure><p>这会在 ~/.ssh 目录下生成两个文件：id_rsa 和 id_rsa.pub</p><ol><li>拷贝A的id_rsa.pub到B：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.ssh/id_rsa.pub yliu@192.168.200.1:/home/yliu</span><br></pre></td></tr></table></figure><ol><li>登录B，并把id_rsa.pub输入到B的authorized_keys文件中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/yliu/id_rsa.pub &gt;&gt; /home/yliu/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><ol><li>最后一步：如果是第一次生成authorized_keys，需要授权：chmod 600 authorized_keys</li></ol><p>大功告成！此时在复制文件就无需输入密码了。而且，<strong>在A中ssh登录B也无需密码</strong>了。</p><p>反之亦然，在B中设置A的免密码登录完全一样，在此不做赘述。</p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="一行内指令"><a href="#一行内指令" class="headerlink" title="一行内指令"></a>一行内指令</h3><p>一行内指定依次运行的一系列指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls</span><br></pre></td></tr></table></figure><h3 id="命令行中输入tab"><a href="#命令行中输入tab" class="headerlink" title="命令行中输入tab"></a>命令行中输入tab</h3><p>我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在<code>sort -t</code>选项后输入<code>字符），你可以先按`Ctrl-V`，然后再按Tab键，就可以输入</code>字符了。当然，你也可以使用<code>$&#39;\t&#39;</code>。</p><p>EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。</p><p>参考：<a href="https://awk.readthedocs.io/en/latest/chapter-one.html" target="_blank" rel="noopener">https://awk.readthedocs.io/en/latest/chapter-one.html</a></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
            <tag> ing </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>photoshop曲线原理与应用</title>
      <link href="/2018/12/18/photoshop%E6%9B%B2%E7%BA%BF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2018/12/18/photoshop%E6%9B%B2%E7%BA%BF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>转载poco：photoshop曲线原理与应用，<a href="https://www.jb51.net/photoshop/532386.html" target="_blank" rel="noopener">https://www.jb51.net/photoshop/532386.html</a></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><blockquote><p>关键句：可以看到S型曲线中间部分，输入和输出值变化很小。所以<strong>S曲线在中间调区域的影响并不大，很好的保护了照片细节最丰富的部分。</strong>白色和黑色区域在最两端，S型曲线对这些亮度区域的改变也不大，<strong>有效防止了过曝和欠曝溢出。</strong></p></blockquote><h3 id="零、曲线工具原理"><a href="#零、曲线工具原理" class="headerlink" title="零、曲线工具原理"></a>零、曲线工具原理</h3><p>如果说直方图是摄影师的“X光片”，那么曲线工具一定是摄影师的“手术刀”了。</p><p>曲线作为重要的影调和色调调整工具，不仅存在于Photoshop中，在ACR，Lightroom甚至其他很多手机P图软件中都占据着显眼的位置。本篇文章，就将详细谈谈什么是RGB曲线，如何使用提亮压暗、黑白场、对比度，以及局部调整曲线等基本形态，调整一张照片的影调。同时，还会讲解如何把各种基本曲线形态组合起来，达到胶片、漂白、日系等等更复杂的影调效果。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754284.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p><strong>曲线工具在哪?</strong></p><p>曲线面板在Lightroom和Adobe Camera Raw工具中，都是紧接着基本面板的第二个面板，足以感受到它的重要性。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754285.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>在Photoshop中，我们一般会使用曲线调整图层来改变曲线。在PS中图层面板的右下角，第四个图标就是“新建调整图层”选项，点击后选择“曲线”，我们就可以新建一个“曲线调整图层”。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754286.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>新建调整图层，而不是在原图层上直接改变曲线。优点就是可以让我们方便的撤销/恢复所做的任意调整。曲线是什么?</p><p>本文将重点讲解RGB通道曲线，它是由红(R)绿(G)蓝(B)三个通道的曲线叠加而成的，可以“近似的”理解成图片的亮度曲线。</p><p><strong>RGB曲线调整的核心其实就是对原图亮度的变换。</strong></p><p>曲线的横轴是原图的亮度分布，从左到右依次是0值纯黑，1-254的中间灰色值，以及最右边255的纯白最亮值。横轴上叠加着一个直方图，显示出原图各个亮度上，分别存在着多少像素。</p><p>曲线的纵轴是目标图(调整后)的亮度，从下到上任然是0-255的亮度值。当中的那根线就是我们的“曲线”。当我们在曲线上任意取一个点，它的“输入值”就是它横轴对应的值，即原图中的亮度，它的“输出值”就是它纵轴中的数值，也就是调整后它的亮度值。</p><p>未调整的情况下，图像的曲线会是一条对角线，也就是横轴(原图)和纵轴(目标图)的亮度值相等。比如我在曲线上取了一个点，它的输入和输出值都是193。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754287.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>如果我把这个点往上移动，可以看到这个点的输出值变成了232.这意味着原图直方图上那些193亮度的点，都被提亮到了更亮的232。同时我们可以发现曲线的一个特点，当我们变动一个点的时候，旁边的点也会跟着一起变化，离调整点越远的点变化越小。这样使得曲线调整的图片，大多数情况都比较的平滑自然。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754288.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>通过在曲线上添加控制点(锚点)，我们就可以把曲线变成各种各样的形态，从而达到我们想要的影调效果。接下来我就会通过一些基本的曲线形态，来进一步的解释曲线。</p><h3 id="一、提亮压暗曲线"><a href="#一、提亮压暗曲线" class="headerlink" title="一、提亮压暗曲线"></a>一、提亮压暗曲线</h3><p>提亮和压暗一张图片，并不是我们想象中的对图片中所有点都加大减小同样的亮度值。比如下面这个曲线，就是把图像上所有的点亮度都提高了64。这样造成了2个不好的结果：</p><p>(1)图片的高光区域直接过曝溢出了</p><p>(2)图片的阴影和黑色区域亮度大大提高，使得图片黑场不足，严重发灰。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754289.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>所以我们一般提亮图片都是用如下的曲线，把锚点放在中间调附近往上提。这样照片主要是中间调的亮度大幅提高。高光区域亮度提高较少，防止了过曝。阴影黑色区域提升也不多，较好的维持了图像的对比反差程度。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754290.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>同样的，我们要压暗一张图片，也是用描点下拉图片的中间调。保护阴影区域不欠曝，让高光白色区域维持住对比度。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754291.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><h3 id="二、黑白场曲线"><a href="#二、黑白场曲线" class="headerlink" title="二、黑白场曲线"></a>二、黑白场曲线</h3><p>我们把照片上最暗的点叫做黑场，最亮的点叫做白场，黑白场的差值决定了一张照片的反差程度。通过横移和竖移曲线的左右两端，就可以加大和减小照片的黑白场差值。</p><p>比如下面这张图片就是一张灰蒙蒙的低反差图片，照片最暗的地方也只是亮度高达50多的深灰色，照片最亮的地方也只是200多的浅灰色。照片的黑色和白色区域完全没有像素。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754292.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>所以我把曲线最右侧横向左移，此时原来亮度值(输入值)219的像素，全部被提亮到了255(输出值)的纯白色。照片中终于有了亮白的部分。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754293.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>同样我在曲线最左侧建立一个锚点，横向右拉，此时原来亮度值55的深灰色区域，就全部输出成了亮度为0的纯黑区域。照片中又有了深黑色。通过这两步，我们加大了照片黑白场的差距，照片的反差就大大提高了。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754294.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>黑白场差值大的图片一般层次丰富，鲜艳锐利。但是照片的黑白场差值并不是越高越好。一个很大的误区就是照片的黑场一定要是0，白场必须为255。实则不然，比如这张照片，照片的黑场是0，照片中有许多深黑区域，显得反差比较大，可能并不是我们想要的效果。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754295.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>我在曲线最左侧建立一个锚点，纵向上拉。这样输入值为0的纯黑部分，亮度被提高到了38。照片中不再有纯黑，最暗的部分(也就是黑场)也是亮度38的深灰色，这样的照片看起来更加的朦胧淡雅，符合我们想要的气氛。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754296.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><h3 id="三、对比度曲线"><a href="#三、对比度曲线" class="headerlink" title="三、对比度曲线"></a>三、对比度曲线</h3><p>对比度曲线，其实就是摄影里几乎人人皆知的S型曲线和反S型曲线了。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754297.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>增强对比度曲线(S型曲线)，其实就是在高光处建立锚点并提高，在阴影处建立锚点并降低，拉出一个像英语字母S一样的曲线。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754298.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>仔细观察S曲线，或许我们就能理解到其背后的原理。前面的教程我们提到过，一张照片按亮度从低到高分为黑色，阴影，中间调(曝光度)，高光和白色5个部分。其中中间调区域的过渡与细节最为细腻。可以看到S型曲线中间部分，输入和输出值变化很小。所以S曲线在中间调区域的影响并不大，很好的保护了照片细节最丰富的部分。白色和黑色区域在最两端，S型曲线对这些亮度区域的改变也不大，有效防止了过曝和欠曝溢出。S曲线主要是提高了原来照片中高光部分的亮度，降低了阴影部分的亮度，让照片的影调更加偏向硬调。因此S曲线在保护黑白色与中间调细节的前提下，有效的提高了照片的对比度，几乎成为了大部分照片必用的一步。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754299.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>类似的，如果我们降低高光锚点，提高阴影锚点，形成一个反S的形状。就是降低对比度曲线了。</p><h3 id="四、曲线的局部调整"><a href="#四、曲线的局部调整" class="headerlink" title="四、曲线的局部调整"></a>四、曲线的局部调整</h3><p>前面三个曲线形态都是作用在照片的全局。但数码后期的一个核心思路，就是局部调整照片不同的区域，让每个区域在展现出最好效果的同时不要影响到其他区域。比如这张图片，雪山和湖之间的草地一片漆黑，需要提亮。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754300.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>如果我直接应用提亮曲线，草地倒是变亮了，但雪山(高光部分)和天空(中间调部分)一下子就过曝了。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754301.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>所以我需要建立两个锚点，把提亮的高光和中间调部分重新拉回来。这样这条曲线就只提高了照片阴影部分的亮度。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754302.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>在局部调整曲线时，有一个非常有用的工具。就是圆圈中那个手一样的图标，点击它之后再把鼠标移动到图像里面，鼠标就会变成一个吸管，同时在右边曲线面板里，会实时显示吸管所在点对应在曲线里的位置。单击吸管，吸管所在的点，就会对应成一个锚点记录在直方图上，方便我们调整。比如这张图，我想降低深色的山体的亮度，同时又保持住白色雾气的亮度。所以我选择“手”图标后，先在红圈1的山体处点一下，曲线中对应建立了1锚点。再在雾气的红圈2处点一下，曲线中就建立了对应的2锚点。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754303.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>这样我下压1锚点，同时保持住2锚点，就只降低了阴影的山体区域，而高光的雾气则没有被影响。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754304.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>在上面讲了RGB曲线是什么。通过提亮压暗曲线，黑白场曲线，对比度曲线三种基本形态，以及对他们的局部应用，就可以快速的调整一张照片的影调了。接下来谈谈如何把这几种基本曲线组合起来，调出复杂的影调效果。</p><p>同样的，三种基本曲线虽然看起来都很简单，但当我们把这些基本形态结合起来的时候，却可以创作出丰富多样的复杂效果。</p><h3 id="五、暗调效果曲线"><a href="#五、暗调效果曲线" class="headerlink" title="五、暗调效果曲线"></a>五、暗调效果曲线</h3><p>下图是一张英国七姐妹白崖的照片，如果我们想让它更加的阴沉，仿佛世界尽头一样。应该怎么调整呢?</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754305.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>直接运用我们学过的压暗曲线，可以发现照片的中间调已经达到了我们想要的低沉影调。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754306.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>但是这样的话暗部几乎一片漆黑，失去了细节。所以我在暗部再增加一个锚点上拉，相当于在暗部又局部的应用了提亮曲线。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754307.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>这样虽然暗部细节回来了，但是阴影部分发灰严重，乌云已经完全失去了立体感。所以再在暗部建立2个锚点，叠加上一条S型曲线，提高暗部的对比度。可以发现天上的乌云内部的层次对比又展现了出来。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754308.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>最后在高光区也建立一个锚点上拉，相当于在高光部分叠加了一个局部提亮曲线，重新恢复了高光的亮度。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754309.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>这张暗调照片的最后曲线=全局压暗曲线+暗部提亮曲线+暗部增加对比度曲线+亮部提亮曲线。看起来很复杂，其实只要理解了原理非常简单，三种基本曲线的一步步的叠加应用而已。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754310.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><h3 id="六、胶片效果曲线"><a href="#六、胶片效果曲线" class="headerlink" title="六、胶片效果曲线"></a>六、胶片效果曲线</h3><p>下图是一张泰国美功铁路市场的照片，如果我们想让它更有胶片味儿。应该怎么调整呢?</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754311.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>最简单的办法就是直接套用PS里的颜色查找表(3D-Lut)工具或者使用各种第三方胶片滤镜了。各种预设好的胶片LUT，可以快速的让图片带上不同类型胶片的影调和色调。不过其实这些效果也是可以通过曲线来完成的。仔细观察下面这张套用 柯达5218胶片 LUT 的成片效果，可以发现它的直方图在保持对比度的同时有一个明显的右移，黑色区域完全没有像素。发灰的暗部给了我们一种照片暗部细节非常丰富的错觉，看起来就像是用高宽容度的胶片拍摄的。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754312.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>要消除直方图中的黑色像素很简单，使用我们学过的黑白场曲线，(竖直向上)提高照片的黑场锚点即可。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754313.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>不过这样不仅照片的暗部发灰，中间调和高光也变灰了。所以为了恢复对比度，我再在上面曲线的基础上拉一个S型曲线(增加对比度曲线)。这样这张照片就获得了很多胶片类似的影调，暗部发灰但对比度又很足。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754314.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>之后我们可以继续应用可选颜色、渐变映射、色相饱和度等等调色工具，给照片加上胶片的色调，这些色彩调整工具会在以后的教程中继续展开。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754315.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>这里的胶片曲线=提高黑场曲线+增强对比度曲线。我们并不需要记忆这个公式，因为有的胶片效果反而是需要减少对比度的。只要理解了三种基本的曲线形态，各种各样的效果我们都是可以组合出来的。</p><p><strong>七、压黑漂白效果曲线</strong></p><p>压黑漂白效果很适合运动类，主体硬朗，以及感情强烈的片子。其特点如下图所示，有大量的纯黑或者纯白区域，反差强烈。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754316.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>下面是这张道路上飞驰的装甲车的原片，反差不够强烈，无法体现出装甲战士带给我们的冲击力。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754317.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>使用黑白场曲线右移黑场锚点，照片中很暗的部分全部都变成了纯黑。黑色倒是足够了，但黑白场曲线的副作用就是把整个图片都压黑了。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754318.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>所以在亮部建立锚点，用提亮曲线提高高光和中间调，营造硬朗的反差效果。这种扩大纯黑并提亮亮部的效果就称为压黑(Crushed Black)效果。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754319.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>与压黑类似的还有漂白效果。顾名思义，漂白效果就是照片整体提亮，白色溢出，同时暗处也变亮并压缩成深灰色，仿佛照片印在纸上再放进漂白水里漂白出来一样。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754320.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>漂白曲线的前两部跟压黑曲线一样，先是把暗部变成纯黑，同时提亮照片。 漂白效果会进一步让高光也溢出成白色，虽然丢掉细节，但是照片会更有明快动感的气氛。在曲线中可以通过左移白场锚点实现这个效果。 最后我们把黑场的点再上移一段距离，可以理解成刚刚压缩成纯黑的暗部，提亮成了同一种深灰色。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754321.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754322.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，不管是胶片曲线，暗调曲线，还是压黑漂白曲线，无论多么复杂的效果。其本质任然是提亮压暗，黑白场和对比度这3种基本曲线，在整体和各个局部组合而成的，所以我们并不需要死记硬背这些复杂效果的曲线长什么样。只要理解了三种基本曲线形态的作用，就可以根据需要，组合出自己想要的各种影调效果了。</p><p>PS曲线不仅可以调整照片的影调，各个色彩通道的曲线还可以影响照片的色调，这些就只能在未来的教程中继续展开了。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> photoshop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> photoshop </tag>
            
            <tag> 曲线 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式必知必会</title>
      <link href="/2018/12/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2018/12/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>正则表达式必知必会的笔记</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="元字符表"><a href="#元字符表" class="headerlink" title="元字符表"></a>元字符表</h2><p>下面介绍的是在正则表达式中有特殊意义的字符，称为元字符</p><p><img src="/2018/12/18/正则表达式必知必会/./正则表达式符号表.jpg" alt="正则表达式符号表"></p><p><img src="/2018/12/18/正则表达式必知必会/./正则表达式符号表2.png" alt="正则表达式符号表2"></p><h3 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h3><p>如果要查找这些字符本身，需要用<code>\</code>进行转义，比如想匹配点号<code>.</code> 就需要这样写<code>\.</code>  有个特殊的例子：如果想匹配<code>\</code>就需要这样<code>\\</code></p><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><h3 id="匹配字符中的一个"><a href="#匹配字符中的一个" class="headerlink" title="匹配字符中的一个"></a>匹配字符中的一个</h3><ul><li><code>.</code>：  匹配任意一个字符（除了换行符）</li><li><code>[]</code>： 匹配多个字符中的一个<ul><li>自定义字符：[akm]，匹配a、k、m中的一个</li><li>字符区间：[ASCII1-ASCII2]，可以是ASCII中的任意字符作为起始字符（<strong>ASCII1小于ASCII2</strong>），常用的有：[a-z]、[A-Z]、[0-9]、[A-Za-z]（<strong>可以有多个字符区间</strong>）</li><li>取反操作：[^a-z] 表示匹配不是a到z的任意字符，<strong>^的作用效果是整个区间</strong>，而不仅仅是跟在其后的字符<blockquote><p>-是一个元字符，表示区间，不会匹配减号，因此不需要转义</p><p>^是一个元字符，表示在[ ]中表示非匹配，不会匹配到^，因此不需要转义</p></blockquote></li></ul></li></ul><h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>也就是不可见的字符</p><table><thead><tr><th>符号</th><th>用途</th></tr></thead><tbody><tr><td>\f</td><td>匹配一个换页符。</td></tr><tr><td>\n</td><td>匹配一个换行符。</td></tr><tr><td>\r</td><td>匹配一个回车符。</td></tr><tr><td>\t</td><td>匹配一个制表符。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。</td></tr></tbody></table><h3 id="匹配特定一类的字符"><a href="#匹配特定一类的字符" class="headerlink" title="匹配特定一类的字符"></a>匹配特定一类的字符</h3><h4 id="不可见字符"><a href="#不可见字符" class="headerlink" title="不可见字符"></a>不可见字符</h4><table><thead><tr><th>符号</th><th>用途</th></tr></thead><tbody><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。<strong>等价于 [ \f\n\r\t\v]。</strong></td></tr><tr><td>\S</td><td>匹配任何非空白字符。<strong>等价于 [ ^\f\n\r\t\v]。</strong></td></tr></tbody></table><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><table><thead><tr><th>\d</th><th>等价于[0-9]</th></tr></thead><tbody><tr><td>\D</td><td>等价于[^0-9]</td></tr></tbody></table><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>匹配大小写字母、数字、下划线</p><table><thead><tr><th>\w</th><th>等价于[a-zA-Z0-9_]</th></tr></thead><tbody><tr><td>\W</td><td>等价于[^a-zA-Z0-9_]</td></tr></tbody></table><h4 id="匹配中文"><a href="#匹配中文" class="headerlink" title="匹配中文"></a>匹配中文</h4><p>需要切换匹配模式为‘u’，表示要匹配的内容为unicode编码内容,汉字的unicode起始编码是：0x4e00—0x9fa5，因此要匹配全部为中文的正则为：<code>$patern = &quot;/[\x{4e00}-\x{9fa5}]/u&quot;</code></p><h2 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h2><table><thead><tr><th>符号</th><th>用途</th></tr></thead><tbody><tr><td>+</td><td>出现1至多次</td></tr><tr><td>*</td><td>出现0至多次</td></tr><tr><td>？</td><td>出现0或1次</td></tr><tr><td>{n}</td><td>精确控制出现n次</td></tr><tr><td>{n,m}</td><td>区间控制，出现n至m次</td></tr><tr><td>{n,}</td><td>至少出现n次</td></tr></tbody></table><h3 id="贪心匹配"><a href="#贪心匹配" class="headerlink" title="贪心匹配"></a><strong>贪心匹配</strong></h3><p>+、*、{n,}会贪婪的进行匹配，比如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;text1&lt;/b&gt; &lt;b&gt;text2&lt;/b&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;[Bb]&gt;.*&lt;/[Bb]&gt;</code> 会匹配着整体字符串，而不是两个<code>&lt;b&gt;text1&lt;/b&gt;</code> <code>&lt;b&gt;text2&lt;/b&gt;</code> </p><p>因此需要<strong>懒惰匹配</strong> ：</p><p><code>&lt;[Bb]&gt;.*?&lt;/[Bb]&gt;</code> 会匹配到两个<code>&lt;b&gt;text1&lt;/b&gt;</code> <code>&lt;b&gt;text2&lt;/b&gt;</code> </p><table><thead><tr><th>贪婪版</th><th>懒惰版</th></tr></thead><tbody><tr><td>*</td><td>*？</td></tr><tr><td>+</td><td>+？</td></tr><tr><td>{n,}</td><td>{n,}？</td></tr></tbody></table><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="单词边界（boundary）"><a href="#单词边界（boundary）" class="headerlink" title="单词边界（boundary）"></a>单词边界（boundary）</h3><p>\b：匹配单词的开始或者结束位置，也就是单词边界：单词和符号之间的边界</p><blockquote><p>单词可以是中文字符,英文字符,数字</p><p>符号可以是中文符号,英文符号,空格,制表符,换行</p></blockquote><p>具体来说：\b匹配的位置是这样的位置，这个位置位于一个能够用来构成单词的字符（\w）和一个不能用来构成单词的字符（\W）之间</p><p>例子：</p><p><code>\bcat\b</code> 可以匹配到 <code>the cat catcat</code> 中的第一个cat，<strong>因为它前面与后面都有一个单词，因此存在单词分隔符</strong>，而不会匹配到后面的catcat</p><p>这里有个<strong>一开始看不懂</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 为什么cat匹配不到，因为cat是单词，它前面与后面都有一个单词，因此存在单词分隔符</span><br><span class="line">&gt;&gt;&gt; re.findall(r&quot;\Bcat\B&quot;,&quot;the   cat  cao&quot;)</span><br><span class="line">[]</span><br><span class="line"># -却能匹配到，因为-不是单词，所以尽管它前后都有单词，但与-之间不存在单词分割符（除了-，其他\W也是一样的）</span><br><span class="line">&gt;&gt;&gt; re.findall(r&quot;\B-\B&quot;,&quot;color  -  code&quot;)</span><br><span class="line">[&apos;-&apos;]</span><br></pre></td></tr></table></figure><p>注意：java与python中有个地方不同，一个匹配失败，一个成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">" 2 "</span>;</span><br><span class="line">String rex = <span class="string">"\b2\b"</span>;</span><br><span class="line"></span><br><span class="line">Pattern pattern = Pattern.compile(rex);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (matcher.matches())</span><br><span class="line">System.out.println(<span class="string">"匹配成功"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"匹配不成功"</span>); <span class="comment">// 这是结果</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=<span class="string">" 2 "</span></span><br><span class="line">&gt;&gt;&gt; m=re.search(r<span class="string">'\b2\b'</span>,s)</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">1</span>, <span class="number">2</span>), match=<span class="string">'2'</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h3><table><thead><tr><th>符号</th><th>用途</th></tr></thead><tbody><tr><td>^</td><td>默认模式下：匹配整个字符串开始位置；<strong>在多行模式下：可以匹配换行符后的开始位置</strong></td></tr><tr><td>$</td><td>默认模式下：匹配整个字符串结束位置；<strong>在多行模式下：可以匹配换行符后的结束位置</strong></td></tr></tbody></table><h2 id="子表达式（分组）"><a href="#子表达式（分组）" class="headerlink" title="子表达式（分组）"></a>子表达式（分组）</h2><p>用<code>()</code>将正则表达式括起来的就是子表达式，子表达式可以嵌套</p><p>例子：</p><p>年份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19|20\d&#123;2&#125;    错误，这会匹配19或者20xx</span><br><span class="line">(19|20)\d&#123;2&#125;  正确</span><br></pre></td></tr></table></figure><p>IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 任意的1位或2位数字</span><br><span class="line">* 任意的以1开头的3位数字</span><br><span class="line">* 任意的以2开头，0-4为第二位的3位数字</span><br><span class="line">* 以25开头，第3位数字是0-5的3位数字</span><br><span class="line">如下，实现了匹配上面的合法的0-255之间的数字</span><br><span class="line">(\d&#123;1,2&#125;)  | (1\d&#123;2&#125;)  | (2[0-4]\d) | (25[0-5]) </span><br><span class="line">因此匹配IP的正则如下：</span><br><span class="line">(((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d)|(25[0-5]))\.)&#123;3&#125; ((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d) |(25[0-5]))</span><br></pre></td></tr></table></figure><h3 id="子表达式嵌套"><a href="#子表达式嵌套" class="headerlink" title="子表达式嵌套"></a>子表达式嵌套</h3><p>使用的是<strong>深度优先搜索</strong>，以下面的例子来解释：</p><ul><li>group(0)代表整个正则表达式</li><li>group(1)代表第1个子表达式，也就是最外层的括号</li><li>group(2)代表第2个子表达式<br><img src="/2018/12/18/正则表达式必知必会/./子表达式嵌套问题.jpg" alt="子表达式嵌套问题"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=&quot;jizx333hhhh&quot;</span><br><span class="line">&gt;&gt;&gt; m=re.search(r&quot;((\w+?)(\d(\d(\d)))(\w&#123;4&#125;))&quot;,s)</span><br><span class="line">&gt;&gt;&gt; m.group(0)</span><br><span class="line">&apos;jizx333hhhh&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(1)   # 上图中的根节点</span><br><span class="line">&apos;jizx333hhhh&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(2)</span><br><span class="line">&apos;jizx&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(3)</span><br><span class="line">&apos;333&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(4)</span><br><span class="line">&apos;33&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(5)</span><br><span class="line">&apos;3&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(6)</span><br><span class="line">&apos;hhhh&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(7)</span><br><span class="line">IndexError: no such group</span><br></pre></td></tr></table></figure><h3 id="不保存分组"><a href="#不保存分组" class="headerlink" title="不保存分组?:"></a>不保存分组<code>?:</code></h3><p><code>(:X)</code>在正则中表示所匹配的子组X不作为结果输出，称为非捕获分组，不想被捕获的时候使用，可以提高程序执行速度</p><p>正常情况(X)中的X会被作为新增的一个组序号输出，比如(A)(B)，A的序号1，B的序号2<br>如果(?:A)(B)，A将没有序号不输出，B的序号为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text=<span class="string">"我的电话是1234567890"</span></span><br><span class="line">pat1=<span class="string">r"(\d&#123;3&#125;)(\d&#123;3&#125;)(\d&#123;4&#125;)"</span></span><br><span class="line">pat2=<span class="string">r"(?:\d&#123;3&#125;)(\d&#123;3&#125;)(\d&#123;4&#125;)"</span></span><br><span class="line"></span><br><span class="line">match=re.search(pat1,s)</span><br><span class="line">print(match.groups())</span><br><span class="line"></span><br><span class="line">match=re.search(pat2,s)</span><br><span class="line">print(match.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('123', '456', '7890')</span></span><br><span class="line"><span class="comment"># ('456', '7890')</span></span><br></pre></td></tr></table></figure><h3 id="python中的一个坑"><a href="#python中的一个坑" class="headerlink" title="python中的一个坑"></a>python中的一个坑</h3><p>python中split方法，在匹配部分加上括号 <code>()</code>之后所切出的结果是不同的，匹配模式加<strong>括号</strong>表示<strong>保留匹配到的分隔子串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">res=re.split(<span class="string">"\|"</span> , <span class="string">' runoob|runoob|runoob.'</span>)</span><br><span class="line"><span class="comment"># [' runoob', 'runoob', 'runoob.']</span></span><br><span class="line"></span><br><span class="line">res=re.split(<span class="string">"(\|)"</span> , <span class="string">' runoob|runoob|runoob.'</span>) <span class="comment"># 添加括号，会保留分割符</span></span><br><span class="line"><span class="comment"># [' runoob', '|', 'runoob', '|', 'runoob.']</span></span><br></pre></td></tr></table></figure><p>如果你不想保留分割字符串到结果列表中去，但仍然需要使用到括号来分组正则表达式的话， 确保你的分组是非捕获分组，形如 <code>(?:pattern)</code></p><h2 id="回溯引用"><a href="#回溯引用" class="headerlink" title="回溯引用"></a>回溯引用</h2><p>回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式。</p><p><code>\0</code>表示整个正则表达式、<code>\1</code>表示第一个子表达式、<code>\2</code>表示第二个子表达式，以此类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is is a apple,and and I like it it.</span><br><span class="line">[ ]+(\w+)[ ]+\1     匹配重复出现两次的单词，\1表示的就是(\w+)</span><br></pre></td></tr></table></figure><h3 id="子表达式-分组-命名"><a href="#子表达式-分组-命名" class="headerlink" title="子表达式(分组)命名"></a>子表达式(分组)命名</h3><p>除了使用上面\1 、\2的方式，来引用子表达式，还可以为子表达式命名，然后引用。</p><p>为子表达式命名：<code>(?P&lt;name&gt; rexp)</code></p><p>引用子表达式：<code>(?P=name)</code></p><p>例子：</p><p>匹配单、双引号包围的字符串</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">she said: &quot;I love you&quot;,and he replied &apos;me,too&apos;</span><br></pre></td></tr></table></figure><p>正则表达式：<code>(?P&lt;quote&gt;[&#39;&quot;]).*?(?P=quote)</code> 等价于<code>([&#39;&quot;]).*?\1</code></p><p>结果：</p><p>she said: <strong>“I love you”</strong>,and he replied <strong>‘me,too’</strong></p><h3 id="使用回溯替换"><a href="#使用回溯替换" class="headerlink" title="使用回溯替换"></a>使用回溯替换</h3><p>将电话格式进行修改：</p><p>文本：</p><p><code>我的电话是1234567890</code></p><p>搜索表达式：</p><p><code>(\d{3})(\d{3})(\d{4})</code></p><p>替换表达式：</p><p><code>\1***\2</code></p><p>结果：</p><p><code>我的电话是123***7890</code></p><blockquote><p>Javascript 在搜索表达式中使用\1，在替换表达式中使用$1来获取引用</p></blockquote><h3 id="使用回溯进行大小写"><a href="#使用回溯进行大小写" class="headerlink" title="使用回溯进行大小写"></a>使用回溯进行大小写</h3><p>不过支持该用法的不多（java不支持）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\E   end，表示大小写转换的结束范围</span><br><span class="line">\l   low，表示把下一个字符转为小写</span><br><span class="line">\L  Low，表示把\L与\E之间的字符转为小写</span><br><span class="line">\u   up，表示把下一个字符转为大写</span><br><span class="line">\U   Up，表示把\U与\E之间的字符转为大写</span><br></pre></td></tr></table></figure><p>举例：<br> 搜索正则表达式<br><code>&lt;([Hh][1-6])&gt;(.*?)&lt;/\1&gt;</code><br> 替换正则表达式<br><code>&lt;$1&gt;\U$2\E&lt;$1&gt;</code><br> 注意：字母有大小写之分，文字没有。</p><h2 id="前后查找"><a href="#前后查找" class="headerlink" title="前后查找"></a>前后查找</h2><p>向前查找、向后查找实际上都是子表达式。它们查找满足条件的字符串，但忽略掉其中指定的部分（不消费）。</p><blockquote><p>具体理解是：从字符串开始位置，有一个光标，光标每向前移动一次，就在光标所在的位置之前或之后判断某些字母是否符合条件，如果符合，就把光标所在位置之前的字符串返回，但忽略子表达式匹配到的字符串</p></blockquote><p>区别是：</p><ul><li>向前查找：真正需要的是<strong>前面部分</strong>的字符串( <strong>http</strong>: )。</li><li>向后查找：真正需要的是<strong>后面部分</strong>的字符串( $<strong>400</strong> )。</li><li>向前查找模式的<strong>长度是可变的</strong>，可以包含.和+之类的元字符</li><li>向后查找模式只能是<strong>固定长度的</strong>。（个人理解为：如果不是固定长度的话，可能会把后面需要输出的部分给隐藏起来）</li></ul><h3 id="正向向前查找（大部分语言支持）"><a href="#正向向前查找（大部分语言支持）" class="headerlink" title="正向向前查找（大部分语言支持）"></a>正向向前查找（大部分语言支持）</h3><p><code>(?=需要匹配但不在结果中的正则表达式)</code></p><p>向前查找指定了一个必须匹配但不在结果中返回的模式，正向是指等于，负向指不等于，后面会讲。</p><hr><p>例子1:</p><p><img src="/2018/12/18/正则表达式必知必会/./前瞻流程.png" alt="预查流程"></p><p>例子2:</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com</span><br><span class="line">https://www.baidu.com</span><br><span class="line">ftp://ftp.forta.com</span><br></pre></td></tr></table></figure><p>正则表达式：</p><p><code>.+(?=:)</code>  需要匹配到冒号，但在结果中不需要该冒号</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">https</span><br><span class="line">ftp</span><br></pre></td></tr></table></figure><h3 id="正向向后查找"><a href="#正向向后查找" class="headerlink" title="正向向后查找"></a>正向向后查找</h3><p><code>(?&lt;=需要匹配但不在结果中的正则表达式)</code></p><hr><p>例子1:</p><p><img src="/2018/12/18/正则表达式必知必会/./后瞻流程.png" alt="后瞻流程"></p><p>例子2:</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AAA:$23.45</span><br><span class="line">BBB:$567.45</span><br><span class="line">total items found:2</span><br></pre></td></tr></table></figure><p>正则表达式：</p><p><code>(?&lt;=\$)[0-9.]+</code>  需要匹配到美元$，但在结果中不需要$</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23.45</span><br><span class="line">567.45</span><br></pre></td></tr></table></figure><h3 id="向前向后结合"><a href="#向前向后结合" class="headerlink" title="向前向后结合"></a>向前向后结合</h3><p>目标：提取出\<title>标签内的文字</title></p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt; ben forta&apos;s homepage &lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>正则表达式：</p><p><code>(?&lt;=\&lt;title\&gt;).*(?=\&lt;/title\&gt;)</code></p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ben forta&apos;s homepage</span><br></pre></td></tr></table></figure><h3 id="负向前后查找（对前后查找取非）"><a href="#负向前后查找（对前后查找取非）" class="headerlink" title="负向前后查找（对前后查找取非）"></a>负向前后查找（对前后查找取非）</h3><p>前面介绍的用法称为 正向前查找 和 正向后查找 ，<strong>“正”指的是寻找匹配的事实</strong></p><p>前后查找还有一种不太常见的用法：负前后查找，“负”指的是寻找不相匹配的事实</p><ul><li>负向前查找：将向前查找 不与给定模式相匹配的文本</li><li>负向后查找：将向后查找 不与给定模式相匹配的文本</li></ul><p>使用<code>!</code>在进行取非</p><table><thead><tr><th>操作法</th><th>说明</th></tr></thead><tbody><tr><td>(?=)</td><td>正向前查找</td></tr><tr><td>(?!)</td><td>负向前查找</td></tr><tr><td>(?&lt;=)</td><td>正向后查找</td></tr><tr><td>(?&lt;!)</td><td>负向后查找</td></tr></tbody></table><p>例子：</p><p><strong>查找价格</strong></p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I paid $30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order.</span><br></pre></td></tr></table></figure><p>正则表达式：<code>(?&lt;=\$)\d+</code></p><p>结果：</p><p>I paid \$<strong>30</strong> for 100 apples, 50 oranges ,and 60 pears. I saved $<strong>5</strong> on this order.</p><p><strong>查找数量</strong></p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I paid $30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order.</span><br></pre></td></tr></table></figure><p>正则表达式：<code>\b(?&lt;!\$)\d+</code></p><p>结果：</p><p>I paid \$30 for <strong>100</strong> apples, <strong>50</strong> oranges ,and <strong>60</strong> pears. I saved $5 on this order.</p><blockquote><p>注意到这里有个\b，为什么要这样呢？看下面的结果就知道了</p><p>正则表达式：<code>(?&lt;!\$)\d+</code></p><p>结果：</p><p>I paid \$3<strong>0</strong> for <strong>100</strong> apples, <strong>50</strong> oranges ,and <strong>60</strong> pears. I saved $5 on this order.</p><p>$30中的0也被匹配上了。因为0前面的3不是\$，完全符合<code>(?&lt;!\$)\d+</code></p></blockquote><h2 id="嵌入条件"><a href="#嵌入条件" class="headerlink" title="嵌入条件"></a>嵌入条件</h2><p><strong><em>并非所有正则表达式实现都支持条件处理</em></strong></p><p>正则表达式里的条件要用<code>(?(condition)true_regx|false_regx)</code>来定义，可以没有false_regx。</p><p>之前见过几种非常特殊的条件了：</p><ul><li><code>.?</code>、<code>[]?</code>或<code>()?</code>匹配前一个字符或者表达式</li><li><code>(?=……)</code>和<code>(?&lt;=……)</code>匹配前面或后面的文本</li></ul><h3 id="回溯引用条件"><a href="#回溯引用条件" class="headerlink" title="回溯引用条件"></a>回溯引用条件</h3><p><code>(?(回溯引用的id)true-regx|false-regx)</code> ，当回溯引用存在时，匹配true-regx模式，否则匹配false-regx，</p><p>例子：匹配合法的电话</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123-456-7890</span><br><span class="line">(123)456-7890</span><br><span class="line">(123)-456-7890</span><br><span class="line">(123-456-7890</span><br><span class="line">1234567890</span><br><span class="line">123 456 7890</span><br></pre></td></tr></table></figure><p>正则表达式：</p><p><code>(\()? \d{3} (?(1)\)|-) \d{3}-\d{4}</code></p><p>结果：</p><p><strong>123-456-7890</strong><br><strong>(123)456-7890</strong><br>(123)-456-7890<br>(123-456-7890<br>1234567890<br>123 456 7890</p><p>其中<code>(?(1)\)|-)</code>就是回溯引用条件，<code>?(1)</code>表示子表达式1存在时，进行匹配右括号<code>)</code>，否则匹配连字符<code>-</code></p><h3 id="前后查找条件"><a href="#前后查找条件" class="headerlink" title="前后查找条件"></a>前后查找条件</h3><p><code>(?(向前向后查找表达式)true-regx|false-regx)</code></p><p>在实际工作中，该方法相当少见，因为有更简单的方法来到达同样的目的。</p><p>例子：</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11111</span><br><span class="line">22222</span><br><span class="line">33333-</span><br><span class="line">44444-4444</span><br></pre></td></tr></table></figure><p>正则表达式：<code>\d{5}(?(?=-)-\d{4})</code></p><p>结果：</p><p><strong>11111</strong><br><strong>22222</strong><br>33333-<br><strong>44444-4444</strong></p><p><code>(?(?=-)-\d{4})</code> 中用<code>(?=-)</code>来进行向前匹配，如果条件成立，则<code>-\d{4}</code>将匹配连字符和随后的4位数字，这样<code>33333-</code> 将被排除在外。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>元字符可以分为2类：</p><ol><li>一种是本身就是元字符，转义后变为普通字符，比如<code>^ $ *</code> ，用\进行转义恢复成普通字符</li><li>另一种是需要\进行配合，才表示元字符，否则就是普通的字符，比如<code>\w \s \d</code></li></ol></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>window添加右键用atom打开</title>
      <link href="/2018/12/15/window%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E7%94%A8atom%E6%89%93%E5%BC%80/"/>
      <url>/2018/12/15/window%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E7%94%A8atom%E6%89%93%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>window添加右键功能，如用atom打开，用vs code打开，可以方便用指定的编辑器打开文件，或者打开文件夹</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>使用<code>regedit</code> 打开注册表，找到如下位置，按照图示添加项，即可</p><p><img src="/2018/12/15/window添加右键用atom打开/./图像 001.png" alt="图像 001"></p><p><img src="/2018/12/15/window添加右键用atom打开/./图像 002.png" alt="图像 002"></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统优化 </tag>
            
            <tag> 效率 </tag>
            
            <tag> atom </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>notepad常用插件与设置</title>
      <link href="/2018/12/12/notepad%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/12/12/notepad%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <ol><li>notepad如何安装插件</li><li>常用的插件推荐</li><li>设置与配置信息备份</li></ol><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>点击菜单中的“插件”—&gt;“plugin manager”—&gt;“show plugin manager”的选项</p><p><img src="/2018/12/12/notepad常用插件/./插件安装1.png" alt="插件安装1"></p><p>进入到插件的管理列表中，找需要的插件，比如“compare”的选项勾选上，点击“install”的进行按钮</p><p><img src="/2018/12/12/notepad常用插件/./插件安装2.png" alt="插件安装2"></p><blockquote><p><strong>插件列表不显示</strong>的情况：</p><ol><li>打开plugin manager 最下面的setting，将use development plugin list 勾选上，注意information那一栏，可能会给出关键的信息，如让你创建 allowAppDataPlugins.xml文件</li><li>缺少PluginManagerPlugins.xml文件<ol><li>先在文件资源管理器的查看在隐藏的项目打勾</li><li>把<a href="http://pan.baidu.com/s/1hsmjCBa" target="_blank" rel="noopener">PluginManagerPlugins.xml</a>放在这个目录下<code>C:\Users\用户\AppData\Roaming\Notepad++</code></li><li>重新打开软件，看时候可行</li></ol></li><li>可能防火墙禁止Notepad++连接网络<ol><li>可以从控制面板-&gt;系统与安全-&gt;windows防火墙-&gt;允许应用通过windows防火墙</li><li>查看notepad++后面对应的专用和公用是否打勾，如果找不到notepad++可以自行添加，从允许其他应用进去，找到你notepad++的安装目录，然后添加</li></ol></li></ol></blockquote><p>安装完成会自动重启Notepad++，重启完成之后，在菜单栏的插件中，即可找到新安装的插件</p><p><img src="/2018/12/12/notepad常用插件/./插件安装3.png" alt="插件安装3"></p><h3 id="常用的插件推荐"><a href="#常用的插件推荐" class="headerlink" title="常用的插件推荐"></a>常用的插件推荐</h3><ul><li><strong>compare</strong>   比较两个文件的修改情况</li><li><strong>JSON viewer</strong>   json文件查看、格式化</li><li><strong>converter</strong>   ASCII码与HEX转换</li></ul><h3 id="设置与配置信息备份"><a href="#设置与配置信息备份" class="headerlink" title="设置与配置信息备份"></a>设置与配置信息备份</h3><p>设置好的配置文件在：C:\Users\用户\AppData\Roaming\Notepad++目录下，建议将这个文件夹备份，避免重装是又要从头设置</p><ul><li>不记住最后打开的文件（标签栏会炸掉的）：备份-&gt;记住最后打开的文件 取消掉</li><li>utf8-无BOM：新建-&gt;编码</li></ul></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> notepad++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>chrome截取整个网页</title>
      <link href="/2018/12/04/chrome%E6%88%AA%E5%8F%96%E6%95%B4%E4%B8%AA%E7%BD%91%E9%A1%B5/"/>
      <url>/2018/12/04/chrome%E6%88%AA%E5%8F%96%E6%95%B4%E4%B8%AA%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>浏览器原生功能实现滚动截屏，截取整个页面</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>在Chrome 浏览器上滚动截屏，不需要插件和任何 app，利用 chrome 浏览器原生功能即可实现。</p><ol><li><p>打开 Chrome 浏览器，进入需要截图的网站页面</p></li><li><p>打开开发者工具：在页面任何地方点击鼠标右键，在弹出菜单中选择「检查」选项。或者使用快捷键组合：option + command + i。</p></li><li><p>打开命令行（command palette）：command + shift + p。</p></li><li><p>在命令行中输入「screen」，这时自动补齐功能会显示出一些包含 「Screen」 关键字的命令。移动方向键到「Capture full size screenshot」并回车，chrome就会自动下载整个页面截屏文件。</p><p><img src="/2018/12/04/chrome截取整个网页/./chrome截图.png" alt="chrome截图"></p></li></ol><p>原文：<a href="https://blog.csdn.net/ianly123/article/details/80565614" target="_blank" rel="noopener">https://blog.csdn.net/ianly123/article/details/80565614</a> </p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 截图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git教程</title>
      <link href="/2018/11/22/Git%E6%95%99%E7%A8%8B/"/>
      <url>/2018/11/22/Git%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>Git 教程</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/11/22/Git教程/./git常用命令流程图.png" alt=""></p><h2 id="Git本地基本"><a href="#Git本地基本" class="headerlink" title="Git本地基本"></a>Git本地基本</h2><h3 id="配置全局信息"><a href="#配置全局信息" class="headerlink" title="配置全局信息"></a>配置全局信息</h3><p>当安装完 Git 应该做的<strong>第一件事</strong>就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。在那个项目目录下运行没有<code>--global</code>选项的命令来配置。</p></blockquote><p>其他有用的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor <span class="string">"notepad"</span>  <span class="comment">#commit时的默认编辑器</span></span><br></pre></td></tr></table></figure><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git config--list</span><br><span class="line"></span><br><span class="line">user.name=JohnDoe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">Jizx</span><br></pre></td></tr></table></figure><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><h4 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h4><p>通过<code>git init</code>命令把这个目录(可以是非空目录)变成Git可以管理的仓库。</p><p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 <code>git add</code>命令来实现对指定文件的跟踪，然后执行<code>git commit</code> 提交</p><h4 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h4><p>克隆仓库的命令格式是 <code>git clone [url] 本地仓库名字</code>。可以不定义本地仓库名字，默认适应原仓库名字。比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p><p><code>$ git clonehttps://github.com/libgit2/libgit2  mylibgit2</code></p><p>这会在当前目录下创建一个名为 “mylibgit2”的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p><strong>第一步，</strong>用命令git add告诉Git，把文件添加到暂存区：</p><p><code>git add readme.txt</code></p><p>add一个文件之后，如果又对文件进行了修改，需要重新add，不然commit只会保存最后一次git add的文件内容。</p><p><strong>第二步，</strong>用命令git commit告诉Git，把文件提交到仓库：</p><p><code>git commit -m &quot;wrote a readmefile&quot;</code></p><p>或者git commit，将会打开默认的文本编辑器（vim）进行文字输入。若实在不习惯 Vim，也可以设置为其它编辑器：</p><p><code>git config --global core.editor &quot;notepad&quot;</code></p><p>其中 notepad 可以替换为更好用的 wordpad、notepad++ 等（不过它们在命令行里无法直接访问，得先设置 PATH 变量）。</p><p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git addfile1.txt</span><br><span class="line">git addfile2.txt file3.txt</span><br><span class="line">git commit-m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure><p><strong>快速提交：</strong></p><p>Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，<code>git commit -a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，<strong>从而跳过 git add 步骤</strong>。</p><h3 id="重新提交"><a href="#重新提交" class="headerlink" title="重新提交"></a>重新提交</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有<code>--amend</code> 选项的提交命令尝试重新提交，命令执行后将暂存区中的文件提交，因此分为以下2种情况：</p><ol><li><p>修改提交信息：</p><p><code>git commit --amend</code></p></li><li><p>添加忘记/漏add的文件，同时修改提交信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'initial commit'</span>  <span class="comment"># 错误的提交</span></span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit –amend</span><br></pre></td></tr></table></figure></li></ol><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><p>要查看哪些文件处于什么状态，可以用 <code>git status</code> 命令。</p><p>使用 <code>git status -s</code> 命令或 <code>git status --short</code>命令，你将得到一种更为紧凑的格式输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><ul><li>?? 标记：新添加的未跟踪文件</li><li>A 标记：新添加到暂存区中的文件</li><li>M 标记：修改过的文件<ul><li>出现在<strong>右边的 M</strong>表示该文件被修改了但是还没放入暂存区</li><li>出现在<strong>左边的 M</strong>表示该文件被修改了并放入了暂存区。</li></ul></li></ul><p>例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区，lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。 而 <strong>Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了</strong>，所以在暂存区和工作区都有该文件被修改了的记录。</p><p><img src="/2018/11/22/Git教程/./文件状态周期.png" alt="文件状态周期"></p><p>Untracked未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件（比如新建的文件）；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。被追踪后处于3种状态：未修改-已修改-已暂存。将暂存的文件commit后就保存在git数据库中，文件就回到未修改状态了。<br>接下来介绍如何对修改的文件进行版本控制。</p><h3 id="查看文件修改内容diff"><a href="#查看文件修改内容diff" class="headerlink" title="查看文件修改内容diff"></a>查看文件修改内容diff</h3><p><img src="/2018/11/22/Git教程/./查看文件变化内容.png" alt="查看文件变化内容"></p><h4 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h4><p>查看<strong>尚未暂存的文件</strong>更新了哪些部分，输入<code>git diff</code><br>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p><p><code>git diff</code>不加参数即默认比较工作区与暂存区</p><p>比较工作区与最新本地版本库</p><p><code>git diff HEAD [&lt;path&gt;...]</code>  如果HEAD指向的是master分支，那么HEAD还可以换成master</p><p>比较工作区与指定commit-id的差异</p><p><code>git diff commit-id  [&lt;path&gt;...]</code></p><h4 id="–cached"><a href="#–cached" class="headerlink" title="–cached"></a>–cached</h4><p>查看<strong>暂存区里将要添加到下次提交</strong>里的内容，可以用 <code>git diff --cached</code>命令。<br>也就是查看暂存区里与最新本地版本库的区别（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。）</p><p>比较暂存区与指定commit-id的差异</p><p><code>git diff --cached [&lt;commit-id&gt;][...]</code></p><p>比较两个commit-id之间的差异</p><p><code>git diff [&lt;commit-id&gt;][]</code></p><h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><p>使用git diff打补丁<code>git diff &gt; patch</code></p><p> patch的命名是随意的，不加其他参数时作用是当我们希望将我们本仓库工作区的修改拷贝一份到其他机器上使用，但是修改的文件比较多，拷贝量比较大，此时我们可以将修改的代码做成补丁，之后在其他机器上对应目录下使用 <code>git apply patch</code> 将补丁打上即可</p><p><code>git diff --cached &gt; patch</code> //是将我们暂存区与版本库的差异做成补丁</p><p> <code>git diff --HEAD &gt; patch</code>//是将工作区与版本库的差异做成补丁</p><p><code>git diff Testfile &gt; patch</code>//将单个文件做成一个单独的补丁</p><p>拓展：git apply patch 应用补丁，应用补丁之前我们可以先检验一下补丁能否应用，<code>git apply --check patch</code> 如果没有任何输出，那么表示可以顺利接受这个补丁</p><p>另外可以使用<code>git apply --reject patch</code>将能打的补丁先打上，有冲突的会生成.rej文件，此时可以找到这些文件进行手动打补丁</p><h3 id="忽略文件（不追踪文件）"><a href="#忽略文件（不追踪文件）" class="headerlink" title="忽略文件（不追踪文件）"></a>忽略文件（不追踪文件）</h3><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，（window下直接新建不了，最好用命令行创建）使用命令<code>cat .gitignore</code>或者<code>touch .gitignore</code>，然后把要忽略的文件名或者目录填进去，Git就会自动忽略这些文件、文件夹。最后一步就是把<code></code>.gitignore`也提交到Git，就完成了！</p><blockquote><p>注意：<code>.gitignore</code>文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。如果要忽略被提交了的文件，请看【删除文件、取消追踪、恢复误删】这节内容</p></blockquote><h4 id="gitignore编写规则"><a href="#gitignore编写规则" class="headerlink" title="gitignore编写规则"></a>gitignore编写规则</h4><ol><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li></ol><ol start="2"><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（/）开头防止递归。</li><li>以（/）结尾 指定目录，忽略该目录下全部内容。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ol><p>所谓的 <strong>glob 模式</strong>是指shell 所使用的简化了的正则表达式。</p><ul><li>星号<code>*</code>匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符</li><li>问号<code>?</code>只匹配一个任意字符；</li><li>如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</li><li>使用两个星号<code>**</code> 表示匹配<strong>任意中间目录</strong>，比如<code>a/**/z</code> 可以匹配 <code>a/z, a/b/z 或 a/b/c/z</code>等。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略任何 以 .a 结尾文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># 但不忽略 lib.a 这个例外</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略当前文件夹下的 TODO ，不忽略子文件夹下的 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略全部在 build/ 文件夹下的文件</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略doc文件夹下的.txt,子目录下的doc/server/arch.txt 不受影响，</span></span><br><span class="line">doc/*.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有doc文件夹下的 .pdf 文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p>GitHub 在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">github/gitignore</a>仓库 提供了一个官方推荐的 .gitignore 文件列表，包括各种流行的操作系统、环境、开发语言。</p><h4 id="强制添加"><a href="#强制添加" class="headerlink" title="强制添加"></a>强制添加</h4><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line"></span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">    App.class</span><br><span class="line">Use -f <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure><p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：<br><code>git add -f App.class</code><br>当然也可以在.gitignore里使用<code>!</code>排除这个文件。</p><h4 id="忽略已经添加到git的文件"><a href="#忽略已经添加到git的文件" class="headerlink" title="忽略已经添加到git的文件"></a>忽略已经添加到git的文件</h4><p>如果你已经将文件提交到到git中，那么git不会处理你后来添加的gitignore规则。这种情况就需要通过下面的命令先取消追踪文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure><h4 id="测试规则"><a href="#测试规则" class="headerlink" title="测试规则"></a>测试规则</h4><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.class    App.class</span><br></pre></td></tr></table></figure><p>Git会告诉我们：.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h4 id="全局忽略"><a href="#全局忽略" class="headerlink" title="全局忽略"></a>全局忽略</h4><p>可以为你的电脑上每个仓库创建一份全局的忽略文件，这样就不必每个仓库都单独创建一个gitignore文件。</p><ol><li>在home目录创建<code>~/.gitignore_global</code>文件</li><li>在命令行中执行<code>git config --global core.excludesfile ~/.gitignore_global</code></li></ol><p>The Octocat 提供了一个推荐列表 方便添加到全局忽略文件中 <a href="https://gist.github.com/octocat/9257657" target="_blank" rel="noopener">a Gist containing some good rules</a> </p><h4 id="本地忽略"><a href="#本地忽略" class="headerlink" title="本地忽略"></a>本地忽略</h4><p><code>.gitignore</code> 这个文件本身会提交到版本库中去，用来保存的是公共的需要排除的文件。</p><p>如果你不想创建一份与他人共享的<code>.gitignore</code>，比如由你的编辑器产生的附属文件，而别人不会产生的情况。可以订制一份本地的忽略规则，这份规则不会提交到git中。</p><p>打开仓库中的<code>.git/info/exclude</code> 文件，在这里添加忽略规则即可，这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。</p><h3 id="撤销修改、提交"><a href="#撤销修改、提交" class="headerlink" title="撤销修改、提交"></a>撤销修改、提交</h3><h4 id="取消本地修改"><a href="#取消本地修改" class="headerlink" title="取消本地修改"></a>取消本地修改</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时， 使用命令<code>git checkout –– filename</code>。<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h4 id="取消add"><a href="#取消add" class="headerlink" title="取消add"></a>取消add</h4><p>场景2：当你不但改乱了工作区某个<strong>已经追踪的文件</strong>的内容，还添加到了暂存区时(<code>git add</code>)，想丢弃修改，分两步：</p><ol><li>第一步用命令<code>git reset HEAD fileName</code>（取消add到暂存区），就回到了场景1（即文件未暂存到暂存区中，仍为被修改过的状态）</li><li>第二步按场景1操作。</li></ol><p>如果是新文件（未提交到git中），那么应该使用<code>git rm --cached &lt;file&gt;</code> 来取消add操作。</p><p><img src="/2018/11/22/Git教程/./撤销修改.png" alt=""></p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>场景3：当你不但添加到了暂存区时(<code>git add</code>)，还提交了(<code>git commit</code>)，那就得进行版本回退了</p><p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>上面的方法仅适合近期恢复，如果忘记应该回退到哪个版本或者要回退到比较久之前的版本，应该通过<code>git log</code> 查看commit id，即可回退到你需要的时间点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit c0ce54b1ce75f69259d7f615bf280ff7a07e3eac (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: jizx &lt;1822980003@qq.com&gt;</span><br><span class="line">Date:   Sun Nov 18 23:16:49 2018 +0800</span><br><span class="line"></span><br><span class="line">    git命令行中文乱码解决方法</span><br><span class="line"></span><br><span class="line">commit 0c0bfca1e3208d83a89366c5be76982d24e03dee</span><br><span class="line">Author: jizx &lt;1822980003@qq.com&gt;</span><br><span class="line">Date:   Sun Nov 18 20:52:07 2018 +0800</span><br><span class="line"></span><br><span class="line">    过滤上根目录的DS_Store</span><br></pre></td></tr></table></figure><p>其中commit 后面的一串字符串就是commit id</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^     <span class="comment"># 回退到上一个版本</span></span><br><span class="line">$ git reset --hard commit_id <span class="comment"># 通过git log 获取的commit id</span></span><br></pre></td></tr></table></figure><p>第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的，Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令，这样就可以找到你全部提交过的commit id。</p><h3 id="删除文件、取消追踪、恢复误删"><a href="#删除文件、取消追踪、恢复误删" class="headerlink" title="删除文件、取消追踪、恢复误删"></a>删除文件、取消追踪、恢复误删</h3><ul><li><p>同时删除库中的文件与工作目录的文件：</p><p>使用命令<code>git rm fileName</code>删掉，并且<code>git commit –m “someLog”</code></p></li><li><p>仅删除库中的文件（取消追踪/恢复未追踪状态）：</p><p>换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪,可以输入命令：<code>git rm –cached filename/dir</code></p></li><li><p>另一种情况是<strong>在文件夹里误删了</strong>，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<code>git checkout -- test.txt</code></p></li></ul><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>要在 Git 中对文件改名，可以这么做：</p><p> <code>git mv README.md NewName.md</code></p><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv README.md NewName.md</span><br><span class="line">git rm README.md</span><br><span class="line">git add NewName.md</span><br></pre></td></tr></table></figure><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。两者唯一的区别是，<code>git mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code>轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p><h3 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h3><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p><code>git log</code>   显示从最近到最远的提交日志</p><p><code>git log -p -2</code>  一个常用的选项是 -p，用来显示每次提交的内容差异。你也可以加上 -2 来仅显示最近两次提交<br><code>git log --decorate</code>  命令查看各个分支当前所指的对象。</p><p><code>git log --pretty=oneline</code><br>另外一个常用的选项是<code>--pretty</code>。 这个选项可以<strong>指定使用不同于默认格式的方式展示</strong>提交历史。 这个选项有一些内建的子选项供你使用。 比如用<code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有<code>short，full 和 fuller</code>可以用（不过不怎么实用）。</p><p><code>git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</code> 最有意思的是format，可以定制要显示的记录格式</p><table><thead><tr><th style="text-align:center"><strong>选项</strong></th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>%H</strong></td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td style="text-align:center"><strong>%h</strong></td><td>提交对象的简短哈希字串</td></tr><tr><td style="text-align:center"><strong>%T</strong></td><td>树对象（tree）的完整哈希字串</td></tr><tr><td style="text-align:center"><strong>%t</strong></td><td>树对象的简短哈希字串</td></tr><tr><td style="text-align:center"><strong>%P</strong></td><td>父对象（parent）的完整哈希字串</td></tr><tr><td style="text-align:center"><strong>%p</strong></td><td>父对象的简短哈希字串</td></tr><tr><td style="text-align:center"><strong>%an</strong></td><td>作者（author）的名字</td></tr><tr><td style="text-align:center"><strong>%ae</strong></td><td>作者的电子邮件地址</td></tr><tr><td style="text-align:center"><strong>%ad</strong></td><td>作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td style="text-align:center"><strong>%ar</strong></td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td style="text-align:center"><strong>%cn</strong></td><td>提交者(committer)的名字</td></tr><tr><td style="text-align:center"><strong>%ce</strong></td><td>提交者的电子邮件地址</td></tr><tr><td style="text-align:center"><strong>%cd</strong></td><td>提交日期</td></tr><tr><td style="text-align:center"><strong>%cr</strong></td><td>提交日期，按多久以前的方式显示</td></tr><tr><td style="text-align:center"><strong>%s</strong></td><td>提交说明</td></tr></tbody></table><blockquote><p><strong>作者</strong>指的是实际作出修改的人，<strong>提交者</strong>指的是最后将此工作成果提交到仓库的人</p></blockquote><p>图像化展示提交记录</p><p><code>$ git log --graph</code></p><p><code>$ git log --graph --pretty=oneline --abbrev-commit</code> 简洁视图版本</p><p>当 oneline 或 format 与另一个 log 选项 –graph 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史。</p><p> <strong>git log</strong> 的常用选项，可以一起使用                                     </p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-p</strong></td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td><strong>–stat</strong></td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td><strong>–shortstat</strong></td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td><strong>–name-only</strong></td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td><strong>–name-status</strong></td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td><strong>–abbrev-commit</strong></td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td><strong>–relative-date</strong></td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td><strong>–graph</strong></td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td><strong>–pretty</strong></td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><p>限制<code>git log</code>输出的选项</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-(n)</strong></td><td>仅显示最近的 n 条提交</td></tr><tr><td><strong>–since</strong>, <strong>–after</strong></td><td>仅显示指定时间之后的提交。</td></tr><tr><td><strong>–until</strong>, <strong>–before</strong></td><td>仅显示指定时间之前的提交。</td></tr><tr><td><strong>–author</strong></td><td>仅显示指定作者相关的提交。</td></tr><tr><td><strong>–committer</strong></td><td>仅显示指定提交者相关的提交。</td></tr><tr><td><strong>–grep</strong></td><td>仅显示含指定关键字的提交</td></tr><tr><td><strong>-S</strong></td><td>仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><p>例子：<br><code>git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; --before=&quot;2008-11-01&quot;</code></p><h4 id="git-relog"><a href="#git-relog" class="headerlink" title="git relog"></a>git relog</h4><p><code>$ git reflog</code>  //查看全部命令记录，以及HEAD指针</p><h3 id="git-help-命令提示"><a href="#git-help-命令提示" class="headerlink" title="git help 命令提示"></a>git help 命令提示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help command # 可以显示某条command的使用方法</span><br></pre></td></tr></table></figure><h2 id="Git远程"><a href="#Git远程" class="headerlink" title="Git远程"></a>Git远程</h2><h3 id="从远程仓库克隆到本地"><a href="#从远程仓库克隆到本地" class="headerlink" title="从远程仓库克隆到本地"></a>从远程仓库克隆到本地</h3><p>在某个目录下，打开命令行，运行以下命令，就可以把远程的仓库克隆到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用命令</span></span><br><span class="line">$ git <span class="built_in">clone</span> username@host:/path/to/repository</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果远程服务器是github</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:你的GitHub用户名/你的某一个仓库名.git</span><br><span class="line"><span class="comment"># .git可以不用写</span></span><br></pre></td></tr></table></figure><p>默认远程仓库别名为 origin，如果要自定义，可以在克隆时运行命令：<br><code>git clone -o jizx git@github.com:你的GitHub用户名/你的某一个仓库名.git</code>，那么你默认的远程分支名字将会是 <code>jizx/master</code><br>注意：克隆后本地只有master分支，如果想要把别的分支如dev克隆下来，需要使用:<code>git checkout -b dev origin/dev</code><br>也就是说，当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<code>git checkout -b dev origin/dev</code><br>git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）</p><h3 id="本地关联到远程仓库"><a href="#本地关联到远程仓库" class="headerlink" title="本地关联到远程仓库"></a>本地关联到远程仓库</h3><h4 id="空文件夹"><a href="#空文件夹" class="headerlink" title="空文件夹"></a>空文件夹</h4><p>新建一个文件夹，进入文件夹后使用git init命令，然后再使用<code>git remote add</code>命令关联一个远程仓库，再使用<code>git pull</code> 命令就可以把管理仓库的所有文件复制到本文件夹中，同样可以修改文件并完成push。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用命令</span></span><br><span class="line">$ git remote add remoteName  git@server-name:path/仓库名.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># github服务器命令</span></span><br><span class="line">$ git remote add remoteName  git@github.com:你的用户名/你的某一个仓库名.git</span><br></pre></td></tr></table></figure><p>或者在一个文件夹下直接使用<code>git clone</code>命令，会把远程仓库整个复制到这个文件夹下，然后进入这个文件夹就可以修改文件并完成push。 这时默认远程的url别名为origin</p><h4 id="非空仓库-TODO非空文件怎么关联"><a href="#非空仓库-TODO非空文件怎么关联" class="headerlink" title="非空仓库(TODO非空文件怎么关联)"></a>非空仓库(TODO非空文件怎么关联)</h4><h3 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h3><p>用<code>git remote</code>可以查看到默认的远程库：<code>origin</code></p><p>用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote-v</span><br><span class="line">origin  git@github.com:jizxgit/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:jizxgit/learngit.git (push)</span><br></pre></td></tr></table></figure><h3 id="remote-详细用法"><a href="#remote-详细用法" class="headerlink" title="remote 详细用法"></a>remote 详细用法</h3><p><code>git help remote</code> 即可显示详细命令用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git remote [-v | --verbose]</span><br><span class="line">git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;</span><br><span class="line">git remote rename  &lt;old&gt;  &lt;new&gt;</span><br><span class="line">git remote remove  &lt;name&gt;</span><br><span class="line">git remote rm  &lt;name&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">git remote <span class="built_in">set</span>-branches [--add] &lt;name&gt; &lt;branch&gt;…</span><br><span class="line">git remote get-url [--push] [--all] &lt;name&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">git remote <span class="built_in">set</span>-url --add [--push] &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…</span><br><span class="line">git remote prune [-n | --dry-run] &lt;name&gt;…</span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…]</span><br></pre></td></tr></table></figure><h3 id="本地推送到远程仓库"><a href="#本地推送到远程仓库" class="headerlink" title="本地推送到远程仓库"></a>本地推送到远程仓库</h3><p>第一次更新时： <code>git push -u origin master</code></p><p>origin：远程服务器url别名  master：本地仓库的一个分支</p><p>加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p><p>以后更新时： <code>git push origin master</code></p><p>如果要推送本地其他分支，比如dev，就改成：<br><code>git push origin dev</code></p><p>以上其实做了一定的简化，完整的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin 本地分支：远程分支</span><br></pre></td></tr></table></figure><p>如果并不想让远程仓库上的分支叫做 serverfix，可以运行 <code>git push origin serverfix:awesomebranch</code>来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。</p><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li>master分支是主分支，因此要时刻与远程同步；</li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h4 id="冲突、推送失败"><a href="#冲突、推送失败" class="headerlink" title="冲突、推送失败"></a>冲突、推送失败</h4><p>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取pull下来并将其合并进你的工作后才能推送。</p><p>相当于是从远程获取最新版本并merge到本地</p><h3 id="从远程仓库获取数据"><a href="#从远程仓库获取数据" class="headerlink" title="从远程仓库获取数据"></a>从远程仓库获取数据</h3><p><code>$ git fetch [remote-name]</code></p><p>这个命令会访问远程仓库，从中拉取所有你<strong>还没有的数据</strong>。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看，它并<strong>不会自动合并或修改你当前的工作</strong>。</p><p><code>$ git pull [remote-name]</code></p><p>如果你有一个分支设置为<strong>跟踪一个远程分支</strong>，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并<strong>自动尝试合并到当前所在的分支</strong>。</p><p>如果git pull失败，一般是因为没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream dev origin/dev</span><br><span class="line"></span><br><span class="line">Branch dev <span class="built_in">set</span> up to track remote branch dev from origin.</span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了，也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有<code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line"></span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line">  - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h2 id="Git-本地高级操作"><a href="#Git-本地高级操作" class="headerlink" title="Git 本地高级操作"></a>Git 本地高级操作</h2><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><h4 id="创建、切换分支"><a href="#创建、切换分支" class="headerlink" title="创建、切换分支"></a>创建、切换分支</h4><p>创建并切换到新的分支dev</p><p><code>$ git branch dev</code></p><p><code>$ git checkout dev</code></p><p>等价于<code>$ git checkout -b dev</code>  </p><p>​       </p><p>复制远程分支到本地</p><p><code>$ git checkout -b dev origin/dev</code></p><p>dev是本地新建的分支名字，origin/dev是远程分支</p><p>查看所有分支，以及当前所在分支，*表示当前分支</p><p><code>$ git branch</code>  </p><p>切换分支</p><p><code>$ git checkout dev</code></p><p>切换出去前，要保存好编辑过的文件，用<code>add commit</code>，或者保存现场</p><h4 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h4><p><code>$ git stash</code></p><p>当在一个分支的开发工作未完成，却又要切换到另外一个分支进行开发的时候，并不是不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。除了commit原分支的代码改动的方法外，我觉得保存现场是一个更加便捷的选择，暂时冻结开发现场，等待其他分支完成后继续回来完成。</p><p>查看现场</p><p><code>git stash list</code></p><p>恢复现场</p><p><code>git stash apply，</code>默认恢复最新的现场，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除</p><p><code>git stash pop，</code>恢复的同时把stash内容也删了</p><p>可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：<code>$ git stash apply stash@{0}</code></p><p>删除合并后的分支</p><p><code>$ git branch -d dev</code> </p><p> 丢弃一个没有被合并过的分支</p><p><code>$ git branch -D dev</code>强行删除。</p><h3 id="分支详解"><a href="#分支详解" class="headerlink" title="分支详解"></a>分支详解</h3><p>当使用<code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中这些校验和被保存为树对象。随后，Git 便会创建一个提交对象（98ca9），它除了包含上面提到的那些信息外，还包含指向这个树对象（92ec2）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：一个提交对象（包含着指向前述树对象的指针和所有提交信息） 、一个树对象（记录着目录结构和 blob 对象索引）以及三个 blob 对象（保存着文件快照）。</p><p><img src="/2018/11/22/Git教程/./commit操作解释.png" alt="commit 操作解释"></p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>快速合并：<code>$ git merge dev</code></p><p><img src="/2018/11/22/Git教程/./快速合并1.png" alt="快速合并1"></p><p><img src="/2018/11/22/Git教程/./快速合并2.png" alt="快速合并2"></p><p>关闭快速合并，这样在Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p><code>$ git merge --no-ff -m &quot;merge withno-ff&quot; dev</code></p><p><img src="/2018/11/22/Git教程/./关闭快速合并.png" alt="关闭快速合并"></p><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的<u>同一个部分</u>进行了<u>不同的修改</u>，Git 就没法干净的合并它们。此时 Git 做了部分合并工作，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。</p><p>例子：</p><p><code>master</code>分支和<code>feature1</code>分支各自都分别对同一部分修改并有新的提交，就会产生冲突</p><p><img src="/2018/11/22/Git教程/./合并冲突1.png" alt="合并冲突1"></p><p>Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交，可以直接查看readme.txt的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under theGPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">Creating a new branchis quick &amp; simple.</span><br><span class="line">=========</span><br><span class="line">Creating a new branchis quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容。</p><p><img src="/2018/11/22/Git教程/./合并冲突2.png" alt="合并冲突2"></p><p>为了冲突解决，你可以选择使用由<code>=======</code>分割的两部分中的一个，或者你也可以自行合并这些内容（可以是完全新的内容），并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> ,<code>=======</code> , 和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行要被完全删除了。</p><p> 在你解决了所有文件里的冲突之后，对每个文件<strong>使用<code>git add</code> 命令来将其标记为冲突已解决</strong>。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决，然后commit保存入仓库。</p><p><img src="/2018/11/22/Git教程/./合并冲突3.png" alt="合并冲突3"></p><p>如果你想使用图形化工具来解决冲突，你可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><p><code>$ git mergetool</code></p><p>查看已合并的分支，从而删除没用的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>查看未合并的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>Git鼓励大量使用分支：</p><ul><li>查看分支：git branch</li><li><p>创建分支：git branch <name></name></p></li><li><p>切换分支：git checkout <name></name></p></li><li>创建+切换分支：git checkout -b <name></name></li><li>合并某分支到当前分支：git merge <name></name></li><li>删除分支：git branch -d <name></name></li></ul><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支，这个本地分支就叫做“跟踪分支”（有时候也叫做 “上游分支”）。 <strong>跟踪分支是与远程分支有直接关系的本地分支</strong>。 如果在一个跟踪分支上输入<code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><ul><li><p>创建跟踪分支：<code>git checkout -b [branch][remotename]/[branch]</code></p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line"></span><br><span class="line">Branch sf <span class="built_in">set</span> upto track remote branch serverfix from origin.</span><br><span class="line"></span><br><span class="line">Switched to a newbranch <span class="string">'sf'</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置已有的本地分支</strong>跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -uorigin/serverfix</span><br><span class="line"></span><br><span class="line">Branch serverfixset up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure></li></ul><p>可以使用 <code>git branch -vv</code> 。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line"></span><br><span class="line">  iss53    7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line"></span><br><span class="line">  master   1ae2a45 [origin/master] deploying index fix</span><br><span class="line"></span><br><span class="line">* serverfix  f8674d9 [teamone/server-fix-good: ahead 3, behind 1]this should <span class="keyword">do</span> it</span><br><span class="line"></span><br><span class="line">  testing  5ea463a trying something new</span><br></pre></td></tr></table></figure><p>可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。<br>这些数字的值来自于你从每个服务器上最后一次抓取(fetch)的数据。 这个命令(branch -vv)并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。<br>可以像这样做：<br><code>git fetch --all; git branch –vv</code></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>Git 可以给历史中的某一个提交打上标签，以示重要。</p><p>Git 使用两种主要类型的标签：<strong>轻量标签</strong>（lightweight）与<strong>附注标签</strong>（annotated）。</p><ul><li>轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</li><li>附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；通常建议创建附注标签，这样你可以拥有以上所有信息</li></ul><p><strong>标签创建</strong></p><p><code>$ `</code>git tag` 查看标签，<strong>注意</strong>，标签不是按时间顺序列出，而是按字母排序的。</p><p><code>$ git tagv1.0</code> 标签默认是打在最新提交的commit上的,标签名为v1.0</p><p><code>$ git tag -a v1.0 -m &quot;version 1.0released&quot; commit_id</code> 可以创建带有说明的附注标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字。</p><p><strong>补打标签</strong></p><p><code>$ git  tag  v1.0 commit_id</code> 你也可以对过去的提交打标签，指定某个历史打标签，通过<code>$ git log --pretty=oneline --abbrev-commit</code>查找到对应要打标签的<code>commit_id</code>。</p><p><code>$ git show &lt;tagname&gt;</code>可以看到说明文字。</p><p><strong>标签推送</strong></p><p>默认情况下，<strong><code>git push</code>命令并<u>不会</u>传送标签到远程仓库服务器</strong>上。 在创建完标签后你必须显式地推送标签到共享服务器上</p><p><code>$ git push origin &lt;tagname&gt;</code> 推送某个标签到远程。</p><p><code>$ git push origin –-tags</code>  一次性推送全部尚未推送到远程的本地标签.</p><p><strong>标签删除</strong></p><p><code>$ git tag -d v1.0</code>如果标签打错了，也可以删除。</p><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v1.0</span><br><span class="line"></span><br><span class="line">Deleted tag <span class="string">'v1.0'</span> (was 6224937)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><p><code>$ git pushorigin :refs/tags/v1.0</code>//可以删除一个远程标签。</p><p><strong>标签切换</strong></p><p>如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 <code>git checkout -b[branchname][tagname]</code>在特定的标签上创建一个新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b version2 v2.0.0</span><br><span class="line"></span><br><span class="line">Switched to a new branch <span class="string">'version2'</span></span><br></pre></td></tr></table></figure><p>当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。</p><h3 id="大文件更新Update-TODO未看"><a href="#大文件更新Update-TODO未看" class="headerlink" title="大文件更新Update(TODO未看)"></a>大文件更新Update(TODO未看)</h3><p>我们知道 Git 不仅仅是用来做代码版本管理的，很多其他领域的项目也会使用 Git。比如说我公司曾经一个客户的项目涉及到精密零件图纸文档的版本管理，他们也用Git。有一种使用场景是<strong>对一些体积庞大的文件进行修改</strong>，但是每一次保存 Git 都要计算文件的变化并更新工作区，这在硬盘慢的时候延迟卡顿非常明显。</p><p>git update-index –assume-unchanged 的真正用法是这样的：</p><ol><li>你正在修改一个巨大的文件，你先对其 git update-index –assume-unchanged，这样 Git 暂时不会理睬你对文件做的修改；</li><li>当你的工作告一段落决定可以提交的时候，重置改标识：git update-index –no-assume-unchanged，于是 Git 只需要做一次更新，这是完全可以接受的了；</li><li>提交＋推送。</li></ol><h3 id="配置命令别名"><a href="#配置命令别名" class="headerlink" title="配置命令别名"></a>配置命令别名</h3><ul><li>配置别名有点像C语言里的宏，进行简单的替换。</li><li><strong>替换单个词</strong>，告诉Git，以后<code>st</code>就表示<code>status</code></li></ul><p><code>$ git config--global alias.st status</code></p><p>当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config--global alias.co checkout</span><br><span class="line">$ git config--global alias.ci commit</span><br><span class="line">$ git config --globalalias.br branch</span><br></pre></td></tr></table></figure><ul><li><strong>替换多个词</strong>（用单引号包含着多个词）；</li></ul><ol><li><p>命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：<code>$ git config --global alias.unstage &#39;reset HEAD&#39;</code></p></li><li><p>配置格式化打印log的：（将<code>log--pretty=format:&quot;%h - %an - %ar : %s&quot;</code>定义为linelog）：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config--global alias.linelog &apos;log --pretty=format:&quot;%h - %an - %ar : %s&quot;&apos;</span><br></pre></td></tr></table></figure></li></ol><ul><li>撤销别名，打开配置文件删除即可，详见【配置文件】章节</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Git的时候，加上–global是针对当前用户（整个软件）起作用的，如果不加，那只针对当前的仓库（当前文件夹）起作用。</p><ul><li><p><strong>当前仓库配置文件</strong>：每个仓库的Git配置文件都放在.git/config文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">    ignorecase = <span class="literal">true</span></span><br><span class="line">    precomposeunicode = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    last = <span class="built_in">log</span> -1</span><br></pre></td></tr></table></figure><p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p></li></ul><ul><li><p><strong>全局配置文</strong>件：放在用户主目录（window系统中的用户目录下）下的一个隐藏文件.gitconfig中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.gitconfig</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">email = your@email.com</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p></li></ul><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="参与Github开源项目"><a href="#参与Github开源项目" class="headerlink" title="参与Github开源项目"></a>参与Github开源项目</h3><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap" target="_blank" rel="noopener">https://github.com/twbs/bootstrap</a>，点“<code>Fork</code>”，将别人的仓库在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：<code>git‍ clone ‍git@github.com:jizxGit/bootstrap.git</code></p><p>一定要从自己的账号下clone仓库，这样你才能推送修改，因为你在github添加了SSH。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><p><img src="/2018/11/22/Git教程/./参与Github开源项目1.png" alt="参与Github开源项目1"></p><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个<code>pull request</code>。当然，对方是否接受你的pull request就不一定了。</p><p><img src="/2018/11/22/Git教程/./参与Github开源项目2.png" alt="参与Github开源项目2"></p><h3 id="小组合作"><a href="#小组合作" class="headerlink" title="小组合作"></a>小组合作</h3><ol><li><p>首先在github上创建一个需要与团队共享的仓库</p></li><li><p>然后在仓库的Settings中添加队友的github帐户： </p><p> <img src="/2018/11/22/Git教程/./小组合作1.png" alt="小组合作1">         </p><p><img src="/2018/11/22/Git教程/./小组合作2.png" alt="小组合作2">                  </p></li><li><p>添加完成后，对方会收到请求，如下图，需要对方同意请求，才算是加入到这个团队中，拥有push的权限。</p><p><img src="/2018/11/22/Git教程/./小组合作3.png" alt="小组合作3"> </p></li></ol><p><strong>流程会像这样</strong>：</p><p>A拥有repository，想要让B也能更新自己的repository，就把B加入collaborators，这样B要一起合作这份code的时候，clone A 的clone repo到本地，然后B就可以在自己的本机尽情修改code (用branch、commit、merge)，最后在push的时候输入B自己的帐密，会更新A的repository(A仍就可以继续更新自己的repository)，但B自己的github账户并不会有一份和A相同的repository(只会有A的repo连结)</p><h2 id="Git-bash-快捷键（window）"><a href="#Git-bash-快捷键（window）" class="headerlink" title="Git bash 快捷键（window）"></a>Git bash 快捷键（window）</h2><h3 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h3><p><code>ATL+ENTER</code></p><h3 id="字体变化"><a href="#字体变化" class="headerlink" title="字体变化"></a>字体变化</h3><p><code>CTRL+PLUS/MINUS/ZERO</code></p><h3 id="右键"><a href="#右键" class="headerlink" title="右键"></a>右键</h3><p><code>ALT+SPACE</code></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python编码问题</title>
      <link href="/2018/11/19/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2018/11/19/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>理清楚 从编写python文件的编码，到运行时的编码，最后print打印显示这一整根流程中的各种编码问题</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>计算机最早是只有英文ASCII码，但世界上除了英语，还有很多其他语言，因此只有ASCII码编码显然不适合这种情况。</p><p>于是后来在中国、日本等其他国家都有了自己的一套编码，但是这样就出现问题了，不同国家之间数据传输，就会出现乱码。</p><p>为了让全世界都可以使用计算机，于是有了Unicode编码方式，俗称万国码，可以存储好几万个字符。（unicode专题TODO）</p><p><strong>因此计算机内存中，对字符串的编码使用的都是Unicode，作为中间者。</strong></p><p>但是又有新的问题出现了，<strong>Unicode是定长编码，不适合存储</strong>，非常浪费存储空间，这里又有了一种新的编码方式：utf-8。<strong>utf-8采用的是不定长编码</strong>，大大节约了存储空间。在数据存储和传输方面非常方便。</p><p>当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码(或者其他编码)。</p><p><img src="/2018/11/19/python编码问题/./1.png" alt=""></p><hr><p><img src="/2018/11/19/python编码问题/./2.png" alt=""></p><h4 id="pyhton2-中的编码过程"><a href="#pyhton2-中的编码过程" class="headerlink" title="pyhton2 中的编码过程"></a>pyhton2 中的编码过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line">s = <span class="string">"中文"</span></span><br><span class="line">print(type(s)) <span class="comment"># &lt;type 'str'&gt;</span></span><br><span class="line"></span><br><span class="line">s2=s.encode(<span class="string">'utf8'</span>) <span class="comment"># unicode解码错误，无法以ASCII解码字节 0xe4，超出了range（128）：UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">u'中文'</span>  <span class="comment"># &lt;type 'unicode'&gt;</span></span><br><span class="line">s3=s2.encode(<span class="string">'utf8'</span>)</span><br><span class="line">print(type(s3)) <span class="comment"># &lt;type 'str'&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>在运行前</strong>，python解释器默认以ASCII码解码文件，因此如果文件中有中文就会报错：<code>Non-ASCII character &#39;\xe9&#39;</code> ，表示出现了超出ASCII码（0-127）以外的字节，因此需要在文件第一行添加：<code># _*_ coding:utf8 _*_</code> ，让编译器以指定的字符集进行解码然后编译。</p></li><li><p><strong>在运行时</strong>，Python2 中字符串有2种类型：<code>&lt;type &#39;str&#39;&gt;</code> 和<code>&lt;type &#39;unicode&#39;&gt;</code>，默认是<code>str</code>类型 。变量<code>s</code> 的类型是<code>&lt;type &#39;str&#39;&gt;</code> ，可以理解为保存了“中文”以utf8编码的二进制数据。<code>s.encode(&#39;utf8&#39;)</code>命令实际上过程是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.decode(defaultencoding).encode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型的转变过程</span></span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;  ——以defaultencoding解码——&gt;   &lt;type <span class="string">'unicode'</span>&gt;——以encode方法指定的字符集编码——&gt;   &lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.getdefaultencoding()) <span class="comment"># ascii</span></span><br></pre></td></tr></table></figure><p><code>defaultencoding</code>在python2中默认是ASCII，而<code>s</code>是以utf8编码的，因此在str—&gt;unicode的时候就会出现<code>UnicodeDecodeError</code></p></li><li><p><strong>解决办法</strong>有2种：</p><ol><li><p>显式进行解码<code>s.decode(&#39;utf8&#39;).encode(&#39;utf8&#39;)</code></p></li><li><p>修改系统默认字符集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)<span class="comment"># Python2.5初始化后会删除sys.setdefaultencoding这个方法，因此需要重新载入</span></span><br><span class="line">print(sys.getdefaultencoding()) <span class="comment"># ascii</span></span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line">print(sys.getdefaultencoding()) <span class="comment"># utf-8</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h5 id="u前缀"><a href="#u前缀" class="headerlink" title="u前缀"></a>u前缀</h5><p>在python2里面，<code>u</code>表示unicode string，类型是unicode, 没有<code>u</code>表示byte string，类型是 str。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'中文'</span>   <span class="comment"># '\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line">print(type(s1)) <span class="comment"># &lt;type 'str'&gt;</span></span><br><span class="line">print(len(s1))  <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">u'中文'</span>     <span class="comment"># u'\u4e2d\u6587'</span></span><br><span class="line">print(type(s2)) <span class="comment"># &lt;type 'unicode'&gt;</span></span><br><span class="line">print(len(s2))  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">print(s1 == s2) <span class="comment"># False (警告 UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal)</span></span><br><span class="line">print(s2 == s1) <span class="comment"># False 不会有警告</span></span><br><span class="line">print(s1 <span class="keyword">is</span> s2) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">s3=s.encode(<span class="string">'utf8'</span>)</span><br><span class="line">print(type(s3))</span><br></pre></td></tr></table></figure><h5 id="字符串长度问题"><a href="#字符串长度问题" class="headerlink" title="字符串长度问题"></a>字符串长度问题</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2.7</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">msg=<span class="string">'中文'</span>   <span class="comment"># '\xe4\xb8\xad\xe6\x96\x87'此时msg被编码为utf-8,而不是ascii ,</span></span><br><span class="line">type(msg)   <span class="comment"># &lt;type 'str'&gt;</span></span><br><span class="line">len(msg) <span class="comment"># 6 因为utf8每个汉字占3个字节</span></span><br><span class="line"></span><br><span class="line">umsg=unicode(msg) <span class="comment"># u'\u4e2d\u6587'</span></span><br><span class="line">type(umsg)  <span class="comment"># &lt;type 'unicode'&gt;</span></span><br><span class="line">len(umsg)   <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h4 id="Python3-中的编码过程"><a href="#Python3-中的编码过程" class="headerlink" title="Python3 中的编码过程"></a>Python3 中的编码过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'中文'</span>   <span class="comment"># '中文'</span></span><br><span class="line">print(type(s1)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(len(s1))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">u'中文'</span>     <span class="comment"># '中文' 与s1没有区别</span></span><br><span class="line">print(type(s2)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(len(s2))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">print(s1 == s2) <span class="comment"># True</span></span><br><span class="line">print(s1 <span class="keyword">is</span> s2) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">s3=s1.encode(<span class="string">"utf8"</span>)</span><br><span class="line">print(type(s3))  <span class="comment">#&lt;class 'bytes'&gt;</span></span><br><span class="line">print(s3) <span class="comment"># b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"></span><br><span class="line">s4=s3.decode(<span class="string">"utf8"</span>) </span><br><span class="line">print(type(s4)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(s4) <span class="comment"># 中文</span></span><br></pre></td></tr></table></figure><p>python3的改进：</p><ol><li>Python3在编译时，文件默认就是以<code>utf-8</code>进行解码然后编译</li><li>python3中<strong>所有字符串都是以unicode格式(\uXXXX)保存在内存中</strong>，<strong><code>u</code>前缀没有特殊含义了</strong>。只有<code>&lt;class str&gt;</code> 类型，对应的就是python2中的 <code>&lt;type &#39;unicode&#39;&gt;</code> 。而<code>&lt;class byte&gt;</code>  类似于python2的<code>&lt;type &#39;str&#39;&gt;</code> 。</li><li><code>encode</code>函数根据参数指定的编码方式，把str类型的字符串转换为bytes类型。而在python3中字符串没有<code>decode</code>函数，<code>byte</code>类型才有。</li><li>在python3中，我们将不能直接看到unicode字节串，它会被显示为中文的“中文”；因为python3默认使用unicode编码，<strong>unicode字节串将被直接处理为中文显示出来。</strong></li></ol><h4 id="获取字符的unicode"><a href="#获取字符的unicode" class="headerlink" title="获取字符的unicode"></a>获取字符的unicode</h4><ul><li>根据unicode获取字符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chr参数支持10进制、16进制</span></span><br><span class="line">chr(<span class="number">0x4e2d</span>)  <span class="comment"># '中' </span></span><br><span class="line">chr(<span class="number">20013</span>)   <span class="comment"># '中'</span></span><br></pre></td></tr></table></figure><ul><li>根据字符获取unicode码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回值：10进制的unicode码</span></span><br><span class="line">ord(<span class="string">"中"</span>)  <span class="comment"># 20013</span></span><br></pre></td></tr></table></figure><h4 id="Python2中的print过程"><a href="#Python2中的print过程" class="headerlink" title="Python2中的print过程"></a>Python2中的print过程</h4><p>Python2.7中调用print打印<code>var</code>变量时，操作系统会对<code>var</code>做一定的字符处理：</p><ul><li>如果<code>var</code>是str类型的变量，则直接将<code>var</code>变量交付给终端进行显示；</li><li>如果<code>var</code>变量是unicode类型，则操作系统首先将var编码成str类型的对象（编码格式取决于stdout的编码格式<code>print(sys.stdout.encoding)</code>），然后再交由终端进行显示。</li><li>在终端显示时，如果str类型的<strong>变量的编码方式</strong>和<strong>终端设置的编码方式</strong>不一致，很可能会出现乱码问题。</li></ul><h4 id="Python2-与3-读取文件的编码问题"><a href="#Python2-与3-读取文件的编码问题" class="headerlink" title="Python2 与3 读取文件的编码问题"></a>Python2 与3 读取文件的编码问题</h4><p><code>codecs</code>会按照指定的字符集解码文件，然后将字符串转为<code>&lt;type &#39;unicode&#39;&gt;</code> </p><p><code>open</code>读取文件后的字符串是<code>&lt;type &#39;str&#39;&gt;</code> 类型，而且a.txt是以utf8编码保存的，与‘分’是同一种编码（<code># _*_ coding:utf8 _*_</code>），因此可以直接split</p><p>a.txt中的内容是：中文分国家</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line=f.read()</span><br><span class="line">    print(type(line)) <span class="comment"># &lt;type 'unicode'&gt;</span></span><br><span class="line">    ss=line.split(<span class="string">'分'</span>.decode(<span class="string">'utf8'</span>))</span><br><span class="line">    <span class="comment"># 相当于下面2行</span></span><br><span class="line">    <span class="comment"># c='分'  # &lt;type 'str'&gt;  </span></span><br><span class="line">    <span class="comment"># ss=line.split(c.decode('utf8')) #因为line是unicode，而c是str，因此必须进行decode</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line2=f.readline()</span><br><span class="line">    print(type(line2)) <span class="comment">#&lt;type 'str'&gt;</span></span><br><span class="line">    ss=line2.split(<span class="string">'分'</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        print(s)</span><br></pre></td></tr></table></figure><p>python3中都是unicode存储字符串，因此没有上面的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line=f.read()</span><br><span class="line">    print(type(line)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">    ss=line.split(<span class="string">'分'</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line2=f.readline()</span><br><span class="line">    print(type(line2)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">    ss=line2.split(<span class="string">'分'</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        print(s)</span><br></pre></td></tr></table></figure><h4 id="JSON-保存中文文件"><a href="#JSON-保存中文文件" class="headerlink" title="JSON 保存中文文件"></a>JSON 保存中文文件</h4><p>使得JSON保存的文件中文可读，必须有<code>ensure_ascii</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(json.dumps(custs,encoding=<span class="string">'UTF-8'</span>,ensure_ascii=<span class="keyword">False</span>))</span><br></pre></td></tr></table></figure></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编码问题 </tag>
            
            <tag> 打印 </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java方法传参问题</title>
      <link href="/2018/07/04/java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/04/java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="一、基本类型-和-引用类型的不同之处"><a href="#一、基本类型-和-引用类型的不同之处" class="headerlink" title="一、基本类型 和 引用类型的不同之处"></a>一、基本类型 和 引用类型的不同之处</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>首先变量其实是堆栈中的地址索引。然后 基本类型的数据直接保存在堆栈中，而对象是保存在堆中，堆栈中保存的是该对象在堆中的地址，这个地址就是所谓的<strong>引用</strong></p><p><img src="/2018/07/04/java方法传参问题/java传参1.png" alt=""></p><h3 id="二、赋值运算符（-）的作用"><a href="#二、赋值运算符（-）的作用" class="headerlink" title="二、赋值运算符（=）的作用"></a>二、赋值运算符（=）的作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">20</span>;</span><br><span class="line">str = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/04/java方法传参问题/java传参2.png" alt=""></p><p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<strong>但是原来的对象不会被改变（重要）。</strong><br>如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p><h3 id="三、调用方法时发生了什么？参数传递基本上就是赋值操作。"><a href="#三、调用方法时发生了什么？参数传递基本上就是赋值操作。" class="headerlink" title="三、调用方法时发生了什么？参数传递基本上就是赋值操作。"></a>三、调用方法时发生了什么？<strong>参数传递基本上就是赋值操作</strong>。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">20</span>;</span><br><span class="line">str = <span class="string">"java"</span>;</span><br><span class="line">func(num,str);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n,String s)</span></span>&#123;</span><br><span class="line">    n=<span class="number">30</span>;</span><br><span class="line">    s+=<span class="string">"haha"</span>;</span><br><span class="line">    <span class="comment">// do something with s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/04/java方法传参问题/java传参3.png" alt=""></p><p>n变为30，num不受影响；s虽然是对象类型，但是由于String是不可变类型，因此并不会影响到原来的str变量。所以结果如下：</p><p><img src="/2018/07/04/java方法传参问题/java传参4.png" alt=""></p><p>如果str是StringBuilder对象的话，就会改变，结果如下：</p><p><img src="/2018/07/04/java方法传参问题/java传参5.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在java中，不管原始参数的类型是什么，<strong>参数都是按值传递的</strong>。</p><p>每当一个方法被执行时，在堆栈中就会为每个参数创建一个拷贝，这个拷贝被传递到方法的内部，这个拷贝分以下2种情况：</p><ul><li>如果参数是基本类型，那么在堆栈中复制的就是这个参数的值</li><li>如果是对象，那么在堆栈中传递的便是指向真正对象数据的新的引用。这个新的引用被传递到方法内部。</li></ul><p>因此关于参数在方法中被修改后，会不会影响到原始变量，根据上面的原理：</p><ol><li>修改一个基础类型的参数，不会影响原始数据；</li><li>修改一个对象参数(数组、集合、map、类)的引用时，永远不会影响到原始的引用；</li><li>修改一个对象参数的属性时，会影响原始对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DuplicatenNum app = <span class="keyword">new</span> DuplicatenNum();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a1=<span class="number">5</span>;</span><br><span class="line">        app.fun1(a1);</span><br><span class="line">        System.out.println(a1);</span><br><span class="line"></span><br><span class="line">        TreeNode a2=<span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        app.fun2(a2);</span><br><span class="line">        System.out.println(a2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a2_2=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        app.fun2_2(a2_2);</span><br><span class="line">        System.out.println(a2_2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        app.fun3(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        a=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2_2</span><span class="params">(<span class="keyword">int</span> []  arr)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">TreeNode&#123;val=5, left=null, right=null&#125;</span><br><span class="line">1</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure><p>参考： <a href="https://www.zhihu.com/question/31203609" target="_blank" rel="noopener">Java 到底是值传递还是引用传递？</a> </p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 传参 </tag>
            
            <tag> 方法调用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何有效批评而不是吵架</title>
      <link href="/2018/06/17/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%89%B9%E8%AF%84%E8%80%8C%E4%B8%8D%E6%98%AF%E5%90%B5%E6%9E%B6/"/>
      <url>/2018/06/17/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%89%B9%E8%AF%84%E8%80%8C%E4%B8%8D%E6%98%AF%E5%90%B5%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>一般情况下，如果一个问题刚刚出现，你就把它指出来，那对方很快就能改正，不要堆积容忍太久。同时要学会如何有效指出问题，有效批评。</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/06/17/如何有效批评而不是吵架/如何有效批评而不是吵架.png" alt=""></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 心理 </category>
          
          <category> 人际交往 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
            <tag> 批评 </tag>
            
            <tag> 吵架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer</title>
      <link href="/2018/06/17/%E5%89%91%E6%8C%87offer/"/>
      <url>/2018/06/17/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>剑指offer题目（持续更新）</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，防止外部使用new创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例模式1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>有人提出在getInstance()方法上同步锁，但是锁住一整个方法可能粒度过大，不利于效率。既然锁方法不太好，那么锁代码呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 构造方法私有化，防止外部使用new创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例模式2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样做看似解决了线程安全问题，其实不然</strong>。设现有线程A和B，在t1时刻线程A和B均已通过判空语句但都未取得锁资源；t2时刻时，A先取得锁资源进入临界区（被锁的代码块），执行new操作创建实例对象，然后退出临界区，释放锁资源。t3时刻，B取得被A释放的锁资源进入临界区，执行new操作创建实例对象，然后退出临界区，释放锁资源。明显地，Singleton被实例化两次。</p><p>改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全，但是如果instance已经存在不能直接返回，也会被锁住，效率很低下，还可以优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例模式3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双检查锁机制（推荐）"><a href="#双检查锁机制（推荐）" class="headerlink" title="双检查锁机制（推荐）"></a>双检查锁机制（推荐）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意此处加上了volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例模式4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK1.5以前，DCL（双检查锁机制）是不稳定的，有时也可能创建多个实例，在1.5以后开始提供volatile关键字修饰变量来达到稳定效果。</p><h4 id="多线程测试入口"><a href="#多线程测试入口" class="headerlink" title="多线程测试入口"></a>多线程测试入口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建实现了Runnable接口的匿名类</span></span><br><span class="line">        Runnable run = () -&gt; Singleton2.getInstance();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(run);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>单例是为了保证系统中只有一个实例，其关键点有：</p><ol><li>私有构造函数</li><li>声明静态单例对象</li><li>构造单例对象之前要加锁（lock一个静态的object对象）</li><li>需要两次检测单例实例是否已经被构造，分别在锁之前和锁之后</li></ol><p><strong>1.为何要检测两次？</strong></p><p>如上面所述，有可能延迟加载或者缓存原因，造成构造多个实例，违反了单例的初衷。</p><p><strong>2.构造函数能否公有化？</strong></p><p>不行，单例类的构造函数必须私有化，单例类不能被实例化，单例实例只能静态调用</p><p><strong>3.lock住的对象为什么要是object对象，可以是int吗？</strong></p><p>不行，锁住的必须是个引用类型。如果锁值类型，<strong>每个不同的线程在声明的时候值类型变量的地址都不一样，那么上个线程锁住的东西下个线程进来会认为根本没锁，相当于每次都锁了不同的门，</strong>没有任何卵用。而引用类型的变量地址是相同的，每个线程进来判断锁多想是否被锁的时候都是判断同一个地址，相当于是锁在通一扇门，起到了锁的作用。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="二维有序数组中查找"><a href="#二维有序数组中查找" class="headerlink" title="二维有序数组中查找"></a>二维有序数组中查找</h4><p><img src="/2018/06/17/剑指offer/3.png" alt=""></p><p>思路：用target与数组右上角的值进行比较，小于右上角，则跳过该列，大于右上角，则跳过该行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] arr2 = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(find(arr, <span class="number">11</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = arr[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用target与数组右上角的值进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; i &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// target小于右上角，则跳过该列</span></span><br><span class="line">            <span class="keyword">while</span> (target &lt; arr[i][j] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// target大于右上角，则跳过该行</span></span><br><span class="line">            <span class="keyword">while</span> (target &gt; arr[i][j] &amp;&amp; i &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target == arr[i][j]) &#123;</span><br><span class="line">                System.out.println(<span class="string">"i:"</span> + (i + <span class="number">1</span>) + <span class="string">",j:"</span> + (j + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h4><p><img src="/2018/06/17/剑指offer/8.png" alt=""></p><p>主要考虑三种情况：</p><ol><li>正常情况：{7,8,1,2,3,4,5,6}</li><li>有序情况：{1, 2, 3, 4, 5, 6}</li><li>相等情况：{1, 1, 0, 1, 1, 1, 1, 1}</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int[] a = &#123;5,6,7,8,1,2,3,4&#125;;</span></span><br><span class="line">        <span class="comment">// int[] a = &#123;1, 1, 0, 1, 1, 1, 1, 1&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(findMin(a));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用二分法进行查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left;<span class="comment">//初始值原因见下方</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 正常情况，左边会大于等于右边，否则就已经是有序的数组，第一个就是最小值，因此mid初始为left</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &gt;= arr[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">                mid = right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 左边=中间=右边，只能遍历,&#123;1, 1, 0, 1, 1, 1, 1, 1&#125;;</span></span><br><span class="line">            <span class="keyword">if</span> (arr[left] == arr[right] &amp;&amp; arr[right] == arr[mid]) &#123;</span><br><span class="line">                <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min &gt; arr[i]) &#123;</span><br><span class="line">                        min = arr[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> min;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 左边&lt;=中间，说明最小值在[mid,right]</span></span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt;= arr[mid]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右边&gt;=中间，说明最小值在[left,mid]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[right] &gt;= arr[mid]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[mid];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="调整数组-使奇数在偶数前面"><a href="#调整数组-使奇数在偶数前面" class="headerlink" title="调整数组 使奇数在偶数前面"></a>调整数组 使奇数在偶数前面</h4><p><img src="/2018/06/17/剑指offer/14.png" alt=""></p><p>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>基本解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((numbers[left] &amp; <span class="number">0x1</span>) == <span class="number">1</span>) left++;</span><br><span class="line">            <span class="keyword">while</span> ((numbers[right] &amp; <span class="number">0x1</span>) == <span class="number">0</span>) right--;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = numbers[left];</span><br><span class="line">                numbers[left] = numbers[right];</span><br><span class="line">                numbers[right] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可扩展的实现，解耦，完成各种条件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可扩展的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        sort(arr, <span class="keyword">new</span> Condition() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ((a &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] numbers, Condition c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; c.check(numbers[left])) left++;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; !c.check(numbers[right])) right--;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = numbers[left];</span><br><span class="line">                numbers[left] = numbers[right];</span><br><span class="line">                numbers[right] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保证顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//O(n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; array[j - <span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                    array[j - <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(n),辅助空间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray2</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从前向后扫描奇数</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; array.length ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                copy[i++] = array[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后向前扫描偶数</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[right] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                copy[j--] = array[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;array.length;k++)&#123;</span><br><span class="line">            array[k]=copy[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><p><img src="/2018/06/17/剑指offer/20.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                <span class="comment">// &#123;10,9,8,7&#125;,</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = printMatrix(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">// 因为每次打印都是从对角线[0,0]、[1,1]……的开始，因此只需要一个变量来标记</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        ArrayList&lt;Integer&gt; printList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (start * <span class="number">2</span> &lt; row &amp;&amp; start * <span class="number">2</span> &lt; col) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; result = print(matrix, row, col, start);</span><br><span class="line">            printList.addAll(result);</span><br><span class="line">            ++start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> printList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endX = col - start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endY = row - start - <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 打印从左到右的上面一行 :第一行肯定要打印的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endX; i++) &#123;</span><br><span class="line">            list.add(matrix[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印从上到下的右面的一列：第二行能不能打印的条件在循环中了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY; i++) &#123;</span><br><span class="line">            list.add(matrix[i][endX]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; endX &amp;&amp; start &lt; endY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">                list.add(matrix[endY][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; endX &amp;&amp; start &lt; endY - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt; start; i--) &#123;</span><br><span class="line">                list.add(matrix[i][start]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中超过一半的数字（还有一种解法）"><a href="#数组中超过一半的数字（还有一种解法）" class="headerlink" title="数组中超过一半的数字（还有一种解法）"></a>数组中超过一半的数字（还有一种解法）</h4><p><img src="/2018/06/17/剑指offer/29.png" alt=""></p><p>解法1：基于partition的函数的O(n)算法，因为数字超过半数，因此将原数组排序后，中位数一定就是那个数值（如果输入是）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解法2：一个数字出现次数超过数组长度的一半，说明他出现的次数比其他所有数字出现的次数还多。因此可以用result，time来分别保存统计的数字，以及出现的次数。遍历时如果相同time+1，不同time-1，当time=0时，result更新为当前数字，time重置为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.输入合法性验证</span></span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.统计超过半数的数字</span></span><br><span class="line">        <span class="keyword">int</span> result = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">//当time=0时，result更新为当前数字，time重置为1</span></span><br><span class="line">            <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">                result = array[i];</span><br><span class="line">                time = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//遍历时如果相同time+1，不同time-1</span></span><br><span class="line">            <span class="keyword">if</span> (result == array[i])</span><br><span class="line">                time++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                time--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.是否超过半数验证</span></span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result == array[i]) &#123;</span><br><span class="line">                time++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (time * <span class="number">2</span> &lt;= array.length)</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="最小的k个数（包含海量数据）"><a href="#最小的k个数（包含海量数据）" class="headerlink" title="最小的k个数（包含海量数据）"></a>最小的k个数（包含海量数据）</h4><p><img src="/2018/06/17/剑指offer/30.png" alt=""></p><p>解法1，小数据量：快排方法 O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; re = GetLeastNumbers_Solution(array, <span class="number">10</span>);</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入检验</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || k &gt; input.length) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = parttition(input, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = input.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index = parttition(input, start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parttition</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        swap(input, mid, low);</span><br><span class="line">        <span class="keyword">int</span> pivot = input[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (input[j] &gt;= pivot &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span> (input[i] &lt;= pivot &amp;&amp; i &lt; j) i++;</span><br><span class="line">            swap(input, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(input, i, low);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = input[i];</span><br><span class="line">        input[i] = input[j];</span><br><span class="line">        input[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2，海量数据：使用红黑树 O(nlogk)，类似下面介绍的方法5</p><p>常见解法思路：</p><ul><li>最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求，该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。</li><li>第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字与容器内的最小数字相比，如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。</li><li>第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。</li></ul><ul><li>第四种方法是Hash法。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。</li></ul><ul><li>第五种方法采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（n*mlogm），空间复杂度是10000（常数）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; re = GetLeastNumbers_Solution(array, <span class="number">10</span>);</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="comment">//输入检验</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || k &gt; input.length) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; topk=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (topk.size() &lt; k) &#123;</span><br><span class="line">                topk.add(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(topk.last()&gt;val)&#123;</span><br><span class="line">                    topk.pollLast();</span><br><span class="line">                    topk.add(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.addAll(topk);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问次数最多的IP"><a href="#访问次数最多的IP" class="headerlink" title="访问次数最多的IP"></a>访问次数最多的IP</h4><p>参考：<a href="http://yueyemaitian.iteye.com/blog/1180299" target="_blank" rel="noopener">http://yueyemaitian.iteye.com/blog/1180299</a></p><p>算法思想：分而治之+Hash</p><p>1、IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；</p><p>2、可以考虑采用分而治之的思想，按照IP地址的Hash(IP) % 1024值，把海量IP日志分别存储到1024个小文件中，这样，每个小文件最多包含4MB个IP地址；</p><p>​     <strong>这里解释一下为什么用Hash(IP) % 1024值，如果不用，而直接分类的话，可能会出现这样一种情况，就是有个IP在每个小文件中都存在，而且这个IP并不一定在那个小文件中是数量最多的，那么最终可能选择的结果会有问题，所以这里用了Hash(IP)%1024值，这样的话，通过计算IP的Hash值，相同IP肯定会放到一个文件中，当然了不同的IP的Hash值也可能相同，就存在一个小文件中。</strong></p><p>3、对于每一个小文件，可以构建一个IP为key，出现的次数为value的Hash Map，同时记录当前出现次数最多的那个IP地址；</p><p>4、可以得到1024个小文件中的出现次数最多的那个IP，再依据常规的排序算法得出总体上出现次数最多的IP。</p><h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><p><img src="/2018/06/17/剑指offer/31.png" alt=""></p><p>解法1 <strong>O(n)，思路如下：</strong></p><p><img src="/2018/06/17/剑指offer/31-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,-<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(FindGreatestSumOfSubArray(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = array[<span class="number">0</span>];  <span class="comment">// 初始化为数组中的第一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果之前的和&lt;=0，说明从之前某个位置开始的子数组的和 会小于 从当前位置开始的子数组的和</span></span><br><span class="line">            <span class="comment">// 因此可以不考虑之前的子数组，Sum重置为当前位置的值</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                end = i;</span><br><span class="line">                sum = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum = sum + array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大和</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                end = i; <span class="comment">//更新子数组最后的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"["</span>+start+<span class="string">","</span>+end+<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> len = array.length;</span><br><span class="line">       <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">       f[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">           <span class="comment">// 递归公式</span></span><br><span class="line">           <span class="comment">// f[i] = array[i]             # i=0 或者 f[i-1]&lt;=0</span></span><br><span class="line">           <span class="comment">// f(i) = f[i - 1] + array[i]  # f[i-1]&gt;0</span></span><br><span class="line">           f[i] = f[i - <span class="number">1</span>] &lt;= <span class="number">0</span> ? array[i] : f[i - <span class="number">1</span>] + array[i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : f) &#123;</span><br><span class="line">           <span class="keyword">if</span> (max &lt; i) &#123;</span><br><span class="line">               max = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>解法3：分治（未实现）</p><h4 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h4><p><img src="/2018/06/17/剑指offer/33.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输入合法性检测</span></span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数字转为字符串类型</span></span><br><span class="line">        ArrayList&lt;String&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : numbers) &#123;</span><br><span class="line">            nums.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义的规则 进行排序</span></span><br><span class="line">        Collections.sort(nums, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//为了避免长度问题，将其拼接后再进行字符串比较</span></span><br><span class="line">                <span class="keyword">return</span> (s1 + s2).compareTo(s2 + s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理最后的结果</span></span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">""</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h4><p><img src="/2018/06/17/剑指offer/36.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countInverse(array, <span class="number">0</span>, array.length - <span class="number">1</span>) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countInverse</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftCount = countInverse(array, low, mid);</span><br><span class="line">        <span class="keyword">int</span> rightCount = countInverse(array, mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝一份数组的左右部分，用于排序并统计，注意copyOfRange[begin,end)，不包括end位置</span></span><br><span class="line">        <span class="keyword">int</span>[] leftCopy = Arrays.copyOfRange(array, low, mid + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] rightCopy = Arrays.copyOfRange(array, mid + <span class="number">1</span>, high + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序并统计逆序对</span></span><br><span class="line">        <span class="keyword">int</span> i = leftCopy.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = rightCopy.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = high;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftCopy[i] &lt;= rightCopy[j]) &#123;</span><br><span class="line">                array[index--] = rightCopy[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[index--] = leftCopy[i--];</span><br><span class="line">                count += (j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 避免数据溢出，进行取余</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1000000007</span>) count %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的部分拷贝回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            array[index--] = leftCopy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            array[index--] = rightCopy[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免数据溢出，进行取余</span></span><br><span class="line">        <span class="keyword">int</span> result = leftCount + rightCount + count;</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">1000000007</span>) result %= <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h4><p><img src="/2018/06/17/剑指offer/38.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (array != <span class="keyword">null</span> || array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 先找到第一个位置</span></span><br><span class="line">        <span class="keyword">int</span> start = getFirstK(array, k, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (start == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 查找不到在则直接返回</span></span><br><span class="line">        <span class="comment">// 再找最后出现的位置</span></span><br><span class="line">        <span class="keyword">int</span> end = getLastK(array, k, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        count = end - start + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midData = array[mid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (midData == k) &#123;</span><br><span class="line">        <span class="comment">// 如果已经是数组第一个 或者 mid前一个位置小于k，则说明已经找到第一个k的位置了</span></span><br><span class="line">        <span class="keyword">if</span> (mid == <span class="number">0</span> || (mid &gt; <span class="number">0</span> &amp;&amp; array[mid - <span class="number">1</span>] &lt; k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = high - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midData &lt; k) &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getFirstK(array, k, low, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midData = array[mid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (midData == k) &#123;</span><br><span class="line">        <span class="comment">// 如果已经是数组最后一个 或者 mid后一个位置大于k，则说明已经找到最后一个k的位置了</span></span><br><span class="line">        <span class="keyword">if</span> (mid == high || (mid &lt; high &amp;&amp; array[mid + <span class="number">1</span>] &gt; k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midData &lt; k) &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getLastK(array, k, low, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h4><p><img src="/2018/06/17/剑指offer/40.png" alt=""></p><p><img src="/2018/06/17/剑指offer/40-1.png" alt=""></p><p><img src="/2018/06/17/剑指offer/40-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] num1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] num2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        FindNumsAppearOnce(array, num1, num2);</span><br><span class="line">        System.out.println(num1[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(num2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历一遍求出异或的结果</span></span><br><span class="line">        <span class="keyword">int</span> xorResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">            xorResult ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = findFirstBit(xorResult); <span class="comment">//找到第一个bit为1的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用第一个bit为1的下标将数组分割为两部分，每部分index位置的bit相同</span></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSameBit(i, index))</span><br><span class="line">                n1 ^= i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n2 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = n1;</span><br><span class="line">        num2[<span class="number">0</span>] = n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右往左寻找第一个为1的二进制下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstBit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; Integer.SIZE) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; num) == i) <span class="keyword">break</span>;</span><br><span class="line">            i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断指定下标的位置的二进制是否为1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameBit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> leftShift)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; leftShift;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; i) == i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似题：leetcode：single-number、 single-number-ii</p><h4 id="在数组中寻找-和为s的两个数字"><a href="#在数组中寻找-和为s的两个数字" class="headerlink" title="在数组中寻找 和为s的两个数字"></a>在数组中寻找 和为s的两个数字</h4><p><img src="/2018/06/17/剑指offer/41.png" alt=""></p><p>思路：分别从最左和最右逼近，如果和小于s，则i++，如果和大于s，则j–</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有多对数字的和等于S，输出两个数的乘积最小的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] + array[j] == sum) &#123;</span><br><span class="line">                result.add(array[i]);</span><br><span class="line">                result.add(array[j]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] + array[j] &lt; sum) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="寻找和为s的连续序列"><a href="#寻找和为s的连续序列" class="headerlink" title="寻找和为s的连续序列"></a>寻找和为s的连续序列</h4><p><img src="/2018/06/17/剑指offer/41-1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    if (sum &lt;= 0) return result;</span><br><span class="line"></span><br><span class="line">    // 初始化将sum分为一大一小的2个数字</span><br><span class="line">    int small = sum / 2;</span><br><span class="line">    int big = sum / 2 + 1;</span><br><span class="line">    int curSum = small + big;</span><br><span class="line"></span><br><span class="line">    while (small &gt;= 1) &#123;</span><br><span class="line">        if (curSum == sum) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            for (int i = small; i &lt;= big; i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">            // 通过添加更小的small，获得产生新的序列</span><br><span class="line">            small--;</span><br><span class="line">            curSum += small;</span><br><span class="line">        &#125; else if (curSum &gt; sum) &#123;</span><br><span class="line">            // 偏大，则剪去big，加上更小的small</span><br><span class="line">            small--;</span><br><span class="line">            curSum = curSum - big + small;</span><br><span class="line">            big--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 偏小则再加一个更小的small</span><br><span class="line">            small--;</span><br><span class="line">            curSum += small;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br><span class="line">    result.sort(Comparator.comparingInt(c -&gt; c.get(0)));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (numbers[i] != i) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = numbers[i];</span><br><span class="line">                <span class="comment">// 如果m和第m个数字相等，则说明m该去的位置被人占了，就找到了第一个重复的数字</span></span><br><span class="line">                <span class="keyword">if</span> (m == numbers[m]) &#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = m;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则交换m到对应的第m个位置</span></span><br><span class="line">                numbers[i] = numbers[m];</span><br><span class="line">                numbers[m] = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h4><p><img src="/2018/06/17/剑指offer/66.png" alt=""></p><p><img src="/2018/06/17/剑指offer/66-1.png" alt=""></p><p>先算左边部分A0–Ai，再乘以右边部分Ai-1—An-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> offer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建乘积数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/24 17:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiply</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自底向上地累乘A[i-1]</span></span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            B[i] = B[i - <span class="number">1</span>] * A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自上向下地在原来基础上，再累成A[i]</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;<span class="comment">//这就是右半部分的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B[i] = B[i] * temp;</span><br><span class="line">            temp = temp * A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序数组的交集"><a href="#有序数组的交集" class="headerlink" title="有序数组的交集"></a>有序数组的交集</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有序数组的交集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/08/19 10:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jiaoji</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        jiaoji(a, b, result);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jiaoji</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> || a.length == <span class="number">0</span> || b.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] min = a;</span><br><span class="line">        <span class="keyword">int</span>[] max = b;</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; b.length) &#123;</span><br><span class="line">            min = b;</span><br><span class="line">            max = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(max, min[min.length / <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(max[index]);</span><br><span class="line">            <span class="comment">// min中去除min[min.length / 2]，max中去除max[index]因为以及找到了</span></span><br><span class="line">            jiaoji(Arrays.copyOfRange(min, <span class="number">0</span>, min.length / <span class="number">2</span>), Arrays.copyOfRange(max, <span class="number">0</span>, index), result);</span><br><span class="line">            jiaoji(Arrays.copyOfRange(min, min.length / <span class="number">2</span> + <span class="number">1</span>, min.length), Arrays.copyOfRange(max, index + <span class="number">1</span>, max</span><br><span class="line">                    .length), result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = -index - <span class="number">1</span>;</span><br><span class="line">            jiaoji(Arrays.copyOfRange(min, <span class="number">0</span>, min.length / <span class="number">2</span>), Arrays.copyOfRange(max, <span class="number">0</span>, index), result);</span><br><span class="line">            jiaoji(Arrays.copyOfRange(min, min.length / <span class="number">2</span> + <span class="number">1</span>, min.length), Arrays.copyOfRange(max, index, max.length),</span><br><span class="line">                    result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="4-字符串替换空格（未实现）"><a href="#4-字符串替换空格（未实现）" class="headerlink" title="4.字符串替换空格（未实现）"></a>4.字符串替换空格（未实现）</h4><p><img src="/2018/06/17/剑指offer/4.png" alt=""></p><p><img src="/2018/06/17/剑指offer/4-2.png" alt=""></p><ol><li>先遍历一次字符串，这样就能统计出字符串中空格的总数</li><li>准备两个指针p1，p2,。p1指向原始字符串的末尾，p2指向替换后的字符串的末尾</li><li>p1、p2同时移动，先前复制，直到p1遇到空格</li><li>p2向前插入‘%20’</li><li>p1、p2继续同时先前移动，直到p1与p2相遇</li></ol><p><img src="/2018/06/17/剑指offer/4-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="35-第一个只出现一次的字符"><a href="#35-第一个只出现一次的字符" class="headerlink" title="35.第一个只出现一次的字符"></a>35.第一个只出现一次的字符</h4><p><img src="/2018/06/17/剑指offer/35.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非法输入检测</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || <span class="string">""</span>.equals(str)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一遍遍历进行统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = counter.get(c) != <span class="keyword">null</span> ? counter.get(c) + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            counter.put(c, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二遍遍历进行搜索</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter.get(c) == <span class="number">1</span>) <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h4><p><img src="/2018/06/17/剑指offer/42.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ReverseSentence(<span class="string">"student. a am I"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">// 先将整个字符串翻转</span></span><br><span class="line">        reverseChars(chars, <span class="number">0</span>, chars.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过空格来定位每个单词的位置，然后进行单词的翻转</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">//指向单词第一个字符</span></span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;<span class="comment">//指向单词后的第一个空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">if</span> (end == chars.length)</span><br><span class="line">                    reverseChars(chars, start, end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// start与end之间是一个单词的情况</span></span><br><span class="line">                <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">                    reverseChars(chars, start, end);</span><br><span class="line">                &#125;</span><br><span class="line">                end++;</span><br><span class="line">                start = end;<span class="comment">// start移动到end位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// start：翻转的开始位置，不包括end位置的字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseChars</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str[i];</span><br><span class="line">            str[i] = str[j];</span><br><span class="line">            str[j] = c;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="左旋转字符串-循环左移字符串"><a href="#左旋转字符串-循环左移字符串" class="headerlink" title="左旋转字符串(循环左移字符串)"></a>左旋转字符串(循环左移字符串)</h4><p>题目描述（推荐）：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p><p><img src="/2018/06/17/剑指offer/42-2.png" alt=""></p><p><img src="/2018/06/17/剑指offer/42-3.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(LeftRotateString(<span class="string">"abcXYZdef"</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">// 通过3次翻转即可实现</span></span><br><span class="line">        reverseChars(chars,<span class="number">0</span>,n);</span><br><span class="line">        reverseChars(chars,n,chars.length);</span><br><span class="line">        reverseChars(chars,<span class="number">0</span>,chars.length);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 字符翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseChars</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str[i];</span><br><span class="line">            str[i] = str[j];</span><br><span class="line">            str[j] = c;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将字符串转换为整数"><a href="#将字符串转换为整数" class="headerlink" title="将字符串转换为整数"></a>将字符串转换为整数</h4><p>题目描述：</p><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例有:+123,-123,234k234</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMinus = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果不是数字，则判断是否是在第一位的正负号</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] &lt; <span class="string">'0'</span> || chars[i] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i != <span class="number">0</span>) || (chars[i] != <span class="string">'+'</span> &amp;&amp; chars[i] != <span class="string">'-'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i] == <span class="string">'-'</span>) isMinus = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + chars[i] - <span class="string">'0'</span>;<span class="comment">// 注意字符要与‘0’进行相减，才是真正对应的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMinus ? -<span class="number">1</span> * result : result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="字符串判断是否为有效数值"><a href="#字符串判断是否为有效数值" class="headerlink" title="字符串判断是否为有效数值"></a>字符串判断是否为有效数值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> offer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否为有效的数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/24 17:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsNumeric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IsNumeric app=<span class="keyword">new</span> IsNumeric();</span><br><span class="line">        System.out.println(app.isNumeric(<span class="string">"-1.e0"</span>.toCharArray()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> dot = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> e = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) sign = <span class="keyword">true</span>;<span class="comment">// 首位</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str[i - <span class="number">1</span>] == <span class="string">'e'</span> || str[i - <span class="number">1</span>] == <span class="string">'E'</span>) &#123;&#125;  <span class="comment">// 紧跟在e后面</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">true</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 已经有e了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == str.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// e后面没有数字了</span></span><br><span class="line">                <span class="keyword">else</span> e = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="comment">// 在e后面，不能有小数点、或者已经有小数点了</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">true</span> || dot == <span class="keyword">true</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> dot = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 其他非法字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h4><p><img src="/2018/06/17/剑指offer/28.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        permutation(<span class="number">0</span>, chars);</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">        HashSet&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(result);</span><br><span class="line">        result.clear();</span><br><span class="line">        result.addAll(set);</span><br><span class="line">        Collections.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> prefix, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix == str.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> String(str));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [a,b,c]，prefix表示固定的位置，比如a，然后将a与后面的字符依次进行交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prefix; i &lt; str.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将固定位置的值与数组中的第i个字符交换</span></span><br><span class="line">            <span class="keyword">char</span> temp = str[i];</span><br><span class="line">            str[i] = str[prefix];</span><br><span class="line">            str[prefix] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归处理[b,c]</span></span><br><span class="line">            permutation(prefix + <span class="number">1</span>, str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//还原交换</span></span><br><span class="line">            temp = str[i];</span><br><span class="line">            str[i] = str[prefix];</span><br><span class="line">            str[prefix] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="java实现链表"><a href="#java实现链表" class="headerlink" title="java实现链表"></a>java实现链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/04/20 15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="string">"bb"</span>);</span><br><span class="line">        list.insert(<span class="number">3</span>, <span class="string">"1"</span>);</span><br><span class="line">        list.printList();</span><br><span class="line">        <span class="comment">// System.out.println(list.find("2"));</span></span><br><span class="line">        System.out.println(list.search(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        list.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> E data;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            data = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = head;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        tail.next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> position, E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            Node current = head;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; position) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            Node temp = current.next;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">            newNode.next = temp;</span><br><span class="line">            current.next = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"超出范围"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        Node pre = head;</span><br><span class="line">        Node current = head.next;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data.equals(data)) &#123;</span><br><span class="line">                pre.next = current.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> position, E data)</span> </span>&#123;</span><br><span class="line">        Node current = head.next;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data.equals(data)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        E result = <span class="keyword">null</span>;</span><br><span class="line">        Node current = head.next;</span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data.equals(data)) &#123;</span><br><span class="line">                <span class="keyword">return</span> position;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">                position++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">search</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; position) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (E) current.data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"超出范围"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node current = head.next;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(current.data);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><p><img src="/2018/06/17/剑指offer/5.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="O-1-时间删除链表结点-未实现"><a href="#O-1-时间删除链表结点-未实现" class="headerlink" title="O(1)时间删除链表结点(未实现)"></a>O(1)时间删除链表结点(未实现)</h4><p><img src="/2018/06/17/剑指offer/13.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h4><p><img src="/2018/06/17/剑指offer/15.png" alt=""></p><p><img src="/2018/06/17/剑指offer/15-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ListNode newHead = findKNode(head, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(newHead.val);</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findKNode</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>|| k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode ahead = head;</span><br><span class="line">        ListNode behind = ahead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两者相差k-1个位置，因此ahead先走k-1个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ahead.next != <span class="keyword">null</span>)</span><br><span class="line">                ahead = ahead.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后两者一起移动</span></span><br><span class="line">        <span class="keyword">while</span> (ahead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ahead = ahead.next;</span><br><span class="line">            behind = behind.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> behind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p><img src="/2018/06/17/剑指offer/16.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ListNode newHead = ReverseList(head);</span><br><span class="line">            <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(newHead.val);</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)  <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode remainHead = <span class="keyword">null</span>;      <span class="comment">// h:剩余未反转的链表头</span></span><br><span class="line">        ListNode handlingNode = head;    <span class="comment">// i:正在处理的结点，从head开始，它的next指向原方向，因此正要反转</span></span><br><span class="line">        ListNode reversedHead = <span class="keyword">null</span>;    <span class="comment">// j:已经反转的链表头</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (handlingNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 原来  reversedHead  handlingNode --&gt; remainHead --&gt;k</span></span><br><span class="line">            <span class="comment">// 反转  reversedHead &lt;-- handlingNode   remainHead --&gt;k</span></span><br><span class="line">            remainHead = handlingNode.next;</span><br><span class="line">            handlingNode.next = reversedHead;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新结点为下一次要处理的位置</span></span><br><span class="line">            reversedHead = handlingNode;</span><br><span class="line">            handlingNode = remainHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reversedHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h4><p><img src="/2018/06/17/剑指offer/17.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode list1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode list2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ListNode node1 = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            ListNode node2 = <span class="keyword">new</span> ListNode(++i);</span><br><span class="line">            cur1.next = node1;</span><br><span class="line">            cur2.next = node2;</span><br><span class="line">            cur1 = node1;</span><br><span class="line">            cur2 = node2;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = Merge(list1, list2);</span><br><span class="line">        <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(newHead.val + <span class="string">" "</span>);</span><br><span class="line">            newHead = newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有一个链表为空，直接返回另一个链表</span></span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="keyword">null</span>)  <span class="keyword">return</span> list1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新链表的头结点初始化为较小的链表的头结点</span></span><br><span class="line">        ListNode head = list1.val &lt; list2.val ? list1 : list2;</span><br><span class="line">        ListNode temp;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                temp = list1.next;</span><br><span class="line">                list1.next = list2;</span><br><span class="line">                list1 = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = list2.next;</span><br><span class="line">                list2.next = list1;</span><br><span class="line">                list2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h4><p><img src="/2018/06/17/剑指offer/26.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        copyChain(pHead);</span><br><span class="line">        copySibling(pHead);</span><br><span class="line">        <span class="keyword">return</span> splitChain(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**第一步：复制链表，暂时不考虑random 字段</span></span><br><span class="line"><span class="comment">     *  A-&gt;B-&gt;C 变为 A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyChain</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode n = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            n.next = cur.next;</span><br><span class="line">            cur.next = n;</span><br><span class="line">            cur = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**第二步：考虑复制sibling字段*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copySibling</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode clone = cur.next;</span><br><span class="line">            RandomListNode sibling = cur.random;</span><br><span class="line">            <span class="keyword">if</span> (sibling != <span class="keyword">null</span>) &#123;</span><br><span class="line">                clone.random = sibling.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**第三步：拆分链表，抽取出copy链表*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">splitChain</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        RandomListNode copy = pHead.next;</span><br><span class="line">        RandomListNode cur1 = pHead;</span><br><span class="line">        RandomListNode cur2 = pHead.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur1.next = cur2.next;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            <span class="keyword">if</span>(cur1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur2.next=cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur2=cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找链表的中间节点（未实现）"><a href="#查找链表的中间节点（未实现）" class="headerlink" title="查找链表的中间节点（未实现）"></a>查找链表的中间节点（未实现）</h4><p>思路：采用快慢指针的方式查找单链表的中间节点，快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针刚好到达中间节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h4><p><img src="/2018/06/17/剑指offer/37.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ListNode a1=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode a2=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode a3=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode a4=<span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode a5=<span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode a6=<span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        ListNode a7=<span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">        a1.next=a2;</span><br><span class="line">        a2.next=a3;</span><br><span class="line">        a3.next=a6;</span><br><span class="line">        a4.next=a5;</span><br><span class="line">        a5.next=a6;</span><br><span class="line">        a6.next=a7;</span><br><span class="line">        System.out.println(FindFirstCommonNode(a1,a4));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历一遍找出两个链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> len1 = getLength(pHead1);</span><br><span class="line">        <span class="keyword">int</span> len2 = getLength(pHead2);</span><br><span class="line"></span><br><span class="line">        ListNode longList = pHead1;</span><br><span class="line">        ListNode shortList = pHead2;</span><br><span class="line">        <span class="keyword">int</span> diff = len1 - len2;</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">            longList = pHead2;</span><br><span class="line">            shortList = pHead1;</span><br><span class="line">            diff = len2 - len1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后让长的链表先走多的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; i++) &#123;</span><br><span class="line">            longList = longList.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一起走，第一个相同结点就是公共结点</span></span><br><span class="line">        <span class="keyword">while</span> (longList != <span class="keyword">null</span> &amp;&amp; shortList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (longList == shortList)&#123;</span><br><span class="line">                <span class="keyword">return</span> longList;</span><br><span class="line">            &#125;</span><br><span class="line">            longList = longList.next;</span><br><span class="line">            shortList = shortList.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode current = list;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h4><p>如果一个链表中包含环，如何找出环的入口节点？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表中环的入口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/03 18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryNodeOfLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EntryNodeOfLoop app = <span class="keyword">new</span> EntryNodeOfLoop();</span><br><span class="line">        ListNode a1=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode a2=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode a3=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode a4=<span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode a5=<span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode a6=<span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        a1.next=a2;</span><br><span class="line">        a2.next=a3;</span><br><span class="line">        a3.next=a4;</span><br><span class="line">        a4.next=a5;</span><br><span class="line">        a5.next=a6;</span><br><span class="line">        a6.next=a3;</span><br><span class="line">        System.out.println(app.EntryNodeOfLoop(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.判断是否有环,如果有则返回环内的一个节点</span></span><br><span class="line">        ListNode loopNode = meetingNode(pHead);</span><br><span class="line">        <span class="keyword">if</span> (loopNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计数环的长度</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        ListNode search = loopNode.next;</span><br><span class="line">        <span class="keyword">while</span> (loopNode != search) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            search = search.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.找到入口</span></span><br><span class="line">        ListNode behind = pHead;<span class="comment">// 慢指针</span></span><br><span class="line">        ListNode prev = pHead;<span class="comment">//快指针</span></span><br><span class="line">        <span class="comment">// 让快指针先走count个节点，这样才能保证他们相遇的节点是入口节点</span></span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(prev!=behind)&#123;</span><br><span class="line">            prev=prev.next;</span><br><span class="line">            behind=behind.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用快慢指针，当其相遇时有环，快指针==null时无环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">meetingNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode slow = head;<span class="comment">// 慢指针</span></span><br><span class="line">        ListNode fast = slow.next;<span class="comment">//快指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果快慢指针相遇、快指针的下一个是慢指针，则有环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast || fast.next == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新快慢指针位置</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast != <span class="keyword">null</span>) fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中重复的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/06 10:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDuplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeleteDuplication app = <span class="keyword">new</span> DeleteDuplication();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        ListNode a1 = app.create(nums);</span><br><span class="line">        a1 = app.deleteDuplication(a1);</span><br><span class="line">        <span class="keyword">while</span> (a1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(a1.val + <span class="string">"--&gt;"</span>);</span><br><span class="line">            a1 = a1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// null或者只有一个结点时 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">// 新链表的头结点</span></span><br><span class="line">        newHead.next = pHead;</span><br><span class="line">        ListNode pre = newHead;<span class="comment">// 记录前一个不重复的结点</span></span><br><span class="line">        ListNode cur = pre.next;<span class="comment">// 当前结点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前结点与下一结点相等</span></span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == cur.val);</span><br><span class="line">                cur = cur.next; <span class="comment">// 更新到这个暂时不重复的点</span></span><br><span class="line">                pre.next = cur; <span class="comment">// pre的next连接到这个暂时不重复的点</span></span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 当前结点与下一结点不相等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur;<span class="comment">// 则pre更新到这个可以确认是不重复的点上</span></span><br><span class="line">                cur = cur.next; <span class="comment">// 移动cur</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 保留一个重复结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication2</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode q = p;</span><br><span class="line">            <span class="keyword">while</span> (q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.val == q.next.val) &#123;</span><br><span class="line">                    q.next = q.next.next;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">create</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        ListNode cur = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(nums[i]);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p><img src="/2018/06/17/剑指offer/6.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先取【先序】的第一个元素，作为根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//然后遍历【中序】，找到对应的根结点，进行划分数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="comment">//注意i对应的是中序的下标，因此是截取pre[1，i+1]</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i + <span class="number">1</span>,</span><br><span class="line">                        in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p><img src="/2018/06/17/剑指offer/23.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      queue.offer(root);</span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          TreeNode node=queue.poll();</span><br><span class="line">          result.add(node.val);</span><br><span class="line">          <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.offer(node.left);   </span><br><span class="line">          <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.offer(node.right);   </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><p><img src="/2018/06/17/剑指offer/18.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isTree = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前两个根结点相等，则进行检查</span></span><br><span class="line">            <span class="keyword">if</span> (root1.val == root2.val) isTree = isSubTree(root1, root2);</span><br><span class="line">            <span class="comment">// 否则递归对root1的左子树判断</span></span><br><span class="line">            <span class="keyword">if</span> (!isTree) isTree = HasSubtree(root1.left, root2);</span><br><span class="line">            <span class="comment">// 左子树也没有，则递归对root1的右子树判断</span></span><br><span class="line">            <span class="keyword">if</span> (!isTree) isTree = HasSubtree(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isTree;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//root2匹配完了，因此true</span></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//root2不为null而root1==null，则不相同</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当前结点相等，则判断左子树，然后判断右子树</span></span><br><span class="line">        <span class="keyword">return</span>  isSubTree(root1.left, root2.left) &amp;&amp;  isSubTree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h4><p><img src="/2018/06/17/剑指offer/19.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先序遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换子节点</span></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        <span class="comment">// 递归处理子节点</span></span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h4><p><img src="/2018/06/17/剑指offer/24.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] c = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">14</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] d = &#123;&#125;;</span><br><span class="line">        System.out.println(VerifySquenceOfBST(d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为空则false</span></span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个点，则为true，直接返回不用递归了</span></span><br><span class="line">        <span class="keyword">if</span> (sequence.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = sequence.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> root = sequence[high];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以root判断大小，寻找划分点，i最终会落在第一个大于root的位置</span></span><br><span class="line">        <span class="keyword">while</span> (sequence[i] &lt; root) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断右子树是否都大于root，否则就不可能是后序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root &gt; sequence[j]) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//  copyOfRange : [begin,end),不包含end</span></span><br><span class="line">        <span class="keyword">int</span>[] leftTree = Arrays.copyOfRange(sequence, <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">int</span>[] rightTree = Arrays.copyOfRange(sequence, i, high);</span><br><span class="line">        <span class="keyword">boolean</span> leftResult = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> rightResult = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftTree.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            leftResult = VerifySquenceOfBST(leftTree);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightTree.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            rightResult = VerifySquenceOfBST(rightTree);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftResult &amp;&amp; rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/06/17/剑指offer/24-1.png" alt=""></p><h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><p><img src="/2018/06/17/剑指offer/25.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allRoad = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Stack&lt;Integer&gt; road = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            path(root, target, road, <span class="number">0</span>, allRoad);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allRoad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode root, <span class="keyword">int</span> target, Stack&lt;Integer&gt; road, <span class="keyword">int</span> currentSum, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allRoad)</span> </span>&#123;</span><br><span class="line">        currentSum = root.val + currentSum;</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        <span class="comment">// 超过目标值，不必向下继续</span></span><br><span class="line">        <span class="keyword">if</span> (currentSum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶结点,但值不等于目标值,返回</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span> &amp;&amp; currentSum != target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        road.push(root.val);</span><br><span class="line">        <span class="comment">// 叶结点，值等于目标值，添加路径</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span> &amp;&amp; currentSum == target) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : road) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            allRoad.add(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            path(left, target, road, currentSum, allRoad);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            path(right, target, road, currentSum, allRoad);</span><br><span class="line">        &#125;</span><br><span class="line">        road.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树与双向链表转换"><a href="#二叉搜索树与双向链表转换" class="headerlink" title="二叉搜索树与双向链表转换"></a>二叉搜索树与双向链表转换</h4><p><img src="/2018/06/17/剑指offer/27.png" alt="二叉搜索树与双向链表转换"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode n1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode n2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode n3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode n4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        TreeNode n5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        TreeNode n6 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        TreeNode n7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//构建树</span></span><br><span class="line">        n4.left = n2;</span><br><span class="line">        n4.right = n6;</span><br><span class="line">        n2.left = n1;</span><br><span class="line">        n2.right = n3;</span><br><span class="line">        n6.left = n5;</span><br><span class="line">        n6.right = n7;</span><br><span class="line">        Convert(n4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        TreeNode lastVisitNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 注意，不可以将lastVisitNode直接传入，因为就像传入null，不会赋值给lastVisitNode</span></span><br><span class="line">        lastVisitNode = convertNode(pRootOfTree, lastVisitNode);</span><br><span class="line">        <span class="comment">// 完成转换，从lastVisitNode往前遍历，到头结点</span></span><br><span class="line">        TreeNode first = lastVisitNode;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first.left==<span class="keyword">null</span>)  <span class="keyword">break</span>;</span><br><span class="line">            first = first.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * currentNode：当前节点</span></span><br><span class="line"><span class="comment">     * lastVisitNode：最后访问的节点，同时也是双向链表的最右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">convertNode</span><span class="params">(TreeNode currentNode, TreeNode lastVisitNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先处理左子树，同时获得左子树最右边的点（最大点）</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastVisitNode = convertNode(currentNode.left, lastVisitNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//互相连接，当前节点的left连接lastVisitNode,同时lastVisitNode的right连接当前节点</span></span><br><span class="line">        currentNode.left = lastVisitNode;</span><br><span class="line">        <span class="keyword">if</span> (lastVisitNode != <span class="keyword">null</span>) lastVisitNode.right = currentNode;</span><br><span class="line">        lastVisitNode = currentNode; <span class="comment">//最后访问的节点更新为当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理右子树</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastVisitNode = convertNode(currentNode.right, lastVisitNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastVisitNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;   <span class="comment">// 连接小的结点</span></span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;  <span class="comment">// 连接大的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的深度-以及是否是平衡二叉树"><a href="#二叉树的深度-以及是否是平衡二叉树" class="headerlink" title="二叉树的深度,以及是否是平衡二叉树"></a>二叉树的深度,以及是否是平衡二叉树</h4><p><img src="/2018/06/17/剑指offer/39.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftDepth = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/06/17/剑指offer/39-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode a1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode a2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode a3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode a4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        TreeNode a5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        TreeNode a6 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        TreeNode a7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        TreeNode a8 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        a1.left=a2;</span><br><span class="line">        a1.right=a3;</span><br><span class="line">        a2.left=a4;</span><br><span class="line">        a2.right=a5;</span><br><span class="line">        a5.right=a7;</span><br><span class="line">        a3.left=a8;</span><br><span class="line">        a3.right=a6;</span><br><span class="line">        System.out.println(IsBalanced_Solution(a1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值 -1：非平衡树，0：null结点，正数：树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = isBalanced(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = isBalanced(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左右子树都是平衡树，则进行深度比较；如果深度差满足要求，则返回最大深度</span></span><br><span class="line">        <span class="keyword">if</span> (leftDepth != -<span class="number">1</span> &amp;&amp; rightDepth != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历二叉树-求某一节点的下一中序节点"><a href="#中序遍历二叉树-求某一节点的下一中序节点" class="headerlink" title="中序遍历二叉树,求某一节点的下一中序节点"></a>中序遍历二叉树,求某一节点的下一中序节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.有右结点，则找该右结点的最左结点</span></span><br><span class="line">    <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pNode = pNode.right;</span><br><span class="line">        <span class="keyword">while</span> (pNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.没有右节点，则向上找父节点</span></span><br><span class="line"><span class="comment">             a          a</span></span><br><span class="line"><span class="comment">       b                    b</span></span><br><span class="line"><span class="comment">           c                    c</span></span><br><span class="line"><span class="comment">        d                     d</span></span><br><span class="line"><span class="comment">    c是当前节点。确定c是在某个节点(a)的左子树中，还是(a)的右子树中；</span></span><br><span class="line"><span class="comment">    如果在左子树中，则找到的第一个包含c的节点就是下一个中序输出的节点；</span></span><br><span class="line"><span class="comment">    否则，就没有下一个节点了</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    TreeLinkNode parent = pNode.next;</span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.left == pNode) <span class="keyword">return</span> parent;</span><br><span class="line">        pNode = parent;</span><br><span class="line">        parent = parent.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h4><p>给定一颗二叉搜索树，请找出其中的第k小的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 序列化</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        String node = Integer.toString(root.val);</span><br><span class="line">        node += <span class="string">","</span>;<span class="comment">//父节点后添加逗号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>)</span><br><span class="line">            node += <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node += Serialize(root.left);</span><br><span class="line">        node += <span class="string">","</span>;<span class="comment">//左节点后添加逗号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span>)</span><br><span class="line">            node += <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node += Serialize(root.right);</span><br><span class="line">        <span class="comment">//右节点后 不添加逗号</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] nodes = str.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Deserialize2(nodes);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正在处理的结点下标</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize2</span><span class="params">(String[] nodes)</span> </span>&#123;</span><br><span class="line">        String node = nodes[index++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"#"</span>.equals(node)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(node));</span><br><span class="line">        root.left = Deserialize2(nodes);</span><br><span class="line">        root.right = Deserialize2(nodes);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h3><h4 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h4><p><img src="/2018/06/17/剑指offer/7.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; inStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();<span class="comment">// 入队保存的栈</span></span><br><span class="line">    Stack&lt;Integer&gt; outStack = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">// 出队保存的栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        inStack.push(node);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用两个队列实现栈（未实现）"><a href="#用两个队列实现栈（未实现）" class="headerlink" title="用两个队列实现栈（未实现）"></a>用两个队列实现栈（未实现）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><p><img src="/2018/06/17/剑指offer/21.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span> (minStack.empty()) &#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node &lt; minStack.peek()) &#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minStack.push(minStack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty()) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><p><img src="/2018/06/17/剑指offer/22.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] b=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(IsPopOrder(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, lena = pushA.length, lenb = popA.length;</span><br><span class="line">        <span class="keyword">boolean</span> isPopOrder = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; lena) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// 栈顶与popA[j]相同，则出栈，否则继续进栈</span></span><br><span class="line">            <span class="keyword">while</span> (stack.peek() == popA[j] &amp;&amp; j &lt; lenb) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 栈不为空，或者popA没有遍历完，则不是</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() || j != lenb) &#123;</span><br><span class="line">            isPopOrder = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isPopOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="员工年龄排序"><a href="#员工年龄排序" class="headerlink" title="员工年龄排序"></a>员工年龄排序</h4><p><img src="/2018/06/17/剑指offer/8-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">23</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">23</span>&#125;;</span><br><span class="line">        sortAge(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortAge(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> oldest = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 创建0-100的数组来统计每个年龄有多少人</span></span><br><span class="line">        <span class="keyword">int</span>[] ages = <span class="keyword">new</span> <span class="keyword">int</span>[oldest + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组进行统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> age = arr[i];</span><br><span class="line">            ages[age]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历统计的数组，将年龄存回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> age = <span class="number">0</span>; age &lt;= oldest; age++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ages[age]; i++) &#123;</span><br><span class="line">                arr[index] = age;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><p><img src="/2018/06/17/剑指offer/矩阵中的路径.png" alt="矩阵中的路径"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断矩阵中是否有路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/09 20:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasPath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HasPath app = <span class="keyword">new</span> HasPath();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] matrix = <span class="string">"ABCESFCSADEE"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str = <span class="string">"ABCB"</span>.toCharArray();</span><br><span class="line">        System.out.println(app.hasPath(matrix, <span class="number">3</span>, <span class="number">4</span>, str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历矩阵中每个位置，穷举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findStr(matrix, rows, cols, i, j, str, visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findStr</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span>[] str, <span class="keyword">boolean</span>[][]  visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strIndex == str.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 矩阵中matrix[row][col] 的字符 与 str[strIndex]的相同，则继续探索该位置的四周与str[strIndex++]是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; !visited[row][col] &amp;&amp; matrix[row * cols + col] == str[strIndex]) &#123;</span><br><span class="line">            strIndex++;</span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            find = findStr(matrix, rows, cols, row - <span class="number">1</span>, col, str, visited) ||</span><br><span class="line">                    findStr(matrix, rows, cols, row + <span class="number">1</span>, col, str, visited) ||</span><br><span class="line">                    findStr(matrix, rows, cols, row, col - <span class="number">1</span>, str, visited) ||</span><br><span class="line">                    findStr(matrix, rows, cols, row, col + <span class="number">1</span>, str, visited);</span><br><span class="line">            <span class="comment">// 如果该点的四周都没有找到符合下一字符的，则退回，重置该位置的状态，以及字符匹配的位置</span></span><br><span class="line">            <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">                visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line">                strIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h4><p><img src="/2018/06/17/剑指offer/机器人的运动范围.png" alt="机器人的运动范围"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 机器人的运动范围</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/09 21:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotMovingCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RobotMovingCount app = <span class="keyword">new</span> RobotMovingCount();</span><br><span class="line">        System.out.println(app.movingCount(<span class="number">18</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rows &lt; <span class="number">0</span> || cols &lt; <span class="number">0</span> || threshold &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> movingCount(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (canIn(rows, cols, row, col, threshold, visited)) &#123;</span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 能够到达的位置：当前位置+其他四个方向能够到达的总和</span></span><br><span class="line">            count = <span class="number">1</span> + movingCount(threshold, rows, cols, row - <span class="number">1</span>, col, visited) +</span><br><span class="line">                    movingCount(threshold, rows, cols, row + <span class="number">1</span>, col, visited) +</span><br><span class="line">                    movingCount(threshold, rows, cols, row, col - <span class="number">1</span>, visited) +</span><br><span class="line">                    movingCount(threshold, rows, cols, row, col + <span class="number">1</span>, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否能进入该位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIn</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> threshold, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[row][col] &amp;&amp; row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (row != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += row % <span class="number">10</span>;</span><br><span class="line">                row /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (col != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += col % <span class="number">10</span>;</span><br><span class="line">                col /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum &lt;= threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="斐波那契数数列"><a href="#斐波那契数数列" class="headerlink" title="斐波那契数数列"></a>斐波那契数数列</h4><p><img src="/2018/06/17/剑指offer/9.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] initial = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">//初始化第0项、第1项</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> initial[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fn=f(n-1)+f(n-2)</span></span><br><span class="line">        <span class="keyword">int</span> fn_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fn_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fn = fn_1 + fn_2;</span><br><span class="line">            fn_2 = fn_1;</span><br><span class="line">            fn_1 = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h5><p><img src="/2018/06/17/剑指offer/9-1.png" alt=""></p><p>但是要注意<strong>与斐波那契数列的下标起始位置不太一样</strong> ，第0 项是1,即：1 1 2 3 5 。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] initial = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">2</span>) <span class="keyword">return</span> initial[target];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> jumpn_1 = <span class="number">1</span>; <span class="comment">//第1项是1</span></span><br><span class="line">    <span class="keyword">int</span> jumpn_2 = <span class="number">1</span>; <span class="comment">//第0项是1</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        num = jumpn_1 + jumpn_2;</span><br><span class="line">        jumpn_2 = jumpn_1;</span><br><span class="line">        jumpn_1 = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="/2018/06/17/剑指offer/9-2.png" alt=""></p><hr><h5 id="矩阵覆盖问题"><a href="#矩阵覆盖问题" class="headerlink" title="矩阵覆盖问题"></a>矩阵覆盖问题</h5><p><img src="/2018/06/17/剑指offer/9-3.png" alt=""></p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h4 id="10-二进制中1的个数"><a href="#10-二进制中1的个数" class="headerlink" title="10.二进制中1的个数"></a>10.二进制中1的个数</h4><p><img src="/2018/06/17/剑指offer/10.png" alt=""></p><p>用1扫描法：</p><p><img src="/2018/06/17/剑指offer/10-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> matcher = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (matcher != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// n与matcher按位 与运算，如果matcer的1 对应n的1，就不会为0</span></span><br><span class="line">        <span class="comment">// n:0000101</span></span><br><span class="line">        <span class="comment">// m:0000100</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; matcher) != <span class="number">0</span>) count++;</span><br><span class="line">        <span class="comment">//让matcer左移，进行扫描</span></span><br><span class="line">        matcher = matcher &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减1法</p><p><img src="/2018/06/17/剑指offer/10-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 把一个整数减去1，再和原整数做 与运算，就会把该整数最右边一个1变成0</span></span><br><span class="line">         n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><h4 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h4><p>由于精度原因，<strong>不能用等号判断两个double 小数是否相等</strong>。</p><p>当小数点后位数 大于15位时，jvm就会忽略这个精度，这种情况，我们在开发时如果需要更精确的比较double类型，就要用到 BigDecimal 这个类了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// jdk1.8</span><br><span class="line">double x1= 4.000000000000002;</span><br><span class="line">double x2= 4.000000000000005;</span><br><span class="line">x1&lt;x2  true</span><br><span class="line"></span><br><span class="line">BigDecimal x3=new BigDecimal(4.0000000000000002);</span><br><span class="line">BigDecimal x4=new BigDecimal(4.0000000000000005);</span><br><span class="line">x3&lt;x4 true</span><br><span class="line"></span><br><span class="line">000000000000002      // double(15位)</span><br><span class="line">0000000000000002     // BigDecimal（16位）</span><br></pre></td></tr></table></figure><h4 id="数值的整数次方pow-x-n"><a href="#数值的整数次方pow-x-n" class="headerlink" title="数值的整数次方pow(x,n)"></a>数值的整数次方pow(x,n)</h4><p>思路：分治</p><p>简洁版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 底数为0,不可以直接用等号判断，因为有精度的问题</span></span><br><span class="line">    <span class="keyword">if</span> (Double.compare(x, <span class="number">0.0</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指数&lt;0的情况，取绝对值，最后进行求倒数即可</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span> / powWithUnsign(x, -n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> powWithUnsign(x, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">powWithUnsign</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">double</span> result = powWithUnsign(x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ((n&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result * result * x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> result * result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> basse, <span class="keyword">int</span> exponent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 输入底数为0，指数小于0</span></span><br><span class="line">        <span class="keyword">if</span> (Double.compare(basse, <span class="number">0.0</span>) == <span class="number">0</span> &amp;&amp; exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"非法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> absExponent = exponent;<span class="comment">//指数取绝对值</span></span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            absExponent = exponent * -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> result = PowerWithUnsignedExponent(basse, absExponent);</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1.0</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断人为输入为0的情况，并不是右移产生的</span></span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span> ((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="打印1到最大的n位数"><a href="#打印1到最大的n位数" class="headerlink" title="打印1到最大的n位数"></a>打印1到最大的n位数</h4><p><img src="/2018/06/17/剑指offer/12.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNMax</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">char</span>[] number = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length; i++) &#123;</span><br><span class="line">         number[i] = <span class="string">'0'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> a = number[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">while</span> (!increase(number, <span class="number">8</span>)) &#123;</span><br><span class="line">         printNum(number);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increase</span><span class="params">(<span class="keyword">char</span>[] number, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> takeOver = <span class="number">0</span>;<span class="comment">// 进位</span></span><br><span class="line">     <span class="keyword">boolean</span> isMax = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 从最后一位开始加一</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = number.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         sum = number[i] - <span class="string">'0'</span> + takeOver;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 个位进行加一</span></span><br><span class="line">         <span class="keyword">if</span> (i == number.length - <span class="number">1</span>) &#123;</span><br><span class="line">             sum += add;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 和大于10，则有进位，否则就可以结束循环</span></span><br><span class="line">         <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果是最高位，则结束</span></span><br><span class="line">             <span class="keyword">if</span> (i == <span class="number">0</span>) isMax = <span class="keyword">true</span>;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 sum -= <span class="number">10</span>;</span><br><span class="line">                 takeOver = <span class="number">1</span>;</span><br><span class="line">                 number[i] = (<span class="keyword">char</span>) (<span class="string">'0'</span> + sum);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             number[i] = (<span class="keyword">char</span>) (<span class="string">'0'</span> + sum);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> isMax;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">boolean</span> isStart = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">while</span> (i &lt; number.length) &#123;</span><br><span class="line">         <span class="keyword">if</span> (number[i] == <span class="string">'0'</span> &amp;&amp; !isStart) &#123;</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             isStart = <span class="keyword">true</span>;</span><br><span class="line">             System.out.print(number[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="34-丑数"><a href="#34-丑数" class="headerlink" title="34.丑数"></a>34.丑数</h4><p><img src="/2018/06/17/剑指offer/34.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存丑数的数组，并初始化第一个丑数</span></span><br><span class="line">        <span class="keyword">int</span>[] uglyNum = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        uglyNum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 指向对应乘积刚好大于当前找到的丑数的下标</span></span><br><span class="line">        <span class="keyword">int</span> base2 = <span class="number">0</span>;<span class="comment">// 乘以2后的值，刚好略大于当前丑数的下标</span></span><br><span class="line">        <span class="keyword">int</span> base3 = <span class="number">0</span>;<span class="comment">// 乘以3后的值，刚好略大于当前丑数的下标</span></span><br><span class="line">        <span class="keyword">int</span> base5 = <span class="number">0</span>;<span class="comment">// 乘以5后的值，刚好略大于当前丑数的下标</span></span><br><span class="line">        <span class="keyword">int</span> currentIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentIndex &lt; index) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextNum = Math.min(Math.min(uglyNum[base2] * <span class="number">2</span>, uglyNum[base3] * <span class="number">3</span>), uglyNum[base5] * <span class="number">5</span>);</span><br><span class="line">            uglyNum[currentIndex] = nextNum;</span><br><span class="line">            <span class="comment">// 更新下标，使得下标在刚好略大于当前丑数的下标</span></span><br><span class="line">            <span class="keyword">while</span> (uglyNum[base2] * <span class="number">2</span> &lt;= nextNum) base2++;</span><br><span class="line">            <span class="keyword">while</span> (uglyNum[base3] * <span class="number">3</span> &lt;= nextNum) base3++;</span><br><span class="line">            <span class="keyword">while</span> (uglyNum[base5] * <span class="number">5</span> &lt;= nextNum) base5++;</span><br><span class="line">            currentIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglyNum[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h4><p><img src="/2018/06/17/剑指offer/47.png" alt=""></p><p>思路：</p><p><img src="/2018/06/17/剑指offer/47-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125; <span class="keyword">while</span> (carry != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不使用新变量交换两个变量的值"><a href="#不使用新变量交换两个变量的值" class="headerlink" title="不使用新变量交换两个变量的值"></a>不使用新变量交换两个变量的值</h4><p><img src="/2018/06/17/剑指offer/47-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于加减法</span></span><br><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br><span class="line"><span class="comment">// 基于异或</span></span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h3 id="抽象建模"><a href="#抽象建模" class="headerlink" title="抽象建模"></a>抽象建模</h3><h4 id="44-扑克牌的顺子"><a href="#44-扑克牌的顺子" class="headerlink" title="44.扑克牌的顺子"></a>44.扑克牌的顺子</h4><p><img src="/2018/06/17/剑指offer/44.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length != <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计大王的个数</span></span><br><span class="line">        <span class="keyword">int</span> king = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) king++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计不连续间隔</span></span><br><span class="line">        <span class="keyword">int</span> gaps = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// i=king的个数+1，从而跳过王</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = king+<span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 出现对子，不可能是顺子</span></span><br><span class="line">            gaps += numbers[i] - numbers[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gaps &lt;= king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>喜欢人的理由为什么说不出来</title>
      <link href="/2018/03/23/%E5%96%9C%E6%AC%A2%E4%BA%BA%E7%9A%84%E7%90%86%E7%94%B1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%B8%8D%E5%87%BA%E6%9D%A5/"/>
      <url>/2018/03/23/%E5%96%9C%E6%AC%A2%E4%BA%BA%E7%9A%84%E7%90%86%E7%94%B1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%B8%8D%E5%87%BA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>喜欢人的理由为什么说不出来</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/03/23/喜欢人的理由为什么说不出来/2018-03-23-喜欢人的理由为什么说不出来.jpg" alt=""></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 所见所闻 </category>
          
          <category> 爱情 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>全球公认的最健康的一天作息图解</title>
      <link href="/2018/03/23/%E5%85%A8%E7%90%83%E5%85%AC%E8%AE%A4%E7%9A%84%E6%9C%80%E5%81%A5%E5%BA%B7%E7%9A%84%E4%B8%80%E5%A4%A9%E4%BD%9C%E6%81%AF%E5%9B%BE%E8%A7%A3/"/>
      <url>/2018/03/23/%E5%85%A8%E7%90%83%E5%85%AC%E8%AE%A4%E7%9A%84%E6%9C%80%E5%81%A5%E5%BA%B7%E7%9A%84%E4%B8%80%E5%A4%A9%E4%BD%9C%E6%81%AF%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>全球公认的最健康的一天作息安排图解</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/03/23/全球公认的最健康的一天作息图解/2018-03-23-全球公认的最健康的一天作息图解.jpg" alt=""></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 健康 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何提高「钝感力」，从此不再「想太多」</title>
      <link href="/2018/03/23/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E3%80%8C%E9%92%9D%E6%84%9F%E5%8A%9B%E3%80%8D%EF%BC%8C%E4%BB%8E%E6%AD%A4%E4%B8%8D%E5%86%8D%E3%80%8C%E6%83%B3%E5%A4%AA%E5%A4%9A%E3%80%8D/"/>
      <url>/2018/03/23/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E3%80%8C%E9%92%9D%E6%84%9F%E5%8A%9B%E3%80%8D%EF%BC%8C%E4%BB%8E%E6%AD%A4%E4%B8%8D%E5%86%8D%E3%80%8C%E6%83%B3%E5%A4%AA%E5%A4%9A%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <blockquote><p>室友跟我说「你是不是该倒个垃圾」，结果我一晚上没睡好，一直在想，他是不是觉得我很懒？</p><p>和朋友一起坐公交，掏了好久才摸到公交卡，特别担心她嫌我傻，不想和我玩了。</p><p>期末考试漏做了一个题，害怕排名会掉下来，好几天了，心里一直很难受。</p></blockquote><blockquote><p>……</p></blockquote><p>虽然这样写出来，你看了可能会觉得不可思议，但实际上，这样的琐事每天都在发生。</p><p><strong>「因为一点小事胡思乱想」</strong>的情况人人都有份，你一定也不例外。</p><p>偶尔一次两次没什么，但如果<strong>每天都为这些琐事心烦意乱，就会觉得「心很累」。</strong></p><p>这么敏感的根源是什么呢？</p><p>@@@来至微信公众号：<a href="https://mp.weixin.qq.com/s?__biz=MzIyNDI0NTQ1Nw==&amp;mid=2247485463&amp;idx=1&amp;sn=e90212bf8f09c998f4dfba0c1c295ad8&amp;chksm=e810aba9df6722bf88714ef5d74725d661feeb1caef7102f7d422e95fd553c33780ea6f1e41f&amp;mpshare=1&amp;scene=1&amp;srcid=0321jNkEseClP7eBH3VnhFG7##" target="_blank" rel="noopener">重构自己</a></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="敏感的根源"><a href="#敏感的根源" class="headerlink" title="敏感的根源"></a><strong>敏感的根源</strong></h2><blockquote><p>同理心太强</p></blockquote><p>同理心（empathy）又称为换位思考、神入或共情，指<strong>站在对方立场设身处地思考的一种方式。</strong></p><p>同理心有两种，其中，认知同理心（cognitive empathy）是指你「辨别他人心智状态」的能力。</p><p>简单来说，就是<strong>你对周围人的情绪的「嗅觉」</strong>。</p><p>敏感的人常常会有很丰富的的情绪「嗅觉」，不仅自己容易陷入不必要的负面情绪，对周围人的感受也<strong>觉察的更敏锐</strong>。</p><p>对方皱了一下眉头，或者抿了抿嘴，你就会「感觉」到他在生气或者伤心。</p><blockquote><p>「自我价值感」来自外界</p></blockquote><p><strong>敏感的人常常过分担心「他人的看法」。</strong></p><p>失败了怕被嘲笑，成功了怕被嫉妒。永远都在担心「我给别人带来了什么影响、留下了什么印象」，整天惴惴不安。</p><p>这是因为，你把<strong>「自己的价值」和「别人的评价」</strong>混为了一谈，<strong>把衡量自己的标准交到了别人手里。</strong></p><p>当你一次考试失利，没获得认可，你就会觉得自己「全完了」；而一旦被别人批评、指责，那就更是「天都塌了」。</p><p>但是，一个很重要的事实是：<strong>你的价值并不取决于别人</strong>，基于外界的自我价值其实是一种<strong>「伪自尊」</strong>。</p><p>如果你的价值由他人决定，那岂不是被赞美的人就是最有价值、最幸福的人？</p><p>而实际上，<strong>赞美可以让人满足，但不能带来快乐，至少绝对不是长久的。</strong>过多的赞美甚至会引起空虚和焦虑。</p><p>很多自杀的名人都很成功，有无数人追捧。而大多数的抑郁症患者也并不缺少「爱」。</p><h2 id="敏感的影响"><a href="#敏感的影响" class="headerlink" title="敏感的影响"></a>敏感的影响</h2><p>欣赏一张图片时，如果你为了观察某个细节，把它不断放大，你会发现自己没法看清整张图了。</p><p>同样，当你过于在意一件「小事」，就会失掉对「全局」的观察和判断，甚至会<strong>把这个小事当成全部</strong>。</p><p>这时，你就对「全局」产生了<strong>「认知扭曲」</strong>。</p><p>常见的认知扭曲有这几种：</p><p><strong>1. 非此即彼</strong></p><p>这通常是由于「过度完美主义」导致的。</p><p><strong>你会害怕自己有一丁点的失败</strong>。比如你七门课都得了 A，第八门得了 B，就会觉得「连全 A 都没拿到，我真是个废物！」</p><p>其实，在「全 A」和「废物」之间，难道没有别的容身之处了吗？</p><p><strong>2. 以偏概全</strong></p><p>这种想法会让你认为：这件事如果发生了一次，就<strong>肯定会发生无数次</strong>。</p><p>当你某次表白失败了，你会开始想：这就是我的命，我这辈子「注孤生」了！实际上，这怎么可能呢？</p><p><strong>3. 心理过滤</strong></p><p>如果你一整天都为些小事心烦意乱，那很可能你的记忆会<strong>被这些不好的东西充斥</strong>。</p><p>你会发现自己只能想起那些负面的事：「做错了三个题」，「昨天被人插队了」，「快递被挤坏了」……而不记得任何好的事情。</p><p>这时，你就要提醒自己：你陷入「心理过滤」的扭曲认知里了。</p><p><strong>4. 妄下结论</strong></p><p>这也可以叫「读心术」。意思是，你总觉得<strong>你知道别人的想法</strong>。</p><p>当你的朋友和你擦肩而过，没打招呼，你会认为他一定是「生你的气、讨厌你了」。而事实上，他可能是没戴眼镜，压根没认出来是你。</p><p><strong>5. 归咎自己</strong></p><p>敏感的人擅长觉察别人的情绪，这倒没什么，但糟糕的是他们经常<strong>把那些情绪归成自己的「责任」</strong>。</p><p>比如你的室友看起来不太高兴，尽管可能他掩饰的很好，但你还是一眼就看出来了。然后你可能就会想：他生气是因为我吗？我是不是哪里做的不好，让他不高兴了？</p><p>这么一来，你就陷进了<strong>毫无必要</strong>的不安和内疚里。</p><h2 id="敏感的解决方法"><a href="#敏感的解决方法" class="headerlink" title="敏感的解决方法"></a>敏感的解决方法</h2><p>这只是一篇文章，不是一针抗敏药。<strong>重要的是你看完之后要去做。</strong></p><p><strong>▍看看真正的「全局」</strong></p><p>当你发现自己在执着于某个小事，先告诉自己：停住，别陷进去！想这些根本没有意义，全是浪费时间！</p><p>问问自己：<strong>五年</strong>、<strong>十年之后</strong>，<strong>你还会记得这件事吗</strong>？它到底能有多少影响？</p><p>把你那幅「放大了无数倍」的画缩回正常尺寸，从时间的「全局」上来看这件事，<strong>它还值得你这么纠结吗</strong>？</p><p>除了时间，还有生活的全局。</p><p>比如当你纠结于室友的那句「该倒个垃圾了」的时候，先告诉自己：别老琢磨了，有啥用？</p><p>然后去想想，你昨天还跟他一块儿打排位，上周末还约了火锅，他难道会因为一个垃圾桶跟你「断交」吗？</p><p>再说了，<strong>你的生活难道只有一个垃圾桶</strong>、<strong>一个室友吗</strong>？这让你爸妈、闺蜜还有你最爱去的那家火锅店，情何以堪？</p><p>除了想，你还可以动起来，<strong>去找点儿事做</strong>。</p><p>很多负面情绪其实都是「闲」出来的。你如果没有躺在床上「琢磨」，而是去追剧，或者吸猫，你根本就不会想起室友的那句话。</p><p>看看生活的全貌，让自己投入进去，<strong>别留太多时间给你「琢磨」</strong>。</p><p><strong>▍不要猜测，把话说出来</strong></p><p>如果你就是控制不住，一直在想「他是不是觉得我懒？我真的很懒吗？」那就把你的疑问说出来。</p><p><strong>不要「猜」</strong>，<strong>直接去问他</strong>：你昨天那样说是因为，你觉得我不经常倒垃圾吗？</p><p>如果他说不是，那你的不安就彻底解决了；如果他说是，那你也不用担心，<strong>这本来就是个「小事」</strong>，<strong>还怕解决不了吗</strong>？</p><p>跟他商量一下，轮流打扫卫生，或者买两个垃圾桶，一人一个，这不就完事了？</p><p><strong>▍卸下不必要的责任</strong></p><p>当你察觉到别人生气或者伤心了，开始担心这是「你的错」，告诉自己：这不关我的事。</p><p>这不是「不善良」或者「自私」，而是因为，每个人都得为自己的行为和情绪负责。这是他自己的难题，<strong>他必须，也只能自己去解决。</strong></p><p>如果他向你寻求帮助，你可以开解或安慰他，但是<strong>不管**</strong>成不成功，你都没有「责任」。</p><h2 id="终极必杀：提高自我认知"><a href="#终极必杀：提高自我认知" class="headerlink" title="终极必杀：提高自我认知"></a>终极必杀：提高自我认知</h2><p>如果你习惯于用别人的评价定义自己，那你一定很敏感。因为你需要不停的「察言观色」，去猜别人的想法。</p><p>那怎么才能不依赖外界，让自己来决定你的价值？</p><p><strong>▍不要物化自己</strong></p><p><strong>你不是学积分，也不是体重秤，更不是别人嘴里的几个「形容词」。</strong>你是一个完整的，有思想、感觉和情绪的人。</p><p>当你因为别人的评价质疑自己的时候，提醒自己：<strong>你是什么样的人，他说了不算。</strong></p><p>不管他是谁，你的父母、老师还是最好的朋友，他都不能定义你。别人看到的只是「他眼中的你」，那不完整。</p><p><strong>你不是一成不变的。</strong>你每一天、每一分钟都在改变。这些变化别人不清楚，但你自己知道。</p><p><strong>▍了解自己</strong></p><p>拿出一张纸，<strong>把这些问题的答案写出来</strong>：</p><blockquote><p>最了解我的人是</p><p>我的一个人生梦想是</p><p>用三个形容词描述我自己</p><p>我最喜欢自己的这一点</p><p>我最不喜欢这一点</p><p>我比较擅长</p><p>我不太擅长</p><p>我喜欢</p><p>我讨厌</p><p>吸引我的三个职业是</p><p>我的人生目标是</p></blockquote><p>回答完毕后，你是不是对自己有了更<strong>明确、稳定</strong>的认知？</p><p>你可以每隔一段时间就回答一次，看看有什么变化，这样会更了解自己。</p><p>当你逐渐认识了自己，你会开始树立出一个<strong>「理想的自我」</strong>。</p><p>朝着这个方向去努力，你会发现，<strong>你不再需要他人的认可来确定自己的「进步」</strong>。你自己心里很清楚，你哪里做得好，哪里还要继续改进。</p><p>当你不再依赖于外界去获取动力，你的前进也就从容起来了。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 所见所闻 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 所见所闻 </tag>
            
            <tag> 同理心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java嵌套类</title>
      <link href="/2018/03/03/java%E5%B5%8C%E5%A5%97%E7%B1%BB/"/>
      <url>/2018/03/03/java%E5%B5%8C%E5%A5%97%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>讲解java中嵌套类的概念，也就是在类中定义另一个类的概念（未完待续。。。）</excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>java语言允许你在一个类中定义另一个类，这样的类称为嵌套类，形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>术语: 嵌套类分为2类：静态、非静态。静态的嵌套类称为静态嵌套类，非静态的嵌套类称为内部类，如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套类是包围它的外部类（enclosing class）的一个成员，非静态嵌套类（内部类）可以访问到其他成员，即使它们被定义为私有的（private）。静态嵌套类不能访问其他成员。作为外部类的成员，嵌套类可以被声明为 private, public, protected, 或者 package private 四种访问权限</p><p><strong>为什么要使用嵌套类呢?</strong></p><ul><li>这是一种有效组织那种只在某一处使用到的类的方法：比如一个类只对另外一个类有用，那么把它们两放在一起，嵌套在一起是合乎逻辑的，将这样的辅助类（helper classes）嵌套在一起使得java包更加简洁合理.</li><li>增强了封装性: 考虑两个顶层类（top-level classes）, A 和 B, 其中B需要访问A的成员，否则这些成员将被声明为私有。如果将B藏在A中, A的成员即使被定义为私有的，B也可以访问到， 另外，B本身也与外界隔离开来</li><li>更加可读，并且有利于维护代码: Nesting small classes within top-level classes places the code closer to where it is used.</li></ul><h3 id="静态嵌套类（Static-Nested-Classes）"><a href="#静态嵌套类（Static-Nested-Classes）" class="headerlink" title="静态嵌套类（Static Nested Classes）"></a>静态嵌套类（Static Nested Classes）</h3><p>与类方法、类变量成员一样，一个静态嵌套类与外部类是相关联的，而且与静态方法类似，静态嵌套类不能直接获取到外部类的实例变量或者其中的函数：它只能通过类引用来使用它们。</p><p>注意：静态嵌套类与其外部类（或者其他类）的实例成员之间的交互，就像其他顶层类之间一样。实际上，一个静态嵌套类在表现上像是一个顶级类，其实是嵌套在另一个顶级类中的，以方便打包。<br>使用到静态嵌套类时必须通过外部类，形如：<code>OuterClass.StaticNestedClass</code><br>比如要创建一个静态嵌套类的实例，语法如下：<br><code>OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();</code><br>​     </p><h3 id="内部类（Inner-Classes）"><a href="#内部类（Inner-Classes）" class="headerlink" title="内部类（Inner Classes）"></a>内部类（Inner Classes）</h3><p>与实例方法、实例变量成员一样，一个内部类与外部类的一个实例是相关联的，而且能够直接访问到外部类实例中的方法与变量，而且因为内部类是与实例相关联的，因此内部类中是无法定义静态成员的。</p><p>内部类的实例只能与外部类的实例同时存在，无法独立实例化，并且能够直接访问到外部类的方法与变量<br>想要实例化一个内部类，你必须先实例化一个外部类，然后才能通过外部类创建一个内部类的实例，语法如下：</p><p><code>OuterClass.InnerClass innerObject = outerObject.new InnerClass();</code><br>内部类中有两种特殊的类：局部类、匿名类</p><h4 id="局部类（Local-Classes）"><a href="#局部类（Local-Classes）" class="headerlink" title="局部类（Local Classes）"></a>局部类（Local Classes）</h4><p>Local classes are classes that are defined in a <em>block</em>, which is a group of zero or more statements between balanced braces. You typically find local classes defined in the body of a method.</p><p>This section covers the following topics:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#declaring-local-classes" target="_blank" rel="noopener">Declaring Local Classes</a></li><li>Accessing Members of an Enclosing Class<ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#shadowing-and-local-classes" target="_blank" rel="noopener">Shadowing and Local Classes</a></li></ul></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#local-classes-are-similar-to-inner-classes" target="_blank" rel="noopener">Local Classes Are Similar To Inner Classes</a></li></ul><h5 id="Declaring-Local-Classes"><a href="#Declaring-Local-Classes" class="headerlink" title="Declaring Local Classes"></a><a href="">Declaring Local Classes</a></h5><p>You can define a local class inside any block (see <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html" target="_blank" rel="noopener">Expressions, Statements, and Blocks</a> for more information). For example, you can define a local class in a method body, a <code>for</code> loop, or an <code>if</code> clause.</p><p>The following example, <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LocalClassExample.java" target="_blank" rel="noopener"><code>LocalClassExample</code></a>, validates two phone numbers. It defines the local class <code>PhoneNumber</code> in the method <code>validatePhoneNumber</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class LocalClassExample &#123;</span><br><span class="line">  </span><br><span class="line">    static String regularExpression = &quot;[^0-9]&quot;;</span><br><span class="line">  </span><br><span class="line">    public static void validatePhoneNumber(</span><br><span class="line">        String phoneNumber1, String phoneNumber2) &#123;</span><br><span class="line">      </span><br><span class="line">        final int numberLength = 10;</span><br><span class="line">        </span><br><span class="line">        // Valid in JDK 8 and later:</span><br><span class="line">       </span><br><span class="line">        // int numberLength = 10;</span><br><span class="line">       </span><br><span class="line">        class PhoneNumber &#123;</span><br><span class="line">            </span><br><span class="line">            String formattedPhoneNumber = null;</span><br><span class="line"></span><br><span class="line">            PhoneNumber(String phoneNumber)&#123;</span><br><span class="line">                // numberLength = 7;</span><br><span class="line">                String currentNumber = phoneNumber.replaceAll(</span><br><span class="line">                  regularExpression, &quot;&quot;);</span><br><span class="line">                if (currentNumber.length() == numberLength)</span><br><span class="line">                    formattedPhoneNumber = currentNumber;</span><br><span class="line">                else</span><br><span class="line">                    formattedPhoneNumber = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public String getNumber() &#123;</span><br><span class="line">                return formattedPhoneNumber;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Valid in JDK 8 and later:</span><br><span class="line"></span><br><span class="line">//            public void printOriginalNumbers() &#123;</span><br><span class="line">//                System.out.println(&quot;Original numbers are &quot; + phoneNumber1 +</span><br><span class="line">//                    &quot; and &quot; + phoneNumber2);</span><br><span class="line">//            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);</span><br><span class="line">        PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);</span><br><span class="line">        </span><br><span class="line">        // Valid in JDK 8 and later:</span><br><span class="line"></span><br><span class="line">//        myNumber1.printOriginalNumbers();</span><br><span class="line"></span><br><span class="line">        if (myNumber1.getNumber() == null) </span><br><span class="line">            System.out.println(&quot;First number is invalid&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;First number is &quot; + myNumber1.getNumber());</span><br><span class="line">        if (myNumber2.getNumber() == null)</span><br><span class="line">            System.out.println(&quot;Second number is invalid&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;Second number is &quot; + myNumber2.getNumber());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        validatePhoneNumber(&quot;123-456-7890&quot;, &quot;456-7890&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The example validates a phone number by first removing all characters from the phone number except the digits 0 through 9. After, it checks whether the phone number contains exactly ten digits (the length of a phone number in North America). This example prints the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First number is 1234567890</span><br><span class="line">Second number is invalid</span><br></pre></td></tr></table></figure><h5 id="Accessing-Members-of-an-Enclosing-Class"><a href="#Accessing-Members-of-an-Enclosing-Class" class="headerlink" title="Accessing Members of an Enclosing Class"></a><a href="">Accessing Members of an Enclosing Class</a></h5><p>A local class has access to the members of its enclosing class. In the previous example, the <code>PhoneNumber</code> constructor accesses the member <code>LocalClassExample.regularExpression</code>.</p><p>In addition, a local class has access to local variables. However, a local class can only access local variables that are declared final. When a local class accesses a local variable or parameter of the enclosing block, it <em>captures</em> that variable or parameter. For example, the <code>PhoneNumber</code> constructor can access the local variable <code>numberLength</code> because it is declared final; <code>numberLength</code> is a <em>captured variable</em>.</p><p>However, starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or <em>effectively final</em>. A variable or parameter whose value is never changed after it is initialized is effectively final. For example, suppose that the variable <code>numberLength</code> is not declared final, and you add the highlighted assignment statement in the <code>PhoneNumber</code> constructor to change the length of a valid phone number to 7 digits:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumber(String phoneNumber) &#123;</span><br><span class="line">    numberLength = 7;</span><br><span class="line">    String currentNumber = phoneNumber.replaceAll(</span><br><span class="line">        regularExpression, &quot;&quot;);</span><br><span class="line">    if (currentNumber.length() == numberLength)</span><br><span class="line">        formattedPhoneNumber = currentNumber;</span><br><span class="line">    else</span><br><span class="line">        formattedPhoneNumber = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because of this assignment statement, the variable <code>numberLength</code> is not effectively final anymore. As a result, the Java compiler generates an error message similar to “local variables referenced from an inner class must be final or effectively final” where the inner class <code>PhoneNumber</code> tries to access the <code>numberLength</code> variable:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (currentNumber.length() == numberLength)</span><br></pre></td></tr></table></figure><p>Starting in Java SE 8, if you declare the local class in a method, it can access the method’s parameters. For example, you can define the following method in the <code>PhoneNumber</code> local class:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void printOriginalNumbers() &#123;</span><br><span class="line">    System.out.println(&quot;Original numbers are &quot; + phoneNumber1 +</span><br><span class="line">        &quot; and &quot; + phoneNumber2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The method <code>printOriginalNumbers</code> accesses the parameters <code>phoneNumber1</code> and <code>phoneNumber2</code> of the method <code>validatePhoneNumber</code>.</p><h6 id="Shadowing-and-Local-Classes"><a href="#Shadowing-and-Local-Classes" class="headerlink" title="Shadowing and Local Classes"></a><a href="">Shadowing and Local Classes</a></h6><p>Declarations of a type (such as a variable) in a local class shadow declarations in the enclosing scope that have the same name. See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing" target="_blank" rel="noopener">Shadowing</a> for more information.</p><h5 id="Local-Classes-Are-Similar-To-Inner-Classes"><a href="#Local-Classes-Are-Similar-To-Inner-Classes" class="headerlink" title="Local Classes Are Similar To Inner Classes"></a><a href="">Local Classes Are Similar To Inner Classes</a></h5><p>Local classes are similar to inner classes because they cannot define or declare any static members. Local classes in static methods, such as the class <code>PhoneNumber</code>, which is defined in the static method <code>validatePhoneNumber</code>, can only refer to static members of the enclosing class. For example, if you do not define the member variable <code>regularExpression</code> as static, then the Java compiler generates an error similar to “non-static variable <code>regularExpression</code> cannot be referenced from a static context.”</p><p>Local classes are non-static because they have access to instance members of the enclosing block. Consequently, they cannot contain most kinds of static declarations.</p><p>You cannot declare an interface inside a block; interfaces are inherently static. For example, the following code excerpt does not compile because the interface <code>HelloThere</code> is defined inside the body of the method <code>greetInEnglish</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void greetInEnglish() &#123;</span><br><span class="line">    interface HelloThere &#123;</span><br><span class="line">       public void greet();</span><br><span class="line">    &#125;</span><br><span class="line">    class EnglishHelloThere implements HelloThere &#123;</span><br><span class="line">        public void greet() &#123;</span><br><span class="line">            System.out.println(&quot;Hello &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HelloThere myGreeting = new EnglishHelloThere();</span><br><span class="line">    myGreeting.greet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You cannot declare static initializers or member interfaces in a local class. The following code excerpt does not compile because the method <code>EnglishGoodbye.sayGoodbye</code> is declared <code>static</code>. The compiler generates an error similar to “modifier ‘static’ is only allowed in constant variable declaration” when it encounters this method definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void sayGoodbyeInEnglish() &#123;</span><br><span class="line">    class EnglishGoodbye &#123;</span><br><span class="line">        public static void sayGoodbye() &#123;</span><br><span class="line">            System.out.println(&quot;Bye bye&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EnglishGoodbye.sayGoodbye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A local class can have static members provided that they are constant variables. (A <em>constant variable</em> is a variable of primitive type or type <code>String</code> that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html" target="_blank" rel="noopener">Understanding Class Members</a> for more information.) The following code excerpt compiles because the static member <code>EnglishGoodbye.farewell</code> is a constant variable:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void sayGoodbyeInEnglish() &#123;</span><br><span class="line">    class EnglishGoodbye &#123;</span><br><span class="line">        public static final String farewell = &quot;Bye bye&quot;;</span><br><span class="line">        public void sayGoodbye() &#123;</span><br><span class="line">            System.out.println(farewell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();</span><br><span class="line">    myEnglishGoodbye.sayGoodbye();</span><br><span class="line">&#125;待补充。。。</span><br></pre></td></tr></table></figure><h4 id="匿名类（Anonymous-Classes）"><a href="#匿名类（Anonymous-Classes）" class="headerlink" title="匿名类（Anonymous Classes）"></a>匿名类（Anonymous Classes）</h4><p>Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.</p><p>This section covers the following topics:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#declaring-anonymous-classes" target="_blank" rel="noopener">Declaring Anonymous Classes</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#syntax-of-anonymous-classes" target="_blank" rel="noopener">Syntax of Anonymous Classes</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#accessing" target="_blank" rel="noopener">Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#examples-of-anonymous-classes" target="_blank" rel="noopener">Examples of Anonymous Classes</a></li></ul><h5 id="Declaring-Anonymous-Classes"><a href="#Declaring-Anonymous-Classes" class="headerlink" title="Declaring Anonymous Classes"></a><a href="">Declaring Anonymous Classes</a></h5><p>While local classes are class declarations, anonymous classes are expressions, which means that you define the class in another expression. The following example, <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/HelloWorldAnonymousClasses.java" target="_blank" rel="noopener"><code>HelloWorldAnonymousClasses</code></a>, uses anonymous classes in the initialization statements of the local variables <code>frenchGreeting</code> and <code>spanishGreeting</code>, but uses a local class for the initialization of the variable <code>englishGreeting`</code>:`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldAnonymousClasses &#123;</span><br><span class="line">  </span><br><span class="line">    interface HelloWorld &#123;</span><br><span class="line">        public void greet();</span><br><span class="line">        public void greetSomeone(String someone);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        </span><br><span class="line">        class EnglishGreeting implements HelloWorld &#123;</span><br><span class="line">            String name = &quot;world&quot;;</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                greetSomeone(&quot;world&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            public void greetSomeone(String someone) &#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(&quot;Hello &quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        HelloWorld englishGreeting = new EnglishGreeting();</span><br><span class="line">        </span><br><span class="line">        HelloWorld frenchGreeting = new HelloWorld() &#123;</span><br><span class="line">            String name = &quot;tout le monde&quot;;</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                greetSomeone(&quot;tout le monde&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            public void greetSomeone(String someone) &#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(&quot;Salut &quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        HelloWorld spanishGreeting = new HelloWorld() &#123;</span><br><span class="line">            String name = &quot;mundo&quot;;</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                greetSomeone(&quot;mundo&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            public void greetSomeone(String someone) &#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(&quot;Hola, &quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        englishGreeting.greet();</span><br><span class="line">        frenchGreeting.greetSomeone(&quot;Fred&quot;);</span><br><span class="line">        spanishGreeting.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        HelloWorldAnonymousClasses myApp =</span><br><span class="line">            new HelloWorldAnonymousClasses();</span><br><span class="line">        myApp.sayHello();</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Syntax-of-Anonymous-Classes"><a href="#Syntax-of-Anonymous-Classes" class="headerlink" title="Syntax of Anonymous Classes"></a><a href="">Syntax of Anonymous Classes</a></h5><p>As mentioned previously, an anonymous class is an expression. The syntax of an anonymous class expression is like the invocation of a constructor, except that there is a class definition contained in a block of code.</p><p>Consider the instantiation of the <code>frenchGreeting</code> object:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld frenchGreeting = new HelloWorld() &#123;</span><br><span class="line">    String name = &quot;tout le monde&quot;;</span><br><span class="line">    public void greet() &#123;</span><br><span class="line">        greetSomeone(&quot;tout le monde&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void greetSomeone(String someone) &#123;</span><br><span class="line">        name = someone;</span><br><span class="line">        System.out.println(&quot;Salut &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The anonymous class expression consists of the following:</p><ul><li>The <code>new</code> operator</li><li>The name of an interface to implement or a class to extend. In this example, the anonymous class is implementing the interface <code>HelloWorld</code>.</li><li>Parentheses that contain the arguments to a constructor, just like a normal class instance creation expression. <strong>Note</strong>: When you implement an interface, there is no constructor, so you use an empty pair of parentheses, as in this example.</li><li>A body, which is a class declaration body. More specifically, in the body, method declarations are allowed but statements are not.</li></ul><p>Because an anonymous class definition is an expression, it must be part of a statement. In this example, the anonymous class expression is part of the statement that instantiates the <code>frenchGreeting</code> object. (This explains why there is a semicolon after the closing brace.)</p><h5 id="Accessing-Local-Variables-of-the-Enclosing-Scope-and-Declaring-and-Accessing-Members-of-the-Anonymous-Class"><a href="#Accessing-Local-Variables-of-the-Enclosing-Scope-and-Declaring-and-Accessing-Members-of-the-Anonymous-Class" class="headerlink" title="Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class"></a><a href="">Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class</a></h5><p>Like local classes, anonymous classes can <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#accessing-members-of-an-enclosing-class" target="_blank" rel="noopener">capture variables</a>; they have the same access to local variables of the enclosing scope:</p><ul><li>An anonymous class has access to the members of its enclosing class.</li><li>An anonymous class cannot access local variables in its enclosing scope that are not declared as <code>final</code> or effectively final.</li><li>Like a nested class, a declaration of a type (such as a variable) in an anonymous class shadows any other declarations in the enclosing scope that have the same name. See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing" target="_blank" rel="noopener">Shadowing</a> for more information.</li></ul><p>Anonymous classes also have the same restrictions as local classes with respect to their members:</p><ul><li>You cannot declare static initializers or member interfaces in an anonymous class.</li><li>An anonymous class can have static members provided that they are constant variables.</li></ul><p>Note that you can declare the following in anonymous classes:</p><ul><li>Fields</li><li>Extra methods (even if they do not implement any methods of the supertype)</li><li>Instance initializers</li><li>Local classes</li></ul><p>However, you cannot declare constructors in an anonymous class.</p><h5 id="Examples-of-Anonymous-Classes"><a href="#Examples-of-Anonymous-Classes" class="headerlink" title="Examples of Anonymous Classes"></a><a href="">Examples of Anonymous Classes</a></h5><p>Anonymous classes are often used in graphical user interface (GUI) applications.</p><p>Consider the JavaFX example <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm" target="_blank" rel="noopener"><code>HelloWorld.java</code></a> (from the section <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm" target="_blank" rel="noopener">Hello World, JavaFX Style</a> from <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/javafx_get_started.htm" target="_blank" rel="noopener">Getting Started with JavaFX</a>). This sample creates a frame that contains a <strong>Say ‘Hello World’</strong> button. The anonymous class expression is highlighted:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import javafx.event.ActionEvent;</span><br><span class="line">import javafx.event.EventHandler;</span><br><span class="line">import javafx.scene.Scene;</span><br><span class="line">import javafx.scene.control.Button;</span><br><span class="line">import javafx.scene.layout.StackPane;</span><br><span class="line">import javafx.stage.Stage;</span><br><span class="line"> </span><br><span class="line">public class HelloWorld extends Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        launch(args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void start(Stage primaryStage) &#123;</span><br><span class="line">        primaryStage.setTitle(&quot;Hello World!&quot;);</span><br><span class="line">        Button btn = new Button();</span><br><span class="line">        btn.setText(&quot;Say &apos;Hello World&apos;&quot;);</span><br><span class="line">        btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">            @Override</span><br><span class="line">            public void handle(ActionEvent event) &#123;</span><br><span class="line">                System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        StackPane root = new StackPane();</span><br><span class="line">        root.getChildren().add(btn);</span><br><span class="line">        primaryStage.setScene(new Scene(root, 300, 250));</span><br><span class="line">        primaryStage.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, the method invocation <code>btn.setOnAction</code> specifies what happens when you select the <strong>Say ‘Hello World’</strong> button. This method requires an object of type <code>EventHandler&lt;ActionEvent&gt;</code>. The <code>EventHandler&lt;ActionEvent&gt;</code> interface contains only one method, handle. Instead of implementing this method with a new class, the example uses an anonymous class expression. Notice that this expression is the argument passed to the <code>btn.setOnAction</code> method.</p><p>Because the <code>EventHandler&lt;ActionEvent&gt;</code> interface contains only one method, you can use a lambda expression instead of an anonymous class expression. See the section <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda Expressions</a> for more information.</p><p>Anonymous classes are ideal for implementing an interface that contains two or more methods. The following JavaFX example is from the section <a href="https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/custom.htm" target="_blank" rel="noopener">Customization of UI Controls</a>. The highlighted code creates a text field that only accepts numeric values. It redefines the default implementation of the <code>TextField</code> class with an anonymous class by overriding the <code>replaceText</code> and <code>replaceSelection</code> methods inherited from the <code>TextInputControl</code> class.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import javafx.application.Application;</span><br><span class="line">import javafx.event.ActionEvent;</span><br><span class="line">import javafx.event.EventHandler;</span><br><span class="line">import javafx.geometry.Insets;</span><br><span class="line">import javafx.scene.Group;</span><br><span class="line">import javafx.scene.Scene;</span><br><span class="line">import javafx.scene.control.*;</span><br><span class="line">import javafx.scene.layout.GridPane;</span><br><span class="line">import javafx.scene.layout.HBox;</span><br><span class="line">import javafx.stage.Stage;</span><br><span class="line"></span><br><span class="line">public class CustomTextFieldSample extends Application &#123;</span><br><span class="line">    </span><br><span class="line">    final static Label label = new Label();</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void start(Stage stage) &#123;</span><br><span class="line">        Group root = new Group();</span><br><span class="line">        Scene scene = new Scene(root, 300, 150);</span><br><span class="line">        stage.setScene(scene);</span><br><span class="line">        stage.setTitle(&quot;Text Field Sample&quot;);</span><br><span class="line"> </span><br><span class="line">        GridPane grid = new GridPane();</span><br><span class="line">        grid.setPadding(new Insets(10, 10, 10, 10));</span><br><span class="line">        grid.setVgap(5);</span><br><span class="line">        grid.setHgap(5);</span><br><span class="line"> </span><br><span class="line">        scene.setRoot(grid);</span><br><span class="line">        final Label dollar = new Label(&quot;$&quot;);</span><br><span class="line">        GridPane.setConstraints(dollar, 0, 0);</span><br><span class="line">        grid.getChildren().add(dollar);</span><br><span class="line">        </span><br><span class="line">        final TextField sum = new TextField() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void replaceText(int start, int end, String text) &#123;</span><br><span class="line">                if (!text.matches(&quot;[a-z, A-Z]&quot;)) &#123;</span><br><span class="line">                    super.replaceText(start, end, text);                     </span><br><span class="line">                &#125;</span><br><span class="line">                label.setText(&quot;Enter a numeric value&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            @Override</span><br><span class="line">            public void replaceSelection(String text) &#123;</span><br><span class="line">                if (!text.matches(&quot;[a-z, A-Z]&quot;)) &#123;</span><br><span class="line">                    super.replaceSelection(text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        sum.setPromptText(&quot;Enter the total&quot;);</span><br><span class="line">        sum.setPrefColumnCount(10);</span><br><span class="line">        GridPane.setConstraints(sum, 1, 0);</span><br><span class="line">        grid.getChildren().add(sum);</span><br><span class="line">        </span><br><span class="line">        Button submit = new Button(&quot;Submit&quot;);</span><br><span class="line">        GridPane.setConstraints(submit, 2, 0);</span><br><span class="line">        grid.getChildren().add(submit);</span><br><span class="line">        </span><br><span class="line">        submit.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handle(ActionEvent e) &#123;</span><br><span class="line">                label.setText(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        GridPane.setConstraints(label, 0, 1);</span><br><span class="line">        GridPane.setColumnSpan(label, 3);</span><br><span class="line">        grid.getChildren().add(label);</span><br><span class="line">        </span><br><span class="line">        scene.setRoot(grid);</span><br><span class="line">        stage.show();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        launch(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遮盖（Shadowing）、变量作用域问题"><a href="#遮盖（Shadowing）、变量作用域问题" class="headerlink" title="遮盖（Shadowing）、变量作用域问题"></a>遮盖（Shadowing）、变量作用域问题</h3><p>如果在特定范围内（比如在内部类或者方法中）有一个声明（成员变量声明或者方法参数名字）与该范围外的另一个声明拥有相同的名字，那么该范围内的声明就会遮盖掉范围外的声明。你就不能仅简单地通过名字来引用被遮盖的那个声明，请看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FirstLevel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">methodInFirstLevel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"x = "</span> + x);</span><br><span class="line">            System.out.println(<span class="string">"this.x = "</span> + <span class="keyword">this</span>.x);</span><br><span class="line">            System.out.println(<span class="string">"ShadowTest.this.x = "</span> + ShadowTest.<span class="keyword">this</span>.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        ShadowTest st = <span class="keyword">new</span> ShadowTest();</span><br><span class="line">        ShadowTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">23</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">ShadowTest.<span class="keyword">this</span>.x = <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>该例子中定义了3个名为x的变量：类ShadowTest的成员变量、内部类FirstLevel的成员变量、methodInFirstLevel方法的形参。methodInFirstLevel方法的形参遮盖住了内部类FirstLevel的成员变量，因此，当你在方法中使用x时，x表示的是方法的参数x。想要获得内部类FirstLevel的成员变量x，要通过关键字<strong>this</strong> 来代表外部的作用域（enclosing scope），也就是FirstLevel类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"this.x = "</span> + <span class="keyword">this</span>.x);</span><br></pre></td></tr></table></figure><p>要获取到更大作用域的成员变量时，需要通过其所属的类的类名来访问，比如以下的语句，在methodInFirstLevel方法中获取最外层的ShadowTest 类的成员变量x</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"ShadowTest.this.x = "</span> + ShadowTest.<span class="keyword">this</span>.x);</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html</a></p></the>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>英语语法——中级：第3章.完成时态</title>
      <link href="/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC3%E7%AB%A0-%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/"/>
      <url>/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC3%E7%AB%A0-%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>第3章.完成时态总结<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="/2018/02/11/英语语法——中级：第3章-完成时态/3.完成时态.png" alt="完成时态"></the></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时态 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>英语语法——中级：第2章.名词、定语、状语从句</title>
      <link href="/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC2%E7%AB%A0-%E5%90%8D%E8%AF%8D%E3%80%81%E5%AE%9A%E8%AF%AD%E3%80%81%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
      <url>/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC2%E7%AB%A0-%E5%90%8D%E8%AF%8D%E3%80%81%E5%AE%9A%E8%AF%AD%E3%80%81%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>第2章.名词、定语、状语从句总结<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="/2018/02/11/英语语法——中级：第2章-名词、定语、状语从句/2.名词、定语、状语从句.png" alt="名词、定语、状语从句"></the></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>英语语法——中级：第1章.简单句与复合句</title>
      <link href="/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC1%E7%AB%A0-%E7%AE%80%E5%8D%95%E5%8F%A5%E4%B8%8E%E5%A4%8D%E5%90%88%E5%8F%A5/"/>
      <url>/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC1%E7%AB%A0-%E7%AE%80%E5%8D%95%E5%8F%A5%E4%B8%8E%E5%A4%8D%E5%90%88%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>第1章.简单句与复合句总结<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="/2018/02/11/英语语法——中级：第1章-简单句与复合句/1.简单句与复合句.png" alt="简单句与复合句"></the></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复合句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim</title>
      <link href="/2017/11/08/vim/"/>
      <url>/2017/11/08/vim/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>通过对linux中自带的vimtutor命令学习，以及《vim实用技巧》学习，然后对常用的vim命令进行总结，方便以后忘记了常看。<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim file +n ：打开文件并跳到第N行</span><br><span class="line"></span><br><span class="line">默认显示行号：编辑或新建~/.vimrc   添加一行 set nu 即可，或者在/etc/vimrc 内编辑</span><br></pre></td></tr></table></figure><h2 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h2><table><thead><tr><th>按键操作</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;Esc&gt;</code></td><td>切换到普通模式</td></tr><tr><td><code>&lt;Ctrl+[&gt;</code></td><td>切换到普通模式</td></tr><tr><td><code>&lt;Ctrl+o&gt;</code></td><td>切换到<strong>插入-普通</strong>模式，能让我们执行一次普通模式命令。 在此模式中， 可以执行一个普通模式命令， 执行完后， 马上又返回到插入模式</td></tr></tbody></table><p><strong>插入-普通</strong>模式是一个子模式， 可以让我们执行一个普通模式命令， 之后马上又回到插入模式。 </p><h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><p>命令的基本模式 <code>operation [number] range</code></p><h3 id="基础定位移动"><a href="#基础定位移动" class="headerlink" title="基础定位移动"></a>基础定位移动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">" 面向行的移动</span><br><span class="line">         k上</span><br><span class="line">    h左       l右</span><br><span class="line">         j下</span><br><span class="line">    </span><br><span class="line">4h 左4个字符     4k 上4行     4j 下4行     4l 右4个字符</span><br><span class="line">    </span><br><span class="line">2gg                             "定位到第2行代码，等同于2G</span><br><span class="line">2G                              "定位到第2行代码</span><br><span class="line">gg                              "定位到整个代码的第1行</span><br><span class="line">G                               "定位到整个代码的最后一行</span><br><span class="line"></span><br><span class="line">0或^                            "行首</span><br><span class="line"><span class="meta">$</span><span class="bash">                               <span class="string">"行尾</span></span></span><br><span class="line"></span><br><span class="line">" 面向单词的移动</span><br><span class="line">w                               "向后跳到下一个单词的开始处</span><br><span class="line">b                               "向前跳到上一个单词的开始处</span><br><span class="line">e                               "向后跳到下一个单词的结束处</span><br><span class="line">ge                              "向前跳到上一个单词的结束处</span><br><span class="line">2e,2w,2b表示移动2个单位</span><br><span class="line">" 面向字串的移动</span><br><span class="line">W、 B、 E 和gE                  </span><br><span class="line"></span><br><span class="line">" 面向字符的移动</span><br><span class="line">f                               "光标正向移动到行内的指定字符前</span><br><span class="line">F                               "光标反向移动到行内的指定字符前</span><br><span class="line">t                               "光标正向移动到行内的指定字符的前一个字符</span><br><span class="line">T                               "光标反向移动到行内的指定字符的前一个字符</span><br><span class="line">;                               "正向重复执行字符查找</span><br><span class="line">,                               "反向重复执行字符查找</span><br><span class="line">" 飞雷神</span><br><span class="line">mm                              "将位置标记在m</span><br><span class="line">`m                              "回到标记 m 的位置</span><br><span class="line">'m                              "回到标记 m 的所在行首</span><br><span class="line"></span><br><span class="line">H                               "当前屏幕可见的第一行</span><br><span class="line">M                               "当前屏幕可见的中间</span><br><span class="line">L                               "当前屏幕可见的最后一行</span><br><span class="line"></span><br><span class="line">Ctrl+o                          "快速跳回上一个位置</span><br></pre></td></tr></table></figure><h3 id="快速移动"><a href="#快速移动" class="headerlink" title="快速移动"></a>快速移动</h3><h4 id="行移动"><a href="#行移动" class="headerlink" title="行移动"></a>行移动</h4><p>区分<strong>实际行与屏幕行(超出屏幕显示区域的vim会帮你soft wrap)</strong> , j、 k、 0 和 $ 都用于操作实际行，而如果在这些键前加上 g 前缀的话， 就会让 Vim 对屏幕行进行操作 </p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">光标动作</th></tr></thead><tbody><tr><td style="text-align:left">j</td><td style="text-align:left">向下移动一个实际行</td></tr><tr><td style="text-align:left">gj</td><td style="text-align:left">向下移动一个屏幕行</td></tr><tr><td style="text-align:left">k</td><td style="text-align:left">向上移动一个实际行</td></tr><tr><td style="text-align:left">gk</td><td style="text-align:left">向上移动一个屏幕行</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">移动到实际行的行首</td></tr><tr><td style="text-align:left">g0</td><td style="text-align:left">移动到屏幕行的行首</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">移动到实际行的第一个非空白字符</td></tr><tr><td style="text-align:left">g^</td><td style="text-align:left">移动到屏幕行的第一个非空白字符</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">移动到实际行的行尾</td></tr><tr><td style="text-align:left">g$</td><td style="text-align:left">移动到屏幕行的行尾</td></tr></tbody></table><p>如果你想让 j 及 k 命令操作屏幕行而不是实际行， 可以重新映射它们。把下面加到你的 vimrc 文件中 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nnoremap k gk</span><br><span class="line">nnoremap gk k</span><br><span class="line">nnoremap j gj</span><br><span class="line">nnoremap gj j</span><br></pre></td></tr></table></figure><h4 id="基于单词的移动"><a href="#基于单词的移动" class="headerlink" title="基于单词的移动"></a>基于单词的移动</h4><p>先学会用 w 和 b命令 ，e 和 ge 命令是对此命令集的补充 </p><p><strong>单词与字串</strong></p><ul><li><p><strong>单词</strong>：字母、 数字、 下画线， 或其他非空白字符的序列组成，单词间以空白字符分隔（参见 :h word）</p></li><li><p><strong>字串</strong>：由非空白字符序列组成， 字串间以空白字符分隔（参见 :h WORD）</p></li></ul><p>普通用户可以这样简单地想： <strong>字串比单词更长</strong>！</p><p>我们之前面向单词的动作命令， 都有一个面向字串的命令与其对应， 这当中包括 W、 B、 E 和gE。</p><table><thead><tr><th>命令</th><th>光标动作</th></tr></thead><tbody><tr><td></td><td>对应<strong>单词</strong></td></tr><tr><td>w</td><td>正向移动到下一单词的开头</td></tr><tr><td>b</td><td>反向移动到当前单词/上一单词的开头</td></tr><tr><td></td><td><strong>假设想把单词“fast”改成“faster”</strong></td></tr><tr><td>e</td><td>正向移动到当前单词/下一单词的结尾</td></tr><tr><td>ge</td><td>反向移动到上一单词的结尾</td></tr><tr><td></td><td></td></tr><tr><td></td><td>对应<strong>字串</strong></td></tr><tr><td>W</td><td>正向移动到下一字串的开头</td></tr><tr><td>B</td><td>反向移动到当前单词/上一字串的开头</td></tr><tr><td>E</td><td>正向移动到当前单词/下一字串的结尾</td></tr><tr><td>gE</td><td>反向移动到上一字串的结尾</td></tr></tbody></table><p>感受一下单词与字串的差别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.g. we&apos;re going too slow # 可以试一下这个文本</span><br></pre></td></tr></table></figure><p>例如， 如果想把“we”“you”</p><table><thead><tr><th style="text-align:left">按键操作</th><th style="text-align:left">缓冲区内容</th></tr></thead><tbody><tr><td style="text-align:left">{start}</td><td style="text-align:left">e.g. we’re going too slow</td></tr><tr><td style="text-align:left">cwyou<esc></esc></td><td style="text-align:left">e.g. you’re going too slow</td></tr></tbody></table><p>在另外一些时候， 我们可能更想把“we’re”“it’s”</p><table><thead><tr><th style="text-align:left">按键操作</th><th style="text-align:left">缓冲区内容</th></tr></thead><tbody><tr><td style="text-align:left">{start}</td><td style="text-align:left">e.g. we’re going too slow</td></tr><tr><td style="text-align:left">cWit’s<esc></esc></td><td style="text-align:left">e.g. it’s going too slow</td></tr></tbody></table><h4 id="基于字符的移动"><a href="#基于字符的移动" class="headerlink" title="基于字符的移动"></a>基于字符的移动</h4><p><code>f{char}</code> 在光标位置与当前行行尾之间查找指定的字符， 如果找到了， 就会把光标移到此字符上； 如果未找到， 则保持光标不动</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">f{char}</td><td style="text-align:left">正向移动到下一个 {char} 所在之处</td></tr><tr><td style="text-align:left">F{char}</td><td style="text-align:left">反向移动到上一个 {char} 所在之处</td></tr><tr><td style="text-align:left">t{char}</td><td style="text-align:left">正向移动到下一个 {char} 所在之处的前一个字符上</td></tr><tr><td style="text-align:left">T{char}</td><td style="text-align:left">反向移动到上一个 {char} 所在之处的后一个字符上</td></tr><tr><td style="text-align:left">;</td><td style="text-align:left">重复上次的字符查找命令</td></tr><tr><td style="text-align:left">,</td><td style="text-align:left">反转方向查找上次的字符查找命令</td></tr></tbody></table><p><strong>有意思的例子</strong></p><table><thead><tr><th style="text-align:left">按键操作</th><th style="text-align:left">缓冲区内容</th></tr></thead><tbody><tr><td style="text-align:left">{start}</td><td style="text-align:left">I’ve been expecting you, Mister Bond.</td></tr><tr><td style="text-align:left">f,</td><td style="text-align:left">I’ve been expecting you, Mister Bond.</td></tr><tr><td style="text-align:left">dt.</td><td style="text-align:left">I’ve been expecting you.</td></tr></tbody></table><p><code>dt.</code>表示删除从 当前光标所在字符，到<code>t.</code>所找到的点号（<code>.</code>）前的字符</p><p><strong>技巧</strong></p><p>在使用字符查找命令时， 最好是选择出现<strong>频率比较低的字母</strong>作目标字符。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Improve your writing by deleting excellent adjectives.</span><br></pre></td></tr></table></figure><p>让光标移到单词“excellent”上，更好的选择是用 <code>fx</code>， 这条命令一下就能让我们移动到此单词上， 接下来就可以用 daw 命令删除该单词了 </p><h4 id="飞雷神"><a href="#飞雷神" class="headerlink" title="飞雷神"></a>飞雷神</h4><p>在Vim的前身vi里，并没有诸如现在的可视模式这样的功能。那时，位置标记是一个比现在重要得多的功能。但现在，很多在vi里需要用位置标记完成的工作，都可以在Vim里用可视模式来做，因此对位置标记的需求也就相应减少了。但是位置标记在Vim里并没有过时，它们仍然有用处。</p><p><strong>第一步：标记</strong></p><p><code>m{a-zA-Z}</code> 命令会用选定的字母标记当前光标所在位置 </p><ul><li>小写位置标记只在每个缓冲区局部可见</li><li>大写位置标记则全局可见</li></ul><p><strong>第二步：跳转</strong></p><p><code>&#39;{mark}</code> 命令跳到位置标记所在行， 并把光标置于该行第一个非空白字符上；</p><p>`{mark} 命令则把光标移动到设置此位置标记时光标所在之处；（推荐）</p><p><strong>Vim自动设置的标记</strong></p><p>Vim 会自动设置一些位置标记， 这些标记用起来非常方便。  Vim 会自动设置一些位置标记， 这些标记用起来非常方便。 </p><table><thead><tr><th>位置标记</th><th>跳转到</th></tr></thead><tbody><tr><td>``</td><td>当前文件中上次跳转动作之前的位置</td></tr><tr><td>`.</td><td>上次修改的地方</td></tr><tr><td>`^</td><td>上次插入的地方</td></tr><tr><td>`[</td><td>上次修改或复制的起始位置</td></tr><tr><td>`]</td><td>上次修改或复制的结束位置</td></tr><tr><td>`&lt;</td><td>上次高亮选区的起始位置</td></tr><tr><td>`&gt;</td><td>上次高亮选区的结束位置</td></tr></tbody></table><h4 id="括号间跳转"><a href="#括号间跳转" class="headerlink" title="括号间跳转"></a>括号间跳转</h4><p><code>%</code> 命令允许在一组开、 闭括号间跳转（参见 :h % ） ， 它可作用于 <code>()</code>、 <code>{}</code>以及<code>[]</code> </p><p>例子：修改括号的陷阱</p><p>假设想把 <code>%w{London Berlin New\ York}</code> 改成普通的列表定义<code>[&quot;London&quot;, &quot;Berlin&quot;, &quot;New York&quot;]</code></p><h4 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tpl = [</span><br><span class="line">    <span class="string">'&lt;a href="&#123;url&#125;"&gt;&#123;title&#125;&lt;/a&gt;'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在上面的代码中， 每个开括号字符<code>{</code>都对应一个闭括号字符<code>}</code>、<code>[</code>和<code>]</code>、<code>&lt;</code>和<code>&gt;</code>、以及HTML标签也是一样。这些<strong>配对符号具有规整的格式</strong>，而Vim能够理解其结构，并允许对它们分隔的区域进行操作。<strong>文本对象</strong>就是基于结构定义的文本区域（参见:htext-objects）</p><p>文本对象自身并不是动作命令， 不能用它们在文档中移动。 但是却可以在<strong>可视模式</strong>及<strong>操作符待决模式</strong>中使用文本对象</p><blockquote><p>  记住： 每当在命令语法里看到 {motion} 时， 也可以在这个地方使用文本对象， 常见的例子包括 <code>d{motion}</code>、 <code>c{motion}</code>和<code>y{motion}</code></p></blockquote><p>Vim 的文本对象分为两类：</p><ol><li><p>一类是操作分隔符的文本对象， 如i)、 i” 和it，称为 <strong>分隔符文本对象</strong> </p></li><li><p>另一类用于操作文本块， 如单词、 句子和段落，称为 <strong>范围文本对象</strong> </p><blockquote><p>  Vim 的文档把它们称为“块对象”（block object） 和“非块对象”(non-block object)</p></blockquote></li></ol><h5 id="分隔符文本对象"><a href="#分隔符文本对象" class="headerlink" title="分隔符文本对象"></a>分隔符文本对象</h5><p>用于快速选择引号括号内容</p><p>以 <code>i</code> 开头的文本对象会选择分隔符内部的文本，而以<code>a</code>开头的文本对象会选择包括分隔符在内的整个文本，i——&gt;“inside”，a——&gt;“around”或“all”。</p><table><thead><tr><th style="text-align:left">文本对 象</th><th style="text-align:left">选择区域</th><th style="text-align:left">文本对象</th><th style="text-align:left">选择区域</th></tr></thead><tbody><tr><td style="text-align:left">a) 或 ab</td><td style="text-align:left">一对圆括号 (parentheses)</td><td style="text-align:left">i) 或 ib</td><td style="text-align:left">圆括号 (parentheses) 内部</td></tr><tr><td style="text-align:left">a} 或 aB</td><td style="text-align:left">一对花括号 {braces}</td><td style="text-align:left">i} 或 iB</td><td style="text-align:left">花括号 {braces} 内部</td></tr><tr><td style="text-align:left">a]</td><td style="text-align:left">一对方括号 [brackets]</td><td style="text-align:left">i]</td><td style="text-align:left">方括号 [brackets] 内部</td></tr><tr><td style="text-align:left">a&gt;</td><td style="text-align:left">一对尖括号 <code>&lt;angle brackets&gt;</code></td><td style="text-align:left">i&gt;</td><td style="text-align:left">尖括号 <code>&lt;angle brackets&gt;</code> 内部</td></tr><tr><td style="text-align:left">a’</td><td style="text-align:left">一对单引号 ‘single quotes’</td><td style="text-align:left">i’</td><td style="text-align:left">单引号 ‘single quotes’ 内部</td></tr><tr><td style="text-align:left">a”</td><td style="text-align:left">一对双引号 “double quotes”</td><td style="text-align:left">i”</td><td style="text-align:left">双引号 “double quotes” 内部</td></tr><tr><td style="text-align:left">a`</td><td style="text-align:left">一对反引号 backticks</td><td style="text-align:left">i`</td><td style="text-align:left">反引号 backticks 内部</td></tr><tr><td style="text-align:left">at</td><td style="text-align:left">一对 XML 标签 <code>&lt;xml&gt;tags&lt;/xml&gt;</code></td><td style="text-align:left">it</td><td style="text-align:left">X 部ML标签<code>&lt;xml&gt;tags&lt;/xml&gt;</code>内</td></tr></tbody></table><blockquote><p>  i( 和 i) 等同， a[ 和 a] 也相同 </p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(some text)</span><br><span class="line"></span><br><span class="line">di) 即可删除括号内容</span><br></pre></td></tr></table></figure><h5 id="范围文本对象"><a href="#范围文本对象" class="headerlink" title="范围文本对象"></a>范围文本对象</h5><table><thead><tr><th>文本对象</th><th>选择范围</th></tr></thead><tbody><tr><td>iw</td><td>当前单词</td></tr><tr><td>aw</td><td>当前单词及一个空格</td></tr><tr><td>iW</td><td>当前字串</td></tr><tr><td>aW</td><td>当前字串及一个空格</td></tr><tr><td>is</td><td>当前句子</td></tr><tr><td>as</td><td>当前句子及一个空格</td></tr><tr><td>ip</td><td>当前段落</td></tr><tr><td>ap</td><td>当前段落及一个空行</td></tr></tbody></table><p>一般来说， <code>d{motion}</code> 命令和 <code>aw</code>、 <code>as</code> 和 <code>ap</code> 配合起来使用比较好， 而 <code>c{motion}</code> 命令和 <code>iw</code> 及类似的文本对象一起用效果会更好 </p><p><strong>例子</strong></p><p>1、假设想删除下句中的单词“excellent” 此时可以用 <code>daw</code> 命令</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Improve your writing by deleting e<strong>x</strong>cellent adjectives.</td></tr><tr><td>daw</td><td>Improve your writing by deleting <strong>a</strong>djectives.</td></tr></tbody></table><p>这条命令会删除此单词，外加一个空格， 因此结果会很干净。 如果用的是 <code>diw</code>，删完后就会有两个连在一起的空格 </p><p>2、假设想把此单词改成另外一个单词， 这次可以用 <code>ciw</code> 命令 </p><table><thead><tr><th style="text-align:left">按键操作</th><th style="text-align:left">缓冲区内容</th></tr></thead><tbody><tr><td style="text-align:left">{start}</td><td style="text-align:left">Improve your writing by deleting excellent adjectives.</td></tr><tr><td style="text-align:left"><code>ciwmost&lt;Esc&gt;</code></td><td style="text-align:left">Improve your writing by deleting most adjectives.</td></tr></tbody></table><p>ciw 命令只删除该单词， 而不删除其前后的空白字符， 随后它会进入插入模式， 这刚好是我们想要的效果。 如果用的是<code>caw</code> ， 最后两个单词就会连在一起， 变成“mostadjectives”。 </p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">i                               "光标处插入</span><br><span class="line">a                               "光标后一个字符处插入</span><br><span class="line">A                               "光标所在行末尾插入</span><br><span class="line">o                               "光标下方新建一行</span><br><span class="line">O                               "光标上方新建一行</span><br><span class="line"></span><br><span class="line">p                               "粘贴在光标后</span><br><span class="line">P                               "粘贴在光标前</span><br><span class="line">y                               "复制选择的文本</span><br><span class="line">yw或ye                          "复制一个单词</span><br><span class="line">yy                              "复制 光标所在的这一行</span><br><span class="line">4yy                             "复制 光标所在行开始向下的4行</span><br><span class="line"></span><br><span class="line">dd                              "剪切 光标所在的这一行</span><br><span class="line">2dd                             "剪切 光标所在行 向下 2行</span><br><span class="line">d0                              "从当前的光标开始剪切，一直到行首</span><br><span class="line">D                               "从当前的光标开始剪切，一直到行末</span><br><span class="line"></span><br><span class="line">daw                             "删除光标所在的单词</span><br><span class="line">dw                              "删除光标后的一个单词</span><br><span class="line">d2w                             "删除光标后2个单词</span><br><span class="line">x                               "删除当前的光标所在的字符，每次只会删除一个</span><br><span class="line">X                               "删除当前光标前面的那个，每次只会删除一个</span><br><span class="line"></span><br><span class="line">r                               "替换光标后的一个字符</span><br><span class="line">R                               "连续替换光标后的字符</span><br><span class="line"></span><br><span class="line">ce或cw                          "修改该单词到单词结尾</span><br><span class="line">C或c$                           "修改光标后该行的全部内容</span><br><span class="line"></span><br><span class="line">J                               "连接两行</span><br><span class="line"></span><br><span class="line">.                               "重复执行上一次的命令</span><br><span class="line"></span><br><span class="line">u                               "撤销最后的操作</span><br><span class="line">U                               "撤销对整行的修改</span><br><span class="line">ctrl+r                          "反撤销</span><br><span class="line"></span><br><span class="line">ctrl+a 或 ctrl+x                "对光标下的数字进行加减，10ctrl+a可以每次加10，再配合点号.可以重复累加 *</span><br></pre></td></tr></table></figure><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p><strong>撤销块的概念</strong></p><p><code>i{insert some text}&lt;Esc&gt;</code> 是一次修改。 </p><p>如果在<strong>插入模式</strong>中使用了 <code>&lt;Up&gt;、 &lt;Down&gt;、 &lt;Left&gt;或 &lt;Right&gt;</code>这些光标键， 将会产生一个新的撤销块。  </p><h3 id="操作符-动作命令-操作"><a href="#操作符-动作命令-操作" class="headerlink" title="操作符 + 动作命令 = 操作"></a>操作符 + 动作命令 = 操作</h3><p><code>d{motion}</code> ，d是操作符， motion是动作</p><p>操作符与动作命令的结合形成了一种语法。 这种语法的第一条规则很简单， 即一个操作由一个操作符， 后面跟一个动作命令组成。 学习新的动作命令及操作符， 就像是在学习Vim的词汇一样。 如果掌握了这一简单的语法规则， 在词汇量增长时， 就能表达更多的想法。 </p><p>Vim的语法只有一条额外规则， 即当一个操作符命令被连续调用两次时， 它会作用于当前行。 所以 dd 删除当前行， 而 &gt;&gt; 缩进当前行。 gU 命令是一种特殊情况， 我们既可以用 gUgU ， 也可以用简化版的gUU 来使它作用于当前行。 </p><p> Vim操作符</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>c</td><td>修改</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>y</td><td>复制到寄存器</td></tr><tr><td>g~</td><td>反转大小写</td></tr><tr><td>gu</td><td>转换为小写</td></tr><tr><td>gU</td><td>转换为大写</td></tr><tr><td>&gt;</td><td>增加缩进</td></tr><tr><td>&lt;</td><td>减小缩进</td></tr><tr><td>=</td><td>自动缩进</td></tr><tr><td>!</td><td>使用外部程序过滤{motion}所跨越的行</td></tr></tbody></table><p>一键代替两键</p><table><thead><tr><th>快捷按键</th><th>等效按键</th><th>效果</th></tr></thead><tbody><tr><td>S</td><td>^C</td><td>清空当前行</td></tr><tr><td>C</td><td>c$</td><td>删除当前行光标后的内容</td></tr><tr><td>s</td><td>cl</td><td>TODO</td></tr><tr><td>I</td><td>^i</td><td>在行首插入</td></tr><tr><td>A</td><td>$a</td><td>在行尾插入</td></tr><tr><td>o</td><td>A\&lt;Enter></td><td>在下方新建一行空白行</td></tr><tr><td>O</td><td>ko&lt;&gt;</td><td>在上方新建一行空白行</td></tr></tbody></table><h4 id="删除与查找结合起来"><a href="#删除与查找结合起来" class="headerlink" title="删除与查找结合起来"></a>删除与查找结合起来</h4><p>学会把<code>d{motion}</code> 操作符与查找动作结合在一起使用， 这是个很大的进步， 你<br>可以好好在朋友和同事们面前炫耀一番了。 </p><p>例子：</p><p>删除take与到get之间的内容</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>This phrase <strong>t</strong>akes time but <br>eventually gets to the point.</td></tr><tr><td>d/ge\<cr></cr></td><td>This phrase <strong>g</strong>ets to the point.</td></tr></tbody></table><p>虽然光标是在单词“gets”开头的“g”上的， 但此字符却被排除在删除操作之外（参见 :h exclusive ）。jizx的理解是<code>/ge</code>查找时，光标是在ge之前的，因此删除时不包括<code>ge</code>。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><code>yyp</code> 会使用寄存器，<code>:t.</code> 则不会</p><p>在复制距离较远的行时，<code>:t</code> 命令通常更加高效</p><h4 id="删除一个单词"><a href="#删除一个单词" class="headerlink" title="删除一个单词"></a>删除一个单词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The end is nigh</span><br></pre></td></tr></table></figure><p>假设光标在<strong>h</strong>上，要删除nigh，可行的方法有<code>db x</code>，<code>b dw</code>，以及<code>daw</code></p><p>推荐<code>daw</code>,可以把 daw 命令解读为“delete a word”,因为<code>.</code>会把这一个命令完整记住，而其他的命令会被视为2部分</p><h4 id="行尾添加字符串"><a href="#行尾添加字符串" class="headerlink" title="行尾添加字符串"></a>行尾添加字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-v&gt;G$   &quot; 全选</span><br><span class="line">A;        &quot; 进入插入模式，添加;</span><br><span class="line">&lt;Esc&gt;     &quot; 完成插入</span><br></pre></td></tr></table></figure><p>或者使用替换命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/$/;/g</span><br></pre></td></tr></table></figure><h4 id="对数字进行加减"><a href="#对数字进行加减" class="headerlink" title="对数字进行加减"></a>对数字进行加减</h4><p><code>ctrl+a</code> <code>ctrl+x</code> 分别会对光标下的数字进行加减，默认一次加1，<code>10ctrl+a</code>可以每次加10，再配合<code>.</code>可以重复累加</p><p>使用<code>ctrl+a</code>的话，对007会进行八进制的加法：007 + 001 = 010， 如果你想要10进制的，<code>set nrformats=</code>这会让Vim把所有数字都当成十进制， 不管它们是不是以0开<br>头的。 </p><h3 id="重复与回退"><a href="#重复与回退" class="headerlink" title="重复与回退"></a>重复与回退</h3><table><thead><tr><th>目的</th><th>操作</th><th>重复</th><th>回退</th></tr></thead><tbody><tr><td>做出一个修改</td><td>{edit}</td><td>.</td><td>u</td></tr><tr><td>在行内查找下一指定字符</td><td>f{char}/t{char}</td><td>;</td><td>,</td></tr><tr><td>在行内查找上一指定字符</td><td>F{char}/T{char}</td><td>;</td><td>,</td></tr><tr><td>在文档中查找下一处匹配项</td><td>/pattern</td><td>n</td><td>N</td></tr><tr><td>在文档中查找上一处匹配项</td><td>?pattern</td><td>n</td><td>N</td></tr><tr><td>执行替换</td><td>:s/target/replacement</td><td>&amp;</td><td>u</td></tr><tr><td>执行一系列修改</td><td>qx{changes}q</td><td>@x</td><td>u</td></tr><tr><td>重复上次的 Ex 命令非常简单</td><td>:move5</td><td>@:</td><td>u</td></tr></tbody></table><p><strong><code>.</code> 范式</strong></p><p>用一次按键移动，另一次按键执行，再没有比这更好的了，不是吗？这就是我们的理想解决方案。我们将会一次又一次地看到这一编辑模式，所以为了方便起见，把它叫做“.范式”。</p><p><strong>重复与计数</strong></p><p>只在必要时使用次数 </p><p>计算次数很是讨厌， 因此我宁愿按6次 <code>.</code> 命令， 也不愿意只为减少按键的次数， 而浪费同样的时间去统计次数。 如果我多按了一次 . 命令怎么办？ 没关系， 只要按一次 u 键就可以回退回来。 </p><h3 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f                          "向下翻一页代码</span><br><span class="line">ctrl+b                          "向上翻一页代码</span><br><span class="line"></span><br><span class="line">ctrl+d                          "向下翻半页代码</span><br><span class="line">ctrl+u                          "向上翻半页代码</span><br><span class="line"></span><br><span class="line">" 可视化模式，可以配合d,x,y等进行修改，也可以进来末行模式:w filename 进行另存</span><br><span class="line">v                               "字符可视化模式（Characterwise visual mode），文本选择是以字符为单位的，</span><br><span class="line">V                               "行可视化模式（Linewise visual mode)，文本选择是以行为单位的。</span><br><span class="line">ctrl-V                          "块可视化模式（Blockwise visual mode），可以选择一个矩形内的文本。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;                              <span class="string">"向右移动代码</span></span></span><br><span class="line">&lt;&lt;                              "向左移动代码</span><br><span class="line"></span><br><span class="line">shift+zz                        "相当于wq</span><br></pre></td></tr></table></figure><h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">*                               "高亮光标下的全部单词，使用 n 跳到下一处</span><br><span class="line"></span><br><span class="line">/xxx                            "向下查找xxx</span><br><span class="line">/xxx\c                          "忽略大小写</span><br><span class="line">/xxx\C                          "区分大小写</span><br><span class="line">?xxx                            "向上查找xxx</span><br><span class="line">?xxx\c                          "忽略大小写</span><br><span class="line">?xxx\C                          "区分大小写</span><br><span class="line">输入n则继续查找下一个匹配</span><br><span class="line">ctrl+o                          "光标跳转到查询到的上一个位置</span><br><span class="line">ctrl+i                          "光标跳转到查询到的下一个位置</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">                               <span class="string">"快速查找光标所在处的括号所匹配的另一个括号 (),[],&#123;&#125;</span></span></span><br><span class="line"></span><br><span class="line">:s/old/new                      "替换该行第一个匹配串</span><br><span class="line">:s/old/new/g                    "替换该行全部匹配串</span><br><span class="line">:#,#s/old/new/g                 "替换#到"行之间的词</span><br><span class="line">:%s/old/new/gc                  "替换全文匹配串，并逐个询问是否替换</span><br></pre></td></tr></table></figure><p>命令<code>*</code>等效于输入 <code>/\&lt;&lt;C-r&gt;&lt;C-w&gt;\&gt;&lt;CR&gt;</code> 序列， 请参见命令行模式下的“快速复制单词”一节，关于 <code>\&lt;</code> 和<code>\&gt;</code>在模式中的作用， 请参见技巧77的讨论）。</p><p><strong>在命令行模式中的<code>%</code>表示所有行</strong></p><p>例子：<strong>在行尾添加分号</strong></p><p><code>$</code>表示行尾，替换为<code>;</code>  。不能写成<code>%s/$/;$/g</code> ，暂时不知道为什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/$/;/g</span><br></pre></td></tr></table></figure><h3 id="查看字符编码"><a href="#查看字符编码" class="headerlink" title="查看字符编码"></a>查看字符编码</h3><p>如果你想知道文档中任意字符的编码， 只需把光标移到它上面并按<code>ga</code> 命令， 然后屏幕下方会显示出一条消息， 分别以十进制和十六进制的形式显示出其字符编码（参见 :h ga ）  </p><h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><h3 id="不离开插入模式粘贴"><a href="#不离开插入模式粘贴" class="headerlink" title="不离开插入模式粘贴"></a>不离开插入模式粘贴</h3><p>在<strong>普通模式</strong>，使用复制命令<code>yt</code> 把“some text”复制到复制专用寄存器中</p><p>然后在<strong>插入模式</strong>中， 按 <code>&lt;C-r&gt;0</code>把刚才复制的文本粘贴到光标所在位置 </p><p><code>&lt;C-r&gt;&lt;C-p&gt;{register}</code>命令则会更智能一些，它会按原义插入寄存器内的文本，并修正任何不必要的缩进，不过这个命令有点不太好输入！因此，如果我想从 一个寄存器里粘贴很多行文本的话，我更喜欢切换到普通模式，然后使用某个粘贴命令。</p><h3 id="编辑-1"><a href="#编辑-1" class="headerlink" title="编辑"></a>编辑</h3><table><thead><tr><th>按键操作</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;C-h&gt;</code></td><td>删除前一个字符（同退格键）</td></tr><tr><td><code>&lt;C-w&gt;</code></td><td>删除前一个单词</td></tr><tr><td><code>&lt;C-u&gt;</code></td><td>删至行首</td></tr></tbody></table><h3 id="插入特殊字符"><a href="#插入特殊字符" class="headerlink" title="插入特殊字符"></a>插入特殊字符</h3><p>在插入模式下，<code>ctrl+v</code>进入特殊字符输入状态</p><p>假设想插入大写字母“A”， 它的字符编码是65， 因此需要输入 <code>&lt;C-v&gt;065</code></p><p>假设想插入字符编码为00bf的反转问号（“¿”） ， 只需在插入模式中输入 <code>&lt;C-v&gt;u00bf</code> </p><p>如果<code>&lt;C-v&gt;</code> 命令后面跟一个非数字键， 它会插入这个按键本身代表的字符。 例如， 如果启用了 ‘expandtab’ 选项， 那么按\<tab> 键将会插入空格而不是制表符。 然而， 按 \<c-v>\<tab> 则会一直插入制表符， 不管 ‘expandtab’ 选项激活与否。 </tab></c-v></tab></p><p><strong>二合字母输入特殊字符</strong></p><p>在插入模式中， 只需输入 <c-k>&gt;{char1}{char2} 即可。 因此， 如果想输入以二合字母 ?I 表示的“¿”字符， 可以简单地输入 <c-k>?I </c-k></c-k></p><p>用命令<code>:digraphs</code> 可以查看可用的二合字母列表， 不过该命令的输出不太好阅读。 也可以用 <code>:h digraph-table</code> 查看另一个更为有用的列表。 </p><p><strong>总结</strong></p><p>插入非常用字符</p><table><thead><tr><th>按键操作</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;C-v&gt;065</code></td><td>以十进制字符编码插入字符A</td></tr><tr><td><code>&lt;C-v&gt;u1F3B</code></td><td>以十六进制字符编码插入字符</td></tr><tr><td><code>&lt;C-v&gt;nondigit</code></td><td>按原义插入非数字字符</td></tr><tr><td><code>&lt;C-k&gt;{char1}{char2}</code></td><td>插入以二合字母{char1}{char2}表示的字符</td></tr></tbody></table><h2 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h2><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>v</td><td>激活面向字符的可视模式</td></tr><tr><td>V</td><td>激活面向行的可视模式</td></tr><tr><td><code>&lt;C-v&gt;</code></td><td>激活面向列块的可视模式</td></tr><tr><td>gv</td><td>重选上次的高亮选区</td></tr></tbody></table><p>可视模式间切换的命令。</p><table><thead><tr><th>按键操作</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;Esc&gt;</code>/ <code>&lt;C-[&gt;</code></td><td>回到普通模式</td></tr><tr><td>v / V / <code>\&lt;C-v&gt;</code></td><td>切换到普通模式（在对应的面向字符可视模式、 面向行的可视模式和面 向列块的可视模式中使用时）</td></tr><tr><td>V</td><td>切换到面向字符的可视模式</td></tr><tr><td>V</td><td>切换到面向行的可视模式</td></tr><tr><td><code>&lt;C-v&gt;</code></td><td>切换到面向列块的可视模式</td></tr><tr><td>O/o</td><td>切换高亮选区的活动端</td></tr></tbody></table><p><strong>经验</strong></p><p>如果想使点命令能够重复某些有用的工作， 那么最好要远离可视模式。 作为一般的原则， 在做一系列可重复的修改时， <strong>最好首选操作符命令， 而不是其对应的可视模式命令</strong>。 </p><p>对一次性的修改任务来说， 可视模式完全够用， 并且尽管Vim的动作命令允许进行精确的移动， 但有时要修改的文本范围的结构很难用动作命令表达出来， 而处理这种情形恰恰是可视模式擅长的。 </p><h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:w                              "保存</span><br><span class="line">:w filename                     "保存为指定的文件</span><br><span class="line">:q                              "退出</span><br><span class="line">:wq                             "保存并且推出</span><br><span class="line">:x                              "等同于wq</span><br><span class="line">:r filename                     "读取外部文件粘贴到光标处</span><br><span class="line">:r !ls                          "获取命令输出内容粘贴到光标处</span><br></pre></td></tr></table></figure><h3 id="命令行补全"><a href="#命令行补全" class="headerlink" title="命令行补全"></a>命令行补全</h3><p><code>:set col</code></p><p><code>&lt;C-d&gt;</code>命令会让Vim 显示可用的补全列表（参见 :h c_CTRL-D），如果多次按 <code>&lt;Tab&gt;</code> 键， 命令行上会依次显示colder、 colorscheme， 然后再回到最初的 col， 如此循环往复。 </p><p>调整<code>wildmode</code>选项可以自定义补全行为（参见 <code>:h wildmode</code>） 。</p><p><strong>bash shell的方式工作</strong>(列出所有候选项)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set wildmenu</span><br><span class="line">set wildmode=longest,list</span><br></pre></td></tr></table></figure><p><strong>zsh 提供的自动补全</strong>菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set wildmenu</span><br><span class="line">set wildmode=full</span><br></pre></td></tr></table></figure><p>当 <code>wildmenu</code>’选项被启用时， Vim 会提供一个补全导航列表。 可以按 <tab> 、 <c-n> 或 <right> 正向遍历其列表项， 用 <stab>、 <c-p> 或 <left> 对其进行反向遍历。 </left></c-p></stab></right></c-n></tab></p><h3 id="执行-shell-命令"><a href="#执行-shell-命令" class="headerlink" title="执行 shell 命令"></a>执行 shell 命令</h3><p><code>:!{cmd}</code> 适用于执行一次性命令，比如<code>:!ls</code></p><p><code>:shell</code> 可以启动一个交互的shell会话执行多条命令，用<code>exit</code>命令可以退出此shell并返回Vim</p><blockquote><p>  注意区分 <code>:!ls</code> 和 <code>:ls</code> 的不同之处。前者调用的是 shell 中的 ls 命 令，而 :ls 调用的是 Vim的内置命令，用来显示缓冲区列表的内容。</p></blockquote><p>在 Vim 的命令行中， 符号 <code>%</code> 代表当前文件名，如果当前正在编辑 Python 文件，可以用<code>:!python %</code>执行此文件。</p><p><strong>推荐Ctrl-z 和 fg</strong></p><p>假设正在 bash shell 中运行 Vim， 然后需要执行一些 shell 命令。 可以先按 <strong>Ctrl-z</strong> 挂起Vim 所属的进程， 并把控制权交还给bash。 此时 Vim 进程在后台处于挂起状态， 让我们可以像往常一样与 bash 会话进行交互。 运行下面这条命令可以查看当前的作业 列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➾ $ jobs</span><br><span class="line">《[1]+ Stopped vim</span><br></pre></td></tr></table></figure><p>在 bash 中， 可以用 fg 命令唤醒一个被挂起的作业， 把它移到前台。 这会让 Vim 恢复成挂起前的状态。 <strong>Ctrl-z 和 fg 命令比Vim 提供的 :shell 和 exit 命令更加方便快捷。</strong> </p><p><strong>把缓冲区内容作为标准输入或输出</strong></p><p> <code>:read !{cmd}</code> 把<code>{cmd}</code>命令的<strong>标准输出</strong>读入当前缓冲区中</p><p><code>:write !{cmd}</code> 把缓冲区内容作为指定命令的<strong>标准输入</strong> </p><p><strong>注意感叹号</strong></p><p>根据叹号在命令行上的位置不同， 它的含义也不大相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➾ :write !sh</span><br><span class="line">➾ :write ! sh</span><br><span class="line"></span><br><span class="line">➾ :write! sh</span><br></pre></td></tr></table></figure><p>前两个命令都会把缓冲区的内容传给外部的 sh 命令作为标准输入， 而最后一条命令调用 <code>:write!</code> 命令把缓冲区内容写到一个名为<code>sh</code>的文件， 这里的叹号<strong>表示强制</strong></p><p><code>:write !sh</code> 命令的作用是在shell中执行当前缓冲区中的每行内容， 查阅<code>:h rename-files</code>可看到该命令的一个绝佳示例。 </p><p>当前目录中有以下文件：，想要将<code>*.c</code> 改为 <code>*.bla</code><br>buffer.c<br>charset.c<br>digraph.c<br>…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim</span><br><span class="line">:r !ls *.c</span><br><span class="line">:%s/\(.*\).c/mv &amp; \1.bla</span><br><span class="line">:w !sh</span><br><span class="line">:q!</span><br></pre></td></tr></table></figure><h3 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h3><p>与bash一样，上下键<code>↑↓</code>可以浏览历史；</p><p>如果输入部分命令，<code>↑↓</code>就会过滤包含部分命令的记录</p><p>Vim 不仅会记录 Ex 命令的历史， 还会为查找命令单独保存一份历史记录。 在按 <code>/</code> 调出查找提示符后， 用 <code>↑↓</code>可以正向或反向遍历之前的查找记录。 </p><h3 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h3><p>命令行窗口相当于另一个vim窗口，使用 Vim 完整的、 区分模式的编辑能力来修改历史命令。默认处于普通模式。基本上所有vim操作(<code>i, x等</code>)都可以使用</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">动作</th></tr></thead><tbody><tr><td style="text-align:left">q/</td><td style="text-align:left">打开 正向查找命令 历史的命令行窗口</td></tr><tr><td style="text-align:left">q?</td><td style="text-align:left">打开 反向查找命令 历史的命令行窗口</td></tr><tr><td style="text-align:left">q:</td><td style="text-align:left">打开 Ex 命令历史的命令行窗口</td></tr><tr><td style="text-align:left"><code>&lt;Ctrl-f&gt;</code></td><td style="text-align:left">当处于 命令行模式 下时意识到需要 更强大的编辑能力，可以用 <c-f> 映射项切换到命令行窗口中，此前已经输入命令行上的内容仍然 会得以保留</c-f></td></tr><tr><td style="text-align:left">:q</td><td style="text-align:left">退出命令行窗口</td></tr><tr><td style="text-align:left"><code>&lt;CR&gt;</code></td><td style="text-align:left">执行光标所在行的命令</td></tr></tbody></table><h3 id="快速复制光标下的单词"><a href="#快速复制光标下的单词" class="headerlink" title="快速复制光标下的单词"></a>快速复制光标下的单词</h3><p>在输入命令行的时候，vim始终记住光标的位置，使用快捷键<code>ctrl+r ctrl+w</code>可以快速输入光标下的单词，<code>ctrl+r ctrl+a</code>可以快速输入光标下的字符串（字符串范围是离光标最近的前后两个空格之间的字符串）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/tally/&lt;C-r&gt;&lt;C-w&gt;/g    # 将tally替换为光标下的单词</span><br></pre></td></tr></table></figure><h2 id="打字机模式"><a href="#打字机模式" class="headerlink" title="打字机模式"></a>打字机模式</h2><p>用<code>zz</code> 命令可以重绘屏幕， 并把当前行显示在窗口正中， 这样就能够阅读当前行之上及之下的半屏内容。 我常常会键入<code>&lt;C-o&gt;zz</code>， 在插入-普通模式中触发这条命令。 此操作完成后就会直接回到插入模式， 因此可以不受中断地继续打字。 </p><h2 id="复制粘贴与寄存器"><a href="#复制粘贴与寄存器" class="headerlink" title="复制粘贴与寄存器"></a>复制粘贴与寄存器</h2><h3 id="复制粘贴删除快捷键"><a href="#复制粘贴删除快捷键" class="headerlink" title="复制粘贴删除快捷键"></a>复制粘贴删除快捷键</h3><p>普通模式：<code>y(yank)、p(put) 、d(delete)</code></p><p>Ex命令命令行模式： <code>:delete c</code>， 把当前行剪切到寄存器 c， 然后再执行 <code>:put c</code>命令将其粘贴至当前光标所在行之下 </p><blockquote><p>  怎样才能知道 p 命令是把寄存器的文本粘贴到当前字符之后还是当前行之后呢？ 这取决于这个指定的寄存器是怎样被赋值的。 面向行的复制或者删除操作（如 dd、 yy 或者 dap） ， 将创建面向行的寄存器； 面向字符的复制或者删除操作（如x、 diw或者 das） 则创建面向字符的寄存器。 </p></blockquote><h4 id="p的粘贴位置问题处理"><a href="#p的粘贴位置问题处理" class="headerlink" title="p的粘贴位置问题处理"></a>p的粘贴位置问题处理</h4><p>我不喜欢被迫去判断面向字符的文本区域到底是放在光标之前还是之后。 因此， 较之使用普通模式的 <code>p</code> 和 <code>P</code> 命令， 我有时更喜欢在插入模式中使用 <code>&lt;C-r&gt;{register}</code> 的映射项来粘贴面向字符的文本区域。 通过这种方式， 寄存器的文本总会被插入光标之前， 就像我们在插入模式下手动输入它们一样。 </p><p>因此推荐在插入模式下：</p><ul><li>通过输入 <code>&lt;C-r&gt;&quot;</code> 来插入<strong>无名寄存器</strong>的内容</li><li>通过输入 <code>&lt;C-r&gt;0</code> 来插入<strong>复制专用寄存器</strong>的内容 </li></ul><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>Vim的删除、 复制与粘贴命令都会用到众多寄存器中的某一个。</p><p>在<strong>普通模式</strong>，可以通过给命令加 <code>&quot;{register}</code>前缀的方式指定要用的寄存器。 若不指明， Vim将缺省使用<strong>无名寄存器</strong>，它用双引号表示，例如， <code>&quot;&quot;p</code>， 它完全等同于 <code>p</code> 命令。 </p><p>在<strong>插入模式</strong>，可以输入<code>ctrl+r {register}</code>获取寄存器内容</p><p>查看寄存器内容<code>:reg &quot;0</code></p><h4 id="黑洞寄存器-quot"><a href="#黑洞寄存器-quot" class="headerlink" title="黑洞寄存器&quot;-"></a>黑洞寄存器<code>&quot;-</code></h4><p>删除文本而不把其内容复制到任何寄存器，用下画线符号（参见 :h quote_ ） 可以引用<strong>黑洞寄存器</strong>。 因此， <code>&quot;_d{motion}</code>会执行真正的删除操作。 </p><h4 id="复制专用寄存器-quot-0"><a href="#复制专用寄存器-quot-0" class="headerlink" title="复制专用寄存器&quot;0"></a>复制专用寄存器<code>&quot;0</code></h4><p>使用 <code>y{motion}</code> 命令时， 要复制的文本不仅会被拷贝到无名寄存器中， 而且也被拷贝到了复制专用寄存器 <code>&quot;0</code>。</p><p>复制专用寄存器 ，仅当使用 <code>y{motion}</code>命令时才会被赋值。 换句话讲， 使用 <code>x</code>、 <code>s</code>、 <code>c{motion}</code> 以及 <code>d{motion}</code> 命令均不会覆盖该寄存器。</p><h4 id="有名寄存器-quot-a-–-quot-z"><a href="#有名寄存器-quot-a-–-quot-z" class="headerlink" title="有名寄存器&quot;a – &quot;z"></a>有名寄存器<code>&quot;a – &quot;z</code></h4><p>Vim提供了一组以26个英文字母（参见 :h quote_alpha ） 命名的有名寄存器。 因此可以剪切（ “ad{motion}） 、 复制（”ay{motion}） 和粘贴（”ap） 多达26段文本。 </p><p>用<strong>小写字母</strong>引用有名寄存器， 会<strong>覆盖</strong>该寄存器的原有内容；</p><p>用<strong>大写字母</strong>的话， 会将新内容<strong>添加</strong>到该寄存器的原有内容之后。 </p><h4 id="表达式寄存器-quot"><a href="#表达式寄存器-quot" class="headerlink" title="表达式寄存器&quot;="></a>表达式寄存器<code>&quot;=</code></h4><p>表达式寄存器可以用来执行一段Vim脚本 </p><p>在<strong>普通模式</strong>中，执行<code>&quot;=</code>， Vim将跳到命令行模式， 并显示提示符“=”。 这时， 可以输入一段Vim脚本表达式并按 <code>&lt;CR&gt;</code> 执行， 如果返回的是字符串（或者可被强制转换成字符串的数据），Vim将会使用它。</p><p>在<strong>插入模式</strong>中， 输入 <code>&lt;Cr&gt;=</code>，会在屏幕的下方显示提示符“=”， 可以在其后输入要执行的表达式， 输入表达式后敲一下 <code>&lt;CR&gt;</code>，Vim就会把执行的结果插入文档的当前位置了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-r&gt;=6*35&lt;CR&gt;    # 就会得到结果</span><br></pre></td></tr></table></figure><h4 id="只读寄存器"><a href="#只读寄存器" class="headerlink" title="只读寄存器"></a>只读寄存器</h4><table><thead><tr><th>寄存器</th><th>等价方法</th><th>内容</th></tr></thead><tbody><tr><td><code>&quot;%</code></td><td><code>&lt;C-r&gt;%</code></td><td>当前文件名</td></tr><tr><td><code>&quot;#</code></td><td><code>&lt;C-r&gt;#</code></td><td>轮换文件名</td></tr><tr><td><code>&quot;.</code></td><td><code>&lt;C-r&gt;.</code></td><td>上次插入的文本</td></tr><tr><td><code>&quot;:</code></td><td><code>&lt;C-r&gt;:</code></td><td>上次执行的Ex命令</td></tr><tr><td><code>&quot;/</code></td><td><code>&lt;C-r&gt;/</code></td><td>上次查找的模式</td></tr></tbody></table><h4 id="系统剪切板-quot-与选择专用寄存器-quot"><a href="#系统剪切板-quot-与选择专用寄存器-quot" class="headerlink" title="系统剪切板&quot;+与选择专用寄存器&quot;*"></a>系统剪切板<code>&quot;+</code>与选择专用寄存器<code>&quot;*</code></h4><p>Vim的加号寄存器<code>&quot;+</code>与系统剪贴板等效相通。</p><p>Linux的X11视窗系统支持另一种被叫作主剪贴板（primary）的剪贴板，它保存着上次被高亮选中的文本，可以用鼠标中键（如果有的话）把它们粘贴出来。Vim的星号寄存器对应主剪贴板，可用<code>*</code>号加以引用。</p><table><thead><tr><th>寄存器</th><th>用途</th></tr></thead><tbody><tr><td><code>&quot;+</code></td><td>X11剪贴板， 用剪切、 复制与粘贴命令操作</td></tr><tr><td><code>&quot;*</code></td><td>X11主剪贴板， 用鼠标中键操作</td></tr></tbody></table><p>Windows与Mac OS X操作系统并没有主剪贴板的概念， 因此 <code>&quot;+</code> 寄存器与 <code>&quot;*</code> 寄存器可以混用， 它们都代表系统剪贴板。 </p><blockquote><p>  X11剪贴板的功能可在编译Vim时被激活或禁用。 如果想验证该功能是否在自己的Vim中被激活， 可运行 :version命令， 然后找到<br>  xterm_clipboard关键字。 如果它前面有个减号， 就表示这个版本的Vim不支持该功能， 加号则表示此功能已被激活 </p></blockquote><h4 id="用寄存器内容替换高亮选区的文本"><a href="#用寄存器内容替换高亮选区的文本" class="headerlink" title="用寄存器内容替换高亮选区的文本"></a>用寄存器内容替换高亮选区的文本</h4><p>在可视模式下使用 <code>p</code> 命令时， Vim将用指定的寄存器内容来替换高亮选区中的文本，</p><p>它不再把无名寄存器既用于复制又用于删除， 因为根本就没有删除这一步。 相反的， 把删除和粘贴合成了一步， 完成高亮选区的替换。 </p><h3 id="粘贴缩进问题"><a href="#粘贴缩进问题" class="headerlink" title="粘贴缩进问题"></a>粘贴缩进问题</h3><p>当在插入模式下使用系统粘贴命令时， Vim就像我们用手敲键盘一样地输入字符。 一旦 <code>autoindent</code>选项被启用， 意味着每当创建新行时， Vim都会保持同级缩进。 <strong>剪贴板中每行起始的空格是在之前自动缩进的基础上累加出来的</strong>， 这样将导致一行比一行往右偏。</p><p><strong>打开粘贴</strong> </p><p><code>paste</code>选项允许手动通知Vim“要使用系统粘贴命令了”。<code>paste</code>选项启用后，Vim将禁用所有插入模式下的映射项与缩写，并重置很多选项，其中就包括<code>autoindent</code>。</p><p><strong>关闭粘贴</strong></p><p>使用完系统粘贴命令之后，还要再次关闭<code>paste</code>选项。这意味着先切换回普通模式，再运行Ex命令<code>:setpaste!</code>。这样比较麻烦，可以通过下面的方法简化步骤：</p><p><code>paste</code>选项启用后， 在Vim插入模式下创建自定义映射项的方法都失效了。 作为替代方案， 可以把 <code>pastetoggle</code>选项（参见 :h’pastetoggle’ ） 映射成一个功能键。 </p><p>推荐：<code>:set pastetoggle=&lt;f5&gt;</code></p><p><strong>终极方法</strong>（在xshell中没测试成功）</p><p>普通模式下的 “+p 命令用来粘贴加号寄存器中的内容， 即系统剪贴板的镜像。 更多细节， 请参见系统剪贴板（”+） 与选择专用寄存器（”*） 。 无论 <code>paste</code>与<code>autoindent</code>选项激活与否， <strong>该命令都能保证位于剪贴板中的文本缩进不会乱套</strong>。 </p><h4 id="粘贴的推荐结论"><a href="#粘贴的推荐结论" class="headerlink" title="粘贴的推荐结论"></a>粘贴的推荐结论</h4><p><code>p</code> 与 <code>P</code> 命令对于粘贴多行文本区域非常重要， 但是对于小段的、 面向字符的文本来讲， 使用 <code>&lt;C-r&gt;{register}</code> 映射项的方式会更直观。 </p><h2 id="查找与正则"><a href="#查找与正则" class="headerlink" title="查找与正则"></a>查找与正则</h2><h3 id="查找快捷键"><a href="#查找快捷键" class="headerlink" title="查找快捷键"></a>查找快捷键</h3><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>n</td><td>跳至下一处匹配， 保持查找方向与偏移不变</td></tr><tr><td>N</td><td>跳至上一处匹配， 保持查找方向与偏移不变</td></tr><tr><td>/<cr></cr></td><td>正向跳转至相同模式的下一处匹配</td></tr><tr><td>?<cr></cr></td><td>反向跳转至相同模式的上一处匹配</td></tr><tr><td>gn</td><td>进入面向字符的可视模式， 并选中下一处匹配</td></tr><tr><td>gN</td><td>进入面向字符的可视模式， 并选中上一处匹配</td></tr></tbody></table><h3 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h3><p><strong>循环查找</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set wrapscan </span><br><span class="line">:set ws</span><br><span class="line">&quot;如果只想在当前光标位置至文档结尾的范围内查找，而不想绕回文档继续查找的话</span><br></pre></td></tr></table></figure><p><strong>暂时关闭高亮</strong></p><p><code>:set nohlsearch</code> 命令<strong>彻底禁用</strong>查找高亮功能（使用 <code>:se nohls</code> 与 <code>:se hls!</code> 效果一样）。但在执行其他查找时，我们又可能想重新激活它。</p><p><code>:nohlsearch</code>命令<strong>暂时关闭</strong>查找高亮功能（参见 <code>:h :noh</code> ）。此命令使得高亮功能一直处于关闭状态，直到执行新的或重复的查找命令为止。</p><p>通过创建映射项，可以加速操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap&lt;silent&gt; &lt;C-l&gt; :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;`</span><br></pre></td></tr></table></figure><p><strong>边输入边查找</strong></p><p><code>:set incsearch</code> ：预览第一处匹配</p><p><strong>将光标匹配到结尾</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lang/e&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>查看多次后发现要移动到结尾处，可以不用重新输入模式，直接使用<code>//e&lt;CR&gt;</code></p><h3 id="历史记录-1"><a href="#历史记录-1" class="headerlink" title="历史记录"></a>历史记录</h3><p>Vim会一直记录我们执行过的查找模式，因此可以方便地重用它们。</p><p>在普通模式想再次执行上一次的查找时<strong>可以不输入模式</strong>，直接按 <code>n</code> ， <code>N</code>，<code>/</code>或者<code>?</code>，此时 Vim 将重用上一次的查找模式，然后正向或反向查找。</p><p>在命令行模式，当查找提示符<code>/</code>或<code>?</code>出现时，可以通过 <code>&lt;Up&gt;</code> 键，滚动浏览之前的查找记录。</p><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>快捷键<code>&lt;C-r&gt;&lt;C-w&gt;</code>会用当前预览的匹配结果对查找域进行自动补全。如果已在查找域中输入了“carr”，执行该命令会将“ot”添加到结尾，使其最终匹配完整的单词“carrot”。</p><blockquote><p>  注意，<code>&lt;C-r&gt;&lt;C-w&gt;</code> 自动补全功能在查找内容中存在元字符<code>\v</code>前缀时会有瑕疵，<code>&lt;C-r&gt;&lt;C-w&gt;</code>会把光标下的完整单词，而不是单词的余下部分，作为补全的内容（例如，执行补全后会变成<code>/\vcarrcarrot&lt;CR&gt;</code>）。</p></blockquote><h3 id="大小写相关"><a href="#大小写相关" class="headerlink" title="大小写相关"></a>大小写相关</h3><h4 id="临时区分大小写"><a href="#临时区分大小写" class="headerlink" title="临时区分大小写"></a>临时区分大小写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/str\C     区分大小写</span><br><span class="line">/str\c     不区分大小写</span><br></pre></td></tr></table></figure><p>小写字母\c会让查找模式忽略大小写，而大写字母<code>\C</code>会强制区分大小写。这两个元字符可以出现在模式的任意位置，不过在末尾可读写比较好。</p><h4 id="smartcase选项"><a href="#smartcase选项" class="headerlink" title="smartcase选项"></a>smartcase选项</h4><p><code>smartcase</code>选项被启用后，无论何时，只要在查找模式中输入了大写字母，<code>ignorecase</code>设置就不再生效了。 换句话说，如果模式全是由小写字母组成的，就会按照忽略大小写的方式查找，但只要输入一个大写字母，查找方式就会变成区分大小写的了。</p><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><h4 id="转义问题之-一：-very-magic"><a href="#转义问题之-一：-very-magic" class="headerlink" title="转义问题之 一： very magic"></a>转义问题之 一： very magic</h4><p><strong>案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body      &#123; color: #3c3c3c; &#125; </span><br><span class="line">a         &#123; color: #0000EE; &#125;</span><br><span class="line">strong    &#123; color: #0000EE; &#125;</span><br></pre></td></tr></table></figure><p>想要<strong>匹配颜色</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/#\([0-9a-fA-F]\&#123;6&#125;\|[0-9a-fA-F]\&#123;3&#125;\)</span><br></pre></td></tr></table></figure><p>此例用到了3类括号。</p><ul><li>方括号<code>[]</code>缺省具有特殊含义，因此不用转义。 </li><li>圆括号<code>()</code>会按原义匹配普通字符<code>(</code>及<code>)</code>，因此需要转义，使其具有特殊含义。圆括号无论<strong>开闭括号都必须转义</strong>。</li><li>花括号<code>{}</code>也一样需要转义，不过，<strong>只需为开括号转义</strong>，而与之对应的闭括号则不用，因为Vim会推测我们的意图。</li></ul><p><strong>解决方法</strong></p><p>可以利用 <code>\v</code>模式开关来<strong>统一所有特殊符号</strong>的规则。该元字符将会激活 <strong>very magic</strong>搜索模式，即假定除<code>_</code>、大小写字母以及数字0～9之外 的所有字符都具有特殊含义。因此上例进行修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)</span><br></pre></td></tr></table></figure><p>由于出现在起始位置的<code>\v</code>开关，位于它后面的所有字符都具有特 殊含义。这样一来，那些反斜杠字符就可以去掉了，可读性更强了。</p><p><strong>总结</strong></p><p>作为通用法则，如果想<strong>按正则表达式</strong>查找，就用模式开关 <code>\v</code>，</p><p>而如果想<strong>按原义查找</strong>文本， <code>\V</code> 会使得其后的模式中<strong>只有反斜杠有特殊的意义</strong>。</p><h4 id="转义问题之二：特殊字符的特殊处理"><a href="#转义问题之二：特殊字符的特殊处理" class="headerlink" title="转义问题之二：特殊字符的特殊处理"></a>转义问题之二：特殊字符的特殊处理</h4><p><code>\V</code>原义开关使得按原义查找文本变得更容易，因为符号 <code>.</code>、<code>+</code> 以及 <code>*</code> 的特殊含义被屏蔽掉了。但还有一些字符，其特殊含义无法被屏蔽。</p><p>要处理的字符串：<code>http://vimdoc.net/search?q=/\\</code></p><h5 id="正向查找时要转义-字符"><a href="#正向查找时要转义-字符" class="headerlink" title="正向查找时要转义 / 字符"></a>正向查找时要转义 <code>/</code> 字符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\Vhttp://vimdoc.net/search?q=/\\          # 错误写法</span><br></pre></td></tr></table></figure><p>实际上只会匹配 <code>/字符串/</code> ,也就是<code>/\Vhttp:/</code>，因此需要对<code>/</code>进行转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\    # 正确写法</span><br></pre></td></tr></table></figure><h5 id="反向查找时要转义-号"><a href="#反向查找时要转义-号" class="headerlink" title="反向查找时要转义?号"></a>反向查找时要转义<code>?</code>号</h5><p>与正向类似，匹配的内容是<code>?字符串?</code>，因此需要对<code>?</code>进行转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?http://vimdoc.net/search\?q=/\\\\</span><br></pre></td></tr></table></figure><h5 id="查找域结束符-与"><a href="#查找域结束符-与" class="headerlink" title="查找域结束符/与?"></a>查找域结束符<code>/</code>与<code>?</code></h5><p>你可能会觉得奇怪，为什么查找域会把某个字符视为结束符呢？它为什么不把所有位于查找提示符之后的内容都纳入查找匹配呢？答案是如果在查找域结束符之后附加某些标志位，可以调 整Vim查找命令的行为。例如，如果运行命令 <code>/vim/e&lt;CR&gt;</code>，光标将会移到每个匹配的结尾，而非起始。</p><h5 id="每次都要转义符号"><a href="#每次都要转义符号" class="headerlink" title="每次都要转义符号 \"></a>每次都要转义符号 \</h5><p>在查找域中，还有一个字符需要转义，即反斜杠。通常情况下，一 个 <code>\</code> 的出现预示着紧挨着它后面的字符将会得到某种特殊对待。如果变为 <code>\\</code>，前者会消除后者的特殊含义，让Vim查找一个反斜杠。</p><p>无论采用的是正向还是反向查找方式，反斜杠字符永远都需要转义。</p><h5 id="用编程的方式转义字符"><a href="#用编程的方式转义字符" class="headerlink" title="用编程的方式转义字符"></a>用编程的方式转义字符</h5><p>用手动方式转义字符既耗时费力，又容易出错。幸运的是，Vim脚本提供了一个库函数<code>escape({string}, {chars})</code></p><p><code>{chars}</code> 参数将指定哪些字符需要用反斜杠转义。</p><ul><li>如果要进行正向查找，可以调用 <code>escape(str, &#39;/\&#39;)</code>，它会为每个 <code>/</code> 与 <code>\</code> 加上反斜杠前缀。</li><li>如果进行的是反向查找，则要换用 <code>escape(str,&#39;?\&#39;)</code></li></ul><ol><li><p><code>&quot;uyi</code>将正则复制到寄存器 u 中</p></li><li><p>输入 / 或 者 ? 调出查找提示符</p></li><li><p>依次输入原义开关 <code>\V</code>与 <code>&lt;C-r&gt;=</code>，Vim就会从查找提示符的状态切换到表达寄存器提示符的状态了</p></li><li><p><code>=escape(@u, getcmdtype().&#39;\&#39;)</code></p><blockquote><p>  <code>getcmdtype()</code>返回命令类型，比如正向查找返回<code>/</code>，反向返回<code>?</code></p><p>  在Vim脚本中，<code>.</code>起到连接字符串的作用，因此正向查找时<code>getcmdtype().&#39;\&#39;</code>将产生<code>/\</code></p></blockquote></li></ol><h4 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; 与 &gt;   单词前后定界符</span><br></pre></td></tr></table></figure><p><code>/\v&lt;the&gt;</code>只匹配 the ，而不会匹配 these。这是零宽度元字符，它们本身不匹配任何字符，仅表示单词与围绕此单词的空白字符（或标点符号）之间的边界</p><h4 id="子匹配"><a href="#子匹配" class="headerlink" title="子匹配"></a>子匹配</h4><p><strong>案例</strong>：查找重复的单词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v&lt;(\w+)\_s+\1&gt;</span><br></pre></td></tr></table></figure><p>诀窍就在于 <code>()</code> 与 <code>\1</code>的组合使用。任何圆括号内部的匹配文本都会自动保存到一个临时的仓库。可以用 <code>\1</code>引用这段被捕获的文本。另外，不论模式中是否使用了圆括号，元字符<code>\0</code>永远会引用整个匹配。</p><p><code>\_s</code>会匹配空白符或换行符，<code>\_</code>表示包含换行符，<code>s</code>在正则中表示空白符，因此还以是<code>\_w</code>匹配字母或换行符。</p><p><strong>不捕获子匹配</strong></p><p>有时只想使用圆括号的分组功能，但并不关心捕获的子匹配。例如，可以使用以下模式来匹配作者名字的两种形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v(And|D)rew Neil</span><br></pre></td></tr></table></figure><p>这一次使用圆括号的目的在于匹配“Andrew”或者“Drew”，但并不想捕获位于圆括号内部的“And或D”。可以<strong>在圆括号前面 加上% ，指示Vim不要将括号内的内容赋给寄存器 <code>\1</code></strong>，就像这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v%(And|D)rew Neil</span><br></pre></td></tr></table></figure><blockquote><p>  如果你发现自己经常会用到多组圆括号，使用<code>%</code>的速度会比原来快了一些</p></blockquote><p><strong>案例</strong>：把所有的名和姓调换位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\v(%(And|D)rew) (Neil) </span><br><span class="line">:%s//\2, \1/g</span><br></pre></td></tr></table></figure><p>该查找模式会把“Andrew”或者“Drew”赋给寄存器 <code>\1</code>，而把“Neil”赋给寄存器 <code>\2</code>。如果没有对第二组圆括号使用 <code>%()</code> ，便会得到无用的文本片段，从而扰乱替换域。</p><h4 id="截取部分匹配"><a href="#截取部分匹配" class="headerlink" title="截取部分匹配"></a>截取部分匹配</h4><p>比如想查找带引号的字符串，比如：<code>&quot;Vim&quot;</code>，但是只想修改 Vim，因此可使用元字 符 <code>\zs</code> 与 <code>\ze</code>对匹配进行裁剪，使其成为这个完整模式的一个子集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v&quot;\zs[^&quot;]+\ze&quot;</span><br></pre></td></tr></table></figure><p><code>\zs</code> 与<code>\ze</code>之间的内容就是你感兴趣的内容，而外部的其他字符可以认为是额外的限制条件。</p><p>可以只有<code>\zs</code>，比如查找Practical Vim，但只想修改 Vim，可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Practical \zsVim</span><br></pre></td></tr></table></figure><h3 id="增强-功能"><a href="#增强-功能" class="headerlink" title="增强*功能"></a>增强<code>*</code>功能</h3><p>在普通模式下，<code>*</code> 命令可以查找光标下的单词。通过一小段 Vim脚本，可以重新定义可视模式下的 <code>*</code> 命令，使其可以查找当前选中高亮的文本，而不仅仅是光标下的单词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xnoremap * :&lt;C-u&gt;call &lt;SID&gt;VSetSearch(&apos;/&apos;)&lt;CR&gt;/&lt;C-R&gt;=@/&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">xnoremap # :&lt;C-u&gt;call &lt;SID&gt;VSetSearch(&apos;?&apos;)&lt;CR&gt;?&lt;C-R&gt;=@/&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">function! s:VSetSearch(cmdtype)</span><br><span class="line">    let temp = @s</span><br><span class="line">    norm! gv&quot;sy</span><br><span class="line">    let @/ = &apos;\V&apos; . substitute(escape(@s, a:cmdtype.&apos;\&apos;), &apos;\n&apos;, &apos;\\n&apos;, &apos;g&apos;)</span><br><span class="line">    let @s = temp</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><p>可以直接将这段代码粘贴至你的 vimrc 文件中，或者安装visual star search插件。</p><h3 id="工程目录查找：grep、vimgrep、ack"><a href="#工程目录查找：grep、vimgrep、ack" class="headerlink" title="工程目录查找：grep、vimgrep、ack"></a>工程目录查找：grep、vimgrep、ack</h3><h4 id="vim内部grep"><a href="#vim内部grep" class="headerlink" title="vim内部grep"></a>vim内部grep</h4><p>vim的 <code>:grep Waldo *</code>命令是对外部 grep 程序的包装，用法与 <code>grep</code> 一致，Vim将在后台为我们在shell中执行 <code>grep -n Waldo *</code></p><h5 id="定制-grep"><a href="#定制-grep" class="headerlink" title="定制 grep"></a>定制 grep</h5><p>配置<code>grepprg</code>与<code>grepformat</code>这两个选项，可以对 Vim 查找的行为进行定制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grepprg=&quot;grep -n $* /dev/null&quot; </span><br><span class="line">grepformat=&quot;%f:%l:%m,%f:%l%m,%f %l%m&quot;</span><br></pre></td></tr></table></figure><blockquote><p>  grepprg：<code>$*</code> 表示占位符，将会被<code>:grep</code>命令的参数代替</p><p>  grepformat：<code>%f</code>表示文件名，<code>%l</code>表示行号，<code>%m</code>则表示匹配行的文本，<code>%c</code>表示列号。字符串可以包含以<strong>逗号分隔</strong>的多组格式。</p></blockquote><h4 id="vimgrep"><a href="#vimgrep" class="headerlink" title="vimgrep"></a>vimgrep</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vim[grep][!] /&#123;pattern&#125;/[g][j] &#123;file&#125; …</span><br></pre></td></tr></table></figure><p><code>{file}</code>参数一定不能为空，它可以是文件名、通配符、反引号表达 式以及这些类型的组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➾ :vim /going/g *.txt</span><br></pre></td></tr></table></figure><p>除了可以使用和<code>*</code>通配符外，也可以使用<code>##</code>符号，它将被扩展成参数列表中的所有文件。</p><p>因此可以先把希望查找的文件加入参数列表，然后再在参数列表中的 所有文件上运行 <code>:vimgrep</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➾s :args *.txt</span><br><span class="line">➾ :vim /going/g ##</span><br></pre></td></tr></table></figure><blockquote><p>  优点：这种方式能够两件事分开：要在哪些文件中查找，以及要用什么模式查找。一旦文件被 加入参数列表，在这组文件上执行多少次<code>:vimgrep</code>命令都可以。</p></blockquote><p>使用<code>:vimgrep</code>的主要优点在于其使用的模式与Vim的查找命令一 致。如果是使用 <code>:grep</code> 在工程范围内查找相同模式，就不得不先把该模式转化成POSIX正则表达式</p><h4 id="ack：beyond-grep"><a href="#ack：beyond-grep" class="headerlink" title="ack：beyond grep"></a>ack：beyond grep</h4><p>首先，需要安装 ack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu</span><br><span class="line">➾ $ sudo apt-get install ack-grep </span><br><span class="line">➾ $ sudo ln -s /usr/bin/ack-grep /usr/local/bin/ack</span><br><span class="line">OS X</span><br><span class="line">➾ $ brew install ack</span><br></pre></td></tr></table></figure><p>定制 ‘grepprg’ 与 ‘grepformat’ 这两个选项， 实现让 <code>:grep</code> 调用 <code>ack</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➾ :set grepprg=ack\ --nogroup\ --column\ $*</span><br><span class="line">➾ :set grepformat=%f:%l:%c:%m</span><br></pre></td></tr></table></figure><p>这样在浏览查找结果时，就可以跳转到每一处匹配的精确位置，而不仅是准确的行</p><blockquote><p>  grep采用的 是POSIX风格的正则表达式，ack则采用的是Perl风格的正则表达 式。如果 :grep命令在后台调用ack，可能会引起误导，因此也可以使用<strong>Ack.vim</strong>插件。fugitive.vim插件也提供了一个名为 :Ggrep的自定义命令用于执行git-grep。</p></blockquote><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]s[ubstitute]/&#123;pattern&#125;/&#123;string&#125;/[flags]</span><br></pre></td></tr></table></figure><h3 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h3><ol><li><code>g</code> 使得subsititute命令可在全局范围内执行，即可以修改一行 内的所有匹配，而不仅仅是第一处匹配。</li><li><code>c</code> 让我们有机会可以确认或拒绝每一处修改。</li><li><code>n</code>会抑制正常的替换行为，即让 Vim 不执行替换操作，而只是报告本次 substitute 命令匹配的个数。</li><li>执行 substitute 命令时，如果在当前文件中没有匹配到该模式，Vim 会提示错误信息“E486: 找不到模式”。标志位<code>e</code>专门用于屏蔽这些错误提 示。</li><li><code>&amp;</code> 仅仅用于指示Vim重用上一次substitute命令所用过的标志 位。技巧93展示了其应用的场景。</li></ol><h3 id="替换域中的特殊字符"><a href="#替换域中的特殊字符" class="headerlink" title="替换域中的特殊字符"></a>替换域中的特殊字符</h3><p>一些字符在用作查找模式时具有特殊含义。替换域中也有一些特殊字符。过查询 :h sub-replacespecial ，可以找到完整的列表</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>\r</td><td>插入一个换行符</td></tr><tr><td>\t</td><td>插入一个制表符</td></tr><tr><td><code>\\</code></td><td>插入一个反斜杠</td></tr><tr><td>\1</td><td>插入第1个子匹配</td></tr><tr><td>\2</td><td>插入第2个子匹配（以此类推，最多到 \9）</td></tr><tr><td>\0</td><td>插入匹配模式的所有内容</td></tr><tr><td>&amp;</td><td>插入匹配模式的所有内容</td></tr><tr><td>~</td><td>使用上一次调用 :substitute时的 {string}</td></tr><tr><td>\={Vim script}</td><td>执行 {Vim Script} 表达式；并将返回的结果作为替换 {string}</td></tr></tbody></table><h3 id="全局替换"><a href="#全局替换" class="headerlink" title="全局替换"></a>全局替换</h3><p>将文件想象成二维平面，字符沿着x轴增加，文本行则随着y轴向下增长。在缺省情况下，substitute命令仅仅作用于当前行的第一处匹配。</p><p>为了使substitute命令作用于整个横轴，需要引入标志位<code>g</code>。<code>g</code>看似为全局之意（global），实则有<strong>误导之嫌</strong>。也许有人想借此标志位在整个文件范围内进行替换操作，但实际上，它仅表示“<strong>当前一整行范围</strong>”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/going/rolling/g</span><br></pre></td></tr></table></figure><p>怎样才能控制substitute命令在整个文件的纵轴上执行呢？</p><p>答案是设定一个范围。如果在substitute命令的开头加上前缀<code>%</code>，它就会在文件的每一行上执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/going/rolling/g</span><br></pre></td></tr></table></figure><h3 id="每次替换进行询问"><a href="#每次替换进行询问" class="headerlink" title="每次替换进行询问"></a>每次替换进行询问</h3><p>引入标志位<code>c</code>后，vim 会对每处匹配结果提示“替换为str?”</p><p>Vim会体贴 地提示所有的选项“y/n/a/q/l/E/Y”。下表展示了每种答案的含义。</p><table><thead><tr><th style="text-align:left">回答</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">y</td><td style="text-align:left">Yes 替换此处匹配</td></tr><tr><td style="text-align:left">n</td><td style="text-align:left">No 忽略此处匹配</td></tr><tr><td style="text-align:left">q</td><td style="text-align:left">Quit 退出替换过程</td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">last  替换此处匹配后退出</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">all   替换此处与之后所有的匹配</td></tr><tr><td style="text-align:left"><code>&lt;C-e&gt;</code></td><td style="text-align:left">向上滚动屏幕</td></tr><tr><td style="text-align:left"><code>&lt;C-y&gt;</code></td><td style="text-align:left">向下滚动屏幕</td></tr></tbody></table><h3 id="一分为二：先查找再替换"><a href="#一分为二：先查找再替换" class="headerlink" title="一分为二：先查找再替换"></a>一分为二：先查找再替换</h3><p>执行substitute命令通常包括两个步骤：</p><ol><li>撰写查找模式</li><li>设计合适的替换字符串</li></ol><p>利用查找的历史记录功能，可以将替换分为两步，先测试查找内容，然后进行替换。因此，一分为二的技术让我们消除了这两项任务的耦合性，这才是关键所在。</p><p>对于<code>:%s/\n/,</code>将“换行替换为逗号”这种简单的命令，就没必要将它一分为二了，否则非但得不到 什么好处，反而有可能增加工作量。</p><p>对于复杂的内容，推荐一分为二。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➾ /\v&apos;(([^&apos;]|&apos;\w)+)&apos;</span><br><span class="line"></span><br><span class="line">将查找域留空，Vim将重用上一次的查找命令</span><br><span class="line">➾ :%s//“\1”/g</span><br><span class="line"></span><br><span class="line">实际上，我们刚才所做的等同于如下命令。</span><br><span class="line">➾ :%s/\v&apos;(([^&apos;]|&apos;\w)+)&apos;/“\1”/g</span><br></pre></td></tr></table></figure><p>但是也有不好的影响，会在命令历史中<strong>留下一项不完整的记录</strong>，从而导致当再想重用之前的substitute命令时，会遇到困难。</p><p>如果你觉得将来会以完整形式来调用历史记录中的substitute命令， 就要养成在查找域中填充内容的习惯。只需在命令行中输入 <code>&lt;C-r&gt;/</code> ， 即可把上次的查找内容粘贴进来。因此，通过以下命令，就可以在命令历史中创建一项完整的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➾ /\v&apos;(([^&apos;]|&apos;\w)+)&apos;</span><br><span class="line">➾ :%s/&lt;C-r&gt;//“\1”/g</span><br></pre></td></tr></table></figure><h2 id="global命令"><a href="#global命令" class="headerlink" title="global命令"></a>global命令</h2><p><code>:global</code> 命令允许在某个指定模式的所有匹配行上运行Ex命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range] global[!] /&#123;pattern&#125;/ [range][Excmd]</span><br></pre></td></tr></table></figure><p><code>[Excmd]</code>可以是除 <code>:global</code>命令之外的任何Ex命令，如果不指定任何 <code>[Excmd]</code>，Vim将缺省使用 <code>:print</code>。</p><p><code>:global!</code> 或者 <code>:vglobal</code>（v表示invert）反转<code>:global</code>命令的行为。这两条命令将指示Vim在没有匹配到指定模式 的行上执行 <code>[Excmd]</code>。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="复制TODO-内容"><a href="#复制TODO-内容" class="headerlink" title="复制TODO 内容"></a>复制TODO 内容</h4><p>假设想把所有TODO项收集到一起。</p><ol><li><p>首先运行 <code>qaq</code>，将寄存器 a清空。</p></li><li><p><code>:g/TODO/yank A</code>把包含TODO注释的行复制到此寄存器中</p><blockquote><p>  要用大写字母A引用寄存器。这意味着Vim将 把内容附加到指定的寄存器，用小写字母 a的话，则会覆盖原有寄存器 的内容。因此，这条global命令可以被解读为“将所有匹配模式 /TODO/ 的文本行依次附加到寄存器 a。</p></blockquote></li><li><p><code>&quot;ap</code>命令，就可以将寄存器 a的内容粘贴进去 了。</p></li></ol><p>另一种方案</p><p>该命令是将所有TODO项 复制到当前文件的末尾，而不是把它们附加到寄存器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/TODO/t$</span><br></pre></td></tr></table></figure><h4 id="global-高级"><a href="#global-高级" class="headerlink" title="global 高级"></a>global 高级</h4><p>假设想对 CSS 内容进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">html &#123; 　</span><br><span class="line">    margin: 0; </span><br><span class="line">    padding: 0; 　</span><br><span class="line">    border: 0; 　</span><br><span class="line">    font-size: 100%; 　</span><br><span class="line">    font: inherit; 　</span><br><span class="line">    vertical-align: baseline; </span><br><span class="line">&#125;</span><br><span class="line"># 排序后</span><br><span class="line">html &#123; </span><br><span class="line">    border: 0; </span><br><span class="line">    font-size: 100%; </span><br><span class="line">    font: inherit; </span><br><span class="line">    margin: 0; </span><br><span class="line">    padding: 0; </span><br><span class="line">    vertical-align: baseline; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/&#123;/ .+1,/&#125;/-1 sort</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>Ex命令通常都会接受“范围”作为其参数，因此 global 命令可以扩展为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/&#123;pattern&#125;/[range][Excmd]</span><br></pre></td></tr></table></figure><p>因此上面的排序命令可以分解为 2 部分</p><p>第一部分是<code>g/{/</code>找到<code>{</code></p><p>第二部分是<code>.+1,/}/-1 sort</code>，其中<code>.+1,/}/-1</code> 表示范围，去掉偏移后：<code>.,/}/</code>,</p><p><code>.</code> 符号通常表示光标所在行，但在 <code>:global</code>命令的上下文中，它则表示 <code>{pattern}</code> 的匹配行。因此<code>.,/}/</code>的含义是“从匹配模式<code>/{/</code>那一行开始，一直到匹配模式 <code>/}/</code> 的那一行为止”。</p><p><strong>结论</strong></p><p><code>:global</code>命令的广义形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/&#123;start&#125;/ .,&#123;finish&#125; [Excmd]</span><br></pre></td></tr></table></figure><p>可以将其解读为“对从 {start} 开始，到 {finish} 结束的所有文 本行，执行指定的 [Excmd]”。</p><p><strong>例子</strong></p><p>假设想对某一段指定范围内的文本内容进行缩进，用Ex命令 <code>:&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/&#123;/ .+1,/&#125;/—1 &gt;</span><br></pre></td></tr></table></figure><p>每当调用 <code>:&gt;</code> 命令时，Vim都会提示一条信息。如果在 [cmd] 的前面加 上 <code>:slient</code>（参见 :h :sil ），就可以屏蔽这些信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/&#123;/sil .+1,/&#125;/−1 &gt;</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="缓冲区列表-ls"><a href="#缓冲区列表-ls" class="headerlink" title="缓冲区列表:ls"></a>缓冲区列表<code>:ls</code></h3><p><strong>查看缓存区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:ls</span><br></pre></td></tr></table></figure><p>标记 <code>+</code> 号， 表示这个缓冲区被修改过了 </p><p>标记为<code>a</code>， 表示它当前是活动缓冲区（active） </p><p>标记为 <code>h</code>， 表示它是一个隐藏缓冲区（hidden） </p><p><strong>切换缓冲区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:bnext     &quot;切换</span><br><span class="line">:bnext!    &quot;强制切换，不保存</span><br></pre></td></tr></table></figure><p><strong>退出缓冲区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:quit</span><br></pre></td></tr></table></figure><p>当想关闭编辑会话时， vim就会提醒某个缓冲区中有未保存的修改 ，并把第一个有改动的隐藏缓冲区载入当前窗口， 这样就可以决定如何处理它。</p><ul><li>如果要保留修改， 可以执行 <code>:write</code> 命令把缓冲区保存到文件；</li><li>如果想摒弃此修改， 可以执行 <code>:edit!</code>， 重新从磁盘读取此文件；</li><li>如果会话里有不止一个被修改过的隐藏缓冲区，那么每次执行<code>:quit</code>命令时，都会激活下一个未保存的缓冲区。可以用<code>:write</code>及<code>:edit!</code>来保存或摒弃此修改。</li></ul><p>在退出时， 处理隐藏缓冲区的方式<strong>总结</strong></p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">:w[rite]</td><td style="text-align:left">把缓冲区内容写入磁盘</td></tr><tr><td style="text-align:left">:e[dit]!</td><td style="text-align:left">把磁盘文件内容读入缓冲区（即回滚所做修改）</td></tr><tr><td style="text-align:left">:qa[ll]!</td><td style="text-align:left">关闭所有窗口， 摒弃修改而无需警告</td></tr><tr><td style="text-align:left">:wa[ll]!</td><td style="text-align:left">把所有改变的缓冲区写入磁盘</td></tr></tbody></table><h3 id="参数列表-args"><a href="#参数列表-args" class="headerlink" title="参数列表:args"></a>参数列表<code>:args</code></h3><p>当不带参数运行 <code>:args</code> 命令时， 它会打印当前参数列表的内容。 </p><p>另外， 也可以用下列格式来设置参数列表的内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args &#123;arglist&#125;</span><br></pre></td></tr></table></figure><ol><li>用文件名指定文件 <code>:args index.html app.js</code></li><li>用 Glob 模式指定文件 <code>:args **/*.js **/*.css</code></li></ol><blockquote><p>  *符号用于匹配0个或多个字符， 但它的范围仅局限于指定的目录， 而不会递归其子目录（参见 :h wildcard ） </p><p>  ** 通配符也匹配0个或多个字符， 但它可以递归进入指定目录的子目录 </p><p>  可以把这两种通配符结合起来用， 并加上部分文件名或目录名， 以此构造一个模式（即所谓的 <strong>glob模式</strong>）  </p></blockquote><ol><li><p>用反引号读取命令指定文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args `cat chapters.txt`</span><br></pre></td></tr></table></figure></li></ol><p>参数列表比缓冲区列表更容易管理，这使其成为对缓冲区进行分组的理想方式。使用<code>:args {arglist}</code>命令，一下就可清空并重新设置参数列表，接着可以用<code>:next</code>及<code>:prev</code>命令遍历参数列表中的文件，或是用<code>:argdo</code>命令在列表中的每个缓冲区上执行同一条命令。</p><h3 id="多屏幕"><a href="#多屏幕" class="headerlink" title="多屏幕"></a>多屏幕</h3><h4 id="新建分屏"><a href="#新建分屏" class="headerlink" title="新建分屏"></a>新建分屏</h4><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><strong>在新窗口中打开同一缓冲区</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><c-w>s</c-w></td><td style="text-align:left">水平切分当前窗口， 新窗口仍显示当前缓冲区</td></tr><tr><td style="text-align:left"><c-w>v</c-w></td><td style="text-align:left">垂直切分当前窗口， 新窗口仍显示当前缓冲区</td></tr><tr><td style="text-align:left"><strong>在新窗口中打开另一个缓冲区</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">:sp[lit] {file}</td><td style="text-align:left">水平切分当前窗口， 并在新窗口中载入{file}</td></tr><tr><td style="text-align:left">:vsp[lit] {file}</td><td style="text-align:left">垂直切分当前窗口， 并在新窗口中载入{file}</td></tr><tr><td style="text-align:left">先执行 <code>&lt;C-w&gt;s</code>， 再执行 <code>:edit {filename}</code></td><td style="text-align:left">水平切分当前窗口， 并在新窗口中载入{file}</td></tr><tr><td style="text-align:left">先执行 <code>&lt;C-w&gt;</code>v， 再执行 <code>:edit {filename}</code></td><td style="text-align:left">垂直切分当前窗口， 并在新窗口中载入{file}</td></tr></tbody></table><h4 id="分屏切换"><a href="#分屏切换" class="headerlink" title="分屏切换"></a>分屏切换</h4><p>可以使用鼠标来激活窗口，请注意<code>:set mouse=</code>TODO如何设置？</p><p>也可以使用快捷键来激活窗口</p><p>上下左右与<code>hjkl</code>的一致</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><c-w><c-w>或<c-w>w</c-w></c-w></c-w></td><td style="text-align:left">在窗口间循环切换</td></tr><tr><td style="text-align:left"><c-w>h</c-w></td><td style="text-align:left">切换到左边的窗口</td></tr><tr><td style="text-align:left"><c-w>j</c-w></td><td style="text-align:left">切换到下边的窗口</td></tr><tr><td style="text-align:left"><c-w>k</c-w></td><td style="text-align:left">切换到上边的窗口</td></tr><tr><td style="text-align:left"><c-w>l</c-w></td><td style="text-align:left">切换到右边的窗口</td></tr></tbody></table><h4 id="关闭分屏"><a href="#关闭分屏" class="headerlink" title="关闭分屏"></a>关闭分屏</h4><table><thead><tr><th style="text-align:left">Ex 命令</th><th style="text-align:left">普通模式命令</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">:clo[se]</td><td style="text-align:left"><c-w>c</c-w></td><td style="text-align:left">关闭活动窗口</td></tr><tr><td style="text-align:left">:on[ly]</td><td style="text-align:left"><c-w>o</c-w></td><td style="text-align:left">只保留活动窗口， 关闭其他所有窗口</td></tr></tbody></table><h4 id="调整分屏大小"><a href="#调整分屏大小" class="headerlink" title="调整分屏大小"></a>调整分屏大小</h4><p>完整的列表请查阅 :h window-resize </p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><c-w>=</c-w></td><td style="text-align:left">使所有窗口等宽、 等高</td></tr><tr><td style="text-align:left"><c-w>_</c-w></td><td style="text-align:left">最大化活动窗口的高度</td></tr><tr><td style="text-align:left"><c-w>｜</c-w></td><td style="text-align:left">最大化活动窗口的宽度</td></tr><tr><td style="text-align:left">[N]<c-w>_</c-w></td><td style="text-align:left">把活动窗口的高度设为[N]行</td></tr><tr><td style="text-align:left">[N]<c-w>｜</c-w></td><td style="text-align:left">把活动窗口的宽度设为[N]列</td></tr></tbody></table><p>改变窗口大小是我喜欢用鼠标做的少量操作之一， 其做法很简单</p><h4 id="重新排序分屏"><a href="#重新排序分屏" class="headerlink" title="重新排序分屏"></a>重新排序分屏</h4><p>window-moving </p><p><a href="http://vimcasts.org/episodes/working-with-windows/" target="_blank" rel="noopener">http://vimcasts.org/episodes/working-with-windows/</a></p><h3 id="标签tab"><a href="#标签tab" class="headerlink" title="标签tab"></a>标签tab</h3><p>Vim 的标签页与缓冲区并非一一对应的关系， 相反， 应该把标签页想成容纳一系列窗口的容器 </p><p>技巧41 如何使用标签页  不太明白 TODO</p><p><code>:lcd {path}</code> 命令让我们可以设置当前窗口的本地工作目录。 如果创建了一个新标签页， 并用 <code>:lcd</code> 命令切换到另一个目录， 就可以把每个标签页限制在不同的工程范围内。 注意： <code>:lcd</code> 只影响当前窗口，而非当前标签页。 如果一个标签页包含了两个或更多的窗口， 可以用<code>:windo lcd {path}</code> 命令为所有这些窗口设置本地工作目录。 </p><h4 id="打开和关闭标签"><a href="#打开和关闭标签" class="headerlink" title="打开和关闭标签"></a>打开和关闭标签</h4><p><code>:tabedit {filename}</code> 命令可以打开一个新的标签页， 如果省略了 <code>{filename}</code> 参数， 那么 Vim 会创建一个新标签页， 里面包含一个空缓冲区。 </p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>:tabe[dit] {filename}</td><td>在新标签页中打开 {filename}，如果省略了 {filename} 参数， 那么 Vim 会创建一个新标签页， 里面包含一个空缓冲区。</td></tr><tr><td>\<c-w>T</c-w></td><td>把当前窗口移到一个新标签页</td></tr><tr><td>:tabc[lose]</td><td>关闭当前标签页及其中的所有窗口</td></tr><tr><td>:tabo[nly]</td><td>只保留活动标签页， 关闭所有其他标签页</td></tr></tbody></table><h4 id="标签页间切换"><a href="#标签页间切换" class="headerlink" title="标签页间切换"></a>标签页间切换</h4><table><thead><tr><th>Ex 命令</th><th>普通模式命令</th><th>用途</th></tr></thead><tbody><tr><td>:tabn[ext] {N}</td><td>{N}gt</td><td>切换到编号为 {N} 的标签页</td></tr><tr><td>:tabn[ext]</td><td>gt</td><td>切换到下一标签页</td></tr><tr><td>:tabp[revious]</td><td>gT</td><td>切换到上一标签页</td></tr></tbody></table><h4 id="重排标签"><a href="#重排标签" class="headerlink" title="重排标签"></a>重排标签</h4><p><code>:tabmove [N]</code>命令可以重新排列标签页</p><ul><li>当 [N] 为0时， 当前标签页会被移到开头</li><li>如果省略 [N]， 当前标签页会被移到结尾</li></ul><p>如果终端支持鼠标可以通过鼠标拖曳来进行重排操作。</p><h3 id="使用sudo保存文件"><a href="#使用sudo保存文件" class="headerlink" title="使用sudo保存文件"></a>使用sudo保存文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➾ :w !sudo tee % &gt; /dev/null</span><br><span class="line">《 Password:</span><br><span class="line">   W12: Warning: File &quot;hosts&quot; has changed and the buffer was</span><br><span class="line">   changed in Vim as well</span><br><span class="line">   [O]k, (L)oad File, Load (A)ll, (I)gnore All:</span><br></pre></td></tr></table></figure><p>此时进行两次交互。 首先要输入用户的密码， 然后 Vim 会警告我们该文件已被修 改了， 并显示出一个选项菜单。 这里建议按 <code>l</code> 键重新将该文件载入缓冲区。</p><p><strong>这条命令是如何工作的？</strong></p><p> <code>:write !{cmd}</code>命令会把缓冲区的内容作为标准输入传给指定的 <code>{cmd}</code>， <code>{cmd}</code> 可以是任何外部程序。 虽然Vim仍然是以普通用户运行的， 但是<strong>可以让调用的外部进程以超级用户权限运行</strong>。 </p><p>在本例中， <code>tee</code>程序将以sudo权限运行， 也就是说它拥有写 <code>/etc/hosts</code> 文件的权限。在 Vim 命令行中， <code>%</code> 符号具有特殊含义。 它会展开成当前文件的完整路径<code>/etc/hosts</code>。 因此，该命令的后半部分可以展开为下面的命令：<code>tee /etc/hosts &gt;/dev/null</code>。 这条命令会把缓冲区的内容当作标准输入， 并用它来覆盖<code>/etc/hosts</code> 文件的内容。 </p><p>之后， Vim 会检测到该文件已经被一个外部程序修改。 一般情况下， 这意味着缓冲区中的内容和文件不同步了， 这就是为什么 Vim 会提示我们做出选择， 是要保留缓冲区中的版本， 还是载入磁盘上的版本 。 </p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h3><p>黄金法则：在录制一个宏时，要确保每条命令都可被重复执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q&#123;register&#125;     录制</span><br><span class="line">q               停止</span><br><span class="line">@&#123;register&#125;     命令执行指定寄存器的内容</span><br><span class="line">100@&#123;register&#125;  以串行方式重复 100 次命令，执行指定寄存器的内容</span><br><span class="line">@@              来重复最近调用过的宏</span><br></pre></td></tr></table></figure><h3 id="点与宏"><a href="#点与宏" class="headerlink" title="点与宏"></a>点与宏</h3><p>对于重复次数不多的工作，点范式是一种高效的编辑策略， 但它不能指定执行的次数。为了克服该限制，可以录制一个廉价 的、一次性的宏，然后再加次数进行回放。</p><p><code>11;.</code>会先运行11次 <code>;</code>命令，再运行1次 <code>.</code>命令，因此并不会运行成功。</p><p>通过录制一个最简单的宏，可以模拟执行11次的 <code>;.</code>，即 <code>qq;.q</code>，然后<code>11@q</code></p><blockquote><p>  首先 qq将指示Vim录制后续的按键操作并将它们保存至寄存器q中。然后再输入命令 <code>;.</code>。最后按下q键结束宏的录制。可以加上次数11执 行这个宏 11@q，即执行11次 <code>;.</code>。</p></blockquote><h3 id="并行宏"><a href="#并行宏" class="headerlink" title="并行宏"></a>并行宏</h3><p>执行宏的时候，如果遇到错误，后续的内容将不会继续执行，因此为了避免某一行文本运行失败而提前退出宏，推荐并行宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. one</span><br><span class="line">2. two</span><br><span class="line">// break up the monotony</span><br><span class="line">3. three</span><br><span class="line">4. four</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li><code>qa</code></li><li><code>0f.r)w~</code></li><li><code>q</code></li><li><code>jVG</code> 可视模式选择剩余行</li><li><code>:&#39;&lt;,&#39;&gt;normal @a</code>  对剩余行都执行寄存器 a 中的宏</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1( One</span><br><span class="line">2( Two</span><br><span class="line">// break up the monotony</span><br><span class="line">3( Three</span><br><span class="line">4( Four</span><br></pre></td></tr></table></figure><h3 id="追加宏"><a href="#追加宏" class="headerlink" title="追加宏"></a>追加宏</h3><blockquote><p>  你可能遇到刚一按下<code>q</code>键，停止了宏的录制，才发现应该在结束之前按一下<code>j</code>键，将光标移至下一行。</p></blockquote><p>在输入 <code>qa</code>时，Vim将开始录制接下来的按键操作，并将它们保存到寄存器 <code>a</code>中，这会覆盖该寄存器原有的内容。</p><p>如果输入的是 <code>qA</code>，Vim也 会录制按键操作，但会把它们附加到寄存器<code>a</code>原有的内容之后。可以用这种方式更正该错误。</p><h3 id="修改宏"><a href="#修改宏" class="headerlink" title="修改宏"></a>修改宏</h3><p>用于录制宏的寄存器，与用作复制、粘贴操作的寄存器相同。因此，如果想修改寄存器 a中的宏，<strong>只需将其粘贴至文档中，便可以像编辑普通文本一样编辑它</strong>了。</p><ol><li><code>:put a</code> 把寄存器 a中的内 容粘贴至新的一行</li><li>修改宏内容</li><li><code>0</code> 回到行首</li><li><code>&quot;ay$</code>  复制宏内容到寄存器 a 中，<code>&quot;add</code>会将换行符都复制进去，因此不推荐</li><li><code>dd</code> 删除文本</li></ol><h3 id="宏中的变量"><a href="#宏中的变量" class="headerlink" title="宏中的变量"></a>宏中的变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">partridge in a pear tree </span><br><span class="line">turtle doves </span><br><span class="line">French hens </span><br><span class="line">calling birds </span><br><span class="line">golden rings</span><br></pre></td></tr></table></figure><p>最终想变成这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) partridge in a pear tree</span><br><span class="line">2) turtle doves</span><br><span class="line">3) French hens</span><br><span class="line">4) calling birds</span><br><span class="line">5) golden ring</span><br></pre></td></tr></table></figure><ol><li><code>:let i=1</code> 设置变量</li><li><code>qa</code> 开始录制</li><li><code>I&lt;C-r&gt;=i&lt;CR&gt;)&lt;Esc&gt;</code>插入变量 i</li><li><code>:let i += 1</code> 变量递增</li><li><code>q</code> 退出录制</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以将定制化的选项写入文件，加以保存。此后通过 <code>:source {file}</code> 命令加载配置。在加载文件时，Vim会把每一行文本当作<code>Ex</code>命令加以执行，就好像在Vim命令行上执行它们一样。</p><p>每当想在当前缓冲区应用这些配置项时，可以运行这条命令：<code>:source two-space-indent.vim</code></p><h3 id="vimrc-的路径"><a href="#vimrc-的路径" class="headerlink" title="vimrc 的路径"></a>vimrc 的路径</h3><ul><li>单次启用某个配置项，在命令模式下，先输入一个冒号，再输入配置</li><li>用户个人的配置<ul><li>在UNIX 系统中，Vim希望能找到路径为 ~/.vimrc的文件</li><li>在Windows系统 中，理想的文件路径为 $HOME/_vimrc</li></ul></li><li>Vim 的全局配置一般在<code>/etc/vim/vimrc</code>或者<code>/etc/vimrc</code>，对所有用户生效</li></ul><p>无论运行的是哪种系统，都可以通过<code>:edit $MYVIMRC</code>来编辑配置文件，<code>:source $MYVIMRC</code>为当前的Vim 会话加载新的配置选项，如果活动的缓冲区是vimrc文件则可以简化为<code>:so%</code></p><h3 id="查看、设置参数"><a href="#查看、设置参数" class="headerlink" title="查看、设置参数"></a>查看、设置参数</h3><p>对于<strong>布尔类型</strong>，要么打开，要么关闭。”关闭”就是在”打开”前面加上前缀<code>no</code>。以 ‘ignorecase’ 选项为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:set ignorecase   &quot;打开</span><br><span class="line">:set noignorecase &quot;关闭</span><br><span class="line">:set ignorecase!  &quot;反转该设置</span><br><span class="line">:set ignorecase?  &quot;获取该选项当前的状态</span><br><span class="line">:set ignorecase&amp;  &quot;重置为默认值</span><br></pre></td></tr></table></figure><p>对于要用到<strong>字符串或者数字</strong>的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set tabstop=2</span><br><span class="line">:set ts=2 sts=2 sw=2 et   &quot;可以用一条 set 语句设置多组选项。</span><br></pre></td></tr></table></figure><p>另外，大多数Vim选项都有其简写形式。</p><h3 id="生效范围"><a href="#生效范围" class="headerlink" title="生效范围"></a>生效范围</h3><p><strong>局部生效</strong></p><p>Vim的设置项通常全局生效，但有些选项只对一个<strong>窗口</strong>或<strong>缓冲区</strong>生效。例如，当运行 <code>:setlocal tabstop=4</code>时，只会影响当前活动的缓冲区。这意味着我们可以打开不同的文件，并为每个文件单独定制。</p><p><strong>缓冲区生效</strong></p><p>如果我们想在现有的所有<strong>缓冲区</strong>内应用同样的设置，可以运行以下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:bufdo setlocal tabstop=4</span><br></pre></td></tr></table></figure><p><strong>窗口生效</strong></p><p>‘number’ 选项只在<strong>窗口</strong>范围内生效。运行 <code>:setlocal number</code> 时，Vim将会激活当前活动窗口的显示行号功能。如果想为每个窗口都激活该功能，可以运行下面这条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:windo setlocal number</span><br></pre></td></tr></table></figure><h3 id="末行命令自动补全"><a href="#末行命令自动补全" class="headerlink" title="末行命令自动补全"></a>末行命令自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">" 末行命令自动补全</span><br><span class="line">set wildmenu " (跟下面组合使用？没看出效果)</span><br><span class="line">set wildmode=longest:list,full    "命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。</span><br></pre></td></tr></table></figure><h3 id="为特定类型的文件应用个性化设置"><a href="#为特定类型的文件应用个性化设置" class="headerlink" title="为特定类型的文件应用个性化设置"></a>为特定类型的文件应用个性化设置</h3><p>我们的偏好设置有可能根据文件的类型不同而有所差异。例如，假设排版格式要求，对 Ruby文件要采用两个空格的缩进，而对JavaScript 文件采用4列宽度的制表符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if has(&quot;autocmd&quot;) </span><br><span class="line">    filetype on</span><br><span class="line">    autocmd FileType ruby setlocal ts=2 sts=2 sw=2 et</span><br><span class="line">    autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noet</span><br><span class="line">    autocmd FileType javascript compiler nodelint</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><blockquote><p>  autocmd语句的检测机制将指示Vim监听某一类事件，一旦该事件发生，Vim将执行指定的命令（参见 :h :autocmd ）。在本例中， 将监听 FileType事件，它会在Vim检测出当前文件类型时被触发。可以为相同类型的事件添加不止一条自动命令。</p></blockquote><p>如果想在某一类文件中应用很多项设置，这样做会使 vimrc 变得很乱。另一种方法是使用<strong>文件类型插件</strong>（ftplugin）来定制不同文件类型。针对不同的语言，都有单独的配置文件，路径为<code>~/.vim/after/ftplugin/javascript.vim</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setlocal ts=4 sts=4 sw=4 noet </span><br><span class="line">compiler nodelint</span><br></pre></td></tr></table></figure><p>为了能够使用 ftplugin 机制，必须确保检测文件类型的功能以及插件功能都被激活了。请检查 vimrc，看看是否包含了<code>filetype plugin on</code></p><h3 id="推荐的配置"><a href="#推荐的配置" class="headerlink" title="推荐的配置"></a>推荐的配置</h3><p><a href="http://www.ruanyifeng.com/blog/2018/09/vimrc.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/09/vimrc.html</a></p><h4 id="外观、代码风格"><a href="#外观、代码风格" class="headerlink" title="外观、代码风格"></a>外观、代码风格</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">" 颜色相关</span><br><span class="line"></span><br><span class="line">syntax on                       "打开语法高亮，自动识别代码</span><br><span class="line">set hlsearch                    "搜索时，高亮显示匹配结果</span><br><span class="line">set hls                         "高亮显示匹配到的关键字‘hlsearch’</span><br><span class="line">“set noh                        取消高亮显示匹配结果</span><br><span class="line">”set nohlsearch                 取消高亮显示匹配结果</span><br><span class="line"></span><br><span class="line">set showmatch                   "光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号</span><br><span class="line">set t_Co=256                    "启用256色</span><br><span class="line"></span><br><span class="line">" 换行相关</span><br><span class="line">set tabstop=4                   "按下Tab 键时，Vim 显示的空格数</span><br><span class="line">set wrap                        "自动折行，即太长的行分成几行显示。</span><br><span class="line">set linebreak                   "不会在单词内部折行。只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行</span><br><span class="line"></span><br><span class="line">" 光标位置相关</span><br><span class="line">set scrolloff=5                 "垂直滚动时，光标距离顶部/底部的行数，方便看到后面的内容</span><br><span class="line">set sidescrolloff=15            "水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用</span><br><span class="line"></span><br><span class="line">" 状态栏相关</span><br><span class="line">set ruler                       "在状态栏显示光标的当前位置（位于哪一行哪一列）</span><br><span class="line">set laststatus=2                "是否显示状态栏。0:不显示，1:只在多窗口时显示，2:显示</span><br><span class="line">set showmode                    "在底部显示，当前处于命令模式还是插入模式</span><br><span class="line">set showcmd                     "命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失。</span><br><span class="line"></span><br><span class="line">" 辅助显示</span><br><span class="line">set nu</span><br><span class="line">set number                      "显示行号</span><br><span class="line"></span><br><span class="line">set list                        "如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块。与listchars配合使用</span><br><span class="line">set listchars=tab:»■,trail:■ ,eol:$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"""""""""""""" 没效果或没用的😁</span><br><span class="line">" set cursorline                光标所在的当前行用下划线高亮(没什么用)</span><br><span class="line">" set relativenumber            显示光标所在的当前行的行号，其他行都为相对于该行的相对行号。(没什么用)</span><br><span class="line">" set spell spelllang=en_us     打开英语单词的拼写检查(不推荐，太亮了)</span><br><span class="line">" set textwidth=80              设置行宽，即一行显示多少个字符。(没效果？)</span><br><span class="line">" set wrapmargin=2              指定折行处与编辑窗口的右边缘之间空出的字符数</span><br></pre></td></tr></table></figure><h4 id="编辑相关"><a href="#编辑相关" class="headerlink" title="编辑相关"></a>编辑相关</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">set mouse=a                     "支持使用鼠标</span><br><span class="line">set encoding=utf-8              "使用 utf-8 编码。</span><br><span class="line"></span><br><span class="line">" 缩进相关</span><br><span class="line">set autoindent                  "按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致</span><br><span class="line">set expandtab                   "tab转为空格,而不是\t。</span><br><span class="line">set softtabstop=4               "Tab 转为多少个空格</span><br><span class="line">filetype indent on              "开启文件类型检查，并且载入与该类型对应的缩进规则。比如，如果编辑的是.py文件，Vim 就是会找 Python 的缩进规则~/.vim/indent/python.vim</span><br><span class="line"></span><br><span class="line">set history=1000                "Vim 需要记住多少次历史操作。</span><br><span class="line">set nocompatible                "不与 Vi 兼容（采用 Vim 自己的操作命令）。</span><br><span class="line"></span><br><span class="line">" 文件备份、历史相关</span><br><span class="line">set nobackup                    "不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）。</span><br><span class="line">set swapfile                    "创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.swp。</span><br><span class="line">set undofile                    "关闭文件后仍保留撤销历史。Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以.un~开头。</span><br><span class="line">set autochdir                   "自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。</span><br><span class="line">set backupdir=~/.vim/.backup//  "要新建这个文件夹</span><br><span class="line">set directory=~/.vim/.swp//     "要新建这个文件夹</span><br><span class="line">set undodir=~/.vim/.undo//      "要新建这个文件夹</span><br><span class="line">" 设置备份文件、交换文件、操作历史文件的保存位置。结尾的//表示生成的文件名带有绝对路径，路径中用%替换目录分隔符，这样可以防止文件重名。</span><br><span class="line"></span><br><span class="line">set autoread                    "打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 末行命令自动补全</span><br><span class="line">set wildmenu                    "(跟下面组合使用？没看出效果)</span><br><span class="line">set wildmode=longest:list,full  "命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。</span><br><span class="line"></span><br><span class="line">""""""" 暂时不知道有什么用的</span><br><span class="line">set shiftwidth=4                "在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者==（取消全部缩进）时，每一级的字符数</span><br><span class="line"></span><br><span class="line">"实际行与屏幕行相关的按键映射</span><br><span class="line">nnoremap k gk</span><br><span class="line">nnoremap gk k</span><br><span class="line">nnoremap j gj</span><br><span class="line">nnoremap gj j</span><br></pre></td></tr></table></figure><h4 id="搜索相关"><a href="#搜索相关" class="headerlink" title="搜索相关"></a>搜索相关</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set incsearch </span><br><span class="line">set is                          "输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果</span><br><span class="line">set ignorecase </span><br><span class="line">set ic                          "搜索时忽略大小写</span><br><span class="line">set smartcase                   "如果同时打开了ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索Test时，将不匹配test；搜索test时，将匹配Test</span><br></pre></td></tr></table></figure><h3 id="tab相关"><a href="#tab相关" class="headerlink" title="tab相关"></a>tab相关</h3><h4 id="缩进-lt-与-gt"><a href="#缩进-lt-与-gt" class="headerlink" title="缩进&lt;与&gt;"></a>缩进<code>&lt;</code>与<code>&gt;</code></h4><p>要想让 <code>&lt;</code> 和 <code>&gt;</code> 命令正常工作， 需要把 ‘shiftwidth’ 及‘softtabstop’ 的值设为4， 并启用 ‘expandtab’ 选项。 如果想了解这些配置是如何协同工作的， 请查阅<a href="http://vimcasts.org/episodes/tabs-and-spaces/" target="_blank" rel="noopener">Vimcasts.org</a>上的“Tabs and Spaces”主题。  </p><h4 id="tab-and-space"><a href="#tab-and-space" class="headerlink" title="tab and space"></a>tab and space</h4><p><a href="http://vimcasts.org/episodes/tabs-and-spaces/" target="_blank" rel="noopener">http://vimcasts.org/episodes/tabs-and-spaces/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tabstop, softtabstop, shiftwidth, expandtab</span><br></pre></td></tr></table></figure><p>如果你喜欢使用 tab，那应该确保 <code>tabstop == softtabstop</code>. 减少缩进时混淆 tabs 和spaces。</p><p>如果你喜欢使用 space, 那应该确保 <code>softtabstop == shiftwidth</code>. 这样在不论在插入模式中 按下tab键，还是在普通/可视模式中使用缩进命令<code>&gt;</code>，都可以保证插入相同数量的空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&quot; put all this in your .vimrc or a plugin file</span><br><span class="line">&quot; Set tabstop, softtabstop and shiftwidth to the same value</span><br><span class="line">command! -nargs=* Stab call Stab()</span><br><span class="line">function! Stab()</span><br><span class="line">  let l:tabstop = 1 * input(&apos;set tabstop = softtabstop = shiftwidth = &apos;)</span><br><span class="line">  if l:tabstop &gt; 0</span><br><span class="line">    let &amp;l:sts = l:tabstop</span><br><span class="line">    let &amp;l:ts = l:tabstop</span><br><span class="line">    let &amp;l:sw = l:tabstop</span><br><span class="line">  endif</span><br><span class="line">  call SummarizeTabs()</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function! SummarizeTabs()</span><br><span class="line">  try</span><br><span class="line">    echohl ModeMsg</span><br><span class="line">    echon &apos;tabstop=&apos;.&amp;l:ts</span><br><span class="line">    echon &apos; shiftwidth=&apos;.&amp;l:sw</span><br><span class="line">    echon &apos; softtabstop=&apos;.&amp;l:sts</span><br><span class="line">    if &amp;l:et</span><br><span class="line">      echon &apos; expandtab&apos;</span><br><span class="line">    else</span><br><span class="line">      echon &apos; noexpandtab&apos;</span><br><span class="line">    endif</span><br><span class="line">  finally</span><br><span class="line">    echohl None</span><br><span class="line">  endtry</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/1562336/tab-vs-space-preferences-in-vim/1610732#1610732" target="_blank" rel="noopener">https://stackoverflow.com/questions/1562336/tab-vs-space-preferences-in-vim/1610732#1610732</a></p><h3 id="关于粘贴缩进问题"><a href="#关于粘贴缩进问题" class="headerlink" title="关于粘贴缩进问题"></a>关于粘贴缩进问题</h3><p>结论：使用<code>:set paste</code></p><p>在Vim中粘贴Python代码后，缩进就全乱了。仔细研究了以下，原来是自动缩进的缘故，于是做如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set noai nosi</span><br></pre></td></tr></table></figure><p>取消了自动缩进和智能缩进，这样粘贴就不会错行了。但在有的vim中不行，还是排版错乱。</p><p>后来发现了<strong>更好用</strong>的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set paste</span><br></pre></td></tr></table></figure><p>进入paste模式以后，可以在插入模式下粘贴内容，不会有任何变形。这个真是灰常好用，情不自禁看了一下帮助，发现它做了这么多事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">textwidth设置为0</span><br><span class="line">wrapmargin设置为0</span><br><span class="line">set noai</span><br><span class="line">set nosi</span><br><span class="line">softtabstop设置为0</span><br><span class="line">revins重置</span><br><span class="line">ruler重置</span><br><span class="line">showmatch重置</span><br><span class="line">formatoptions使用空值</span><br><span class="line"></span><br><span class="line">下面的选项值不变，但却被禁用：</span><br><span class="line"></span><br><span class="line">lisp</span><br><span class="line">indentexpr</span><br><span class="line">cindent</span><br></pre></td></tr></table></figure><p>怪不得之前只设置noai和nosi不行，原来与这么多因素有关！</p><h4 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h4><p>但这样还是比较麻烦的，每次要粘贴的话，先set paste，然后粘贴，然后再set nopaste。<strong>更方便的方法</strong>是使用键盘映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:map &lt;F10&gt; :set paste&lt;CR&gt; </span><br><span class="line">:map &lt;F11&gt; :set nopaste&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>这样在粘贴前按F10键启动paste模式，粘贴后按F11取消paste模式即可。其实，paste有一个切换paste开关的选项，这就是pastetoggle。通过它可以绑定快捷键来激活/取消 paste模式。比如（暂时没试成功）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set pastetoggle=&lt;F11&gt;</span><br></pre></td></tr></table></figure><p>这样减少了一个快捷键的占用，使用起来也更方便一些。</p><p>以上这些设置只是打开这次回话才有效，想要永久有效，需要在<code>~/.vimrc</code>中添加上面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; 不需要冒号</span><br><span class="line">set pastetoggle=&lt;F11&gt;</span><br></pre></td></tr></table></figure><h2 id="自动补全-1"><a href="#自动补全-1" class="headerlink" title="自动补全"></a>自动补全</h2><p><code>&lt;C-p&gt;</code> 在插入模式下触发自动补全，并向上选择候选项（prev）</p><p> <code>&lt;C-n&gt;</code>在插入模式下触发自动补全，并向下选择候选项（next）</p><h3 id="补全类型"><a href="#补全类型" class="headerlink" title="补全类型"></a>补全类型</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">补全类型</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;C-n&gt;</code></td><td style="text-align:left">普通关键字</td></tr><tr><td style="text-align:left"><code>&lt;C-p&gt;</code></td><td style="text-align:left">普通关键字</td></tr><tr><td style="text-align:left"><code>&lt;C-x&gt;&lt;C-n&gt;</code></td><td style="text-align:left">当前缓冲区关键字</td></tr><tr><td style="text-align:left"><code>&lt;C-x&gt;&lt;C-i&gt;</code></td><td style="text-align:left">包含文件关键字</td></tr><tr><td style="text-align:left"><code>&lt;C-x&gt;&lt;C-]&gt;</code></td><td style="text-align:left">标签文件关键字</td></tr><tr><td style="text-align:left"><code>&lt;C-x&gt;&lt;C-k&gt;</code></td><td style="text-align:left">字典查找</td></tr><tr><td style="text-align:left"><code>&lt;C-x&gt;&lt;C-l&gt;</code></td><td style="text-align:left">整行补全</td></tr><tr><td style="text-align:left"><code>&lt;C-x&gt;&lt;C-f&gt;</code></td><td style="text-align:left">文件名补全</td></tr><tr><td style="text-align:left"><code>&lt;C-x&gt;&lt;C-o&gt;</code></td><td style="text-align:left">全能（Omni） 补全</td></tr></tbody></table><p>不论使用哪种自动补全命令，当其弹出式菜单出现时，都可以用 <c-p> 与 <c-n> 选择菜单中的上一项或者下一项。</c-n></c-p></p><p><code>ignorecase</code>选项被启用后，在自动补全时也会忽略大小写，在自动补全时也会忽略大小写，可以通过<code>set infercase</code>选项来修正这一行为。</p><h3 id="弹出框操作"><a href="#弹出框操作" class="headerlink" title="弹出框操作"></a>弹出框操作</h3><table><thead><tr><th style="text-align:left">按键操作</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;C-n&gt;</code></td><td style="text-align:left">使用来自补全列表的下一个匹配项（next 匹配项）</td></tr><tr><td style="text-align:left"><code>&lt;C-p&gt;</code></td><td style="text-align:left">使用来自补全列表的上一个匹配项（previous 匹配项）</td></tr><tr><td style="text-align:left"><code>&lt;Down&gt;</code></td><td style="text-align:left">选择来自补全列表的下一个匹配项，但不改变文本</td></tr><tr><td style="text-align:left"><code>&lt;Up&gt;</code></td><td style="text-align:left">选择来自补全列表的上一个匹配项，但不改变文本</td></tr><tr><td style="text-align:left"><code>&lt;C-y&gt;</code>或<code>&lt;CR&gt;</code></td><td style="text-align:left">确认使用当前选中的匹配项（yes）</td></tr><tr><td style="text-align:left"><code>&lt;C-e&gt;</code></td><td style="text-align:left">还原最早输入的文本（从自动补全中exit）</td></tr><tr><td style="text-align:left"><code>&lt;C-h&gt;</code> （与 <code>&lt;BS&gt;</code>）</td><td style="text-align:left">从当前匹配项中删除一个字符</td></tr><tr><td style="text-align:left"><code>&lt;C-l&gt;</code></td><td style="text-align:left">从当前匹配项中增加一个字符</td></tr><tr><td style="text-align:left">{char}</td><td style="text-align:left">中止自动补全并插入字符 {char}</td></tr></tbody></table><h3 id="实时更新补全列表"><a href="#实时更新补全列表" class="headerlink" title="实时更新补全列表"></a>实时更新补全列表</h3><p>在与自动补全弹出式菜单的交互过程中，输入 <code>&lt;C-n&gt;&lt;C-p&gt;</code>是我最喜欢的技巧之一：在不关闭弹出式菜单的情况下，可以继续输入文本，而Vim将实时过滤补全列表。</p><p>该技巧对于其他自动补全功能也同样有效。例如，可以通过 <code>&lt;C-x&gt; &lt;C-o&gt;&lt;C-p&gt;</code> 对全能补全的结果进行实时性过滤。</p><h3 id="定制普通关键字自动补全"><a href="#定制普通关键字自动补全" class="headerlink" title="定制普通关键字自动补全"></a>定制普通关键字自动补全</h3><p>普通关键字自动补全，会把来自于缓冲区列表、包含文件以及标签文件的单词列表组合在一起，并生成补全建议。如果想改变该功能的行为，可以通过<code>complete</code>选项来定制普通关键字补全时扫描的位置。该选项包含一组由逗号分隔的单个字符，当某个参数出现时，就意味着需要扫描该参数代表的位置。该选项的缺省设置为<code>complete=.,w,b,u,t,i</code>。可以使用以下命令禁止扫描所有的包含文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set complete-=i</span><br></pre></td></tr></table></figure><p>或者，可以通过以下命令来激活拼写字典自动补全功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set complete+=k</span><br></pre></td></tr></table></figure><p>请查阅 :h ‘complete’ ，以便了解各个参数的作用。</p><h4 id="启用字典"><a href="#启用字典" class="headerlink" title="启用字典"></a>启用字典</h4><p>有时候，我们可能想通过自动补全功能输入某个单词，但它并没有在任何打开的缓冲区、包含文件或者标签文件中出现过。在这种情况下，可以在字典中查找。</p><p>为了激活该功能，需要为Vim提供一份合适的单词列表。最简单的方法就是通过运行 <code>:set spell</code></p><p>也可以通过<code>dictionary</code>’选项来指定一个或多个含有单词列表的文件（参见 :h ‘dictionary’）</p><h3 id="补全一整行"><a href="#补全一整行" class="headerlink" title="补全一整行"></a>补全一整行</h3><p>当使用自动补全功能补全单词时，Vim会记住该单词的来源位置。如果紧接着再次调用自动补全功能，Vim就会插入位于其后的单词。可以一次次重复此动作以插入整个单词序列。用这种方式复制短句通常比复制粘贴更快。</p><p>Vim的自动补全不仅仅可以插入单词序列，<strong>也可以用于插入一系列行</strong>。如果重复使用 <code>&lt;C-x&gt;&lt;C-l&gt;</code> 命令（技巧116），就可以插入文档其他位置上的若干个连续的行。</p><h3 id="补全文件名"><a href="#补全文件名" class="headerlink" title="补全文件名"></a>补全文件名</h3><p>Vim的文件名自动补全功能只<strong>相对于工作目录的路径进行扩展</strong>，而<strong>不是相对于当前编辑文件的路径</strong>，理解这一点很重要。</p><p>通过 <code>:pwd</code>命令（print working directory）获取到工作目录的路径信息</p><p>通过 <code>:cd {path}</code> 命令（change directory）随时切换工作目录</p><h3 id="根据上下文自动补全"><a href="#根据上下文自动补全" class="headerlink" title="根据上下文自动补全"></a>根据上下文自动补全</h3><p>技巧 119</p><p>输入 ba，由于“ba”作为CSS属性 的一部分，因此显示的列表内容将包括 background、background-attachment以及其他的几种属性。在此例中，选择的是 backgroundcolor。而当第二次触发全能补全时，尽管没有输入任何文本，但Vim会根据上下文判断出我们需要的是颜色信息，因此，它提供了3项补全建议：<code>#</code>、<code>rgb(</code> 以及 <code>transparent</code>。</p><h2 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h2><h3 id="拼写检查快捷键"><a href="#拼写检查快捷键" class="headerlink" title="拼写检查快捷键"></a>拼写检查快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:set spell             ”启用拼写检查</span><br><span class="line">:set spelllang=en_us   “设置拼写字典，默认是英文</span><br><span class="line">[s    &quot;反向跳转</span><br><span class="line">]s    &quot;正向跳转</span><br><span class="line">z=    &quot;更正建议列表</span><br><span class="line">zg    &quot;把当前单词添加到拼写文件中,即可避免以后对该单词的错误检查，使Vim可以识别它</span><br><span class="line">zw    &quot;把当前单词从拼写文件中删除</span><br><span class="line">zug   &quot;撤销针对当前单词的zg或zw命令</span><br></pre></td></tr></table></figure><h3 id="使用其他拼写字典"><a href="#使用其他拼写字典" class="headerlink" title="使用其他拼写字典"></a>使用其他拼写字典</h3><p>内置了支持英语的拼写文件，可以 到<a href="http://ftp.vim.org/vim/runtime/spell/" target="_blank" rel="noopener">http://ftp.vim.org/vim/runtime/spell/</a> 下载它支持的其他几 十种语言的拼写文件</p><h3 id="定制专有名词字典"><a href="#定制专有名词字典" class="headerlink" title="定制专有名词字典"></a>定制专有名词字典</h3><p>很多单词，如grep。我既不想让Vim将它们标记为拼写错误，也不想让Vim视其为合法的英语单词。作为折中方案，单独维护一个单词列表，专门用于保存Vim的术语。这样一来，在撰写 Vim相关的文章时，可以随时把它作为拼写文件加载进来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setlocal spelllang=en_us </span><br><span class="line">setlocal spellfile=~/.vim/spell/en.utf-8.add </span><br><span class="line">setlocal spellfile+=~/books/practical_vim/jargon.utf-8.add</span><br></pre></td></tr></table></figure><p>‘spellfile’ 选项，可以指定一个文件路径，用于保存 由 zg 和 zw 命令添加、删除的单词</p><p><code>~/.vim/spell/en.utf-8.add</code>是缺省路径，它保存所有由 zg 命 令添加的单词</p><p><code>~/books/practical_vim/jargon.utf-8.add</code> 保存由我维护的Vim术语列表</p><p>现在对于每一个被拼写检查器误判的单词，目前都有两种处理方式，既可以通过 <code>2zg</code>将其添加到Vim的术语列表中，也可以通过 <code>1zg</code> 将其添加到缺省的单词列表中。</p><h3 id="插入模式下使用自动补全"><a href="#插入模式下使用自动补全" class="headerlink" title="插入模式下使用自动补全"></a>插入模式下使用自动补全</h3><p>只有某行文本出现的拼写错误不止一处时，<code>&lt;C-x&gt;s</code> 命令才能充分发挥出其优势，然后使用<code>&lt;C-p&gt;</code> <code>&lt;C-n&gt;</code>进行上下选择</p><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><p>surround.vim   用它可以很容易地给选中的文本加分隔符 </p><p>matchit.vim   可以在配对的关键字间跳转 </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>自定义操作符<code>:h :map-operator</code></p><p>自定义动作命令 <code>:h omapinfo</code> </p><h3 id="别将反向字符查找命令弃之不用"><a href="#别将反向字符查找命令弃之不用" class="headerlink" title="别将反向字符查找命令弃之不用"></a>别将反向字符查找命令弃之不用</h3><p>技巧 50</p><p>Vim 几乎为键盘上的每个键都赋予了一个功能。 如果想创建自定义映射项， 那么该把它们绑定到哪个键上呢？ Vim 提供了一个 <code>&lt;Leader&gt;</code> ， 以此作为用户自定义命令的名字空间。 下面的例子显示了如何利用 <code>&lt;Leader&gt;</code> 来创建自定义映射项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;Leader&gt;n nzz</span><br><span class="line">noremap &lt;Leader&gt;N Nzz</span><br></pre></td></tr></table></figure><p>缺省的<code>&lt;Leader&gt;</code>键是<code>\</code>，因此可以按<code>\n</code>和<code>\N</code>来触发刷新屏幕的功能。 在有些键盘上， <code>\</code> 命令不太容易够到， 因此 Vim 允许把<code>&lt;Leader&gt;</code>键映射为其他更方便的字符（参见 :h mapleader） 。 一个普遍的选择是把逗号设置为 <code>&lt;Leader&gt;</code> 键。 如果你也是这么做的， 我强烈建议把反向字符查找命令映射为另一个键。 下面给出了一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mapleader=&quot;,&quot;</span><br><span class="line">noremap \ ,</span><br></pre></td></tr></table></figure><p><code>;</code> 和<code>,</code> 命令是互为补充的， 如果去掉了其中一个，整个字符查找命令集的用处就会大打折扣了。</p><h2 id="交互式教程"><a href="#交互式教程" class="headerlink" title="交互式教程"></a>交互式教程</h2><p><a href="https://www.openvim.com/" target="_blank" rel="noopener">https://www.openvim.com/</a></p><p><a href="https://vim-adventures.com/" target="_blank" rel="noopener">https://vim-adventures.com</a></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>技巧31没看懂</p><p>第7，9,16,17章还没看</p><p>技巧70</p><p>gn 的作用</p><p>c%(<c-r>“) <esc> 的话，请参考技巧55以及技巧15。</esc></c-r></p><p>技巧92</p><p>技巧 73 的总结</p><p>技巧21 gv命令会激活可视模式，并重新将上次被选中的文本高亮起 来</p><p>技巧96　交换两个或更多的单词</p><p>技巧97　在多个文件中执行查找与替换</p><p>虚拟替换模式替换制表符</p><p>POSIX风格的正则表达式，Perl风格的正则表达式来了解一下</p></the>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
