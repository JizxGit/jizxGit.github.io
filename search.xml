<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>bash定制命令提示符</title>
      <link href="/2019/09/04/bash%E5%AE%9A%E5%88%B6%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/"/>
      <url>/2019/09/04/bash%E5%AE%9A%E5%88%B6%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="常用显示参数"><a href="#常用显示参数" class="headerlink" title="常用显示参数"></a>常用显示参数</h3><p><code>\d</code>：代表日期，格式为weekday month date，例如：”Mon Aug 1”<br><code>\H</code>：完整的主机名称<br><code>\h</code>：仅取主机的第一个名字<br><code>\t</code> ：显示时间为24小时格式，如：HH：MM：SS<br><code>\T</code>：显示时间为12小时格式<br><code>\A</code> ：显示时间为24小时格式：HH：MM<br><code>\u</code> ：当前用户的账号名称<br><code>\v</code> ：BASH的版本信息<br><code>\w</code>：完整的工作目录名称<br><code>\W</code> ：利用basename取得工作目录名称，所以只会列出最后一个目录<br><code>\#</code> ：下达的第几个命令<br><code>\$</code> ：提示字符，如果是root时，提示符为：<code>#</code> ，普通用户则为：<code>$</code><br><code>\n</code> ：换行符</p><p>可以在 bash 的 man 手册 PROMPTING 章节中查阅</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p><strong>PS1中设置字符颜色的格式为：<code>\[\e[F;Bm\]</code>，其中“F“为字体颜色，编号为30到37，“B”为背景颜色，编号为40到47。可以只设置前景色或背景色。颜色表如下：</strong></p><table><thead><tr><th style="text-align:left">F</th><th style="text-align:right">B</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:left">30</td><td style="text-align:right">40</td><td style="text-align:center">黑色</td></tr><tr><td style="text-align:left">31</td><td style="text-align:right">41</td><td style="text-align:center">红色</td></tr><tr><td style="text-align:left">32</td><td style="text-align:right">42</td><td style="text-align:center">绿色</td></tr><tr><td style="text-align:left">33</td><td style="text-align:right">43</td><td style="text-align:center">黄色</td></tr><tr><td style="text-align:left">34</td><td style="text-align:right">44</td><td style="text-align:center">蓝色</td></tr><tr><td style="text-align:left">35</td><td style="text-align:right">45</td><td style="text-align:center">紫红色</td></tr><tr><td style="text-align:left">36</td><td style="text-align:right">46</td><td style="text-align:center">青蓝色</td></tr><tr><td style="text-align:left">37</td><td style="text-align:right">47</td><td style="text-align:center">白色</td></tr></tbody></table><p>颜色格式后面跟着的就是<code>\u</code>、<code>\w</code>这样的显示参数，颜色格式后面的字符串都将使用该颜色，为了实现不同字段不同颜色，建议使用<code>指定的颜色 显示参数 None颜色</code> 这样进行划分。见下例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">COLOR_GRAY=<span class="string">'\[\e[1;30m\]'</span>    还有一种写法是将\e写成\033</span><br><span class="line">COLOR_RED=<span class="string">'\[\e[1;31m\]'</span></span><br><span class="line">COLOR_GREEN=<span class="string">'\[\e[1;32m\]'</span></span><br><span class="line">COLOR_YELLOW=<span class="string">'\[\e[1;33m\]'</span></span><br><span class="line">COLOR_BLUE=<span class="string">'\[\e[1;34m\]'</span></span><br><span class="line">COLOR_MAGENTA=<span class="string">'\[\e[1;35m\]'</span></span><br><span class="line">COLOR_CYAN=<span class="string">'\[\e[1;36m\]'</span></span><br><span class="line">COLOR_WHITE=<span class="string">'\[\e[1;37m\]'</span></span><br><span class="line">COLOR_NONE=<span class="string">'\[\e[m\]'</span></span><br><span class="line"></span><br><span class="line">PS1_USER=<span class="string">"<span class="variable">$&#123;COLOR_MAGENTA&#125;</span>\u<span class="variable">$&#123;COLOR_NONE&#125;</span>"</span></span><br><span class="line">PS1_HOST=<span class="string">"<span class="variable">$&#123;COLOR_CYAN&#125;</span>\h<span class="variable">$&#123;COLOR_NONE&#125;</span>"</span></span><br><span class="line">PS1_PWD=<span class="string">"<span class="variable">$&#123;COLOR_YELLOW&#125;</span>\w<span class="variable">$&#123;COLOR_NONE&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">"<span class="variable">$&#123;PS1_USER&#125;</span>@<span class="variable">$&#123;PS1_HOST&#125;</span>:<span class="variable">$&#123;PS1_PWD&#125;</span>\\\$ "</span></span><br></pre></td></tr></table></figure><p>在颜色定制文本(例如： <code>COLOR_GRAY=&#39;\[\033[1;30m\]&#39;</code>)中，开始的<code>\[</code>和结尾的<code>\]</code>是必须的，否则当输入的命令很长的时候，就会回车但不换行,于是覆盖了行首的有颜色的字符串</p><p>通过Bash编程在Terminal上输出彩色的字符串，是不能添加<code>\[</code>和<code>\]</code>的。 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">print</span> &#123; <span class="built_in">printf</span> -- <span class="string">"$*\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> _isatty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">typeset</span> -l isatty=<span class="variable">$&#123;ISATTY:-"auto"&#125;</span></span><br><span class="line">    [[ <span class="variable">$isatty</span> == <span class="string">"yes"</span> ]] &amp;&amp; <span class="built_in">return</span> 0         <span class="comment"># yes</span></span><br><span class="line">    [[ <span class="variable">$isatty</span> == <span class="string">"no"</span> ]] &amp;&amp; <span class="built_in">return</span> 1          <span class="comment"># no</span></span><br><span class="line">    [[ -t 1 &amp;&amp; -t 2 ]] &amp;&amp; <span class="built_in">return</span> 0 || <span class="built_in">return</span> 1 <span class="comment"># auto</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> str2gray    &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;30m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2red     &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;31m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2green   &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;32m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2yellow  &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;33m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2blue    &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;34m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2magenta &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;35m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2cyan    &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;36m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> str2white   &#123; _isatty &amp;&amp; <span class="built_in">print</span> <span class="string">"\e[1;37m<span class="variable">$@</span>\033[m"</span> || <span class="built_in">print</span> <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="在线网站"><a href="#在线网站" class="headerlink" title="在线网站"></a>在线网站</h3><p>如果上面的方法觉得麻烦，可以使用推荐的在线制作网站：<a href="http://ezprompt.net/" target="_blank" rel="noopener">http://ezprompt.net/</a></p><p>参考：</p><p><a href="https://www.jianshu.com/p/426d0eeee671" target="_blank" rel="noopener">https://www.jianshu.com/p/426d0eeee671</a></p><p><a href="https://www.cnblogs.com/idorax/p/8270025.html" target="_blank" rel="noopener">https://www.cnblogs.com/idorax/p/8270025.html</a></p></the></excerpt>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>awk</title>
      <link href="/2019/09/02/awk/"/>
      <url>/2019/09/02/awk/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>基本组成形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk options program file1 </span><br><span class="line">awk options program file1 file2</span><br><span class="line">awk options program <span class="comment"># 进入交互模式，直到ctrl+d结束输入</span></span><br></pre></td></tr></table></figure><p>由于gawk命令行假定脚本是单个文本字符串，你<strong>必须将脚本放到单引号中</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; print "start";command2 &#125; pattern &#123; command1;command2 &#125; END&#123; print "end";command2 &#125;'</span> file</span><br></pre></td></tr></table></figure><ul><li><p>一个命令就是一个以新行或者分号分隔的语句序列。</p></li><li><p>由于模式和命令两者任一都是可选的，所以需要使用大括号包围动作以区分于其他模式。</p></li><li><p>多条语句之间用<code>;</code>分隔</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; print $1,$6 &#125;'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="/2019/09/02/awk/./awk_workflow.jpg" alt="img"></p><ol><li><p>awk以<strong>逐行的形式</strong>处理文件</p></li><li><p><code>BEGIN</code>之后的命令会先于公共语句块执行</p><blockquote><p>  BEGIN语句块在awk开始从输入流中读取行之前被执行（除非调用了 <code>getline</code>）。这是一个<strong>可选的</strong>语句块，诸如变量初始化、打印输出表格的表头等语句通常都可以放在BEGIN语句块中。</p></blockquote></li><li><p>对于匹配PATTERN的行，awk会对其执行<code>PATTERN</code>之后的命令</p><blockquote><p>  这个语句块是<strong>可选的</strong>。如果不提供，则默认执行<code>{ print }</code>，即打印所读取到的每一行。 如果提供，则每个pattern依次测试每个输入行。对于匹配到行的模式，其对应的命令（也许包含多步）得到执行，然后读取下一行并继续匹配，直到所有的输入读取完毕。</p></blockquote></li><li><p>最后，在处理完整个文件之后，awk会执行<code>END</code>之后的命令</p><blockquote><p>  END语句块和BEGIN语句块类，也是<strong>可选的</strong>语句块。它在awk读取完输入流中所有的行之后被执行。像打印所有行的分析结果这种常见任务都是在END语句块中实现的。</p></blockquote></li></ol><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a><code>print</code>输出</h4><p><code>print</code>接受的变量之间以<strong>逗号分隔</strong>，在输出时会<strong>以空格作为变量之间的分隔符</strong>。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $3,$4&#125;&apos; marks.txt</span><br></pre></td></tr></table></figure><p><strong><code>print</code>之间的空格不会影响输出格式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $3 "\t" $4&#125;'</span> marks.txt <span class="comment"># $3与\t之间的空格不会显示在输出中</span></span><br><span class="line">awk <span class="string">'&#123;print $3 , $4&#125;'</span> marks.txt <span class="comment"># 逗号表示最终会以空格分分隔两个字段</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><p>在awk的<code>print</code>语句中，<strong>双引号被当作拼接操作符</strong>（concatenation operator）使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; var1="v1"; var2="v2"; var3="v3"; \</span></span><br><span class="line"><span class="string">print var1 "-" var2 "-" var3 ; &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># v1-v2-v3</span></span><br></pre></td></tr></table></figure><p><strong>省略<code>print</code></strong></p><p>如果没有主体块——默认的动作是输出行。因此比如搜索字符串<code>Tom</code>可以使用下面简略方式实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/Tom/'</span> marks.txt</span><br></pre></td></tr></table></figure><p><strong>打印一行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; print &#125;</span><br><span class="line"># 或者，由于 $0 表示整行,</span><br><span class="line">&#123; print $0 &#125;</span><br></pre></td></tr></table></figure><p><strong>打印特定列</strong></p><p>使用一个 print 语句可以在同一行中输出不止一个字段. 下面的程序输出了每 行输入中的第一和第三个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $1, $3 &#125;</span><br></pre></td></tr></table></figure><p><strong>NF</strong> 列总数</p><p>该变量表示一共有多少列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print NF, $1, $NF &#125; # 打印第一列 和最后一列</span><br></pre></td></tr></table></figure><p><strong>计算和打印</strong></p><p>你也可以对字段的值进行计算后再打印出来. 下面的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $1, $2 * $3 &#125;</span><br></pre></td></tr></table></figure><p><strong>NR 打印行号</strong></p><p>存储当前已经读取了多少行的计数。给每一行加上行号:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print NR, $0 &#125;</span><br></pre></td></tr></table></figure><p><strong>在输出中添加内容</strong></p><p>双引号内的文字将会在字段和计算的值中插入输出.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print &quot;total pay for&quot;, $1, &quot;is&quot;, $2 * $3 &#125;</span><br></pre></td></tr></table></figure><p><strong>排序输出</strong></p><p>最简单的方式是使用awk将每位员工的总薪酬置于其记录之前，然后利用<strong>sort</strong>命令来处理awk的输出。Unix上，命令行如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123; printf(&quot;%6.2f    %s\n&quot;, $2 * $3, $0) &#125;&apos; emp.data | sort</span><br></pre></td></tr></table></figure><p><strong>打印表头，表尾</strong></p><p> BEGIN 用于匹配第一个输入文件的第一行之前的位置， END 则用于匹配处理过的最后一个文件的最后一行之后的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;print &quot;Name Rate Hour&quot;;print &quot;=========&quot;&#125; &#123;print $0&#125;&apos; file</span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><ul><li><p>在命令中使用<strong>空格</strong>进行变量拼接</p></li><li><p>在<code>print</code>语句块中使用<strong>双引号</strong>拼接</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将names变量与当前行的的$1以及空格进行拼接，赋值给names</span><br><span class="line"> &#123; names = names $1 &quot; &quot;&#125;</span><br><span class="line">END &#123; print names &#125;</span><br></pre></td></tr></table></figure><p><strong>只打印最后一行</strong></p><p><strong>打印最后一个输入行</strong></p><p>虽然在 END 动作中 NR 还保留着它的值，但 $0 没有。程序是打印最后一个输入行的一种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#123; last = $0 &#125;</span><br><span class="line">END &#123; print last &#125;</span><br></pre></td></tr></table></figure><h4 id="printf高级输出"><a href="#printf高级输出" class="headerlink" title="printf高级输出"></a><code>printf</code>高级输出</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>printf 语句的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(format, value1, value2, ..., valuen)</span><br></pre></td></tr></table></figure><p>其中 format 是字符串，包含要逐字打印的文本，穿插着 format 之后的每个值该如何打印的规格(specification)。一个规格是一个 % 符，后面跟着一些字符，用来控制一个 value 的格式。第一个规格说明如何打印 value1 ，第二个说明如何打印 value2 ，… 。因此，有多少 value 要打印，在 format 中就要有多少个 % 规格。（与C语言很像）</p><p>这里有个程序使用 printf 打印每位员工的总薪酬：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; printf(&quot;total pay for %s is $%.2f\n&quot;, $1, $2 * $3) &#125;</span><br></pre></td></tr></table></figure><h5 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h5><p><strong>退格符</strong><code>\b</code></p><p><strong>换页符</strong><code>\f</code></p><p><strong>换行符</strong><code>\n</code> ，进入下一行</p><p><strong>回车符</strong><code>\r</code> ，光标移动到第一列</p><blockquote><p>  这与以前的打字机相关，以前的打字机达打完一行后，机械上需要2步，先将指针移动到下一行（换行），然后将指针回到行首（回车）</p></blockquote><p>我们在每个域输出后输出一个回车符<code>\r</code>，随后输出的域会覆盖之前输出的内容。也就是说，我们只能看到最后输出的 Field 4。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; printf "Field 1\rField 2\rField 3\rField 4\n" &#125;'</span></span><br><span class="line"><span class="comment"># Field 4</span></span><br></pre></td></tr></table></figure><p><strong>垂直制表符</strong></p><p>如下示例，使用垂直制表符输出不同域：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; printf "Sr No\vName\vSub\vMarks\n" &#125;'</span></span><br><span class="line"><span class="comment"># 执行上面的命令可以得到如下的结果</span></span><br><span class="line">Sr No</span><br><span class="line">    Name</span><br><span class="line">        Sub</span><br><span class="line">            Marks</span><br></pre></td></tr></table></figure><h5 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符%"></a>格式说明符%</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>%c</td><td>输出<strong>单个字符</strong>。如果参数是个数值，那么数值也会被当作字符然后输出。如果参数是字符串，那么只会输出第一个字符。</td></tr><tr><td>%d 与 %i</td><td>输出十进制数的整数部分。</td></tr><tr><td>%f</td><td>输出浮点数，以 [-]ddd.dddddd 的格式</td></tr><tr><td>%e 与 %E</td><td>输出浮点数，以 [-]d.dddddde[+-]dd 的格式。区别就是输出<code>8.066000e+01</code>与<code>8.066000E+01</code>的<code>e</code>的大小写</td></tr><tr><td>%g 与 %G</td><td>输出浮点数，使用 %e 或 %E 转换。但它们会<strong>删除那些对数值无影响的 0</strong>。（推荐）</td></tr><tr><td>%o</td><td>无符号八进制输出。</td></tr><tr><td>%u</td><td>无符号十进制数输出。</td></tr><tr><td>%x 与 %X</td><td>输出十六进制无符号数。%X 中使用大写字母，%x 使用小写字母。</td></tr><tr><td>%%</td><td>输出百分号（%），不需要输入参数。</td></tr></tbody></table><h5 id="格式说明符-的可选参数"><a href="#格式说明符-的可选参数" class="headerlink" title="格式说明符% 的可选参数"></a>格式说明符% 的可选参数</h5><p><strong>列宽</strong></p><p><code>%8d</code>表示用空格填充占8列，如果紧接在 % 后是以0开头的数字<code>%08d</code>，表示输出应该使用0填充而不是空格字符。</p><p><strong>对齐</strong></p><p>默认是右边对齐，在 % 之后数字之前使用减号（-）即可指定输出左对齐</p><p><strong>符号前缀</strong></p><p>但是<code>+</code>不是表示右对齐，是表示输出数值的符号，正号也输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; num = -10; printf "Num = %-+10d\n", num &#125;'</span> | cat -vte</span><br></pre></td></tr></table></figure><p><strong>哈希<code>#</code></strong></p><p>将<code>#</code>放在<code>%</code>后， 可以为 %o 的结果前添加0，为 %x 或 %X 输出的结果前添加 0x 或 0X （结果不为零时），为 %e，%E，%f，%F添加小数点；对于 %g 或 %G，使用哈希可以保留尾部的零</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123; printf &quot;Octal representation = %#o\nHexadecimal representaion = %#X\n&quot;, 10, 10&#125;&apos;</span><br></pre></td></tr></table></figure><h4 id="重定向、管道、双向管道"><a href="#重定向、管道、双向管道" class="headerlink" title="重定向、管道、双向管道"></a>重定向、管道、双向管道</h4><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>AWK 重定向操作符重定向数据到文件 message.txt 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "Hello, World !!!" &gt; "/tmp/message.txt" &#125;'</span></span><br><span class="line">cat /tmp/message.txt</span><br></pre></td></tr></table></figure><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>下面的例子中我们使用 <code>tr</code> 命令将小写字母转换成大写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "hello, world !!!" | "tr [a-z] [A-Z]" &#125;'</span></span><br><span class="line"><span class="comment"># HELLO, WORLD !!！</span></span><br></pre></td></tr></table></figure><h5 id="双向通信通道"><a href="#双向通信通道" class="headerlink" title="双向通信通道"></a>双向通信通道</h5><p>（TODO 还不知道怎么用）</p><p>AWK 允许使用 <code>|&amp;</code> 与一个外部进程通信，并且可以双向通信。下面的例子中，使用 <code>tr</code> 命令将字母转换为大写字母。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    cmd = <span class="string">"tr [a-z] [A-Z]"</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"hello, world !!!"</span> |&amp; cmd</span><br><span class="line">    close(cmd, <span class="string">"to"</span>)</span><br><span class="line">    cmd |&amp; getline out</span><br><span class="line">    <span class="built_in">print</span> out;</span><br><span class="line">    close(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的命令可以得到如下的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELLO, WORLD !!!</span><br></pre></td></tr></table></figure><p>脚本的内容看上去很神秘吗？让我们一步一步揭开它神秘的面纱。</p><ul><li>第一条语句 cmd = “tr [a-z][A-Z]” 在AWK 中建立了一个双向的通信通道。</li><li>第二条语句 print 为 tr 命令提供输入。&amp;| 表示双向通信。</li><li>第三条语句 close(cmd, “to”) 执行后关闭 to 进程。</li><li>第四条语句 cmd |&amp; getline out 使用 getline 函数将输出存储到 out 变量中。</li><li>接下来的输出语句打印输出的内容，最后 close 函数关闭 cmd。</li></ul><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td></td><td><strong>标准参数</strong></td></tr><tr><td>-F fs</td><td>fs是分隔符，默认是空白符（空格、制表符），fs可以是字符串或正则表达式。<br>如<code>-F:</code> 表示冒号为分隔符；<br>如果想指定空格为分隔符，请看下面例子。</td></tr><tr><td>-v var=value</td><td>赋值一个用户定义变量，将外部变量传递给awk</td></tr><tr><td>-f scripfile</td><td>从脚本文件中读取awk命令</td></tr><tr><td>-p[file]</td><td>用于格式化 awk 脚本文件。默认输出文件是 <strong>awkprof.out</strong>。</td></tr><tr><td></td><td><strong>gawk 参数</strong></td></tr><tr><td>-mf N</td><td>指定要处理的数据文件中的最大字段数</td></tr><tr><td>-mr N</td><td>指定数据文件中的最大数据行数</td></tr></tbody></table><blockquote><p>  在BEGIN语句块中可以用OFS=”delimiter”设置输出字段分隔符。<code>awk &#39;BEGIN { FS=&quot;:&quot; }{ print }</code></p></blockquote><p><strong>指定空格为分隔符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc d"</span>|awk -F<span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span>   <span class="comment"># 无效，还是会将\t进行分割</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\tb\nc d"</span>|awk -F<span class="string">'[ ]'</span> <span class="string">'&#123;print $2&#125;'</span> <span class="comment"># 推荐</span></span><br></pre></td></tr></table></figure><p><strong>同时使用多个分隔符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 使用多个分隔符, 遇到";"或者","就进行分割，因此下面的例子会得到 5 列</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1;2,3;4,5"</span>|awk -F <span class="string">'[;,]'</span> <span class="string">'&#123;print $1,$2,$3,$4,$5&#125;'</span></span><br><span class="line"><span class="comment"># 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://ipcmen.com/awk" target="_blank" rel="noopener">https://ipcmen.com/awk</a></p><p><strong>格式化脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk --profile <span class="string">'BEGIN&#123;printf"---|Header|--\n"&#125; &#123;print&#125; END&#123;printf"---|Footer|---\n"&#125;'</span> marks.txt &gt; /dev/null </span><br><span class="line">[jerry]$ cat awkprof.out</span><br></pre></td></tr></table></figure><p>执行上面的命令可以得到如下的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># gawk profile, created Sun Oct 26 19:50:48 2014</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BEGIN block(s)</span></span><br><span class="line"></span><br><span class="line">    BEGIN &#123;</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"---|Header|--\n"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rule(s)</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># END block(s)</span></span><br><span class="line"></span><br><span class="line">    END &#123;</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"---|Footer|---\n"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="模式-pattern-种类"><a href="#模式-pattern-种类" class="headerlink" title="模式(pattern)种类"></a>模式(pattern)种类</h3><p><strong>BEGIN { 语句 }</strong></p><p>在读取任何输入前执行一次语句</p><p><strong>END { 语句 }</strong></p><p>读取所有输入之后执行一次语句</p><p><strong>表达式 { 语句 }</strong></p><p>对于表达式为真（即，非零或非空）的行，执行语句</p><p><strong>/正则表达式/ { 语句 }</strong></p><p>如果输入行包含字符串与正则表达式相匹配，则执行语句</p><p><strong>组合模式 { 语句 }</strong></p><p>一个 组合模式 通过与（<code>&amp;&amp;</code>），或（<code>||</code>），非（<code>!</code>），以及括弧来组合多个表达式；对于组合模式为真的每个输入行，执行 语句</p><p><strong>模式1，模式2 { 语句 }</strong></p><p>范围模式(range pattern)匹配从与模式1相匹配的行到与模式2相匹配的行（包含该行）之间的所有行，对于这些输入行，执行语句。</p><blockquote><p>  BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。BEGIN和END是仅有的必须搭配动作的模式。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;NR &lt; 5&apos;        # 行号小于5的行</span><br><span class="line">awk &apos;NR==1,NR==4&apos;   # 行号在1到5之间的行 </span><br><span class="line">awk &apos;/linux/&apos;       # 包含模式为linux的行（可以用正则表达式来指定模式）</span><br><span class="line">awk &apos;!/linux/&apos;      # 不包含模式为linux的行</span><br></pre></td></tr></table></figure><h3 id="选择、过滤"><a href="#选择、过滤" class="headerlink" title="选择、过滤"></a>选择、过滤</h3><p><strong>数值判断</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$2</span> * <span class="variable">$3</span> &gt; 50 &#123; <span class="built_in">printf</span>(<span class="string">"$%.2f for %s\n"</span>, <span class="variable">$2</span> * <span class="variable">$3</span>, <span class="variable">$1</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>文本内容选择，支持正则</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$1 == &quot;Susie&quot; &#123; print &#125;</span><br><span class="line">$1~/正则内容/ &#123; print $1&#125; #对某一列进行正则</span><br><span class="line">/正则内容/ &#123; print $1&#125;# 对整行进行匹配</span><br></pre></td></tr></table></figure><p><strong>多条件组合</strong></p><p>逻辑操作符与 &amp;&amp; ， 或 || ， 以及非 ! 对模式进行组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$2 &gt;= 4 || $3 &gt;= 20 &#123;print&#125;</span><br></pre></td></tr></table></figure><h3 id="多条命令"><a href="#多条命令" class="headerlink" title="多条命令"></a>多条命令</h3><p>要在命令行上的程序脚本中使用多条命令，</p><ul><li><p>只要在命令之间放个<strong>分号</strong>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;My name is Rich&quot; | gawk &apos;&#123;$4=&quot;Christine&quot;; print $0&#125;&apos; My name is Christine</span><br></pre></td></tr></table></figure></li><li><p>也可以用次提示符一次一行地输入程序脚本命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gawk <span class="string">'&#123; \</span></span><br><span class="line"><span class="string">&gt; $4="Christine"</span></span><br><span class="line"><span class="string">&gt; print $0&#125;'</span> </span><br><span class="line">My name is Rich </span><br><span class="line"></span><br><span class="line">$ My name is Christine</span><br></pre></td></tr></table></figure></li></ul><h3 id="将命令保存在文件中"><a href="#将命令保存在文件中" class="headerlink" title="将命令保存在文件中"></a>将命令保存在文件中</h3><p>当引号内的程序过长时，可以单独保存在文件中，假设存在文件 progfile ，输入命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f progfilefile</span><br></pre></td></tr></table></figure><p>文件中不用引号包起来，但是中括号还是需要的，多条指令在同一行中用分号分分隔，或者以多行形式书写</p><h4 id="读取命令的输出"><a href="#读取命令的输出" class="headerlink" title="读取命令的输出"></a>读取命令的输出</h4><p>awk可以调用命令并读取输出。把命令放入引号中，然后利用管道将命令输出传入getline：<code>&quot;command&quot; | getline output ;</code></p><p>下面的代码从<code>/etc/passwd</code>文件中读入一行，然后显示出用户登录名及其主目录。在BEGIN语 句块中将字段分隔符设置为:，在主语句块中调用了<code>grep</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; print $1,$6 &#125;'</span> </span><br><span class="line"><span class="comment"># root /root</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><table><thead><tr><th style="text-align:left">变量</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left"></td><td><strong>标准 AWK 变量</strong></td></tr><tr><td style="text-align:left">ARGC</td><td>命令行提供的参数的个数</td></tr><tr><td style="text-align:left">ARGV</td><td>存储命令行输入参数的数组。数组的有效索引是从 0 到 ARGC-1。</td></tr><tr><td style="text-align:left">ARGIND</td><td>命令行中当前文件的位置(从0开始算)</td></tr><tr><td style="text-align:left">CONVFMT</td><td>数据转换为字符串的格式，其默认值为 %.6g</td></tr><tr><td style="text-align:left">OFMT</td><td>数值输出的格式，它的默认值为 %.6g。</td></tr><tr><td style="text-align:left">OFS</td><td>输出域之间的分割符，其默认为空格。</td></tr><tr><td style="text-align:left">ORS</td><td>输出记录（行）之间的分割符，其默认值是换行符。</td></tr><tr><td style="text-align:left">RS</td><td>输入记录的分割符，其默认值为换行符。</td></tr><tr><td style="text-align:left">NR</td><td>表示记录编号，当awk将行作为记录时，该变量相当于当前行号。全局行数（第二个文件的第一行接着第一个文件尾行数顺序计数）</td></tr><tr><td style="text-align:left">FNR</td><td>当前文件自身的行数（不考虑前几个输入文件的自身行数及总数。NR  的值依次为：1，2……40，41，42……90。FNR的值依次为：1，2……40， 1， 2……50</td></tr><tr><td style="text-align:left">NF</td><td>表示字段数量，在处理当前记录时，相当于字段数量。默认的字段分隔符是空格。</td></tr><tr><td style="text-align:left">FS</td><td>定义分隔符，可以用在 BEGIN 语句块中，这样你就不用依靠脚本用户在命令行选项中定义字段分隔符了。</td></tr><tr><td style="text-align:left">$0</td><td>该变量包含当前记录的文本内容。</td></tr><tr><td style="text-align:left">$n</td><td>该变量包含第n个字段的文本内容。</td></tr><tr><td style="text-align:left">ENVIRON</td><td>与环境变量相关的关联数组变量，<code>awk &#39;BEGIN { print ENVIRON[&quot;USER&quot;] }&#39;</code></td></tr><tr><td style="text-align:left">FILENAME</td><td>此变量表示当前文件名称</td></tr><tr><td style="text-align:left">RLENGTH</td><td>表示 match 函数匹配的字符串长度</td></tr><tr><td style="text-align:left">RSTART</td><td>表示由 match 函数匹配的字符串的第一个字符的位置</td></tr><tr><td style="text-align:left"></td><td><strong>GNU AWK 特定的变量</strong></td></tr><tr><td style="text-align:left">IGNORECASE</td><td>GAWK将变得大小写不敏感，<code>awk &#39;BEGIN{IGNORECASE=1} /amit/&#39; marks.txt</code></td></tr></tbody></table><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><p>变量不用初始化即可使用</p><h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><p>用作数字的awk<strong>变量的默认初始值为0</strong>，所以我们不需要初始化 emp 。</p><p>这个程序使用一个变量 emp 来统计工作超过15个小时的员工的数目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$3 &gt; 15 &#123; emp = emp + 1 &#125;</span><br><span class="line">END     &#123; print emp, &quot;employees worked more than 15 hours&quot; &#125;</span><br></pre></td></tr></table></figure><p>对于第三个字段超过15的每行， emp 的前一个值加1。该程序输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 employees worked more than 15 hours</span><br></pre></td></tr></table></figure><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>awk变量可以保存数字也<strong>可以保存字符串</strong>。这个程序会找出时薪最高的员工：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 如果$2大于最大值，则更新为当前行的信息</span><br><span class="line">$2 &gt; maxrate &#123; maxrate = $2; maxemp = $1 &#125;</span><br><span class="line">END &#123; print &quot;highest hourly rate:&quot;, maxrate, &quot;for&quot;, maxemp &#125;</span><br></pre></td></tr></table></figure><h4 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h4><p>awk 中其实并不存在数组类型，所谓的关联数组是一种使用字符串作为索引的字典。因此并不是 <code>[&quot;value1&quot;, &quot;value2&quot;]</code>这样，而是<code>{0: &quot;value1&quot;, 1: &quot;value2&quot;}</code>。在awk中数组之间是无序的，一个数组的key值是数值，例如1，2，3，并不代表该数组元素在数组中的出现的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123;nam[$1]=$5&#125; END &#123;for &#123;i in nam&#125;  &#123;print i,nam[i]&#125;&#125;'</span> /etc/passwd </span><br><span class="line"><span class="comment"># root root </span></span><br><span class="line"><span class="comment"># ftp FTP User </span></span><br><span class="line"><span class="comment"># userj Joe User</span></span><br></pre></td></tr></table></figure><p><strong>判断一个元素是否在数组中</strong></p><p>awk 支持<code>in</code>操作，但是<code>in</code> 判断的是键 <code>key</code>，awk 自身是没有判断是否在值<code>value</code>中的方法。</p><p>因此为了实现判断是否在数组中，要将<code>value</code>转为<code>key</code>，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    split(<span class="string">"value1 value2"</span>, valuesAsValues)</span><br><span class="line">    <span class="comment"># valuesAsValues = &#123;0: "value1", 1: "value2"&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> valuesAsValues) valuesAsKeys[valuesAsValues[i]] = <span class="string">""</span></span><br><span class="line">    <span class="comment"># valuesAsKeys = &#123;"value1": "", "value2": ""&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now you can use `in`</span></span><br><span class="line">(<span class="variable">$1</span> <span class="keyword">in</span> valuesAsKeys) &#123;<span class="built_in">print</span>&#125;</span><br></pre></td></tr></table></figure><p>一行的写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"A:B:C:D:E:F"</span> | tr <span class="string">':'</span> <span class="string">'\n'</span> | \</span><br><span class="line">awk <span class="string">'BEGIN&#123; split("A D F", parts); for (i in parts) dict[parts[i]]=""&#125;  $1 in dict'</span></span><br></pre></td></tr></table></figure><p><strong>遍历数组</strong></p><p>awk支持列表形式的<strong><code>for</code>循环</strong>，是对 key 进行遍历，然后显示出数组的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> array) &#123; <span class="built_in">print</span> array[k]; &#125;</span><br></pre></td></tr></table></figure><p><strong>数组排序</strong></p><p>使用 asort 完成数组元素的排序，或者使用 asorti 实现数组索引的排序等等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits[<span class="string">"mango"</span>]=<span class="string">"yellow"</span>;</span><br><span class="line">fruits[mango]=<span class="string">"yellow"</span>; <span class="comment"># 这种写法也可以</span></span><br><span class="line">value必须加双引号</span><br><span class="line"></span><br><span class="line">delete array_name[index]</span><br></pre></td></tr></table></figure><p><strong>删除数组元素</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete arr[key]</span><br></pre></td></tr></table></figure><p>例子：<strong>按行逆序打印</strong></p><p>第一个动作将输入行存为数组 line 的连续元素；即第一行放在 line[1] ，第二行放在 line[2] , 依次继续。 END 动作使用一个 while 语句从后往前打印数组中的输入行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 反转 - 按行逆序打印输入</span><br><span class="line">    &#123; line[NR] = $0 &#125;  # 记下每个输入行</span><br><span class="line">END &#123; i = NR           # 逆序打印</span><br><span class="line">      while (i &gt; 0) &#123;</span><br><span class="line">        print line[i]</span><br><span class="line">        i = i - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以 emp.data 为输入，输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Susie    4.25   18</span><br><span class="line">Mary     5.50   22</span><br><span class="line">Mark     5.00   20</span><br><span class="line">Kathy    4.00   10</span><br><span class="line">Dan      3.75   0</span><br><span class="line">Beth     4.00   0</span><br></pre></td></tr></table></figure><h4 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h4><p>借助选项<code>-v</code>，我们可以将一个外部值（并非来自stdin）传递给awk：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VAR=10000  </span><br><span class="line">echo | awk -v VARIABLE=$VAR &apos;&#123; print VARIABLE &#125;&apos;  [filename]</span><br><span class="line"># 10000</span><br></pre></td></tr></table></figure><blockquote><p>  gawk 程序在引用变量值时并未像shell脚本一样使用美元符。</p></blockquote><p><strong>可以不用加引号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk -v name=<span class="string">"Jerry"</span> <span class="string">'&#123;print name&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> | awk -v name=Jerry <span class="string">'&#123;print name&#125;'</span>    <span class="comment"># 等价   </span></span><br><span class="line"><span class="built_in">echo</span> | awk -v path=<span class="variable">$PATH</span> <span class="string">'&#123;print path&#125;'</span>    <span class="comment"># 如果是环境变量，需要添加$</span></span><br></pre></td></tr></table></figure><p>可以将<strong>多个</strong>外部变量传递给awk。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1=<span class="string">"Variable1"</span></span><br><span class="line">var2=<span class="string">"Variable2"</span></span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123; print v1,v2 &#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line"><span class="comment"># Variable1 Variable2</span></span><br></pre></td></tr></table></figure><p>在上面的方法中，变量以键值对的形式给出，使用空格分隔（<code>v1=$var1 v2=$var2</code>），作为awk 的命令行参数紧随在<code>BEGIN</code>、<code>{}</code>和<code>END</code>语句块之后。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><a href="https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html" target="_blank" rel="noopener">https://doc.yonyoucloud.com/doc/wiki/project/awk/operators.html</a></p><p>基本与C语言的操作相同</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">= += -= *= /= %= ^= **=</td><td style="text-align:left">赋值</td></tr><tr><td style="text-align:left">?:</td><td style="text-align:left">C条件表达式</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">\</td><td></td><td>逻辑或</td></tr><tr><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">逻辑与</td></tr><tr><td style="text-align:left">~ ~!</td><td style="text-align:left">匹配正则表达式和不匹配正则表达式</td></tr><tr><td style="text-align:left">&lt; &lt;= &gt; &gt;= != ==</td><td style="text-align:left">关系运算符</td></tr><tr><td style="text-align:left">空格</td><td style="text-align:left">拼接字符串</td></tr><tr><td style="text-align:left">+ –</td><td style="text-align:left">加，减</td></tr><tr><td style="text-align:left">* / %</td><td style="text-align:left">乘，除与求余</td></tr><tr><td style="text-align:left">+ – !</td><td style="text-align:left">一元加，减和逻辑非</td></tr><tr><td style="text-align:left">^ ***</td><td style="text-align:left">求幂</td></tr><tr><td style="text-align:left">++ —</td><td style="text-align:left">增加或减少，作为前缀或后缀</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">字段引用</td></tr><tr><td style="text-align:left">in</td><td style="text-align:left">字典成员</td></tr></tbody></table><p><code>+=</code>, 等于<code>==</code>，不等于<code>!=</code></p><p>逻辑与运算符为 &amp;&amp;。逻辑或运算符为 ||。逻辑非 ! 。</p><p>逻辑非将 expr1 的真值取反。如果 expr1 为真，则返回 0。否则返回 1。下面的示例判断字符串是否为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; name = &quot;&quot;; if (! length(name)) print &quot;name is empty string.&quot; &#125;&apos;</span><br></pre></td></tr></table></figure><p>三元运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; a = 10; b = 20; (a &gt; b) ? max = a : max = b; print &quot;Max =&quot;, max&#125;&apos;</span><br></pre></td></tr></table></figure><p>字符串连接操作符</p><p>空格 (space) 操作符可以完成两个字符串的连接操作。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; str1=&quot;Hello, &quot;; str2=&quot;World&quot;; str3 = str1 str2; print str3 &#125;&apos;</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure><p>数组成员操作符</p><p>数组成员操作符为 in。该操作符用于访问数组元素 。下面的示例用于此操作符输出数组中所有元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123; arr[0] = 1; arr[1] = 2; arr[2] = 3; for (i in arr) printf &quot;arr[%d] = %d\n&quot;, i, arr[i] &#125;&apos;</span><br><span class="line"></span><br><span class="line">arr[0] = 1</span><br><span class="line">arr[1] = 2</span><br><span class="line">arr[2] = 3</span><br></pre></td></tr></table></figure><p>awk中并没有数组对象，其实是字典，因此<code>i</code> 遍历的是arr的key，而不是value</p><p>匹配（Match）</p><p>匹配运算符为 ~。不匹配操作符为 !~。 它用于搜索包含匹配模式字符串的域。下面的示例中将输出包括 9 的行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;$0 ~ 9&apos; marks.txt    # 这种写法只对数字有效，如果是字母，就会失效</span><br><span class="line">[jerry]$ awk &apos;$0 ~ /9/&apos; marks.txt  # 推荐正则写法</span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><blockquote><p>  仅可以在动作中使用</p></blockquote><p>一定要加<code>{}</code>与其他语言一样的用法，括号内的为同一语句块</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">    action-1</span><br><span class="line">    action-1</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    action-n</span><br><span class="line">&#125;</span><br><span class="line">else if (a == 30)</span><br><span class="line">  print &quot;a = 30&quot;;</span><br><span class="line">else</span><br><span class="line">  print &quot;a = 30&quot;;</span><br></pre></td></tr></table></figure><p>例子：将每隔几行就拼接在一起输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"cat\nbat\nfun\nfin\nfan\nend"</span> | awk <span class="string">'&#123;str=str $0&#125;;NR %2==0&#123;print str;str=""&#125;'</span></span><br></pre></td></tr></table></figure><p>if-else 语句中，if 后的条件会被计算。如果为真，执行第一个 print 语句。否则，执行第二个 print 语句。注意我们可以使用一个逗号将一个长语句截断为多行来书写。</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>一个 while 语句有一个条件和一个执行体。条件为真时执行体中的语句会被重复执行。这个程序使用公式 value=amount(1+rate)yearsvalue=amount(1+rate)years</p><p>来演示以特定的利率投资一定量的钱，其数值是如何随着年数增长的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># interest1 - 计算复利</span><br><span class="line">#   输入: 钱数    利率    年数</span><br><span class="line">#   输出: 复利值</span><br><span class="line"></span><br><span class="line">&#123;   i = 1</span><br><span class="line">    while (i &lt;= $3) &#123;</span><br><span class="line">        printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">        i = i + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件是 while 后括弧包围的表达式；循环体是条件后大括号包围的两个表达式。 printf 规格字符串中的 \t 代表制表符； ^ 是指数操作符。从 # 开始到行尾的文本是注释，会被awk忽略，但能帮助程序的读者理解程序做的事情。</p><p>你可以为这程序输入三个一组的数字，看看不一样的钱数、利率、以及年数会产生什么。例如，如下事务演示了1000美元，利率为6%与12%，5年的复利分别是如何增长的：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ awk -f interest1</span><br><span class="line">1000 .06 5</span><br><span class="line">        1060.00</span><br><span class="line">        1123.60</span><br><span class="line">        1191.02</span><br><span class="line">        1262.48</span><br><span class="line">        1338.23</span><br><span class="line">1000 .12 5</span><br><span class="line">        1120.00</span><br><span class="line">        1254.40</span><br><span class="line">        1404.93</span><br><span class="line">        1573.52</span><br><span class="line">        1762.34</span><br></pre></td></tr></table></figure><h4 id="do-while"><a href="#do-while" class="headerlink" title="do -while"></a>do -while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;i = 1; do &#123; print i; ++i &#125; while (i &lt; 6) &#125;&apos;</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p> for ，将大多数循环都包含的初始化、测试、以及自增压缩成一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; for (i = 1; i &lt;= $3; ++i)</span><br><span class="line">    printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 i = 1 只执行一次。接下来，测试条件 i &lt;= $3 ；如果为真，则执行循环体的 printf 语句。循环体执行结束后执行自增 i = i + 1 ，接着由另一次条件测试开始下一个循环迭代。代码更加紧凑，并且由于循环体仅是一条语句，所以不需要大括号来包围它。</p><h4 id="跳出循环（break、continue、exit、next）"><a href="#跳出循环（break、continue、exit、next）" class="headerlink" title="跳出循环（break、continue、exit、next）"></a>跳出循环（break、continue、exit、next）</h4><p>break、continue、exit都支持</p><p>next </p><p>等价于<code>continue</code>,next 停止处理当前记录，并且进入到下一条记录的处理过程。下面的例子中，当模式串匹配成功后程序并不执行任何操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;if ($0 ~/Shyam/) next; print $0&#125;'</span> marks.txt</span><br></pre></td></tr></table></figure><p>nextfile</p><p>nextfile 停止处理当前文件，从下一个文件第一个记录开始处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; if ($0 ~ /file1:str2/) nextfile; print $0 &#125;'</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><a href="https://man.linuxde.net/awk" target="_blank" rel="noopener"><a href="https://man.linuxde.net/awk" target="_blank" rel="noopener">更多的函数说明</a></a></p><h4 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h4><h5 id="match"><a href="#match" class="headerlink" title="match"></a>match</h5><p>返回正则表达式在字符串 str 中第一个最长匹配的位置。如果能够找到，返回非0值；否则，返回0。match()有两个<strong>相关的特殊变量</strong>，分别是<code>RSTART</code>和<code>RLENGTH</code>。变量<code>RSTART</code>包含了匹配内容的起始位置，而变量<code>RLENGTH</code>包含了匹配内容的长度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "One Two Three"</span></span><br><span class="line"><span class="string">    subs = "Two"</span></span><br><span class="line"><span class="string">    ret = match(str, subs)</span></span><br><span class="line"><span class="string">    printf "Substring \"%s\" found at %d location.\n", subs, ret</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Substring "Two" found at 5 location.</span></span><br></pre></td></tr></table></figure><h5 id="asort-数组排序"><a href="#asort-数组排序" class="headerlink" title="asort 数组排序"></a>asort 数组排序</h5><p>asort(arr,[, d [,how] ])</p><p>asort 函数使用 GAWK 值比较的一般规则排序 arr 中的value，然后用以 1 开始的有序整数替换排序内容的索引。</p><p>大写的会排在前面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;</span><br><span class="line">    arr[0] = &quot;Three&quot;</span><br><span class="line">    arr[1] = &quot;One&quot;</span><br><span class="line">    arr[2] = &quot;two&quot;</span><br><span class="line"></span><br><span class="line">    print &quot;Array elements before sorting:&quot;</span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asort(arr)</span><br><span class="line"></span><br><span class="line">    print &quot;Array elements after sorting:&quot;</span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><h5 id="asorti-数组排序"><a href="#asorti-数组排序" class="headerlink" title="asorti 数组排序"></a>asorti 数组排序</h5><p>asorti(arr,[, d [,how] ])</p><p>asorti 函数的行为与 asort 函数的行为很相似，二者的差别在于 aosrt 对数组的value排序，而 asorti 对数组的index排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    arr["Two"] = 1</span></span><br><span class="line"><span class="string">    arr["One"] = 2</span></span><br><span class="line"><span class="string">    arr["Three"] = 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    asorti(arr)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    print "Array indices after sorting:"</span></span><br><span class="line"><span class="string">    for (i in arr) &#123;</span></span><br><span class="line"><span class="string">        print arr[i]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h5 id="sub、gsub-替换"><a href="#sub、gsub-替换" class="headerlink" title="sub、gsub 替换"></a>sub、gsub 替换</h5><p>sub</p><p>将正则表达式regex匹配到的第一处内容<strong>替换</strong>成replacment_str。</p><p>gsub(regx,sub, string)</p><p>gsub 是全局替换( global substitution )的缩写。它将出现的子串（sub）替换为 regx。第三个参数 string 是可选的，<strong>默认值为 $0</strong>，表示在整个输入记录中搜索子串。进行一次替换的有sub(regex,sub,string)函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "Hello, World"</span></span><br><span class="line"><span class="string">    print "String before replacement = " str</span></span><br><span class="line"><span class="string">    gsub("World", "Jerry", str)</span></span><br><span class="line"><span class="string">    print "String after replacement = " str</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h5 id="index-判断子串包含"><a href="#index-判断子串包含" class="headerlink" title="index 判断子串包含"></a>index 判断子串包含</h5><p>index(str,sub)</p><p>index 函数用于检测字符串 sub 是否是 str 的子串。如果 sub 是 str 的子串，则返回子串 sub 在字符串 str 的开始位置；若不是其子串，则返回 0。str 的字符位置索引从 1 开始计数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "One Two Three"</span></span><br><span class="line"><span class="string">    subs = "Two"</span></span><br><span class="line"><span class="string">    ret = index(str, subs)</span></span><br><span class="line"><span class="string">    printf "Substring \"%s\" found at %d location.\n", subs, ret</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h5 id="split-分割字符串"><a href="#split-分割字符串" class="headerlink" title="split 分割字符串"></a>split 分割字符串</h5><p><code>split(str, arr, regex)</code></p><p>split 函数使用正则表达式 regex 分割字符串 str。分割后的所有结果存储在数组 arr 中。如果没有指定 regex 则使用 FS 切分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk &apos;BEGIN &#123;</span><br><span class="line">    str = &quot;One,Two,Three,Four&quot;</span><br><span class="line"></span><br><span class="line">    split(str, arr, &quot;,&quot;)</span><br><span class="line"></span><br><span class="line">    print &quot;Array contains following values&quot;</span><br><span class="line"></span><br><span class="line">    for (i in arr) &#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><h5 id="substr-字符串截取"><a href="#substr-字符串截取" class="headerlink" title="substr 字符串截取"></a>substr 字符串截取</h5><p><code>substr(str, start, length)</code></p><p>substr 函数返回 str 字符串中从第 start 个字符开始长度为 length 的子串。如果没有指定 length 的值，返回 str 从第 start 个字符开始的后缀子串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    str = "Hello, World !!!"</span></span><br><span class="line"><span class="string">    subs = substr(str, 1, 5)</span></span><br><span class="line"><span class="string">    print "Substring = " subs</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Substring = Hello</span></span><br></pre></td></tr></table></figure><h5 id="strtonum字符串转数字"><a href="#strtonum字符串转数字" class="headerlink" title="strtonum字符串转数字"></a>strtonum字符串转数字</h5><p>strtonum(str)</p><p>strtonum 将字符串 str 转换为数值。 如果字符串以 0 开始，则将其当作八进制数；如果字符串以 0x 或 0X 开始，则将其当作十六进制数；否则，将其当作浮点数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[jerry]$ awk <span class="string">'BEGIN &#123;</span></span><br><span class="line"><span class="string">    print "Decimal num = " strtonum("123")</span></span><br><span class="line"><span class="string">    print "Octal num = " strtonum("0123")</span></span><br><span class="line"><span class="string">    print "Hexadecimal num = " strtonum("0x123")</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line">Decimal num = 123</span><br><span class="line">Octal num = 83</span><br><span class="line">Hexadecimal num = 291</span><br></pre></td></tr></table></figure><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><p><code>tolower(str)</code>、<code>toupper(str)</code></p><p>将字符串 str 进行大小写字母转换，然后返回。注意，字符串 str 本身不被改变。</p><h4 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h4><p>getline：得到行，但是注意，<strong>得到的并不是当前行，而是当前行的下一行</strong>。原因如下：</p><p>从整体上来说，应这么理解它的用法：</p><ul><li><p><code>getline var</code> 读取一行内容给 <code>var</code>，没有变量时等价于 <code>getline $0</code></p></li><li><p>当其左右无重定向符 | 或 &lt; 时，getline作用于当前文件，读入当前文件的一行给其后跟的变量  <code>var</code> 或<code>$0</code>（无变量时）；由于<code>awk</code>在处理<code>getline</code>之前已经读入了一行，所以<code>getline</code>得的是下一行（第二行开始）。</p></li><li><p>当其左右有重定向符 | 或 &lt; 时，<code>getline</code>则作用于定向输入文件（用重定向符从另外一个文件中读取内容、管道符号获得UNIX命令的输出）赋值给<code>$0</code> 或<code>getline</code>后面的变量。由于该文件是刚打开，并没有被<code>awk</code>读入一行，那么<code>getline</code>返回的是该文件的第一行，而不是隔行，并赋值。</p><blockquote><p>  <code>getline</code> 会记住重定向的文件读取到哪一行了，并不会重复执行<code>getline var &lt; file</code>  重复读取文件，而是一次读取一行</p></blockquote></li><li><p><code>getline</code>执行后会更新<code>NF</code>，<code>NR</code>，<code>FNR</code>等这些内部变量。</p></li></ul><p>例子：</p><p>比较 <code>getline</code>后有无变量的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 显示奇数</span><br><span class="line">$ seq 10 | awk &apos;&#123;getline var;  print $0&#125;&apos;  # getline var 后，内部变量不变，因此$0仍然是第1行</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line"># 显示偶数</span><br><span class="line">$ seq 10 | awk &apos;&#123;getline;  print $0&#125;&apos;   # getline 等价于 getline $0 ，处理getline之前$0是第一行，因此$0变为第2行</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>同时读取2个文件，不用担心<code>getline &lt; &quot;b.txt&quot;</code>重复读取文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;&#123;printf &quot;%s &quot;, $0; getline &lt; &quot;b.txt&quot;; print $0&#125;&apos; a.txt </span><br><span class="line"># 记住 getline 等价于 getline $0 ，因此$0变成了 b 文件的内容</span><br><span class="line">1 6</span><br><span class="line">2 7</span><br><span class="line">3 8</span><br><span class="line">4 9</span><br><span class="line">5 10</span><br><span class="line"></span><br><span class="line"># 交替打印</span><br><span class="line">awk &apos;&#123;getline var &lt; &quot;a.txt&quot;;print var;print $0&#125;&apos; b.txt   # var 是文件a的行，$0是文件b的内容</span><br></pre></td></tr></table></figure><p>获取命令输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;&quot;date&quot; | getline; close(&quot;date&quot;); print $0&#125;&apos;</span><br><span class="line">Tue May 10 07:50:51 PDT 2016</span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> find_min(num1, num2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2)</span><br><span class="line">    <span class="built_in">return</span> num1</span><br><span class="line">  <span class="built_in">return</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Script execution starts here</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">  main(10, 20) <span class="comment"># 使用自定义函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> awk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux shell编程</title>
      <link href="/2019/08/13/linux-shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/08/13/linux-shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><p>在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。 这个shell程序被称为子shell（child shell）。</p><p>在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中。这会对包括变量在内的一些东西造成影响。</p><h4 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h4><p>可以在一行内指定依次运行的一系列指令，通过<strong>命令列表</strong>来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> ; ls ; <span class="built_in">cd</span> /etc ; <span class="built_in">pwd</span> ; <span class="built_in">cd</span> ; <span class="built_in">pwd</span> ; ls</span><br></pre></td></tr></table></figure><p>命令列表要想成为<strong>进程列表</strong>，这些命令必须包含在括号里。括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令。</p><blockquote><p>  进程列表是一种命令分组（command grouping） 。另一种命令分组是将命令放入花括号中， 并在命令列表尾部加上分号（;）。语法为 <code>{ command; }</code>但是不会像进程列表那样创建出子shell。</p></blockquote><p>要想知道是否生成了子shell，得借助一个使用了环境变量的命令<code>echo $BASH_SUBSHELL</code>。如果该命令返回0，就表明没有子shell。如果返回 1或者其他更大的数字，就表明存在子shell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> ;  <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span></span><br><span class="line">/Users/admin</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">$ &#123; <span class="built_in">pwd</span> ; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>; &#125;</span><br><span class="line">/Users/admin</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">$ (<span class="built_in">pwd</span> ; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>)</span><br><span class="line">/Users/admin</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">$ ( <span class="built_in">pwd</span> ; (<span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>))</span><br><span class="line">/Users/admin</span><br><span class="line">2</span><br></pre></td></tr></table></figure><blockquote><p>  在shell脚本中，经常使用子shell进行多进程处理。但是采用子shell的成本不菲，会明显拖慢处理速度。</p><p>  在交互式的CLI shell会话中，子shell同样存在问题。它并<strong>非真正的多进程</strong>处理，因为终端控制着子shell的I/O。</p><p>  在CLI中运用子shell的创造性方法之一就是将进程列表置入<strong>后台模式</strong>。你既可以在子shell中 进行繁重的处理工作，同时也不会让子shell的I/O受制于终端。</p></blockquote><h4 id="高效子进程"><a href="#高效子进程" class="headerlink" title="高效子进程"></a>高效子进程</h4><h5 id="后台模式"><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 3000&amp; </span><br><span class="line">[1] 2396</span><br></pre></td></tr></table></figure><p>在命令末尾加上字符<code>&amp;</code>，在shell CLI提示符返回之前，会出现一条信息，代表后台作业（background job）号（1）与后台作业的进程ID（2396）。</p><p>可以通过<code>ps -f</code> 或者 <code>jobs -l</code> 来查看</p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>协程 协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。 要进行协程处理，得使用coproc命令，还有要在子shell中执行的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coproc sleep 10</span><br><span class="line">coproc My_Job &#123; sleep 10; &#125; # 指定协程名</span><br></pre></td></tr></table></figure><blockquote><p>  通过使用扩展语法，协程的名字被设置成My_Job。这里要注意的是，扩展语法写起来有点 麻烦。必须确保在第一个花括号<code>{</code>和命令名之间有一个空格。还必须保证命令以分号<code>;</code>结 尾。另外，分号和闭花括号<code>}</code>之间也得有一个空格。</p></blockquote><h4 id="理解-shell-的内建命令"><a href="#理解-shell-的内建命令" class="headerlink" title="理解 shell 的内建命令"></a>理解 shell 的内建命令</h4><h5 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h5><p>外部命令，是存在于bash shell之外的程序。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。</p><p>当外部命令执行时，会创建出一个子进程。这种操作被称为<strong>衍生</strong>（forking）。</p><p>当进程必须执行衍生操作时，它需<strong>要花费时间和精力来设置新子进程的环境</strong>。所以说，外部 命令多少还是有代价的。</p><h5 id="内部命令"><a href="#内部命令" class="headerlink" title="内部命令"></a>内部命令</h5><p>内建命令和外部命令的区别在于前者<strong>不需要使用子进程来执行</strong>。它们已经和shell编译成了一 体，作为shell工具的组成部分存在。比如cd和exit</p><p>利用<code>type</code>命令来了解某个命令是否是内建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ type cd</span><br><span class="line">cd is a shell builtin</span><br></pre></td></tr></table></figure><p>有些命令有多种实现。例如echo和pwd既有内建命令也有外部命令，要查看命令的不同实现，使用type命令的-a选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ type -a echo </span><br><span class="line">echo is a shell builtin </span><br><span class="line">echo is /bin/echo</span><br></pre></td></tr></table></figure><p>要使用外部命令 <code>pwd</code> ，可以输入<code>/bin/pwd</code> 。</p><h5 id="内部命令-history"><a href="#内部命令-history" class="headerlink" title="内部命令 history"></a>内部命令 history</h5><p>设置保存在bash历史记录中的命令数。要想实现这一点，你需要修改名为 <code>HISTSIZE</code> 的环境变量</p><p>输入<code>!!</code>可以重新执行上一条命令，<code>!编号</code>即可执行历史列表中的对应编号的命令</p><p>bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件<code>~/.bash_history</code>中。</p><p><code>~/.bash_history</code>文件只有在打开首个终端会话时才会被读取。</p><p>可以在退出shell会话之前强制将命令历史记录写入<code>.bash_history</code>文件。要实现强制写入，需要使用<code>history -a</code></p><p>要想强制重新读 取.bash_history文件，更新终端会话的历史记录，可以使用 <code>history -n</code> 命令。</p><h5 id="内部命令-alias"><a href="#内部命令-alias" class="headerlink" title="内部命令 alias"></a>内部命令 alias</h5><p>要查看当前可用 的别名，使用<code>alias</code>或者<code>alias -p</code>。</p><p>使用alias命令创建属于自己的别名。</p><p><code>alias li=&#39;ls -li&#39;</code></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的 shell可见。</p><p>查看环境变量的命令有<code>set</code>、<code>env</code>、<code>printenv</code></p><blockquote><p>  它们的区别：</p><p>  set 命令会显示出全局变量、局部变量以 及用户定义变量。它还会按照字母顺序对结果进行排序。</p><p>  env 和 printenv 命令不会对变量排序，也不会输出局部变量和用户定义变量。</p><p>  TODO env 与 printenv</p></blockquote><p>要显示个别环境变量的值，可以使用<code>printenv</code> 或者 <code>echo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ printenv HOME </span><br><span class="line">/home/Christine</span><br><span class="line"></span><br><span class="line">$ echo $HOME </span><br><span class="line">/home/Christine</span><br></pre></td></tr></table></figure><h5 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h5><p>变量名区分大小写。所有的环境变量名均使用大写字母，自己创建的局 部变量或是shell脚本，请使用小写字母。</p><p>赋值时不能有空格的原因：</p><p>记住，变量名、等号和值之间没有空格，这一点非常重要。如果在赋值表达式中加上了空格， bash shell就会把值当成一个单独的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable = &quot;Hello World&quot; </span><br><span class="line">-bash: my_variable: command not found</span><br></pre></td></tr></table></figure><h5 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h5><p>创建全局环境变量的方法是先创建一个局部环境变量，然后通过<code>export</code>命令把它导出到全局环境中。变量名前面不需要加$。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=&quot;I am Global now&quot; </span><br><span class="line">$ my_variable2=&quot;I am Global now&quot; </span><br><span class="line">$ export my_variable my_variable2  # 可以同时导出多个变量</span><br></pre></td></tr></table></figure><p>修改子shell中全局环境变量并<strong>不会影响到父shell中该变量的值</strong>。这种改变仅在子shell中有效，并不会被反映到父shell中。甚至无法使用export命令改变父shell中全局环境变量的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=<span class="string">"I am Global now"</span> </span><br><span class="line">$ <span class="built_in">export</span> my_variable </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> I am Global now </span><br><span class="line">$ </span><br><span class="line"><span class="variable">$bash</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$ </span><br><span class="line">$ my_variable=<span class="string">"Null"</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">export</span> my_variable  <span class="comment"># 导出变量也没用</span></span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span></span><br><span class="line">Null </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">exit</span> </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$</span><br></pre></td></tr></table></figure><h5 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h5><p>记住不要使用$。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset my_variable</span><br></pre></td></tr></table></figure><p>在处理<strong>全局环境变量</strong>时，如果你是在子进程中删除了一个全局环境变量， 这只对子进程有效。该全局环境变量在<strong>父进程中依然可用</strong>。</p><h5 id="什么时候变量前加"><a href="#什么时候变量前加" class="headerlink" title="什么时候变量前加`"></a>什么时候变量前加`</h5><p>记住一点就行了：如果要用到变量，使用<code>$</code>；如果要操作变量，不使用<code>$</code>。这条规则的一个例外就是使用 printenv 显示某个变量的值。</p><h5 id="shell-配置文件"><a href="#shell-配置文件" class="headerlink" title="shell 配置文件"></a>shell 配置文件</h5><p>启动bash shell有3种方式：</p><ul><li><p>登录时作为默认登录shell</p></li><li><p>作为非登录shell的交互式shell </p></li><li><p>作为运行脚本的非交互shell</p></li></ul><h6 id="登录-shell"><a href="#登录-shell" class="headerlink" title="登录 shell"></a>登录 shell</h6><p>当你登录Linux系统时，bash shell会作为登录shell启动。（对于没有图形化界面来说）</p><p>登录shell会从5个不同的启动文件里 读取命令：</p><ul><li>/etc/profile ——&gt;会去读取<code>/etc/profile.d</code>目录下的配置文件</li><li>$HOME/.bash_profile </li><li>$HOME/.bashrc </li><li>$HOME/.bash_login </li><li>$HOME/.profile</li></ul><p>$HOME目录下的启动文件 </p><p>剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环 境变量。大多数Linux发行版只用这四个启动文件中的1、2个：</p><ul><li>$HOME/.bash_profile  </li><li>$HOME/.bashrc</li><li>$HOME/.bash_login</li><li>$HOME/.profile</li></ul><p>shell会按照按照下列顺序，运行第一个被找到的文件，忽略其他文件：</p><ul><li>$HOME/.bash_profile  </li><li>$HOME/.bash_login</li><li>$HOME/.profile</li></ul><p>这个列表中没有<code>$HOME/.bashrc</code>文件是因为该文件<strong>通常通过其他文件运行</strong>的。比如 <code>.bash_profile</code>会先去检查HOME目录中是不是还有一个叫<code>.bashrc</code>的启动文件。如果有的话，会先执行启动文件里面的命令。因此<code>.bashrc</code>顺序最先，但是并不是优先级最高，因为<code>.bash_profile</code>设置的变量会覆盖 <code>.bashrc</code> 中的变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile </span></span><br><span class="line"><span class="comment"># Get the aliases and functions </span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span> </span><br><span class="line">. ~/.bashrc </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="comment"># User specific environment and startup programs </span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin </span><br><span class="line"><span class="built_in">export</span> PATH </span><br><span class="line">$</span><br></pre></td></tr></table></figure><h6 id="交互式-shell-进程"><a href="#交互式-shell-进程" class="headerlink" title="交互式 shell 进程"></a>交互式 shell 进程</h6><p>如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那 么你启动的shell叫作交互式shell。</p><p>作为交互式shell启动的，就<strong>不会访问<code>/etc/profile</code>文件</strong>，只会检查用户HOME目录中的<code>.bashrc</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># .bashrc # Source global definitions </span><br><span class="line">if [ -f /etc/bashrc ]; then </span><br><span class="line">. /etc/bashrc </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># User specific aliases and functions</span><br></pre></td></tr></table></figure><p><code>.bashrc</code>文件有两个作用：</p><ol><li>查看/etc目录下通用的bashrc文件</li><li>为用户提供一个定制自 己的命令别名和私有脚本函数的地方。</li></ol><h6 id="非交互式-shell"><a href="#非交互式-shell" class="headerlink" title="非交互式 shell"></a>非交互式 shell</h6><p>系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。</p><blockquote><p>  脚本能以不同的方式执行。只有其中的某一些方式能够启动子shell。</p></blockquote><p>bash shell提供了BASH_ENV环境变量。当shell启动一个非交互式shell进 程时，它会检查BASH_ENV来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。</p><p>但是 CentoS 与 Ubuntu 都没有该变量，shell脚本到哪里去获得它们的环境变量呢？</p><ul><li>有些 shell脚本是通过启动一个子shell来执行的。子shell可以继承父shell导出过的变量。</li><li>对于那些不启动子shell的脚本， 变量已经存在于当前shell中了。 所以就算没有设置 BASH_ENV，也可以使用当前shell的局部变量和全局变量。</li></ul><h5 id="环境变量持久化"><a href="#环境变量持久化" class="headerlink" title="环境变量持久化"></a>环境变量持久化</h5><p>对全局环境变量来说如果将新的或修 改过的变量设置放在/etc/profile文件中，在你升级了所用的发行版， 这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。</p><p><strong>最好</strong>是在<code>/etc/profile.d</code>目录中创建一个以<code>.sh</code>结尾的文件。把所有新的或修改过的全局环境变 量设置放在这个文件中。</p><p>在大多数发行版中，存储个人用户永久性bash shell变量的地方是<code>~/.bashrc</code>文件。这一点适用于所有类型的shell进程。 但如果设置了 BASH_ENV 变量， 那么记住， 除非它指向的是<code>~/.bashrc</code>，否则你应该将非交互式shell的用户变量放在别的地方。</p><h4 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h4><p>在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：</p><p><code>!/bin/bash</code></p><p>在通常的shell脚本中，井号（#）用作注释行。然而， shell脚本文件的第一行是个例外。</p><h4 id="日期date"><a href="#日期date" class="headerlink" title="日期date"></a>日期date</h4><p>TODO </p><p><code>date +%y%m%d</code></p><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><p>默认情况下，不需要使用引号将要显示的文本字符串划定出来</p><p>可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在 文本中使用其中一种引号，而用另外一种来将字符串划定起来。</p><p>不换行<code>echo -n &quot;The time and date are: &quot;</code></p><blockquote><p>  单引号：</p><p>  双引号：</p></blockquote><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h5><p>在 shell 中<code>set</code>命令来显示一份完整的当前环境变量列表</p><p>在脚本中，你可以在环境变量名称之前加上美元符<code>$</code>来使用这些环境变量，或者<code>${variable}</code> 形式引用的变量。变量名两侧额外的花括号通常用来帮助识别美元符后的变量名</p><h5 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h5><ul><li><p>由字母、数字或下划线组成的文本字符串，长度不超过20个</p></li><li><p>用户变量 区分大小写</p></li><li>使用等号将值赋给用户变量。在变量、等号和值之间<strong>不能出现空格</strong></li><li>在shell脚本结束时会被删除掉</li><li>用户变量可通过美元符引用</li></ul><h5 id="变量拼接"><a href="#变量拼接" class="headerlink" title="变量拼接"></a>变量拼接</h5><p>直接将两个变量写在一起就是拼接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1=1</span><br><span class="line">var2=2</span><br><span class="line">var=<span class="variable">$var1</span><span class="variable">$var2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span>=12</span><br></pre></td></tr></table></figure><h5 id="命令输出赋给变量、命令替换"><a href="#命令输出赋给变量、命令替换" class="headerlink" title="命令输出赋给变量、命令替换"></a>命令输出赋给变量、命令替换</h5><ul><li>反引号字符（`）</li><li><code>$()</code>格式</li></ul><blockquote><p>   原理：命令替换会创建一个子shell来运行对应的命令。子shell（ subshell）是由运行该脚本的shell 所创建出来的一个独立的子shell（child shell） 。正因如此，由该子shell所执行命令是无法 使用脚本中所创建的变量的。</p></blockquote><p>TODO 没明白</p><p>在命令行提示符下使用路径 ./ 运行命令的话，也会创建出子shell；要是运行命令的时候 不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。 在命令行提示符下运行脚本时一定要留心！</p><h5 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h5><p>给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mytest=(one two three four five)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$mytest</span>      <span class="comment"># 打印数组只会显示第一个值</span></span><br><span class="line">one   </span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[*]&#125;</span> <span class="comment"># 显示整个数组变量，用星号作为通配符放在索引值的位置。</span></span><br><span class="line">one two three four five</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[2]&#125;</span> <span class="comment"># 根据索引取值</span></span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>unset命令删除数组中的某个值，但是要小心，这可能会有点复杂。看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">unset</span> mytest[2]  </span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;mytest[*]&#125;  <span class="comment"># 遍历时会跳过被删除的索引位置</span></span><br><span class="line">one two four five </span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[2]&#125;</span> <span class="comment"># 但是该索引位置还占用着</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;mytest[3]&#125; </span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>这个例子用unset命令删除在索引值为2的位置上的值。显示整个数组时，看起来像是索引 里面已经没这个索引了。但当专门显示索引值为2的位置上的值时，就能看到这个位置是空的。 最后，可以在unset命令后跟上数组名来删除整个数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ unset mytest   </span><br><span class="line">$ echo &#123;mytest[*]&#125;</span><br></pre></td></tr></table></figure><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>输出</p><p>覆盖原本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 正常信息写入</span><br><span class="line">2&gt; 错误信息写入</span><br><span class="line">&amp;&gt; 不论是正确还是错误信息，都写入文件中</span><br></pre></td></tr></table></figure><p>追加文本文件，多一个<code>&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 正常信息写入</span><br><span class="line">2&gt;&gt; 错误信息写入</span><br><span class="line">&amp;&gt;&gt; 不论是正确还是错误信息，都写入文件中</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;   # 输入重定向</span><br><span class="line">&lt;&lt;  # 内联输入重定向</span><br></pre></td></tr></table></figure><p>内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，你必须指定一个文本标记来划分输 入数据的开始和结尾。它的用途请看 数学运算那一章节的 bc 计算器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wc &lt;&lt; EOF</span><br><span class="line">&gt; test string 1</span><br><span class="line">&gt; test string 2</span><br><span class="line">&gt; test string 3</span><br><span class="line">&gt; EOF</span><br><span class="line">$ 3  9  42</span><br></pre></td></tr></table></figure><h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><h5 id="expr-不推荐"><a href="#expr-不推荐" class="headerlink" title="expr (不推荐)"></a>expr (不推荐)</h5><p>标准操作符在expr命令中工作得很好，但在脚本或命令行上使用它们时仍有问题出现。 许多expr命令操作符在shell中另有含义（比如星号）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ expr 5 * 2 </span><br><span class="line">expr: syntax error </span><br><span class="line"></span><br><span class="line"># 需要进行转义</span><br><span class="line">$ expr 5 \* 2</span><br></pre></td></tr></table></figure><h5 id="方括号-只支持整数"><a href="#方括号-只支持整数" class="headerlink" title="方括号(只支持整数)"></a>方括号(只支持整数)</h5><p>用<code>$[ operation ]</code>将数学表达式围起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var1=$[1 + 5]</span><br><span class="line">$ echo $var1 </span><br><span class="line"># 6</span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：bash shell数学运算符<strong>只支持整数运算</strong>。若要进行任何实际的数学计算，这是一个巨大的限制。z shell（zsh）提供了完整的浮点数算术操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var1=100</span><br><span class="line">var2=45</span><br><span class="line">var3=$[$var1 / $var2]</span><br><span class="line">echo $var3</span><br><span class="line"># 2</span><br></pre></td></tr></table></figure><h5 id="bc计算器-浮点数计算"><a href="#bc计算器-浮点数计算" class="headerlink" title="bc计算器(浮点数计算)"></a>bc计算器(浮点数计算)</h5><p><strong>命令行</strong></p><p>bash计算器支持变量print语句允许你打印 变量和数字，<code>-q</code> 命令行选项可以不显示bash计算器冗长的欢迎信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bc  -q</span><br><span class="line">res=12 * 5.4 <span class="comment"># 变量</span></span><br><span class="line"><span class="built_in">print</span> res</span><br><span class="line">64.8</span><br><span class="line">1+res</span><br><span class="line">65.8    <span class="comment"># 计算结果</span></span><br><span class="line">quit<span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><p>浮点运算是由内建变量scale控制的。必须将这个值设置为你希望在计算结果中保留的小数 位数，否则无法得到期望的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bc -q</span><br><span class="line">3.44 / 5 </span><br><span class="line">0 </span><br><span class="line">scale=4</span><br><span class="line">3.44 / 5 </span><br><span class="line">.6880 </span><br><span class="line">quit </span><br><span class="line">$</span><br></pre></td></tr></table></figure><p><strong>脚本</strong></p><p>基本格式如下：</p><p><code>variable=$(echo &quot;options; expression&quot; | bc)</code></p><ul><li><p>options 允许你设置变量。 如果你需要不止一个变量， 可以用分号将其分开</p></li><li><p>expression参数定义了通过bc执行的数学表达式</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat test10 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">var1=100 </span><br><span class="line">var2=45 </span><br><span class="line">var3=$(<span class="built_in">echo</span> <span class="string">"scale=4; <span class="variable">$var1</span> / <span class="variable">$var2</span>"</span> | bc) </span><br><span class="line"><span class="built_in">echo</span> The answer <span class="keyword">for</span> this is <span class="variable">$var3</span> </span><br><span class="line">$</span><br></pre></td></tr></table></figure><p> <strong>大量运算</strong></p><p>最好的办法是使用内联输入重定向，当然，必须用命令替换符号标识出用来给变量赋值的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat test12</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">var1=10.46</span><br><span class="line">var2=43.67</span><br><span class="line">var3=33.2</span><br><span class="line">var4=71</span><br><span class="line">var5=$(bc &lt;&lt; EOF </span><br><span class="line">scale = 4 </span><br><span class="line">a1 = ( <span class="variable">$var1</span> * <span class="variable">$var2</span>) </span><br><span class="line">b1 = (<span class="variable">$var3</span> * <span class="variable">$var4</span>) </span><br><span class="line">a1 + b1 </span><br><span class="line">EOF </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> The final answer <span class="keyword">for</span> this mess is <span class="variable">$var5</span> </span><br><span class="line">s$</span><br></pre></td></tr></table></figure><p>你可以在bash计算器中赋值给变量。这一点很重要：在bash 计算器中创建的变量只在bash计算器中有效，<strong>不能在shell脚本中使用</strong>。</p><h4 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h4><p>shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。退出状态码是一个<strong>0～255</strong>的整数值，在命令结束运行时执行<code>exit code</code>传给shell。</p><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>成功结束</td></tr><tr><td>1</td><td>一般性未知错误</td></tr><tr><td>2</td><td>不合适的 shell 命令</td></tr><tr><td>126</td><td>命令不可执行，比如没有权限</td></tr><tr><td>127</td><td>没有找到命令</td></tr><tr><td>128</td><td>无效的退出参数</td></tr><tr><td>128+x</td><td>与 Linux 信号 x 相关的严重错误</td></tr><tr><td>130</td><td>通过 Ctrl+C 终止的命令</td></tr><tr><td>255</td><td>正常范围之外的退出状态码</td></tr></tbody></table><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if command </span><br><span class="line">then</span><br><span class="line">    commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 推荐</span><br><span class="line">if command; then </span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>  通过把分号放在待求值的命令尾部，就可以将 then 语句放在同一行上了，这样看起来更 像其他编程语言中的 if-then 语句。</p></blockquote><p>bash shell的if语句会运行<code>if</code>后面的那个命令。如果该命令的<strong>退出状态码是0</strong>，就执行<code>then</code>后的命令。在其他编程语言 中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。</p><p><strong>if else</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if command</span><br><span class="line">then</span><br><span class="line">    commands </span><br><span class="line">else</span><br><span class="line">    commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>if elif</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if command1 then</span><br><span class="line">    commands </span><br><span class="line">elif command2</span><br><span class="line">then</span><br><span class="line">    more commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>  注意：记住， 在 elif 语句中， 紧跟其后的 else 语句属于 elif 代码块。 它们并不属于之前的 if-then 代码块。</p></blockquote><h4 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h4><p>if-then语句是否能测试命令退出状态码之外的条件。答案是不能。</p><p><code>test</code>命令提供了在<code>if-then</code>语句中测试不同条件的途径。如果test命令中列出的条件成立， <code>test</code>命令就会退出并返回退出状态码<code>0</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if test condition </span><br><span class="line">then </span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="推荐写法"><a href="#推荐写法" class="headerlink" title="推荐写法"></a>推荐写法</h5><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ] </span><br><span class="line">then</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>方括号定义了测试条件。注意，</p><ul><li><strong>第一个方括号之后和第二个方括号之前必须加上一个空格</strong>， 否则就会报错。</li><li>括号内的大于号、小于号，需要进行转义，后面的双括号才不需要。</li></ul><h5 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h5><p>test命令可以判断三类条件：</p><ol><li>数值比较 </li><li>字符串比较</li><li>文件比较</li></ol><h6 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a><em>整数比较</em></h6><p>我们不能在 test命令中使用浮点值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n1 -eq n2    # 检查n1是否与n2相等 </span><br><span class="line">n1 -ge n2    # 检查n1是否大于或等于n2 </span><br><span class="line">n1 -gt n2    # 检查n1是否大于n2 </span><br><span class="line">n1 -le n2    # 检查n1是否小于或等于n2 </span><br><span class="line">n1 -lt n2    # 检查n1是否小于n2 </span><br><span class="line">n1 -ne n2    # 检查n1是否不等于n2</span><br></pre></td></tr></table></figure><p>test命令只能在比较中使用简单的 算术操作。双括号命令提供了更多的数学符号。请看后面内容。</p><h6 id="字符串比较-有坑"><a href="#字符串比较-有坑" class="headerlink" title="字符串比较(有坑)"></a><em>字符串比较(有坑)</em></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = str2   # 检查str1是否和str2相同 </span><br><span class="line">str1 != str2  # 检查str1是否和str2不同 </span><br><span class="line">str1 \&lt; str2   # 检查str1是否比str2小，注意一定要转义</span><br><span class="line">str1 \&gt; str2   # 检查str1是否比str2大，注意一定要转义</span><br><span class="line">-n str1       # 检查str1的长度是否非0</span><br><span class="line">-z str1       # 检查str1的长度是否为0，未在shell脚本中定义过，所以它的字符串长度仍然 为0，</span><br></pre></td></tr></table></figure><p>这里会出现经常困扰shell程序员的问题：</p><ul><li><p>大于号和小于号必须转义，否则shell会把它们当作<strong>重定向符号</strong>，把字符串值当作文件名；</p></li><li><p>大于和小于顺序和sort命令所采用的不同</p><blockquote><p>  这是因为 比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort 命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺 序中小写字母出现在大写字母前。</p></blockquote></li><li><p>未在shell脚本中定义过，<code>-z</code>认为它的字符串长度为0</p></li></ul><h6 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a><em>文件比较</em></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-e file               # 是否存在，可用于文件和目录</span><br><span class="line">-d file               # 是否存在并是一个目录</span><br><span class="line">-f file               # 是否存在并是一个文件</span><br><span class="line">-s file               # 是否存在并非空</span><br><span class="line">-r file               # 是否存在并可读</span><br><span class="line">-w file               # 是否存在并可写</span><br><span class="line">-x file               # 是否存在并可执行</span><br><span class="line">-O file               # 是否存在并属当前用户所有</span><br><span class="line">-G file               # 是否存在并且默认组与当前用户相同</span><br><span class="line"></span><br><span class="line"># 在你尝试使用-nt或 -ot比较文件之前，必须先确认文件是存在的。</span><br><span class="line">file1 -nt file2       # 检查file1是否比file2新</span><br><span class="line">file1 -ot file2       # 检查file1是否比file2旧</span><br></pre></td></tr></table></figure><h5 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：  </span><br><span class="line">[ condition1 ] &amp;&amp; [ condition2 ] </span><br><span class="line">[ condition1 ] || [ condition2 ]</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing compound comparisons </span></span><br><span class="line"><span class="comment"># if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ] </span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The file exists and you can write to it"</span> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"I cannot write to the file"</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h5 id="双括号与双中括号"><a href="#双括号与双中括号" class="headerlink" title="双括号与双中括号"></a>双括号与双中括号</h5><h6 id="数字高级比较-（双括号）"><a href="#数字高级比较-（双括号）" class="headerlink" title="数字高级比较 （双括号）"></a>数字高级比较 （双括号）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure><p>双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。但还是<strong>只支持整数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val++     # 后增 </span><br><span class="line">val--     # 后减</span><br><span class="line">++val     # 先增</span><br><span class="line">--val     # 先减</span><br><span class="line">!         # 逻辑求反</span><br><span class="line">~         # 位求反</span><br><span class="line">**        # 幂运算</span><br><span class="line">&lt;&lt;        # 左位移 </span><br><span class="line">&gt;&gt;        # 右位移</span><br><span class="line">&amp;         # 位布尔和</span><br><span class="line">|         # 位布尔或 </span><br><span class="line">&amp;&amp;        # 逻辑和 </span><br><span class="line">||        # 逻辑或</span><br></pre></td></tr></table></figure><p>注意，<strong>不需要将双括号中表达式里的大于号转义</strong>。这是双括号命令提供的另一个高级特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"># using double parenthesis </span><br><span class="line"># </span><br><span class="line">val1=10 </span><br><span class="line"># </span><br><span class="line">if (( $val1 ** 2 &gt; 90 )) </span><br><span class="line">then</span><br><span class="line">    (( val2 = $val1 ** 2 ))</span><br><span class="line">    echo &quot;The square of $val1 is $val2&quot; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h6 id="字符串高级比较（双中括号）"><a href="#字符串高级比较（双中括号）" class="headerlink" title="字符串高级比较（双中括号）"></a>字符串高级比较（双中括号）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure><p>双方括号提供了test命 令未提供的另一个特性——<strong>模式匹配、正则匹配</strong>（pattern matching）。</p><blockquote><p>  双方括号在bashshell中工作良好。不过要小心，不是所有的shell都支持双方括号。</p></blockquote><p>TODO正则的例子</p><h4 id="swtich-case"><a href="#swtich-case" class="headerlink" title="swtich case"></a>swtich case</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span> </span><br><span class="line">pattern1 | pattern2) </span><br><span class="line">    commands1;; </span><br><span class="line">pattern3) </span><br><span class="line">    commands2;; </span><br><span class="line">*) </span><br><span class="line">    default_commands;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$USER</span> <span class="keyword">in</span> </span><br><span class="line">rich | barbara)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Welcome, <span class="variable">$USER</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Please enjoy your visit"</span>;; </span><br><span class="line">testing)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Special testing account"</span>;; </span><br><span class="line">jessica)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Do not forget to log off when you're done"</span>;; </span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Sorry, you are not allowed here"</span>;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h4 id="for（Python-风格）"><a href="#for（Python-风格）" class="headerlink" title="for（Python 风格）"></a>for（Python 风格）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in list </span><br><span class="line">do </span><br><span class="line">    $var commands </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list; <span class="keyword">do</span> </span><br><span class="line">    <span class="variable">$var</span> commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>类似于 python，执行到 <code>for</code>的时候，已经将数据加载到 list 中了，并不是每次加载一行，然后赋值给变量。list 的内容其实已经全部通过 <code>IFS</code> 分割然后加载进来了。</p><p><strong>list是以空格分割的</strong></p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> Alabama Alaska Arizona Arkansas California Colorado <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The next state is <span class="variable">$test</span>"</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The last state we visited was <span class="variable">$test</span>"</span></span><br></pre></td></tr></table></figure><p>使用<code>$var</code> 获取列表中的值，for循环假定每个值都是用空格分割的。 如果有包含空格的数据值，就必须用双引号将这些值圈起来。或者查看【字段分隔符】章节的解决方案</p><p><strong>list 中有引号的情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for test in I don&apos;t know if this&apos;ll work </span><br><span class="line">do </span><br><span class="line">    echo &quot;word:$test&quot; </span><br><span class="line">done </span><br><span class="line"></span><br><span class="line">$ ./badtest1 </span><br><span class="line">word:I </span><br><span class="line">word:dont know if thisll </span><br><span class="line">word:work</span><br></pre></td></tr></table></figure><p>shell看到了列表值中的单引号并尝试使用它们来定义一个单独的数据值，这真是把事情搞得一团糟。 有两种办法可解决这个问题：</p><ul><li>使用转义字符（反斜线）来将单引号转义； </li><li>使用双引号来定义用到单引号的值:<code>&quot;this&#39;ll&quot;</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> I don\<span class="string">'t know if "this'</span>ll<span class="string">" work </span></span><br><span class="line"><span class="string">do </span></span><br><span class="line"><span class="string">    echo "</span>word:<span class="variable">$test</span><span class="string">" </span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure><p>list添加</p><p>用<code>&quot;</code>进行拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=&quot;Alabama Alaska Arizona Arkansas Colorado&quot; </span><br><span class="line">list=$list&quot; Connecticut&quot; # 拼接</span><br></pre></td></tr></table></figure><h5 id="字段分隔符"><a href="#字段分隔符" class="headerlink" title="字段分隔符"></a>字段分隔符</h5><p>特殊的环境变量<code>IFS</code>，叫作内部字段分隔符（internal field separator）。 IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字 符当作字段分隔符： </p><ul><li>空格 </li><li>制表符 </li><li>换行符</li></ul><p>如果你想修改<code>IFS</code>的值，使其只能识别换行符，那就必须这么做：<code>IFS=$&#39;\n&#39;</code></p><p>指定多个IFS字符，只要将它们在赋值行串起来就行。<code>IFS=$&#39;\n&#39;:;&quot;</code>  ，这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。</p><blockquote><p>  一个可参考的安全实践是在改变 IFS 之前保存原 来的 IFS 值，之后再恢复它。 这种技术可以这样实现：</p><p>  <code>IFS.OLD=$IFS</code></p><p>  <code>IFS=$&#39;\n&#39;</code></p><p>  &lt;在代码中使用新的IFS值&gt;</p><p>  <code>IFS=$IFS.OLD</code></p><p>  这就保证了在脚本的后续操作中使用的是 IFS 的默认值。</p></blockquote><h5 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h5><p>目录名和文件名中包含空格当然是合法的。要适应这种情况，一种方法是将<code>$file</code>变量用双引号圈起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for file in /home/rich/test/* </span><br><span class="line">do</span><br><span class="line">    if [ -d &quot;$file&quot; ] </span><br><span class="line">    then </span><br><span class="line">        echo &quot;$file is a directory&quot; </span><br><span class="line">    elif [ -f &quot;$file&quot; ] </span><br><span class="line">    then </span><br><span class="line">        echo &quot;$file is a file&quot; </span><br><span class="line">    fi </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>另一种方法是指定<code>IFS</code></p><p>典型的例子是处理/etc/passwd文件中的数据。这要求你逐行遍历/etc/passwd文件，并将IFS 变量的值改成冒号，这样就能分隔开每行中的各个数据段了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash # changing the IFS value</span></span><br><span class="line"></span><br><span class="line">IFS.OLD=<span class="variable">$IFS</span> </span><br><span class="line">IFS=$<span class="string">'\n'</span> <span class="comment"># 指定分隔符为换行</span></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> $(cat /etc/passwd) <span class="comment"># 这时数据已经通过\n加载在list中了</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Values in <span class="variable">$entry</span> –"</span></span><br><span class="line">    IFS=: <span class="comment"># 指定为冒号，后面不用恢复成\n，原因如上面的注释</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="variable">$entry</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">" <span class="variable">$value</span>"</span></span><br><span class="line">    <span class="keyword">done</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h5 id="c语言风格的-for"><a href="#c语言风格的-for" class="headerlink" title="c语言风格的 for"></a>c语言风格的 for</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( variable assignment ; condition ; iteration process ))</span><br></pre></td></tr></table></figure><p>这与之前的 bash shell 标准有些不同</p><ul><li>变量赋值可以有空格； </li><li>条件中的变量不以美元符开头； </li><li>迭代过程的算式未用expr命令格式；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"># multiple variables</span><br><span class="line"></span><br><span class="line">for (( a=1, b=10; a &lt;= 10 &amp;&amp; b&gt;=5; a++, b-- )) </span><br><span class="line">do </span><br><span class="line">    echo &quot;$a - $b&quot; </span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while-与-until"><a href="#while-与-until" class="headerlink" title="while 与 until"></a>while 与 until</h4><p>while命令的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while test_command </span><br><span class="line">do </span><br><span class="line">    other commands </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>例子1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while [ $var1 -gt 0 ]</span><br><span class="line">do</span><br><span class="line">    echo $var1</span><br><span class="line">    var1=$[ $var1 - 1 ] </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>while</code>命令允许你在while语句行定义多个测试命令：</p><ul><li>每个测试命令都出现在<strong>单独的一行</strong>上。</li><li>只有<strong>最后一个</strong>测试命令的退出状态码会被用来决定什么时候结束循环。</li><li>在每次迭代中所有的测试命令都会被执行，包括测试命令失败的最后一次迭代。要留心这种用法。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># multiple variables</span></span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">echo</span> <span class="variable">$var1</span> <span class="built_in">echo</span> “minglin2” <span class="comment"># 可以有多条命令，但是测试命令只能一行一条</span></span><br><span class="line">    [ <span class="variable">$var1</span> -ge 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"This is inside the loop"</span></span><br><span class="line">    var1=$[ <span class="variable">$var1</span> - 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>until命令和while命令工作的方式完全相反，只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。其他的与 <code>while</code> 相同</p><h4 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h4><p>默认 break 只跳出所在的最内层的循环。</p><p>有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值：</p><p><code>break n</code>其中n指定了要跳出的循环层级。</p><p>默认情况下，n为1，表明跳出的是当前的循环。如果你将 n设为2，break命令就会停止下一级的外部循环。</p><p>和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环：</p><p><code>continue n</code>其中n定义了要继续的循环层级。</p><p>默认情况下，n为1，表明当继续执行下一次循环。</p><p>例子：当 2&lt;a&lt;4时跳过循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">for (( a = 1; a &lt;= 5; a++ )) </span><br><span class="line">do</span><br><span class="line">    echo &quot;Iteration $a:&quot;</span><br><span class="line">    for (( b = 1; b &lt; 3; b++ )) </span><br><span class="line">    do</span><br><span class="line">        if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ]</span><br><span class="line">        then</span><br><span class="line">            continue 2 # 当 2&lt;a&lt;4时跳过循环</span><br><span class="line">        fi </span><br><span class="line">        var3=$[ $a * $b ] </span><br><span class="line">        echo &quot; The result of $a * $b is $var3&quot; </span><br><span class="line">    done</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">$ ./test22 </span><br><span class="line">Iteration 1:</span><br><span class="line">    The result of 1 * 1 is 1 </span><br><span class="line">    The result of 1 * 2 is 2 </span><br><span class="line">Iteration 2:</span><br><span class="line">    The result of 2 * 1 is 2 </span><br><span class="line">    The result of 2 * 2 is 4 </span><br><span class="line">Iteration 3: # 跳过了第 3 次</span><br><span class="line">Iteration 4:</span><br><span class="line">    The result of 4 * 1 is 4 </span><br><span class="line">    The result of 4 * 2 is 8 </span><br><span class="line">Iteration 5:</span><br><span class="line">    The result of 5 * 1 is 5 </span><br><span class="line">    The result of 5 * 2 is 10</span><br></pre></td></tr></table></figure><h4 id="循环的重定向"><a href="#循环的重定向" class="headerlink" title="循环的重定向"></a>循环的重定向</h4><p>你可以对循环的输出使用管道或进行重定向。这可以通过在关键字<code>done</code>之后添加<code>&gt;</code>或 <code>|</code>命令来实现。</p><p>重定向到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /home/rich/* </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$file</span>"</span> ] </span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a directory"</span> </span><br><span class="line">    <span class="keyword">elif</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a file"</span> </span><br><span class="line">    <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span> &gt; output.txt  <span class="comment"># 重定向到文件</span></span><br></pre></td></tr></table></figure><p>从文件中循环读取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># process new user accounts</span></span><br><span class="line"></span><br><span class="line">input=<span class="string">"users.csv"</span> </span><br><span class="line"><span class="keyword">while</span> IFS=<span class="string">','</span> <span class="built_in">read</span> -r userid name </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"adding <span class="variable">$userid</span>"</span></span><br><span class="line">    useradd -c <span class="string">"<span class="variable">$name</span>"</span> -m <span class="variable">$userid</span> </span><br><span class="line"><span class="keyword">done</span> &lt; <span class="string">"<span class="variable">$input</span>"</span></span><br></pre></td></tr></table></figure><p>                                                                  </p><h3 id="暂时"><a href="#暂时" class="headerlink" title="暂时"></a>暂时</h3><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>位置参数变量是标准的数字：\$0是程序名，\$1是第 一个参数，​\$2是第二个参数，依次类推，直到第九个参数\$9。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python模块-小工具大全</title>
      <link href="/2019/08/06/python%E6%A8%A1%E5%9D%97-%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/08/06/python%E6%A8%A1%E5%9D%97-%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h3><p>The <a href="https://docs.python.org/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> module 实现了二进制协议，用于serializing 和 de-serializing  Python object structure 并保存到磁盘中，并在需要的时候读取出来，任何对象（lambda除外）都可以执行序列化操作。</p><p>Pickle模块中最常用的函数为：</p><h4 id="保存为文件"><a href="#保存为文件" class="headerlink" title="保存为文件"></a>保存为文件</h4><ol><li><p><code>dump(obj, file, [,protocol])</code></p><p>功能：将obj对象序列化存入已经打开的file中。</p><ul><li>obj: 想要序列化的obj对象。</li><li>file: file对象</li><li>protocol: 序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 使用 highest protocol Pickle the 'data' dictionary </span></span><br><span class="line">    pickle.dump(data, file, pickle.HIGHEST_PROTOCOL)</span><br></pre></td></tr></table></figure></li><li><p><code>load(file)</code></p><p>功能：将file中的对象反序列化读出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># protocol版本会自动检测，不要指定</span></span><br><span class="line">    data = pickle.load(file)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>因为pickle是使用二进制保存文件，因此open的读写模式，要使用‘b’</p></blockquote><h4 id="保存为string"><a href="#保存为string" class="headerlink" title="保存为string"></a>保存为string</h4><ol><li><p><code>dumps(obj [, protocol])</code></p><p>功能：将obj对象<strong>序列化为<code>string</code>形式</strong>，而不是存入文件中。</p><ul><li>obj：想要序列化的obj对象。</li><li>protocol：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。</li></ul></li><li><p><code>loads(string)</code></p><p>函数的功能：从string中读出序列化前的obj对象。</p><ul><li>string：pickle序列化后的字符串对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># dumps</span></span><br><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line">r = pickle.dumps(li)</span><br><span class="line">print(r)</span><br><span class="line"><span class="comment">#(lp0</span></span><br><span class="line"><span class="comment"># I11</span></span><br><span class="line"><span class="comment"># aI22</span></span><br><span class="line"><span class="comment"># aI33</span></span><br><span class="line"><span class="comment"># a.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># loads</span></span><br><span class="line">result = pickle.loads(r)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># [11, 22, 33]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>注意：<strong>datetime 类型是不可变对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数代表：year,month,day,hour,minute,second</span></span><br><span class="line">t = datetime.datetime(<span class="number">2019</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">44</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别获取属性</span></span><br><span class="line">t.year</span><br><span class="line">t.hour</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取日期 datetime.date</span></span><br><span class="line">t.date()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取时间 datetime.time</span></span><br><span class="line">t.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改(产生新对象,因为t不可变)</span></span><br><span class="line">b = t.replace(munite=<span class="number">50</span>, second=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime对象 格式化时间</span></span><br><span class="line">t.strftime(<span class="string">"%m-%d %H:%M:%S"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转时间类型</span></span><br><span class="line">datetime.strptime(<span class="string">"2019-08-06"</span>, <span class="string">"%Y-%m-%d"</span>)  <span class="comment"># 第2个参数表示如何解析前面的字符串</span></span><br></pre></td></tr></table></figure><h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><p>注意：datetime 下的 time 与 time 模块不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.time())<span class="comment"># 返回的UTC时间，是从1970.1.1到现在的秒数</span></span><br><span class="line">print(time.ctime(time.time())) <span class="comment"># 接收一个以秒为单位的时间，然后转换成本地时间的字符串表示。</span></span><br><span class="line">print(time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">print(datetime.now())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1565268398.010132</span></span><br><span class="line"><span class="comment"># Thu Aug  8 20:46:38 2019</span></span><br><span class="line"><span class="comment"># 2019-08-08 20:46:38</span></span><br><span class="line"><span class="comment"># 2019-08-08 20:46:38.010703</span></span><br></pre></td></tr></table></figure><h4 id="时间的运算"><a href="#时间的运算" class="headerlink" title="时间的运算"></a>时间的运算</h4><p><code>datetime</code> 只能相减，得到 <code>tiemdelta</code> 对象：<code>datetime.timedelta(m, n)</code>表示相差m天n秒</p><p><code>tiemdelta</code>可以相加减，也可以与<code>datetime</code> 相加减得到新的 <code>datetime</code></p><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><ul><li><code>%y</code> 两位数的年份表示（00-99）</li><li><code>%Y</code> 四位数的年份表示（000-9999）</li><li><code>%m</code> 月份（01-12）</li><li><code>%d</code> 月内中的一天（0-31）</li><li><code>%H</code> 24小时制小时数（0-23）</li><li><code>%I</code> 12小时制小时数（01-12）</li><li><code>%M</code> 分钟数（00=59）</li><li><code>%S</code> 秒（00-59）</li><li><code>%F</code>  %Y-%m-%d的简写（2019-08-06）</li><li><code>%D</code>  %m/%d/%y的简写（08/06/19）</li><li><code>%a</code> 本地简化星期名称</li><li><code>%A</code> 本地完整星期名称</li><li><code>%b</code> 本地简化的月份名称</li><li><code>%B</code> 本地完整的月份名称</li><li><code>%c</code> 本地相应的日期表示和时间表示</li><li><code>%j</code> 年内的一天（001-366）</li><li><code>%p</code> 本地A.M.或P.M.的等价符</li><li><code>%U</code> 一年中的星期数（00-53）星期天为星期的开始</li><li><code>%w</code> 星期（0-6），星期天为星期的开始</li><li><code>%W</code> 一年中的星期数（00-53）星期一为星期的开始</li><li><code>%x</code> 本地相应的日期表示</li><li><code>%X</code> 本地相应的时间表示</li><li><code>%z</code> UTC 时区偏置，格式为+HHMM或-HHMM；如果是简单时区则为空</li><li><code>%Z</code> 当前时区的名称</li><li><code>%%</code> %号本身</li></ul><h3 id="tqdm"><a href="#tqdm" class="headerlink" title="tqdm"></a>tqdm</h3><p><a href="https://pypi.org/project/tqdm/#parameters" target="_blank" rel="noopener">https://pypi.org/project/tqdm/#parameters</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tqdm(self, iterable=<span class="keyword">None</span>, desc=<span class="keyword">None</span>, total=<span class="keyword">None</span>, leave=<span class="keyword">True</span>,file=<span class="keyword">None</span>, ncols=<span class="keyword">None</span>, mininterval=<span class="number">0.1</span>,maxinterval=<span class="number">10.0</span>, miniters=<span class="keyword">None</span>, ascii=<span class="keyword">None</span>, disable=<span class="keyword">False</span>,unit=<span class="string">'it'</span>, unit_scale=<span class="keyword">False</span>, dynamic_ncols=<span class="keyword">False</span>,smoothing=<span class="number">0.3</span>, bar_format=<span class="keyword">None</span>, initial=<span class="number">0</span>, position=<span class="keyword">None</span>,postfix=<span class="keyword">None</span>, unit_divisor=<span class="number">1000</span>):</span><br></pre></td></tr></table></figure><ul><li>desc：progressbar的前缀</li><li>leave : 默认True，结束后保留进度条</li><li>ascii：默认 False，如果True，进度条将以“123456789#”显示，而不是实线</li><li>ncols：整个消息的长度</li></ul><p>设置提示消息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pbar = tqdm([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>])</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> pbar:</span><br><span class="line">    time.sleep(<span class="number">0.25</span>)</span><br><span class="line">    pbar.set_description(<span class="string">"Processing %s"</span> % char)</span><br></pre></td></tr></table></figure><p>手动控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tqdm(total=<span class="number">100</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        pbar.update(<span class="number">10</span>) <span class="comment"># 每次进度增加10</span></span><br></pre></td></tr></table></figure><p>tqdm读取文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> codecs <span class="keyword">as</span> cs</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tqdm(cs.open(<span class="string">"1.txt"</span>),desc = <span class="string">"status: "</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pbar:</span><br><span class="line">        b+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> b % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">            pbar.update(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">print</span> b</span><br></pre></td></tr></table></figure><p>多重进度条</p><p><img src="/2019/08/06/python模块-小工具大全/./多重进度条.gif" alt="Screenshot-Jupyter2"></p><p>除了 tqdm 构造函数之外，还有下面的构造函数可以用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tqdm</span><span class="params">(xrange<span class="params">(*args)</span>, **kwargs)</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">trange</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A shortcut for tqdm(xrange(*args), **kwargs).</span></span><br><span class="line"><span class="string">    On Python3+ range is used instead of xrange.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tqdm_gui</span><span class="params">(tqdm)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tgrange</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Experimental GUI version of trange!</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tnrange</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tqdm_notebook</span><span class="params">(tqdm)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Experimental IPython/Jupyter Notebook widget using tqdm!</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>用来处理Python运行时配置以及资源，从而可以与前当程序之外的系统环境交互，如：Python解释器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sys.argv     #命令行参数List，第一个元素是程序本身路径 </span><br><span class="line">sys.modules.keys()   #返回所有已经导入的模块列表 </span><br><span class="line">sys.exc_info()    #获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息 </span><br><span class="line">sys.exit(n)    #程序，正常退出时exit(0) </span><br><span class="line">sys.hexversion    #获取Python解释程序的版本值，16进制格式如：0x020403F0 </span><br><span class="line">sys.version    #获取Python解释程序的版本信息 </span><br><span class="line">sys.maxint     #最大的Int值 </span><br><span class="line">sys.maxunicode    #最大的Unicode值 </span><br><span class="line">sys.modules    #返回系统导入的模块字段，key是模块名，value是模块 </span><br><span class="line">sys.path     #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 </span><br><span class="line">sys.platform    #返回操作系统平台名称 </span><br><span class="line">sys.stdout     #标准输出  </span><br><span class="line">sys.stdin     #标准输入 </span><br><span class="line">sys.stderr     #错误输出  </span><br><span class="line">sys.exc_clear()   #用来清除当前线程所出现的当前的或最近的错误信息 </span><br><span class="line">sys.exec_prefix   #返回平台独立的python文件安装的位置 </span><br><span class="line">sys.byteorder    #本地字节规则的指示器，big-endian平台的值是&apos;big&apos;,little-endian平台的值是&apos;little&apos; </span><br><span class="line">sys.copyright    #记录python版权相关的东西 </span><br><span class="line">sys.api_version   #解释器的C的API版本 </span><br><span class="line">sys.version_info   #获取Python解释器的版本信息 </span><br><span class="line">sys.getwindowsversion  #获取Windows的版本</span><br><span class="line">sys.getdefaultencoding  #返回当前你所用的默认的字符编码格式</span><br><span class="line">sys.getfilesystemencoding #返回将Unicode文件名转换成系统文件名的编码的名字</span><br><span class="line">sys.setdefaultencoding(name) #用来设置当前默认的字符编码</span><br><span class="line">sys.builtin_module_names #Python解释器导入的模块列表 </span><br><span class="line">sys.executable    #Python解释程序路径 </span><br><span class="line">sys.stdin.readline   #从标准输入读一行，sys.stdout.write(&quot;a&quot;) 屏幕输出a</span><br></pre></td></tr></table></figure><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.remove()       <span class="comment">#删除文件 </span></span><br><span class="line">os.rename()       <span class="comment">#重命名文件</span></span><br></pre></td></tr></table></figure><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.chdir()       <span class="comment">#改变目录 </span></span><br><span class="line">os.mkdir/makedirs()   <span class="comment">#创建目录/多层目录 </span></span><br><span class="line">os.rmdir/removedirs   <span class="comment">#删除目录/多层目录 </span></span><br><span class="line">os.listdir()       <span class="comment">#列出目录下的文件名(不递归)</span></span><br><span class="line">os.walk()       <span class="comment">#列出目录下的所有文件名(递归)</span></span><br></pre></td></tr></table></figure><p><code>os.mkdir</code> 与<code>os.makedirs</code>的差别在于 <strong><code>os.makedirs</code> 会递归地去建立目录</strong>，也就是说连同中继的目录也会一起建立，就类似于 Linux 中的 <code>mkdir -p</code>．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;foo/bar&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">OSError: [Errno 2] No such file or directory: &apos;foo/bar&apos;</span><br><span class="line">&gt;&gt;&gt; os.makedirs(&apos;foo/bar&apos;)</span><br></pre></td></tr></table></figure><p>使用 <code>os.mkdir</code>时，如果你给定的 path 参数是个多层的 path，如果某个中继的目录不存在(比如说上例中的 foo), Python 将会报错．</p><p>但如果使用 <code>os.makedirs</code> 则 Python 会连同中间的目录一起建立．但有一点值得注意，当 path 末端的目录已经存在的话，os.makedirs 也是会引发例外．</p><h3 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h3><p><a href="https://docs.python.org/3/library/os.path.html#os.path.dirname" target="_blank" rel="noopener">https://docs.python.org/3/library/os.path.html#os.path.dirname</a></p><p>os模块包含普遍的操作系统功能。如果你希望你的程序能够与平台无关的话，这个模块是尤为重要的。</p><h4 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd()       <span class="comment">#取得当前工作目录 </span></span><br><span class="line">os.path.abspath(path)<span class="comment">#获取文件、目录的绝对路径</span></span><br><span class="line"></span><br><span class="line">os.path.basename()     <span class="comment">#去掉目录路径，返回文件名 </span></span><br><span class="line">os.path.dirname()     <span class="comment">#去掉文件名，返回目录路径 </span></span><br><span class="line"><span class="comment"># dirname 与 basename 组成完整的文件路径(绝对、相对路径都可以)</span></span><br><span class="line"></span><br><span class="line">os.path.join()      <span class="comment">#将分离的各部分组合成一个路径名 </span></span><br><span class="line">os.path.split(path)     <span class="comment">#返回(dirname(),basename())元组 </span></span><br><span class="line">os.path.splitdrive(path)<span class="comment">#返回(盘符、远程地址,路径)元组</span></span><br><span class="line">os.path.split ext(path)<span class="comment">#返回(剩余部分,扩展名)元组</span></span><br><span class="line"></span><br><span class="line">os.path.commonpath(paths) <span class="comment">#返回公共的父节点路径(有效路径)</span></span><br><span class="line">os.path.commonprefix(list) <span class="comment">#返回公共的路径前缀(字符串匹配，不一定是有效路径)</span></span><br><span class="line"><span class="comment"># commonprefix(['/usr/lib', '/usr/local/lib'])</span></span><br><span class="line"><span class="comment"># '/usr/l'</span></span><br><span class="line"><span class="comment"># commonpath(['/usr/lib', '/usr/local/lib'])</span></span><br><span class="line"><span class="comment"># '/usr'</span></span><br><span class="line"></span><br><span class="line">os.path.realpath(path) <span class="comment">#返回真实路径,消除符号链接，类似于abspath</span></span><br><span class="line">os.path.relpath(path, start=os.curdir)<span class="comment">#返回相对于指定的start的相对路径，默认是当前目录</span></span><br><span class="line"></span><br><span class="line">os.path.expanduser(path)<span class="comment"># 将路径中的~转义为真实的home目录地址，否则不做变化</span></span><br><span class="line">os.path.expandvars(path)<span class="comment"># 将路径中的环境变量转义为真实的值，否则不做变化</span></span><br></pre></td></tr></table></figure><p><code>split(path)</code></p><p>将路径名<em>path</em>分割为<code>(head, tail)</code> ， <em>tail</em> 路径名的最后部分，绝对不包含分隔符(/)  <em>head</em> 是 tail 之前的路径。如果<em>path</em> 以(/) 结尾, 那么<em>tail</em> 为空 </p><p><code>os.path.normcase(path)</code></p><p>返回大小写正常化后的路径名。</p><p>对于 Mac、Unix，该操作没有效果（他们对<code>a.txt</code>,<code>A.txt</code>视为同一名称）</p><p>对于不区分大小写的文件系统，会将路径转为小写；</p><p>对于 window，前向斜杆<code>\</code> 会转为后向斜杆<code>/</code></p><h4 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">os.path.getatime\ctime\mtime   <span class="comment">#分别返回最近访问、创建、修改时间 </span></span><br><span class="line">os.path.getsize()     <span class="comment">#返回文件大小 </span></span><br><span class="line">os.path.exists()      <span class="comment">#是否存在 </span></span><br><span class="line">os.path.isabs()      <span class="comment">#是否为绝对路径 </span></span><br><span class="line">os.path.isdir()      <span class="comment">#是否为目录 </span></span><br><span class="line">os.path.isfile()      <span class="comment">#是否为文件</span></span><br><span class="line">os.path.samefile(path1, path2)<span class="comment">#是否是同一个文件</span></span><br><span class="line">os.path.sameopenfile(fp1, fp2)<span class="comment">#是否指向同一个文件</span></span><br></pre></td></tr></table></figure><h3 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h3><p><a href="https://docs.python.org/3/library/shutil.html#shutil.disk_usage" target="_blank" rel="noopener">https://docs.python.org/3/library/shutil.html#shutil.disk_usage</a></p><h4 id="从文件对象拷贝"><a href="#从文件对象拷贝" class="headerlink" title="从文件对象拷贝"></a>从文件对象拷贝</h4><p><code>copyfileobj(fsrc, fdst[, length])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with 可以同时 支持 多个上下文管理器</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./1.txt"</span>,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f1, open(<span class="string">'./2,txt'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    su.copyfileobj(f1,f2)</span><br></pre></td></tr></table></figure><h4 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p><code>copyfile(src, dst, *, follow_symlinks=True)</code></p><p>从 src复制的文件内容到 dst 文件中，<strong>只复制内容，不包含元数据</strong></p><p><strong>dst 必须是目标文件名，而不是目录</strong></p><p><code>copy(src, dst, *, follow_symlinks=True*)</code></p><p>复制文件数据、权限数据；其他的元数据（创建时间、修改时间）没有保留</p><p>dst允许是目录，或者文件名</p><p><code>copy2(src, dst, *, follow_symlinks=True)</code></p><p>与 copy 一样，除了<strong>会尽量保存文件的元数据</strong></p><h5 id="移动-文件-目录"><a href="#移动-文件-目录" class="headerlink" title="移动(文件/目录)"></a>移动(文件/目录)</h5><p><code>move(src, dst, copy_function=copy2)</code></p><p>将文件或者目录复制到 dst</p><h4 id="目录操作-1"><a href="#目录操作-1" class="headerlink" title="目录操作"></a>目录操作</h4><h5 id="复制-1"><a href="#复制-1" class="headerlink" title="复制"></a>复制</h5><p><code>copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)</code></p><p>将递归地将整个目录文件复制到 dst，dst 必须不存在</p><p>例子：跳过指定的文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure><p>利用 ignore 进行日志记录功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_logpath</span><span class="params">(path, names)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'Working in %s'</span>, path)</span><br><span class="line">    <span class="keyword">return</span> []   <span class="comment"># nothing will be ignored</span></span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=_logpath)</span><br></pre></td></tr></table></figure><h5 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h5><p>参考 <code>move</code></p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><code>rmtree(path, ignore_errors=False, onerror=None)</code></p><p>删除整个目录，<em>path</em> 必须指向目录 (不可以是指向目录的符号链接).</p><p>例子：处理只读的文件，尝试删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="string">"清除 readonly bit 并重新尝试删除"</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure><h5 id="ignore-patterns"><a href="#ignore-patterns" class="headerlink" title="ignore_patterns"></a>ignore_patterns</h5><p>This factory function creates a function that can be used as a callable for <a href="https://docs.python.org/3/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>’s <em>ignore</em> argument, ignoring files and directories that match one of the glob-style <em>patterns</em>provided.</p><h4 id="文件状态操作"><a href="#文件状态操作" class="headerlink" title="文件状态操作"></a>文件状态操作</h4><h5 id="复制文件权限"><a href="#复制文件权限" class="headerlink" title="复制文件权限"></a>复制文件权限</h5><p><code>copymode(src, dst, *, follow_symlinks=True)</code></p><p>从 src 复制 permission bits 到 <em>dst</em>。文件内容、拥有者、组都不受影响</p><h5 id="复制文件状态"><a href="#复制文件状态" class="headerlink" title="复制文件状态"></a>复制文件状态</h5><p><code>copystat(src, dst, *, follow_symlinks=True)</code></p><p>从 src 复制 permission bits、 last access time、last modification time、 flags 到 <em>dst</em>. 在 linux 中，还会尝试复制 “extended attributes” </p><p>文件内容、拥有者、组都不受影响 </p><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><p><code>chown(path, user=None, group=None)</code></p><p>修改 path 的用户或者组</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="磁盘使用情况"><a href="#磁盘使用情况" class="headerlink" title="磁盘使用情况"></a>磁盘使用情况</h5><p><code>disk_usage(path)</code></p><p>返回磁盘的使用情况统计结果元组：<em>total</em>, <em>used</em>,  <em>free</em>, 单位是 bytes.</p><h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><p><code>which(cmd, mode=os.F_OK | os.X_OK, path=None)</code></p><p>查看命令的执行程序名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutil.which(<span class="string">"python"</span>)</span><br><span class="line"><span class="comment"># '/Users/jizhongxian/anaconda3/bin/python'</span></span><br></pre></td></tr></table></figure><h4 id="Archiving-operations-压缩包操作"><a href="#Archiving-operations-压缩包操作" class="headerlink" title="Archiving operations(压缩包操作)"></a>Archiving operations(压缩包操作)</h4><p>用到再看</p><p><a href="https://docs.python.org/3/library/shutil.html#archiving-operations" target="_blank" rel="noopener">https://docs.python.org/3/library/shutil.html#archiving-operations</a></p><h3 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h3><p>glob 规则：<a href="http://www.man7.org/linux/man-pages/man7/glob.7.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man7/glob.7.html</a></p><h4 id="最常用的通配符是-、-、"><a href="#最常用的通配符是-、-、" class="headerlink" title="最常用的通配符是 *、?、[]"></a>最常用的通配符是 *、?、[]</h4><table><thead><tr><th>通配符</th><th>描述</th><th>例子</th><th>匹配</th><th>不匹配</th></tr></thead><tbody><tr><td>*</td><td>匹配任意数量的字符包括空字符</td><td>Law*</td><td>Law, Laws, or Lawyer</td><td></td></tr><tr><td></td><td></td><td>*Law*</td><td>Law, GrokLaw, or Lawyer.</td><td></td></tr><tr><td>?</td><td>匹配任意一个字符</td><td>?at</td><td>Cat, cat, Bat or bat</td><td>at</td></tr><tr><td>[abc]</td><td>匹配任意一个包含的字符</td><td>[CB]at</td><td>Cat or Bat</td><td>cat or bat</td></tr><tr><td>[a-z]</td><td>匹配任意一个给定范围的字符</td><td>Letter[0-9]</td><td>Letter0, Letter1 etc.</td><td>Letters or Letter</td></tr><tr><td>**</td><td>匹配任意的目录(包括当前目录)</td><td>*<em>/\</em>.js</td><td>ss.js, a/hh.js, a/b/c.js</td></tr></tbody></table><h4 id="在Linux和POSIX系统中-…-的扩展"><a href="#在Linux和POSIX系统中-…-的扩展" class="headerlink" title="在Linux和POSIX系统中[…]的扩展"></a>在Linux和POSIX系统中[…]的扩展</h4><table><thead><tr><th>通配符</th><th>描述</th><th>例子</th><th>匹配</th><th>不匹配</th></tr></thead><tbody><tr><td>[!abc]</td><td>不匹配任意一个包含的字符</td><td>[!C]at</td><td>Bat, bat, or cat</td><td>Cat</td></tr><tr><td>[!a-z]</td><td>不匹配任意一个给定范围的字符</td><td>Letter[!3-5]</td><td>Letter1, Letter2 etc.</td><td>Letter3, Letter4 or Letter5</td></tr></tbody></table><h4 id="与正则的比较："><a href="#与正则的比较：" class="headerlink" title="与正则的比较："></a>与正则的比较：</h4><table><thead><tr><th>Glob的通配符</th><th>等价正则的表达式</th></tr></thead><tbody><tr><td>?</td><td>.</td></tr><tr><td>*</td><td>.*</td></tr></tbody></table><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>Glob尝试匹配整个字符串，而不是片段</strong>。<code>S*.DOC</code>将匹配S.DOC和SA.DOC，但不匹配POST.DOC或SURREY.DOCKS，正则只匹配子串除非使用<code>^</code> 和<code>$</code>。所以<code>S*.DOC</code>的等价正则是<code>^S.*\.DOC$</code>。</li><li>路径分隔符（unix的/，windows的\）不会被<code>? *</code>匹配。如果要匹配，需要用<code>**</code>匹配任意层级的目录(包括当前目录)  <code>**/*.js  ==&gt;  a/b/c.js</code></li><li><code>[^...]</code>是无效的</li><li><code>.</code>开头的文件被 glob 视为特殊的文件，<code>*</code>匹配不到他，需要显式处理 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">[<span class="string">'card.gif'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'.c*'</span>) <span class="comment">#显式地指定.</span></span><br><span class="line">[<span class="string">'.card.gif'</span>]</span><br></pre></td></tr></table></figure></li></ul><h4 id="glob-1"><a href="#glob-1" class="headerlink" title="glob"></a>glob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.glob(pathname, *, recursive=False)</span><br></pre></td></tr></table></figure><p>返回符合 pathname 模式的路径列表，recursive会递归地查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">'./[0-9].*'</span>)</span><br><span class="line"><span class="comment"># ['./1.gif', './2.txt']</span></span><br><span class="line">glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line"><span class="comment"># ['1.gif', 'card.gif']</span></span><br><span class="line">glob.glob(<span class="string">'?.gif'</span>)</span><br><span class="line"><span class="comment"># ['1.gif']</span></span><br><span class="line">glob.glob(<span class="string">'**/*.txt'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># ['2.txt', 'sub/3.txt']</span></span><br><span class="line">glob.glob(<span class="string">'./**/'</span>, recursive=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># ['./', './sub/']</span></span><br></pre></td></tr></table></figure><h4 id="iglob"><a href="#iglob" class="headerlink" title="iglob"></a>iglob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.iglob(pathname, *, recursive=False)</span><br></pre></td></tr></table></figure><p>与 glob 作用相同，只不过返回的一个迭代器</p><h4 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.escape(pathname)</span><br></pre></td></tr></table></figure><p>转义所有的字符(<code>&#39;?&#39;</code>, <code>&#39;*&#39;</code> and <code>&#39;[&#39;</code>)。</p><p>比如<code>escape(&#39;//?/c:/Quo vadis?.txt&#39;)</code> 返回 <code>&#39;//?/c:/Quovadis[?].txt&#39;</code>.</p><h3 id="fnmatch"><a href="#fnmatch" class="headerlink" title="fnmatch"></a>fnmatch</h3><table><thead><tr><th style="text-align:left">Pattern</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">matches everything</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">matches any single character</td></tr><tr><td style="text-align:left"><code>[seq]</code></td><td style="text-align:left">matches any character in <em>seq</em></td></tr><tr><td style="text-align:left"><code>[!seq]</code></td><td style="text-align:left">matches any character not in <em>seq</em></td></tr></tbody></table><p>(<code>&#39;/&#39;</code> on Unix) <code>.</code>开头的文件，不是特殊文件</p><h4 id="fnmatch-1"><a href="#fnmatch-1" class="headerlink" title="fnmatch"></a>fnmatch</h4><ul><li><code>fnmatch.fnmatch(filename, pattern)</code></li></ul><p>测试 <em>filename</em> 是否匹配 <em>pattern</em> 字符串,  参数都是用 <a href="https://docs.python.org/3/library/os.path.html#os.path.normcase" target="_blank" rel="noopener"><code>os.path.normcase()</code></a>规范过了。 <a href="https://docs.python.org/3/library/fnmatch.html#fnmatch.fnmatchcase" target="_blank" rel="noopener"><code>fnmatchcase()</code></a> 用于 大小写敏感的比较, 不论那是否是该操作系统的标准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fnmatch</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>):</span><br><span class="line">    <span class="keyword">if</span> fnmatch.fnmatch(file, <span class="string">'*.txt'</span>):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure><h4 id="fnmatchcase"><a href="#fnmatchcase" class="headerlink" title="fnmatchcase"></a>fnmatchcase</h4><ul><li><code>fnmatch.fnmatchcase(filename, pattern)</code><br>大小写敏感的比较，函数中不使用<a href="https://docs.python.org/3/library/os.path.html#os.path.normcase" target="_blank" rel="noopener"><code>os.path.normcase()</code></a>.</li></ul><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><ul><li><code>fnmatch.filter(names, pattern)</code><br>返回列表 <em>names</em> 中符合 <em>pattern</em> 的子列表，等价于 <code>[n for n in namesif fnmatch(n, pattern)]</code>, 但内部更进行了高效地实现。</li></ul><h4 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h4><ul><li><code>fnmatch.translate(pattern)</code><br>将 shell-风格的 <em>pattern</em> 转为正则表达式 <a href="https://docs.python.org/3/library/re.html#re.match" target="_blank" rel="noopener"><code>re.match()</code></a>.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fnmatch, re</span><br><span class="line"></span><br><span class="line">regex = fnmatch.translate(<span class="string">'*.txt'</span>)</span><br><span class="line">print(regex)</span><br><span class="line"><span class="comment"># '(?s:.*\\.txt)\\Z'</span></span><br><span class="line">reobj = re.compile(regex)</span><br><span class="line">reobj.match(<span class="string">'foobar.txt'</span>)</span><br><span class="line"><span class="comment"># &lt;re.Match object; span=(0, 10), match='foobar.txt'&gt;</span></span><br></pre></td></tr></table></figure></li></ul></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pickle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python模块-logging</title>
      <link href="/2019/08/06/python%E6%A8%A1%E5%9D%97-logging/"/>
      <url>/2019/08/06/python%E6%A8%A1%E5%9D%97-logging/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>python logging 模块的使用以及详细讲解</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>logging模块定义了以下几个日志等级，它允许开发人员自定义其他日志级别，但是这是不被推荐的，尤其是在开发供别人使用的库时，因为这会导致日志级别的混乱。</p><table><thead><tr><th>日志等级（level）</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>最详细的日志信息，典型应用场景是 问题诊断</td></tr><tr><td>INFO</td><td>信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作</td></tr><tr><td>WARNING</td><td>当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的</td></tr><tr><td>ERROR</td><td>由于一个更严重的问题导致某些功能不能正常运行时记录的信息</td></tr><tr><td>CRITICAL</td><td>当发生严重错误，导致应用程序不能继续运行时记录的信息</td></tr></tbody></table><p>默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明<strong>默认的日志级别设置为WARNING</strong>（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG）而日志的信息量是依次增多的；</p><p>开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试；</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>logging模块提供了两种记录日志的方式：</p><ul><li>第一种方式是使用logging提供的模块级别的函数</li><li>第二种方式是使用Logging日志系统的四大组件</li></ul><p>首先来看一下第一种，通过logging提供的模块级别的函数进行日志记录。</p><p>logging模块定义的模块级别的常用函数</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>logging.debug(msg, *args, **kwargs)</td><td>创建一条严重级别为DEBUG的日志记录</td></tr><tr><td>logging.info(msg, *args, **kwargs)</td><td>创建一条严重级别为INFO的日志记录</td></tr><tr><td>logging.warning(msg, *args, **kwargs)</td><td>创建一条严重级别为WARNING的日志记录</td></tr><tr><td>logging.error(msg, *args, **kwargs)</td><td>创建一条严重级别为ERROR的日志记录</td></tr><tr><td>logging.critical(msg, *args, **kwargs)</td><td>创建一条严重级别为CRITICAL的日志记录</td></tr><tr><td>logging.log(level, *args, **kwargs)</td><td>创建一条严重级别为level的日志记录</td></tr><tr><td>logging.basicConfig(**kwargs)</td><td>对root logger进行一次性配置</td></tr></tbody></table><p>其中<code>logging.basicConfig(**kwargs)</code>函数用于指定“要记录的日志级别”、“日志格式”、“日志输出位置”、“日志文件的打开模式”等信息，其他几个都是用于记录各个级别日志的函数。</p><p>具体例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,<span class="comment"># 控制台打印的日志级别</span></span><br><span class="line">                    filename=<span class="string">'new.log'</span>,</span><br><span class="line">                    filemode=<span class="string">'w'</span>,<span class="comment"># 写模式：a和w，w就是写模式，a是追加模式，默认是追加模式</span></span><br><span class="line">                    format= <span class="string">'%(asctime)s - %(pathname)s[line:%(lineno)d] - %(name)s - %(levelname)s: %(message)s'</span>, <span class="comment"># 日志格式</span></span><br><span class="line">                    datefmt=<span class="string">'%Y-%m-%d  %H:%M:%S %a '</span>    <span class="comment"># 日期格式</span></span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">"info"</span>)</span><br><span class="line">logging.info(<span class="string">"info"</span>)</span><br><span class="line">logging.warning(<span class="string">"warning"</span>)</span><br><span class="line">logging.error(<span class="string">"error"</span>)</span><br><span class="line">logging.critical(<span class="string">"critical"</span>)</span><br></pre></td></tr></table></figure><h4 id="关于-basicConfig-说明"><a href="#关于-basicConfig-说明" class="headerlink" title="关于 basicConfig 说明"></a>关于 basicConfig 说明</h4><p>主要的配置是通过<code>basicConfig</code>来定制的：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">level</td><td style="text-align:left">指定日志器的日志级别，默认是 WARNING 级别，因此 DEBUG、INFO 都不会输出</td></tr><tr><td style="text-align:left">filename</td><td style="text-align:left">指定日志输出目标文件的文件名（可以写文件名也可以写文件的完整的绝对路径，写文件名日志放执行文件目录下，写完整路径按照完整路径生成日志文件），指定该设置项后日志信息就<strong>不会被输出到控制台了</strong>，如果需要同时显示，请看后面的组件用法。</td></tr><tr><td style="text-align:left">filemode</td><td style="text-align:left">指定日志文件的打开模式，默认为<code>a</code>,追加的方式，该选项要在filename指定时才有效</td></tr><tr><td style="text-align:left">stream</td><td style="text-align:left">指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 <code>ValueError</code>异常</td></tr><tr><td style="text-align:left">handlers</td><td style="text-align:left">Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。</td></tr><tr><td style="text-align:left">format</td><td style="text-align:left">指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段请看<strong>Formater</strong>一节</td></tr><tr><td style="text-align:left">datefmt</td><td style="text-align:left">指定日期/时间格式。需要注意的是，该选项要在format中<strong>包含时间字段%(asctime)s时才有效</strong></td></tr><tr><td style="text-align:left">style</td><td style="text-align:left">Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为’%’、’{‘和’$’，默认为’%’</td></tr></tbody></table><p>注意点：</p><ul><li><code>logging.basicConfig()</code>函数是一个一次性的简单配置工具使，也就是说<strong>只有在第一次调用该函数时会起作用</strong>，后续再次调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作。</li><li>日志器（Logger）是有层级关系的，上面调用的logging模块级别的函数所使用的日志器是<code>RootLogger</code>类的实例，其名称为’root’，它是处于日志器层级关系最顶层的日志器，且<strong>该实例是以单例模式存在的</strong>。</li><li>如果要记录的日志中包含变量数据，可使用一个格式字符串作为这个事件的描述消息（<code>logging.debug</code>、<code>logging.info</code>等函数的第一个参数），然后将变量数据作为第二个参数<code>*args</code>的值进行传递，如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.warning(&apos;%s is %d years old.&apos;, &apos;Tom&apos;, 10)</span><br><span class="line"># WARNING:root:Tom is 10 years old.</span><br></pre></td></tr></table></figure></li></ul><p>其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已。这里其实创建了一个 名为<code>root</code>的日志器组件，是一个默认的、单例的 logger 组件。接下来我们看一下第二种。</p><h3 id="Logging-组件"><a href="#Logging-组件" class="headerlink" title="Logging 组件"></a>Logging 组件</h3><p>logging模块就是通过下面这些组件来完成日志处理的，上面所使用的logging模块级别的函数也是通过这些组件对应的类来实现的。</p><p>在介绍logging模块的日志处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>它们之间的合作关系如下：</p><ul><li>日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</li><li>不同的处理器（handler）可以将日志输出到不同的位置；</li><li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</li><li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</li><li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li></ul><p>简单点说就是：<strong>日志器（logger）是入口，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</strong></p><h3 id="日志流处理简要流程"><a href="#日志流处理简要流程" class="headerlink" title="日志流处理简要流程"></a>日志流处理简要流程</h3><ol><li><p>创建一个logger</p></li><li><p>设置下logger的日志的等级</p></li><li><p>创建合适的Handler(FileHandler要有路径)</p></li><li><p>设置下每个Handler的日志等级。</p></li><li><p>创建下日志的格式Formater</p></li><li><p>向Handler中添加上面创建的Formater</p></li><li><p>将上面创建的Handler注册到logger中</p></li><li><p>打印输出logger.debug\logger.info\logger.warning\logger.error\logger.critical</p></li></ol><blockquote><p>为什么会有两个<code>setLevel()</code>方法？logger 的级别决定了消息是否要传递给处理器。每个handler的级别决定了消息是否要分发到指定目标</p></blockquote><p>从“简单使用”一节中我们了解到了<code>logging.debug()</code>、<code>logging.info()</code>等函数分别用以记录不同级别的日志信息 ，<code>logging.basicConfig()</code>用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到 root logger 中。</p><p>接下来就按照上面的流程来介绍高级的用法，来满足各种需求。</p><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><h4 id="日志器的获取"><a href="#日志器的获取" class="headerlink" title="日志器的获取"></a>日志器的获取</h4><p>如何获取一个Logger对象呢？</p><ol><li>通过Logger类的实例化方法创建一个Logger类的实例，</li><li>但是我们通常都是用第二种方式：<code>logging.getLogger(&#39;name&#39;)</code>方法。</li></ol><p><code>logging.getLogger(&#39;name&#39;)</code>方法有一个可选参数name，该参数表示将要返回的日志器的名称标识， 默认为<code>root</code>。若以相同的name参数值多次调用<code>getLogger()</code>方法，将会返回指向<strong>同一个logger对象的引用</strong>。</p><h4 id="日志器的继承"><a href="#日志器的继承" class="headerlink" title="日志器的继承"></a>日志器的继承</h4><ul><li>logger的名称是以<code>.</code>分割的层级结构，每个<code>.</code>后面的logger都是<code>.</code>前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 <code>foo.bar</code>, <code>foo.bar.baz</code> 和 <code>foo.bam</code>都是 foo 的后代。</li><li>logger有一个”有效等级（effective level）”的概念。如果一个logger上没有被明确设置一个level，那么该logger就使用它parent的level。如果它的parent也没有明确设置level，则继续向上查找parent的parent的有效level，依次类推，直到找到个一个明确设置了level的祖先为止。需要说明的是，root logger总是会有一个明确的level设置（默认为 WARNING）。当决定是否去处理一个已发生的事件时，<strong>logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理</strong>。</li><li>child loggers在完成对日志消息的处理后，默认会将日志消息传递给与它们的祖先loggers相关的handlers。因此，我们不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。</li></ul><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>Handler对象的作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）。Logger对象可以通过addHandler()方法为自己添加0个或者更多个handler对象。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>1）把所有日志都发送到一个日志文件中；</li><li>2）把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>3）把所有严重级别为critical的日志发送到一个email邮件地址。这种场景就需要3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fh = logging.FileHandler(&quot;jizx_log.txt&quot;,encoding=&quot;utf-8&quot;) # 创建一个文件 handler 用于注册到 logger 中</span><br><span class="line">Handler.setLevel(lel):指定被处理的信息级别，低于lel级别的信息将被忽略</span><br><span class="line">Handler.setFormatter()：给这个handler选择一个格式</span><br><span class="line">Handler.addFilter(filt)、Handler.removeFilter(filt)：新增或删除一个filter对象</span><br></pre></td></tr></table></figure><p>应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了素有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些常用的Handler：</p><table><thead><tr><th style="text-align:left">Handler</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">logging.StreamHandler([strm])</td><td style="text-align:left">将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。默认是sys.stderr</td></tr><tr><td style="text-align:left">logging.FileHandler(filename[,mode])</td><td style="text-align:left">将日志消息发送到磁盘文件，默认<code>mode</code>是<code>a</code>,文件大小会无限增长。还可是<code>w</code></td></tr><tr><td style="text-align:left">logging.handlers.RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])</td><td style="text-align:left">将日志消息发送到磁盘文件，并支持日志文件按大小切割。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。<br>backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。</td></tr><tr><td style="text-align:left">logging.hanlders.TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])</td><td style="text-align:left">将日志消息发送到磁盘文件，并支持日志文件按时间切割。interval是时间间隔。when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：S 秒、M 分、H 小时、D 天、W 每星期（interval==0时代表星期一）、midnight 每天凌晨</td></tr><tr><td style="text-align:left">logging.handlers.HTTPHandler</td><td style="text-align:left">将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td style="text-align:left">logging.handlers.SMTPHandler</td><td style="text-align:left">将日志消息发送给一个指定的email地址</td></tr><tr><td style="text-align:left">logging.NullHandler</td><td style="text-align:left">该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免’No handlers could be found for logger XXX’信息的出现。</td></tr></tbody></table><h3 id="formater"><a href="#formater" class="headerlink" title="formater"></a>formater</h3><p>Formater对象用于配置日志信息的最终顺序、结构和内容。与logging.Handler基类不同的是，应用代码可以直接实例化Formatter类。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。</p><p>Formatter类的构造方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.Formatter.__init__(fmt=None, datefmt=None, style=&apos;%&apos;)</span><br></pre></td></tr></table></figure><p>该构造方法接收3个可选参数：</p><ul><li>fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</li><li>datefmt：指定日期格式字符串，如果不指定该参数则默认使用”%Y-%m-%d %H:%M:%S”</li><li>style：Python 3.2新增的参数，可取值为 ‘%’, ‘{‘和 ‘$’，如果不指定该参数则默认使用’%’</li></ul><p><strong>一般直接用<code>logging.Formatter(fmt, datefmt)</code></strong></p><h4 id="format格式字符串说明"><a href="#format格式字符串说明" class="headerlink" title="format格式字符串说明"></a>format格式字符串说明</h4><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>将日志的时间构造成可读的形式，默认情况下是‘2016-02-08 12:00:00,123’精确到毫秒</td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger</td></tr><tr><td>filename</td><td>%(filename)s</td><td>调用日志输出函数的模块的文件名； pathname的文件名部分，包含文件后缀</td></tr><tr><td>funcName</td><td>%(funcName)s</td><td>由哪个function发出的log， 调用日志输出函数的函数名</td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>日志的最终等级（被filter修改后的）</td></tr><tr><td>message</td><td>%(message)s</td><td>日志信息， 日志记录的文本内容</td></tr><tr><td>lineno</td><td>%(lineno)d</td><td>当前日志的行号， 调用日志输出函数的语句所在的代码行</td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td>完整路径 ，调用日志输出函数的模块的完整路径名，可能没有</td></tr><tr><td>process</td><td>%(process)s</td><td>当前进程， 进程ID。可能没有</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)s</td><td>当前线程， 线程ID。可能没有</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr><tr><td>module</td><td>%(module)s</td><td>调用日志输出函数的模块名， filename的名称部分，不包含后缀即不包含文件后缀的文件名</td></tr><tr><td>created</td><td>%(created)f</td><td>当前时间，用UNIX标准的表示时间的浮点数表示； 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>输出日志信息时的，自Logger创建以 来的毫秒数； 日志事件发生的时间相对于logging模块加载时间的相对毫秒数</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的毫秒部分。logging.basicConfig()中用了参数datefmt，将会去掉asctime中产生的毫秒部分，可以用这个加上</td></tr></tbody></table><h3 id="Filter类（暂时了解）"><a href="#Filter类（暂时了解）" class="headerlink" title="Filter类（暂时了解）"></a>Filter类（暂时了解）</h3><p>Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class logging.Filter(name=&apos;&apos;)</span><br><span class="line">    filter(record)</span><br></pre></td></tr></table></figure><p>比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。</p><p>filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。</p><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><p><strong>需求：</strong></p><p>输出log到控制台，并将日志写入log文件，保存2种类型的log：</p><ul><li><p>all.log 保存debug, info, warning, critical 信息</p></li><li><p>error.log则只保存error信息，同时按照时间自动分割日志文件</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging <span class="keyword">import</span> handlers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(object)</span>:</span></span><br><span class="line">    level_relations = &#123;</span><br><span class="line">        <span class="string">'debug'</span>: logging.DEBUG,</span><br><span class="line">        <span class="string">'info'</span>: logging.INFO,</span><br><span class="line">        <span class="string">'warning'</span>: logging.WARNING,</span><br><span class="line">        <span class="string">'error'</span>: logging.ERROR,</span><br><span class="line">        <span class="string">'crit'</span>: logging.CRITICAL</span><br><span class="line">    &#125;  <span class="comment"># 日志级别关系映射</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, level=<span class="string">'info'</span>, when=<span class="string">'D'</span>, backCount=<span class="number">3</span>, fmt=<span class="string">'%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s'</span>)</span>:</span></span><br><span class="line">        self.logger = logging.getLogger(filename)</span><br><span class="line">        self.logger.setLevel(self.level_relations.get(level))  <span class="comment"># 设置日志级别</span></span><br><span class="line">        format_str = logging.Formatter(fmt)  <span class="comment"># 设置日志格式</span></span><br><span class="line"></span><br><span class="line">        out_screen = logging.StreamHandler()  <span class="comment"># 往屏幕上输出</span></span><br><span class="line">        out_screen.setFormatter(format_str)  <span class="comment"># 设置屏幕上显示的格式</span></span><br><span class="line"></span><br><span class="line">        out_file = handlers.TimedRotatingFileHandler(filename=filename, when=when, backupCount=backCount, encoding=<span class="string">'utf-8'</span>)  <span class="comment"># 往文件里写入，指定间隔时间自动生成文件的处理器</span></span><br><span class="line">        out_file.setFormatter(format_str)  <span class="comment"># 设置文件里写入的格式</span></span><br><span class="line">        <span class="comment"># interval是时间间隔，backupCount是备份文件的个数，如果超过这个个数，就会自动删除，when是间隔的时间单位，单位有以下几种：</span></span><br><span class="line">        <span class="comment"># S 秒、M 分、H 小时、、D 天、、W 每星期（interval==0时代表星期一）、midnight 每天凌晨</span></span><br><span class="line"></span><br><span class="line">        self.logger.addHandler(out_screen)  <span class="comment"># 把对象加到logger里</span></span><br><span class="line">        self.logger.addHandler(out_file)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.debug(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.info(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warning</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.warning(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.error(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">critical</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.logger.critical(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    log = Logger(<span class="string">'all.log'</span>,level=<span class="string">'debug'</span>)</span><br><span class="line">    log.logger.debug(<span class="string">'debug'</span>)</span><br><span class="line">    log.logger.info(<span class="string">'info'</span>)</span><br><span class="line">    log.logger.warning(<span class="string">u'警告'</span>)</span><br><span class="line">    log.logger.error(<span class="string">u'报错'</span>)</span><br><span class="line">    log.logger.critical(<span class="string">u'严重'</span>)</span><br><span class="line">    error_log= Logger(<span class="string">'error.log'</span>, level=<span class="string">'error'</span>)</span><br><span class="line">    error_log.logger.error(<span class="string">'error'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这种方法虽然调用简单，但是日志中“lineno”字段的信息就只会对应的到上面的 logger 类中的函数，而不是真正打印信息的行数(后期研究一下如何解决)</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    all_log = Logger(<span class="string">'all.log'</span>, level=<span class="string">'debug'</span>)</span><br><span class="line">    all_log.debug(<span class="string">'debug'</span>)</span><br><span class="line">    all_log.info(<span class="string">'info'</span>)</span><br><span class="line">    all_log.warning(<span class="string">u'警告'</span>)</span><br><span class="line">    all_log.error(<span class="string">u'报错'</span>)</span><br><span class="line">    all_log.critical(<span class="string">u'严重'</span>)</span><br><span class="line">    error_log=Logger(<span class="string">'error.log'</span>, level=<span class="string">'error'</span>)</span><br><span class="line">    error_log.error(<span class="string">'error'</span>)</span><br><span class="line">    error_log.critical(<span class="string">u'严重'</span>)</span><br></pre></td></tr></table></figure><p>参考:<a href="https://www.cnblogs.com/Nicholas0707/p/9021672.html" target="_blank" rel="noopener">https://www.cnblogs.com/Nicholas0707/p/9021672.html</a></p><p><a href="https://www.cnblogs.com/nancyzhu/p/8551506.html" target="_blank" rel="noopener">https://www.cnblogs.com/nancyzhu/p/8551506.html</a> 综合案例</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> logging </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>anaconda与jupyter的使用和设置</title>
      <link href="/2019/08/04/anaconda%E4%B8%8Ejupyter%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/08/04/anaconda%E4%B8%8Ejupyter%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>jupyter 使用介绍、与 anaconda 的虚拟环境结合 、右键打开配置</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=D" target="_blank" rel="noopener">清华镜像站下载</a>   或者 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华镜像站anaconda首页</a></p></li><li><p>安装时，把Anaconda加入环境变量，这涉及到能否直接在cmd中使用conda、jupyter、ipython等命令，推荐打勾。如果没有打钩，后期请加入下面这些路径：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramData\Anaconda3;</span><br><span class="line">C:\ProgramData\Anaconda3\Library\mingw-w64\bin;</span><br><span class="line">C:\ProgramData\Anaconda3\Library\usr\bin;</span><br><span class="line">C:\ProgramData\Anaconda3\Library\bin;</span><br><span class="line">C:\ProgramData\Anaconda3\Scripts;</span><br></pre></td></tr></table></figure></li><li><p>配置镜像地址，否则从官方网站下载升级文件太慢</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure></li><li><p>推荐在默认环境下更新所有的包。打开 Anaconda Prompt （或者 Mac 下的终端），键入<code>conda upgrade —all</code></p></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy scipy pandas            <span class="comment"># 安装多个包</span></span><br><span class="line">conda install numpy=1.10                    <span class="comment"># 指定所需的包版本</span></span><br><span class="line">conda remove package_name                   <span class="comment"># 卸载包</span></span><br><span class="line">conda update package_name                   <span class="comment"># 更新包</span></span><br><span class="line">conda update --all                          <span class="comment"># 更新环境中的所有包（这样做常常很有用）</span></span><br><span class="line">conda list                                  <span class="comment"># 列出已安装的包</span></span><br><span class="line">conda search search_term                    <span class="comment"># 如果不知道要找的包的确切名称，可以尝试进行搜索</span></span><br></pre></td></tr></table></figure><h5 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看环境</span></span><br><span class="line">conda env list                              <span class="comment"># 列出你创建的所有环境</span></span><br><span class="line">conda info -e                               <span class="comment"># 列出你创建的所有环境</span></span><br><span class="line">conda info                                  <span class="comment"># 显示当前环境的全部相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑环境</span></span><br><span class="line">conda create -n env_name python=3.4 pandas  <span class="comment"># 创建环境 ，-n 是指名称</span></span><br><span class="line">conda env remove -n env_name --all          <span class="comment"># 删除指定的环境</span></span><br><span class="line">conda create -n new_env --<span class="built_in">clone</span> old_name    <span class="comment"># 克隆环境，实现重命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活/退出环境</span></span><br><span class="line">activate my_env                             <span class="comment"># 激活环境 window</span></span><br><span class="line"><span class="built_in">source</span> activate my_env                      <span class="comment"># 激活环境 OSX/Linux</span></span><br><span class="line">deactivate                                  <span class="comment"># 退出环境 window</span></span><br><span class="line"><span class="built_in">source</span> deactivate                           <span class="comment"># 退出环境 OSX/Linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出环境信息文件，利用文件信息克隆环境</span></span><br><span class="line">conda env <span class="built_in">export</span> &gt; environment.yaml         <span class="comment"># 将包保存为YAML，共享此文件，而且其他人能够用于创建和你项目相同的环境</span></span><br><span class="line">conda env create -f environment.yaml        <span class="comment"># 利用环境文件创建相同环境</span></span><br></pre></td></tr></table></figure><blockquote><p>  对于不使用 conda 的用户，可以使用命令<code>pip freeze&gt; pip_requirements.txt</code>（<a href="https://pip.pypa.io/en/stable/reference/pip_freeze/" target="_blank" rel="noopener">详情</a>）将一个 pip_requirements.txt 文件导出并包括在其中。</p></blockquote><p>推荐 Mac/linux，在 <code>~/.bash_profile</code> 中添加别名，方便激活环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> activate=<span class="string">"source activate"</span></span><br><span class="line"><span class="built_in">alias</span> deactivate=<span class="string">"source deactivate"</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/python2webdata/p/10034528.html" target="_blank" rel="noopener">https://www.cnblogs.com/python2webdata/p/10034528.html</a></p><h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><p>激活环境后，输入<code>jupyter notebook</code>就打开了当前环境的 notebook（<strong>如果当前环境没有安装jupyter，那么会调用base的</strong>）</p><p>为了不用每次都先切换环境才能使用 jupyter，可以进行一下配置，直接在 jupyter 打开的网页中指定环境。</p><h4 id="使用anaconda的虚拟环境"><a href="#使用anaconda的虚拟环境" class="headerlink" title="使用anaconda的虚拟环境"></a>使用anaconda的虚拟环境</h4><ol><li><p>激活虚拟环境 <code>source activate 环境名称</code></p></li><li><p>安装 ipykernel，注意：在虚拟环境中安装 ipykernel</p><p> <code>conda install ipykernel</code></p></li><li><p>写入Jupyter 的 kernel中，还是在该虚拟环境中，运行命令 <code>python -m ipykernel install --user --name 环境名称 --display-name &quot;Python (环境名称)&quot;</code></p></li><li><p>打开Jupyter <code>jupyter notebook</code></p></li></ol><h4 id="右键打开Jupyter"><a href="#右键打开Jupyter" class="headerlink" title="右键打开Jupyter"></a>右键打开Jupyter</h4><ol><li><p>打开 regedit，定位到<code>HKEY_CLASSES_ROOT\Directory\Background\shell</code></p></li><li><p>右键新建“项”，输入名称“jupyter”，该名称将出现在右键的菜单上</p></li><li><p>然后在jupyter目录的右侧，新建一个字符串值<code>Icon</code>，设置为</p><p> <code>%USERPROFILE%\AppData\Local\Continuum\anaconda3\Menu\jupyter.ico</code>，该图标将出现在右键的菜单上</p></li><li><p>最后在jupyter目录下新建一个目录 “command”，点击command目录，修改右侧的值为<code>&quot;C:\Windows\System32\cmd.exe&quot; &quot;--working-dir&quot; &quot;%v.&quot; &quot;/k jupyter notebook&quot;</code></p><blockquote><p>cmd /c start dir：会打开一个新窗口后执行dir指令，原窗口会关闭；</p><p>cmd /k start dir：会打开一个新窗口后执行dir指令，原窗口不会关闭。</p></blockquote></li></ol><p><img src="/2019/08/04/anaconda与jupyter使用与设置/./jupyter注册表1.png" alt="jupyter注册表1"></p><p><img src="/2019/08/04/anaconda与jupyter使用与设置/./jupyter注册表2.png" alt="jupyter注册表2"></p><p>参考：<a href="https://blog.csdn.net/firing00/article/details/81866878" target="_blank" rel="noopener">https://blog.csdn.net/firing00/article/details/81866878</a></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 效率 </tag>
            
            <tag> anaconda </tag>
            
            <tag> jupyter </tag>
            
            <tag> 右键 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2019/08/04/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/04/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>uniq命令用于报告或忽略文件中的重复行，<strong>查重复行的时候，只会检查相邻的行</strong>，因此一般与<a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort</a>命令结合使用，让重复的排在一起。比如下面：<code>aa</code> 统计结果是出现了 2 次，后面又有出现 1 次的 <code>aa</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 文本</span><br><span class="line">aa</span><br><span class="line">aa</span><br><span class="line">c</span><br><span class="line">aa</span><br><span class="line"></span><br><span class="line"># uniq 后</span><br><span class="line">uniq -c </span><br><span class="line">2 aa</span><br><span class="line">1 c</span><br><span class="line">1 aa</span><br></pre></td></tr></table></figure><p>常用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数；</span><br><span class="line">-u或——unique：仅显示出一次的行列；</span><br><span class="line">-d或--repeated：仅输出重复出现的行列，且重复的只输出一行；</span><br><span class="line">-D, --all-repeated   仅输出重复的行，有几行输出几行  </span><br><span class="line">-i, --ignore-case    不区分大小写  </span><br><span class="line">-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;   指定要比较的前 n 个字符，忽略后面的内容</span><br><span class="line">-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;         忽略前n列（空格分割），-f 1 忽略第一列</span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;   忽略前n个字符 -s 4 忽略前 4 个字符</span><br><span class="line">-z 忽略换行(不知道有什么用)</span><br></pre></td></tr></table></figure><p>提供的测试文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this is a test  </span><br><span class="line">this is a test  </span><br><span class="line">this is a test  </span><br><span class="line">i am tank  </span><br><span class="line">i love tank  </span><br><span class="line">i love tank  </span><br><span class="line">this is a test  </span><br><span class="line">whom have a try  </span><br><span class="line">WhoM have a try </span><br><span class="line">WhoM have a try1</span><br><span class="line">you  have a try  </span><br><span class="line">i want to abroad  </span><br><span class="line">those are good men  </span><br><span class="line">we are good men</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://blog.51yip.com/shell/1022.html" target="_blank" rel="noopener">http://blog.51yip.com/shell/1022.html</a></p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>-b</td><td>–ignore-leading-blanks</td><td>排序时忽略起始的空白</td></tr><tr><td>-c</td><td>–check</td><td>不排序，但检查输入数据是不是已排序；未排序的话，报告</td></tr><tr><td>-t</td><td>–field-separator=SEP</td><td>指定分隔符，如果是<code>\t</code>，需要这样<code>sort -t$&#39;\t&#39; file</code></td></tr><tr><td>-u</td><td>–unique</td><td>在输出行中去除重复行</td></tr><tr><td>-n</td><td>–numeric-sort</td><td>默认是字符串比较，指定-n使用数值比较</td></tr><tr><td>-g</td><td>–general-number-sort</td><td>按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学 计数法表示的值）</td></tr><tr><td>-r</td><td>–reverse</td><td>默认从小到大，指定后改为从大到小排序</td></tr><tr><td>-f</td><td>–ignore-case</td><td>默认情况下，会将大写字母排在前面；这个参数会忽略大小写</td></tr><tr><td>-o</td><td>–output=file</td><td>排序结果输出到指定文件，对于<strong>保存到原文件很有用</strong>，不然是可以用重定向的</td></tr><tr><td>-m</td><td>–merge</td><td>将两个已排序数据文件合并</td></tr><tr><td>-k</td><td>–key=POS1[,POS2]</td><td>指定排序的列，排序从POS1位置开始；如果指定了POS2的话， 到POS2位置结 束</td></tr><tr><td>-z</td><td>–zero-terminated</td><td>NULL字符作为行尾，而不是用换行符</td></tr></tbody></table><h4 id="k"><a href="#k" class="headerlink" title="-k"></a>-k</h4><p>选项的语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FStart.CStart Modifie, FEnd.CEnd Modifier</span><br><span class="line">-------Start---------, -------End--------</span><br><span class="line"> FStart.CStart 选项   ,   FEnd.CEnd 选项</span><br></pre></td></tr></table></figure><p>这个语法格式可以被其中的逗号<code>,</code>分为两大部分，<strong>Start</strong>部分和<strong>End</strong>部分。Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分。</p><p>我们重点说说<code>Start</code>部分的<code>FStart</code>和<code>C.Start</code>。<code>C.Start</code>也是可以省略的，省略的话就表示从本域的开头部分开始。<code>FStart.CStart</code>，其中<code>FStart</code>就是表示使用的域，而<code>CStart</code>则表示在<code>FStart</code>域中<strong>从第几个字符开始算“排序首字符”</strong>。同理，在End部分中，你可以设定<code>FEnd.CEnd</code>，如果你省略<code>.CEnd</code>，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。</p><p>在modifier部分还可以用到哪些选项？    modifier不论写在开始还是结束，都对这个域有效（我观察的）</p><p>可以用到b、d、f、i、n 或 r。</p><ul><li>其中n和r你肯定已经很熟悉了。</li><li>b表示忽略本域的签到空白符号。</li><li>d表示对本域按照字典顺序排序（即，只考虑空白和字母）。</li><li>f表示对本域忽略大小写进行排序。</li><li>i表示忽略“不可打印字符”，只针对可打印字符进行排序。（有些ASCII就是不可打印字符，比如\a是报警，\b是退格，\n是换行，\r是回车等等）</li></ul><p><strong>如果指定的域都一样，那就会从第一个域、第二个域依次升序比较</strong></p><p><strong>跨域的设定是个假象</strong>，FStart 与FEnd必须相同</p><h4 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h4><p>sort按照某列排序，一样的话再按某一列排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort  -k2,2 -k5,5 wide_table |grep <span class="string">"DD4486F320A7F0C112E2757C26609769"</span></span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ol><li><p>从公司英文名称的第二个字母开始进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 1.2 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure><p> 使用了<code>-k 1.2</code>，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。</p></li><li><p>按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -n -t &apos; &apos; -k 3r -k 2 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure><p>在-k 3后面偷偷加上了一个小写字母r。<strong>r和-r选项的作用是一样的，就是表示逆序，不过只对当前域有效</strong>，表示第三个域（员工平均工资）是按照降序排序。此处你还可以加上n，就表示对这个域进行排序时，要按照数值大小进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 3nr -k 2n facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure><p>我们去掉了最前面的-n选项，而是将它加入到了每一个-k选项中了。</p></li><li><p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -t &apos; &apos; -k 1.2,1.2 -k 3nr facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure><blockquote><p>  我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。</p></blockquote></li><li><p>最诡异的排序（跨域是不行的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sort -n -k 2.2,3.1 facebook.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure><p>以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。</p><p>第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。</p><p>又因为sort认为0小于00小于000小于0000….</p><p>因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢？（你可以自己做实验思考一下。）</p><p>答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了。</p></li></ol><p><a href="http://blog.chinaunix.net/uid-10540984-id-313479.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-10540984-id-313479.html</a></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep pattern filename  <span class="comment"># 默认支持正则</span></span><br><span class="line">grep -e pattern1 -e pattern2 filename</span><br></pre></td></tr></table></figure><p>默认情况下，grep命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。</p><p>需要注意的是：限定连续字符范围 的<code>{}</code>符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 <code>\{</code> 与<code>\}</code> 来让它失去特殊意义才行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">grep --color=auto <span class="string">" 在输出行中着重标记出匹配到的模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-a  # 将 binary 文件以 text 文件的方式搜寻数据</span></span><br><span class="line"><span class="string">-e  # 如果要指定多个匹配模式，可用-e参数来指定每个模式,grep -e t -e f file 输出了含有字符t或字符f的所有行。</span></span><br><span class="line"><span class="string">-o # 只输出匹配到的文本，如果在同一行中，会分开显示</span></span><br><span class="line"><span class="string">-v  # 打印出不匹配match_pattern的所有行</span></span><br><span class="line"><span class="string">-c# 统计匹配行的数量，并不是匹配的次数。匹配次数需要与-o配合，请看后面的例子</span></span><br><span class="line"><span class="string">-n  # 打印出匹配字符串所在行的行号,以及该行的内容，如果涉及多个文件，该选项也会随输出结果打印出文件名</span></span><br><span class="line"><span class="string">-i # 忽略模式中的大小写</span></span><br><span class="line"><span class="string">-l # 多文件处理时，可以列出匹配模式所在的文件</span></span><br><span class="line"><span class="string">-L # 与-l相反，它会返回一个不匹配的文件列表</span></span><br><span class="line"><span class="string">-q # 静默模式（主要用于脚本中，，在命令行中没什么用），只判断是否匹配成功,不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。0表示匹配成功，非0表示匹配失败。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 显示前后几行</span></span><br><span class="line"><span class="string">-A # after，显示匹配到的行以及之后的 n 行</span></span><br><span class="line"><span class="string">-B # before，显示匹配到的行以及之前的 n 行</span></span><br><span class="line"><span class="string">-C # Center，显示匹配到的行以及前后的 n </span></span><br><span class="line"><span class="string"># 如果匹配到多行，为了区分匹配到的字符串，用"</span>--<span class="string">"进行区分，比如：</span></span><br><span class="line"><span class="string">echo -e "</span>a\nb\nc\na\nb\nc<span class="string">" | grep a -A 1</span></span><br><span class="line"><span class="string"># a匹配到第1次</span></span><br><span class="line"><span class="string"># b</span></span><br><span class="line"><span class="string"># --</span></span><br><span class="line"><span class="string"># a匹配到第2次</span></span><br><span class="line"><span class="string"># c</span></span><br></pre></td></tr></table></figure><p>统计匹配项的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l</span><br></pre></td></tr></table></figure><h4 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h4><p>egrep命令是grep的一个衍生，支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更 多的可以用来指定匹配模式的字符，增加了额外的正则表达式元字符集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">"[a-z]+"</span> filename</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">egrep <span class="string">"[a-z]+"</span> filename</span><br></pre></td></tr></table></figure><h4 id="不使用正则表达式"><a href="#不使用正则表达式" class="headerlink" title="不使用正则表达式"></a>不使用正则表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -F &apos;str&apos;</span><br><span class="line">fgrep &apos;str&apos;</span><br></pre></td></tr></table></figure><p><code>fgrep</code> 查询速度比<code>grep</code>命令快，但是不够灵活：它<strong>只能找固定的文本，而不是正则表达式。</strong></p><p>如果你想在一个文件或者输出中找到包含星号字符的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fgrep  <span class="string">'*'</span> /etc/profile</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">grep -F <span class="string">'*'</span> /etc/profile</span><br></pre></td></tr></table></figure><p>fgrep则是另外一个版本，支持将匹配模式 指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后 在fgrep命令中用其在一个大型文件中搜索字符串了。</p><h4 id="检索文件内容"><a href="#检索文件内容" class="headerlink" title="检索文件内容"></a>检索文件内容</h4><p>递归搜索目录中的文件内容（不是文件名）<code>-R</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"test_function()"</span> ./ -R -n </span><br><span class="line"><span class="comment"># ./miscutils/test.c:16:test_function(); 找到在test.c的第16行</span></span><br></pre></td></tr></table></figure><p>等价于<code>find . -type f | xargs grep &quot;test_function()&quot;</code></p><p>命令会打印出匹配任意一种模式的行，每个匹配对应一行输出。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a line of text | grep -o -e <span class="string">"this"</span> -e <span class="string">"line"</span> this</span><br></pre></td></tr></table></figure><p>可以将多个模式定义在文件中。选项-f可以读取文件并使用其中的模式（一个模式一行，记得最后留一行空白行，不然最后一种模式匹配不到，很诡异）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat pat_file</span><br><span class="line"><span class="comment"># ^h.*</span></span><br><span class="line"><span class="comment"># co+l</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> hello \n this is cool | grep -f pat_file </span><br><span class="line"><span class="comment"># hello </span></span><br><span class="line"><span class="comment"># this is cool</span></span><br></pre></td></tr></table></figure><h4 id="指定或者排除文件"><a href="#指定或者排除文件" class="headerlink" title="指定或者排除文件"></a>指定或者排除文件</h4><p>使用–include选项在目录中递归搜索所有的 .c和 .cpp文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"main()"</span> . -r --include *.&#123;c,cpp&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  注意，<code>some{string1,string2,string3}</code> 会被扩展成 <code>somestring1 somestring2 somestring3</code>。</p></blockquote><p> 相反的就是<code>--exclude</code></p><p><code>--exclude-dir</code>可以排除目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep main . -r -exclude-dir CVS</span><br></pre></td></tr></table></figure><p><code>--exclude-from FILE</code>从文件中读取排除文件列表</p><h4 id="0值字节后缀的-xargs"><a href="#0值字节后缀的-xargs" class="headerlink" title="0值字节后缀的 xargs"></a>0值字节后缀的 xargs</h4><p>xargs命令可以为其他命令提供命令行参数列表。</p><p>当文件名作为命令行参数时，建议用0值字节作为文件名终结符，而非空格。因为一些文件名中会包含空格字符，一旦它被误解为终结符， 那么单个文件名就会被视为两个（例如，New file.txt被解析成New和file.txt两个文件名）。</p><p>这个问题可以利用0值字节后缀来避免。</p><p>grep和find命令可以生成带有0值字节后缀的输出，然后传递 给 xargs，让它产生文件名列表。为了指明输入中的文件名是以0值字节作为终结，需 要在xargs中使用选项-0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试文件：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; file1  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"cool"</span> &gt; file2 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span> &gt; file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出包含有 test 内容的文件名，并以0值字节作为终结符，然后传递给 xargs，让它生成文件名参数列表，之后传递（不用管道符号）给 rm 命令，删除这些文件</span></span><br><span class="line">grep <span class="string">"test"</span> file* -lZ | xargs -0 rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项-l告诉grep只输出有匹配出现的文件名。选项-Z使得grep使用0值字节（\0）作为文 件名的终结符。这两个选项通常都是配合使用的。xargs的-0选项会使用0值字节作为输入的分隔符</span></span><br></pre></td></tr></table></figure><h4 id="比较两个文件相同的行与不同的行"><a href="#比较两个文件相同的行与不同的行" class="headerlink" title="比较两个文件相同的行与不同的行"></a>比较两个文件相同的行与不同的行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -Ff  file1 file2   <span class="comment"># 输出公共的行</span></span><br><span class="line">grep -vFf  file1 file2   <span class="comment"># 输出不在 file1 的行</span></span><br></pre></td></tr></table></figure><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>tr是translate（转换）的简写，基本功能是将字符从一个字符集合映射到另一个集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr set1 set2</span><br></pre></td></tr></table></figure><blockquote><p>  注意： <code>tr</code>只能通过<code>stdin</code> 接收输入，无法通过命令行参数接收 ，如<code>tr -s &#39;&#39; file</code>，只能转为 <code>stdin</code> 形式，<code>tr -s &#39; &#39;&lt; file.txt</code></p></blockquote><p>如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1 相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;HELLO WHO IS THIS&quot; | tr &apos;A-Z&apos; &apos;a-z&apos;</span><br></pre></td></tr></table></figure><p>字符集合（字符组）可以使用“起始字符—终止字符”，如果不是有效的连续字符序列， 那么它就会被视为<code>起始字符</code>、<code>—</code>、<code>终止字符</code>这3个元素的集合。也可以使用像<code>\t</code>、<code>\n</code> 这种特殊字符或其他ASCII字符。可以按照需要追加字符或<strong>字符类</strong>来构造自己的字符组。</p><table><thead><tr><th>字符类</th><th>说明</th></tr></thead><tbody><tr><td>alnum</td><td>字母和数字</td></tr><tr><td>alpha</td><td>字母</td></tr><tr><td>cntrl</td><td>控制（非打印）字符</td></tr><tr><td>digit</td><td>数字</td></tr><tr><td>graph</td><td>图形字符</td></tr><tr><td>lower</td><td>小写字母</td></tr><tr><td>print</td><td>可打印字符</td></tr><tr><td>punct</td><td>标点符号</td></tr><tr><td>space</td><td>空白字符</td></tr><tr><td>upper</td><td>大写字母</td></tr><tr><td>xdigit</td><td>十六进制字符</td></tr></tbody></table><p>字符类的使用方法<code>tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code></p><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tr [options] set1  [set2]</span><br><span class="line">-d     # 删除(delete)set1 中的字符</span><br><span class="line">-c     # tr会将不在set1中的字符转换成set2中的字符,set2只能是一个字符</span><br><span class="line">-d -c  # 只保留set1的字符，不需要set2</span><br><span class="line">-s     # 删除重复字符，只留下一个</span><br></pre></td></tr></table></figure><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>tr命令可以用来加密。ROT13是一个著名的加密算法。在ROT13算法中，字符会被移动13 个位置，因此文本加密和解密都使用同一个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"tr came, tr saw, tr conquered."</span> | tr <span class="string">'a-zA-Z'</span> <span class="string">'n-za-mN-ZA-M'</span></span><br></pre></td></tr></table></figure><p>将制表符转换成单个空格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr <span class="string">'\t'</span> <span class="string">' '</span> &lt; file.txt</span><br></pre></td></tr></table></figure><p> 删除字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello 123 world 456&quot; | tr -d &apos;0-9&apos; </span><br><span class="line"># Hello world</span><br></pre></td></tr></table></figure><p>只保留set1 的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hello 1 char 2 next 4 | tr -d -c &apos;0-9 \n&apos;</span><br><span class="line"># 124</span><br></pre></td></tr></table></figure><p>压缩空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;GNU  is   not     UNIX.     Recursive       GNU is not UNIX. Recursive right ?&quot; | tr -s &apos; &apos;</span><br></pre></td></tr></table></figure><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、 CSV文件或是由空格分隔的文件。</p><blockquote><p>  如果空格的长度不一致，需要使结合<code>tr</code>命令，进行字符串转换</p></blockquote><p>每列被称为一个<strong>字段</strong>，默认分隔符是制表符<code>\t</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-d&quot;\t&quot;    # 指定分割符为&quot;\t&quot;，默认就是制表符，因此可以不写</span><br><span class="line">-f2,3     # 显示2,3列的内容,f2可以不用空格分开</span><br><span class="line">-f2-4     # 显示第2到4列(field)的内容，2-5 的用法看后面表格说明</span><br><span class="line">-c2-5     # 显示第2到5个字符(character)，注意不能与-d 组合</span><br><span class="line">-b2-5     # 显示第2到5个字节(byte)，注意不能与-d 组合</span><br><span class="line">--complement # 与-f 组合使用，显示f没有指定的列，就是取反</span><br><span class="line">--output-delimiter    指定输出时的列分隔符</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cut range_fields.txt -c1-3,6-9 --output-delimiter <span class="string">","</span> </span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi </span></span><br><span class="line"><span class="comment"># abc,fghi</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选取方式</th><th>说明</th></tr></thead><tbody><tr><td>N-</td><td>从第N个字节、字符或字段开始到行尾</td></tr><tr><td>N-M</td><td>从第N个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</td></tr><tr><td>-M</td><td>从第1个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut -c -2 range_fields.txt    <span class="comment"># 打印前2个字符</span></span><br><span class="line">cut -c2-5 range_fields.txt    <span class="comment"># 打印第2个到第5个字符</span></span><br></pre></td></tr></table></figure><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed是stream editor（流编辑器）的缩写。它最常见的用法是进行文本替换。<strong>默认不修改原文件，只显示修改后的结果。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br><span class="line"></span><br><span class="line">-e &apos;script1;script2&apos;</span><br><span class="line">-f script_file # 从文本中读取大量指令，一行一个，以换行结束</span><br><span class="line">-i # 保存到原文件</span><br><span class="line">-n或--quiet或--silent # 仅显示script处理后的结果。</span><br></pre></td></tr></table></figure><p>要是我们想就地（in place）修改文件内容，可以使用选项<code>-i</code>保存到原文件中。值得<strong>推荐的做法</strong>是</p><ul><li><p>先使用不带<code>-i</code>选项的<code>sed</code>命令，以确保正则表达式没有问题，如果结果符合要求，再加入-i选项将更改写入文件。</p></li><li><p>也可以使用<code>sed -i.bak &#39;s/abc/def/&#39; file</code>，这时的sed不仅替换文件内容，还会创建一个名为<code>file.bak</code>的文件，其中包含着原始文件内容的副本。</p></li></ul><h5 id="替换s"><a href="#替换s" class="headerlink" title="替换s"></a>替换<code>s</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s/old/new/          # 替换每行第1个匹配到的字符串</span><br><span class="line">s/old/new/2         # 替换每行第2个匹配到的字符串</span><br><span class="line">s/old/new/g         # 替换全部</span><br><span class="line">s/old/new/2g        # 只替换第2次及之后匹配到的字符串</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> thisthisthisthis | sed <span class="string">'s/this/THIS/2g'</span> </span><br><span class="line"><span class="comment"># thisTHISTHISTHIS</span></span><br></pre></td></tr></table></figure><h6 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s/pattern/replacement/flags</span><br></pre></td></tr></table></figure><p>有4种可用的替换标记： </p><ul><li>数字，表明新文本只替换每行第几处模式匹配的地方； </li><li>g，表明新文本将会替换所有匹配的文本； </li><li>p，表明原先行的内容要打印出来；</li><li>w file，将匹配到的行替换的结果写到指定的file中。</li></ul><p>p替换标记会打印与替换命令中指定的模式匹配的行替换后的结果。这通常会和sed的-n选项一起使用。-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是 只输出被替换命令修改过的行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat data5.txt </span><br><span class="line">This is a <span class="built_in">test</span> line.</span><br><span class="line">This is a different line.</span><br><span class="line"></span><br><span class="line">$ $ sed -n <span class="string">'s/test/trial/p'</span> data5.txt </span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure><p>w替换标记会产生与 p 模式同样的输出，不过会将输出保存到指定文件中。</p><h6 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h6><p><code>sed</code>命令会将<code>s</code>之后的字符视为命令分隔符。这允许我们更改默认的分隔符<code>/</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s:text:replace:g&apos; </span><br><span class="line">sed &apos;s|text|replace|g&apos;</span><br></pre></td></tr></table></figure><p>如果作为分隔符的字符出现在模式中，必须使用<code>\</code>对其进行转义</p><h6 id="指定行"><a href="#指定行" class="headerlink" title="指定行"></a>指定行</h6><p>方式1（数字）：</p><p>在<code>s</code>前添加行编辑即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2s/dog/cat/'</span> data1.txt   <span class="comment"># 只修改地址指定的第2行的文本</span></span><br><span class="line">sed <span class="string">'2,3s/dog/cat/'</span> data1.txt <span class="comment"># 只修改地址指定的第2，3行的文本</span></span><br><span class="line">sed <span class="string">'2,$s/dog/cat/'</span> data1.txt <span class="comment"># 修改从某行开始的所有行</span></span><br></pre></td></tr></table></figure><p>方式2（正则）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/pattern/s/bash/csh/'</span> /etc/passwd  <span class="comment"># 使用 pattern 正则表达式过滤</span></span><br></pre></td></tr></table></figure><p><strong>已匹配字符串标记（&amp;）</strong></p><p>在sed中，我们可以用&amp;指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹 配的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo this is an example | sed &apos;s/\w+/[&amp;]/g&apos;</span><br><span class="line"># [this] [is] [an] [example]</span><br></pre></td></tr></table></figure><p><strong>子串匹配标记（\num）</strong></p><p> 匹配正则中的子表达式，第1 个是<code>\1</code>，第 2 个是<code>\2</code>，以此类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo this is digit 7 in a number | sed &apos;s/digit \([0-9]\)/\1/&apos; </span><br><span class="line"># this is 7 in a number</span><br></pre></td></tr></table></figure><p><strong>多表达式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'expression; expression'</span></span><br><span class="line">sed <span class="string">'expression'</span> | sed <span class="string">'expression'</span></span><br><span class="line">sed -e <span class="string">'expression'</span> -e <span class="string">'expression'</span></span><br><span class="line">sed -e <span class="string">'expression; expression'</span></span><br><span class="line">sed -e <span class="string">'</span></span><br><span class="line"><span class="string">&gt; s/brown/green/</span></span><br><span class="line"><span class="string">&gt; s/fox/elephant/</span></span><br><span class="line"><span class="string">&gt; s/dog/cat/'</span> data1.txt</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo abc | sed &apos;s/a/A/;s/c/C/&apos;</span><br><span class="line">echo abc | sed &apos;s/a/A/&apos; | sed &apos;s/c/C/&apos;</span><br><span class="line">echo abc | sed -e &apos;s/a/A/&apos; -e &apos;s/c/C/&apos;</span><br><span class="line">echo abc | sed -e &apos;s/a/A/; s/c/C/&apos;</span><br><span class="line"># AbC</span><br></pre></td></tr></table></figure><p><strong>单引号与双引号的区别</strong></p><p>sed表达式<strong>通常用单引号来引用</strong>。如果想在sed表达式中使用变量，双引号就能派上用场了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text=hello </span><br><span class="line">echo hello world | sed &quot;s/$text/HELLO/&quot; </span><br><span class="line"># HELLO world</span><br></pre></td></tr></table></figure><h5 id="多命令"><a href="#多命令" class="headerlink" title="多命令"></a>多命令</h5><p>如果需要在匹配到的行上执行多条命令，可以用<code>{}</code>将多条命令组合在一起，同时指定过滤的行号，或者匹配模式。</p><p>多条命令之间用<code>;</code>分割，或者分成多行书写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行内多个命令</span></span><br><span class="line">sed -n <span class="string">'/root/&#123;s/bash/blueshell/;p;q&#125;'</span> /etc/passwd </span><br><span class="line"></span><br><span class="line"><span class="comment"># 分成多行执行多个命令</span></span><br><span class="line">sed <span class="string">'3,$&#123;</span></span><br><span class="line"><span class="string">&gt; s/brown/green/</span></span><br><span class="line"><span class="string">&gt; s/lazy/active/</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data1.txt</span><br></pre></td></tr></table></figure><h5 id="插入a与i"><a href="#插入a与i" class="headerlink" title="插入a与i"></a>插入<code>a</code>与<code>i</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'[address]command\</span></span><br><span class="line"><span class="string">new line'</span></span><br></pre></td></tr></table></figure><p>插入（insert）命令（i）会在指定行前插入文本，（插入的文本要带有换行，否则就直接插入在指定行的头部）</p><p>附加（append）命令（a）会在指定行后添加文本，（如果文本没换行，会与下一行在同一行）</p><p>可以指定一个行地址，匹配一个数字行号或文本模式</p><blockquote><p>  这两条命令的费解之处在于它们的格式。它们不能在一行内使用。你必须先输入<code>i</code>或者<code>a</code>，然后使用<code>\</code>进行换行，接着输入要插入或者附加的内容。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本中的写法</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'1i\   # 在第一行前插入</span></span><br><span class="line"><span class="string">Test Line 1\     # 换行，否则两行文本会在一同一行</span></span><br><span class="line"><span class="string">'</span> </span><br><span class="line">Test Line 1 </span><br><span class="line">Test Line 2</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Test Line 2"</span> | sed <span class="string">'/Line/a\   # 在包含Line的一行添加</span></span><br><span class="line"><span class="string">Test Line 1\</span></span><br><span class="line"><span class="string">'</span> </span><br><span class="line"></span><br><span class="line">Test Line 2 </span><br><span class="line">Test Line 1</span><br></pre></td></tr></table></figure><h6 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h6><p>插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后 一行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'1i\</span></span><br><span class="line"><span class="string">&gt; This is one line of new text.\</span></span><br><span class="line"><span class="string">&gt; This is another line of new text.'</span> data6.txt </span><br><span class="line"></span><br><span class="line">This is one line of new text.</span><br><span class="line">This is another line of new text.</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h5 id="删除行-d"><a href="#删除行-d" class="headerlink" title="删除行 d"></a>删除行 <code>d</code></h5><p>删除命令<code>d</code>名副其实，它会删除匹配指定寻址模式的所有行。</p><p>支持指定行<code>sed &#39;2,3d&#39; data6.txt</code></p><p>通过特定行区间指定：<code>sed &#39;2,3d&#39; data6.txt</code></p><p>模式匹配特性也适用于删除命令<code>sed &#39;/number 1/d&#39; data6.txt</code></p><p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。</p><ul><li>sed编辑器会删除两个指定行之间 的所有行（包括指定的行）。<strong>如果没有找到停止模式，所以就将数据流中的剩余行全部删除了。</strong></li><li>你指定的第1个模式 会“打开”行删除功能，第2个模式会“关闭”行删除功能。之后<strong>再遇到第1个模式会再打开删除功能</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat data7.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is line number 1 again.   <span class="comment"># 再次触发删除功能</span></span><br><span class="line">This is text you want to keep. </span><br><span class="line">This is the last line <span class="keyword">in</span> the file. </span><br><span class="line"></span><br><span class="line">$ sed <span class="string">'/1/,/3/d'</span> data7.txt </span><br><span class="line">This is line number 4.</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure><h5 id="字符转换y"><a href="#字符转换y" class="headerlink" title="字符转换y"></a>字符转换<code>y</code></h5><p>转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]y/inchars/outchars/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'y/123/789/'</span> data8.txt </span><br><span class="line">This is line number 7.</span><br><span class="line">This is line number 8.</span><br><span class="line">This is line number 9.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is line number 7 again.</span><br><span class="line">This is yet another line.</span><br><span class="line">This is the last line <span class="keyword">in</span> the file. </span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>转换命令会对inchars和outchars值进行一对一的映射。</p><p>如果inchars和outchars的长度不同，则sed编辑器会产生一 条错误消息。</p><p>转换命令是一个全局命令，你无法限定只转换在特定地方出现的字符。</p><h5 id="打印命令"><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h5><ol><li>p命令用来打印文本行； </li><li>等号（=）命令用来打印行号； </li><li>l（小写的L）命令用来列出行。</li></ol><h6 id="p-命令"><a href="#p-命令" class="headerlink" title="p 命令"></a>p 命令</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is a test"</span> | sed <span class="string">'p'</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>它所做的就是打印已有的数据文本</p><p>最常见的用法是与<code>-n</code>配合打印包含匹配文本模式的行。用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line"></span><br><span class="line">$ $ sed -n &apos;/number 3/p&apos; data6.txt </span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><p>修改前后对比</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'/3/&#123;</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; s/line/test/p</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data6.txt </span><br><span class="line">This is line number 3. </span><br><span class="line">This is <span class="built_in">test</span> number 3. $</span><br></pre></td></tr></table></figure><h6 id="等号"><a href="#等号" class="headerlink" title="=等号"></a><code>=</code>等号</h6><p>等号命令会打印行在<strong>数据流中的当前行号</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;=&apos; data1.txt </span><br><span class="line">1 </span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">2 </span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'/number 4/&#123;</span></span><br><span class="line"><span class="string">&gt; =</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; &#125;'</span> data6.txt 4 </span><br><span class="line">This is line number 4. </span><br><span class="line">$</span><br></pre></td></tr></table></figure><h6 id="显示特殊字符l"><a href="#显示特殊字符l" class="headerlink" title="显示特殊字符l"></a>显示特殊字符<code>l</code></h6><p>命令（<code>l</code>）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印 字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\t，来代表制表符。</p><p>制表符的位置使用\t来显示。行尾的美元符表示换行符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat data10.txt </span><br><span class="line">This line contains an escapecharacter.</span><br><span class="line"></span><br><span class="line">$ $ sed -n <span class="string">'l'</span> data10.txt </span><br><span class="line">This line contains an escape\tcharacter. \a$</span><br></pre></td></tr></table></figure><h5 id="保存命令w"><a href="#保存命令w" class="headerlink" title="保存命令w"></a>保存命令<code>w</code></h5><p>w命令用来向文件写入行。该命令的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]w filename</span><br></pre></td></tr></table></figure><p><code>filename</code>可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文 件的写权限。</p><p>地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat data11.txt </span><br><span class="line">Blum, R Browncoat </span><br><span class="line">McGuiness, A Alliance</span><br><span class="line">Bresnahan, C Browncoat </span><br><span class="line">Harken, C Alliance </span><br><span class="line">$ </span><br><span class="line">$ sed -n <span class="string">'/Browncoat/w Browncoats.txt'</span> data11.txt </span><br><span class="line">$ </span><br><span class="line">$ cat Browncoats.txt </span><br><span class="line">Blum, R Browncoat </span><br><span class="line">Bresnahan, C Browncoat</span><br></pre></td></tr></table></figure><h5 id="读取命令"><a href="#读取命令" class="headerlink" title="读取命令"></a>读取命令</h5><p>读取（read）命令（r）允许你将另一个文件中的数据插入到数据流中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]r filename</span><br></pre></td></tr></table></figure><p>地址区间<strong>只能指定单独一个行号或文本模式地址</strong>。sed编辑器会将文件中的<strong>所有文本行</strong>插入到指定地址后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat data12.txt </span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line. </span><br><span class="line">$ </span><br><span class="line">$ sed <span class="string">'3r data12.txt'</span> data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line. </span><br><span class="line">This is line number 4.</span><br><span class="line">$</span><br><span class="line">$ sed <span class="string">'/number 2/r data12.txt'</span> data6.txt </span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>另一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat notice.std </span><br><span class="line">Would the following people:</span><br><span class="line">LIST </span><br><span class="line">please report to the ship<span class="string">'s captain. </span></span><br><span class="line"><span class="string">$</span></span><br><span class="line"><span class="string">$ sed '</span>/LIST/&#123;</span><br><span class="line">&gt; r data11.txt</span><br><span class="line">&gt; d</span><br><span class="line">&gt; &#125;<span class="string">' notice.std </span></span><br><span class="line"><span class="string">Would the following people:</span></span><br><span class="line"><span class="string">Blum, R Browncoat </span></span><br><span class="line"><span class="string">McGuiness, A Alliance </span></span><br><span class="line"><span class="string">Bresnahan, C Browncoat </span></span><br><span class="line"><span class="string">Harken, C Alliance </span></span><br><span class="line"><span class="string">please report to the ship'</span>s captain. $</span><br><span class="line"></span><br><span class="line">现在占位文本已经被替换成了数据文件中的名单。</span><br></pre></td></tr></table></figure><h3 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h3><p>压缩命令 linux 命令行与 shell 脚本编程大全 4.33 </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。</p><p>参考：<a href="https://awk.readthedocs.io/en/latest/chapter-one.html" target="_blank" rel="noopener">https://awk.readthedocs.io/en/latest/chapter-one.html</a></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
            <tag> awk </tag>
            
            <tag> 更新ing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac卸载官网的python</title>
      <link href="/2019/01/04/mac%E5%8D%B8%E8%BD%BD%E5%AE%98%E7%BD%91%E7%9A%84python/"/>
      <url>/2019/01/04/mac%E5%8D%B8%E8%BD%BD%E5%AE%98%E7%BD%91%E7%9A%84python/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>不建议自己安装 官网的Python，因为这是典型的安装容易，删除麻烦。提供了安装器，但没有卸载器</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>我们首先要知道其具体都安装了什么，实际上，在安装 Python 时，其自动生成:</p><ul><li><p>Python framework，即 Python 框架; </p></li><li><p>Python 应用目录; </p></li><li><p>指向 Python 的连接。 </p></li></ul><p>对于 Mac 自带的 Python，其框架目录为：<code>/System/Library/Frameworks/Python.framework</code></p><p>而我们安装的 Python，其(默认)框架目录为：<code>/Library/Frameworks/Python.framework</code></p><p>接下来,我们就分别(在 Mac 终端进行)删除上面所提到的三部分，其中x.x为 Python 的版本号。</p><p>第 1 步，删除框架:</p><p><code>sudo rm -rf /Library/Frameworks/Python.framework/Versions/x.x</code></p><p>第 2 步，删除应用目录:</p><p><code>sudo rm -rf &quot;/Applications/Python x.x&quot;</code></p><p>第 3 步，删除指向 Python 的连接:</p><p><code>ls -l /usr/local/bin | grep &#39;../Library/Frameworks/Python.framework/Versions/x.x&#39; | awk &#39;{print $9}&#39; | tr -d @ | xargs rm</code></p><p>第 4 步，删除环境变量$PATH</p><p>至此，我们已经成功删除 Python 的相关文件</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 系统环境 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>photoshop曲线原理与应用</title>
      <link href="/2018/12/18/photoshop%E6%9B%B2%E7%BA%BF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2018/12/18/photoshop%E6%9B%B2%E7%BA%BF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>转载poco：photoshop曲线原理与应用，<a href="https://www.jb51.net/photoshop/532386.html" target="_blank" rel="noopener">https://www.jb51.net/photoshop/532386.html</a></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><blockquote><p>关键句：可以看到S型曲线中间部分，输入和输出值变化很小。所以<strong>S曲线在中间调区域的影响并不大，很好的保护了照片细节最丰富的部分。</strong>白色和黑色区域在最两端，S型曲线对这些亮度区域的改变也不大，<strong>有效防止了过曝和欠曝溢出。</strong></p></blockquote><h3 id="零、曲线工具原理"><a href="#零、曲线工具原理" class="headerlink" title="零、曲线工具原理"></a>零、曲线工具原理</h3><p>如果说直方图是摄影师的“X光片”，那么曲线工具一定是摄影师的“手术刀”了。</p><p>曲线作为重要的影调和色调调整工具，不仅存在于Photoshop中，在ACR，Lightroom甚至其他很多手机P图软件中都占据着显眼的位置。本篇文章，就将详细谈谈什么是RGB曲线，如何使用提亮压暗、黑白场、对比度，以及局部调整曲线等基本形态，调整一张照片的影调。同时，还会讲解如何把各种基本曲线形态组合起来，达到胶片、漂白、日系等等更复杂的影调效果。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754284.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p><strong>曲线工具在哪?</strong></p><p>曲线面板在Lightroom和Adobe Camera Raw工具中，都是紧接着基本面板的第二个面板，足以感受到它的重要性。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754285.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>在Photoshop中，我们一般会使用曲线调整图层来改变曲线。在PS中图层面板的右下角，第四个图标就是“新建调整图层”选项，点击后选择“曲线”，我们就可以新建一个“曲线调整图层”。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754286.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>新建调整图层，而不是在原图层上直接改变曲线。优点就是可以让我们方便的撤销/恢复所做的任意调整。曲线是什么?</p><p>本文将重点讲解RGB通道曲线，它是由红(R)绿(G)蓝(B)三个通道的曲线叠加而成的，可以“近似的”理解成图片的亮度曲线。</p><p><strong>RGB曲线调整的核心其实就是对原图亮度的变换。</strong></p><p>曲线的横轴是原图的亮度分布，从左到右依次是0值纯黑，1-254的中间灰色值，以及最右边255的纯白最亮值。横轴上叠加着一个直方图，显示出原图各个亮度上，分别存在着多少像素。</p><p>曲线的纵轴是目标图(调整后)的亮度，从下到上任然是0-255的亮度值。当中的那根线就是我们的“曲线”。当我们在曲线上任意取一个点，它的“输入值”就是它横轴对应的值，即原图中的亮度，它的“输出值”就是它纵轴中的数值，也就是调整后它的亮度值。</p><p>未调整的情况下，图像的曲线会是一条对角线，也就是横轴(原图)和纵轴(目标图)的亮度值相等。比如我在曲线上取了一个点，它的输入和输出值都是193。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754287.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>如果我把这个点往上移动，可以看到这个点的输出值变成了232.这意味着原图直方图上那些193亮度的点，都被提亮到了更亮的232。同时我们可以发现曲线的一个特点，当我们变动一个点的时候，旁边的点也会跟着一起变化，离调整点越远的点变化越小。这样使得曲线调整的图片，大多数情况都比较的平滑自然。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754288.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>通过在曲线上添加控制点(锚点)，我们就可以把曲线变成各种各样的形态，从而达到我们想要的影调效果。接下来我就会通过一些基本的曲线形态，来进一步的解释曲线。</p><h3 id="一、提亮压暗曲线"><a href="#一、提亮压暗曲线" class="headerlink" title="一、提亮压暗曲线"></a>一、提亮压暗曲线</h3><p>提亮和压暗一张图片，并不是我们想象中的对图片中所有点都加大减小同样的亮度值。比如下面这个曲线，就是把图像上所有的点亮度都提高了64。这样造成了2个不好的结果：</p><p>(1)图片的高光区域直接过曝溢出了</p><p>(2)图片的阴影和黑色区域亮度大大提高，使得图片黑场不足，严重发灰。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754289.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>所以我们一般提亮图片都是用如下的曲线，把锚点放在中间调附近往上提。这样照片主要是中间调的亮度大幅提高。高光区域亮度提高较少，防止了过曝。阴影黑色区域提升也不多，较好的维持了图像的对比反差程度。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754290.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>同样的，我们要压暗一张图片，也是用描点下拉图片的中间调。保护阴影区域不欠曝，让高光白色区域维持住对比度。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754291.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><h3 id="二、黑白场曲线"><a href="#二、黑白场曲线" class="headerlink" title="二、黑白场曲线"></a>二、黑白场曲线</h3><p>我们把照片上最暗的点叫做黑场，最亮的点叫做白场，黑白场的差值决定了一张照片的反差程度。通过横移和竖移曲线的左右两端，就可以加大和减小照片的黑白场差值。</p><p>比如下面这张图片就是一张灰蒙蒙的低反差图片，照片最暗的地方也只是亮度高达50多的深灰色，照片最亮的地方也只是200多的浅灰色。照片的黑色和白色区域完全没有像素。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754292.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>所以我把曲线最右侧横向左移，此时原来亮度值(输入值)219的像素，全部被提亮到了255(输出值)的纯白色。照片中终于有了亮白的部分。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754293.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>同样我在曲线最左侧建立一个锚点，横向右拉，此时原来亮度值55的深灰色区域，就全部输出成了亮度为0的纯黑区域。照片中又有了深黑色。通过这两步，我们加大了照片黑白场的差距，照片的反差就大大提高了。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754294.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>黑白场差值大的图片一般层次丰富，鲜艳锐利。但是照片的黑白场差值并不是越高越好。一个很大的误区就是照片的黑场一定要是0，白场必须为255。实则不然，比如这张照片，照片的黑场是0，照片中有许多深黑区域，显得反差比较大，可能并不是我们想要的效果。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754295.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>我在曲线最左侧建立一个锚点，纵向上拉。这样输入值为0的纯黑部分，亮度被提高到了38。照片中不再有纯黑，最暗的部分(也就是黑场)也是亮度38的深灰色，这样的照片看起来更加的朦胧淡雅，符合我们想要的气氛。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754296.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><h3 id="三、对比度曲线"><a href="#三、对比度曲线" class="headerlink" title="三、对比度曲线"></a>三、对比度曲线</h3><p>对比度曲线，其实就是摄影里几乎人人皆知的S型曲线和反S型曲线了。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754297.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>增强对比度曲线(S型曲线)，其实就是在高光处建立锚点并提高，在阴影处建立锚点并降低，拉出一个像英语字母S一样的曲线。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754298.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>仔细观察S曲线，或许我们就能理解到其背后的原理。前面的教程我们提到过，一张照片按亮度从低到高分为黑色，阴影，中间调(曝光度)，高光和白色5个部分。其中中间调区域的过渡与细节最为细腻。可以看到S型曲线中间部分，输入和输出值变化很小。所以S曲线在中间调区域的影响并不大，很好的保护了照片细节最丰富的部分。白色和黑色区域在最两端，S型曲线对这些亮度区域的改变也不大，有效防止了过曝和欠曝溢出。S曲线主要是提高了原来照片中高光部分的亮度，降低了阴影部分的亮度，让照片的影调更加偏向硬调。因此S曲线在保护黑白色与中间调细节的前提下，有效的提高了照片的对比度，几乎成为了大部分照片必用的一步。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754299.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>类似的，如果我们降低高光锚点，提高阴影锚点，形成一个反S的形状。就是降低对比度曲线了。</p><h3 id="四、曲线的局部调整"><a href="#四、曲线的局部调整" class="headerlink" title="四、曲线的局部调整"></a>四、曲线的局部调整</h3><p>前面三个曲线形态都是作用在照片的全局。但数码后期的一个核心思路，就是局部调整照片不同的区域，让每个区域在展现出最好效果的同时不要影响到其他区域。比如这张图片，雪山和湖之间的草地一片漆黑，需要提亮。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754300.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>如果我直接应用提亮曲线，草地倒是变亮了，但雪山(高光部分)和天空(中间调部分)一下子就过曝了。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754301.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>所以我需要建立两个锚点，把提亮的高光和中间调部分重新拉回来。这样这条曲线就只提高了照片阴影部分的亮度。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754302.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>在局部调整曲线时，有一个非常有用的工具。就是圆圈中那个手一样的图标，点击它之后再把鼠标移动到图像里面，鼠标就会变成一个吸管，同时在右边曲线面板里，会实时显示吸管所在点对应在曲线里的位置。单击吸管，吸管所在的点，就会对应成一个锚点记录在直方图上，方便我们调整。比如这张图，我想降低深色的山体的亮度，同时又保持住白色雾气的亮度。所以我选择“手”图标后，先在红圈1的山体处点一下，曲线中对应建立了1锚点。再在雾气的红圈2处点一下，曲线中就建立了对应的2锚点。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754303.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>这样我下压1锚点，同时保持住2锚点，就只降低了阴影的山体区域，而高光的雾气则没有被影响。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754304.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>在上面讲了RGB曲线是什么。通过提亮压暗曲线，黑白场曲线，对比度曲线三种基本形态，以及对他们的局部应用，就可以快速的调整一张照片的影调了。接下来谈谈如何把这几种基本曲线组合起来，调出复杂的影调效果。</p><p>同样的，三种基本曲线虽然看起来都很简单，但当我们把这些基本形态结合起来的时候，却可以创作出丰富多样的复杂效果。</p><h3 id="五、暗调效果曲线"><a href="#五、暗调效果曲线" class="headerlink" title="五、暗调效果曲线"></a>五、暗调效果曲线</h3><p>下图是一张英国七姐妹白崖的照片，如果我们想让它更加的阴沉，仿佛世界尽头一样。应该怎么调整呢?</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754305.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>直接运用我们学过的压暗曲线，可以发现照片的中间调已经达到了我们想要的低沉影调。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754306.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>但是这样的话暗部几乎一片漆黑，失去了细节。所以我在暗部再增加一个锚点上拉，相当于在暗部又局部的应用了提亮曲线。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754307.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>这样虽然暗部细节回来了，但是阴影部分发灰严重，乌云已经完全失去了立体感。所以再在暗部建立2个锚点，叠加上一条S型曲线，提高暗部的对比度。可以发现天上的乌云内部的层次对比又展现了出来。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754308.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>最后在高光区也建立一个锚点上拉，相当于在高光部分叠加了一个局部提亮曲线，重新恢复了高光的亮度。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754309.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>这张暗调照片的最后曲线=全局压暗曲线+暗部提亮曲线+暗部增加对比度曲线+亮部提亮曲线。看起来很复杂，其实只要理解了原理非常简单，三种基本曲线的一步步的叠加应用而已。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754310.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><h3 id="六、胶片效果曲线"><a href="#六、胶片效果曲线" class="headerlink" title="六、胶片效果曲线"></a>六、胶片效果曲线</h3><p>下图是一张泰国美功铁路市场的照片，如果我们想让它更有胶片味儿。应该怎么调整呢?</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754311.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>最简单的办法就是直接套用PS里的颜色查找表(3D-Lut)工具或者使用各种第三方胶片滤镜了。各种预设好的胶片LUT，可以快速的让图片带上不同类型胶片的影调和色调。不过其实这些效果也是可以通过曲线来完成的。仔细观察下面这张套用 柯达5218胶片 LUT 的成片效果，可以发现它的直方图在保持对比度的同时有一个明显的右移，黑色区域完全没有像素。发灰的暗部给了我们一种照片暗部细节非常丰富的错觉，看起来就像是用高宽容度的胶片拍摄的。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754312.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>要消除直方图中的黑色像素很简单，使用我们学过的黑白场曲线，(竖直向上)提高照片的黑场锚点即可。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754313.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>不过这样不仅照片的暗部发灰，中间调和高光也变灰了。所以为了恢复对比度，我再在上面曲线的基础上拉一个S型曲线(增加对比度曲线)。这样这张照片就获得了很多胶片类似的影调，暗部发灰但对比度又很足。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754314.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>之后我们可以继续应用可选颜色、渐变映射、色相饱和度等等调色工具，给照片加上胶片的色调，这些色彩调整工具会在以后的教程中继续展开。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754315.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>这里的胶片曲线=提高黑场曲线+增强对比度曲线。我们并不需要记忆这个公式，因为有的胶片效果反而是需要减少对比度的。只要理解了三种基本的曲线形态，各种各样的效果我们都是可以组合出来的。</p><p><strong>七、压黑漂白效果曲线</strong></p><p>压黑漂白效果很适合运动类，主体硬朗，以及感情强烈的片子。其特点如下图所示，有大量的纯黑或者纯白区域，反差强烈。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754316.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>下面是这张道路上飞驰的装甲车的原片，反差不够强烈，无法体现出装甲战士带给我们的冲击力。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754317.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>使用黑白场曲线右移黑场锚点，照片中很暗的部分全部都变成了纯黑。黑色倒是足够了，但黑白场曲线的副作用就是把整个图片都压黑了。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754318.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>所以在亮部建立锚点，用提亮曲线提高高光和中间调，营造硬朗的反差效果。这种扩大纯黑并提亮亮部的效果就称为压黑(Crushed Black)效果。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754319.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>与压黑类似的还有漂白效果。顾名思义，漂白效果就是照片整体提亮，白色溢出，同时暗处也变亮并压缩成深灰色，仿佛照片印在纸上再放进漂白水里漂白出来一样。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754320.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p>漂白曲线的前两部跟压黑曲线一样，先是把暗部变成纯黑，同时提亮照片。 漂白效果会进一步让高光也溢出成白色，虽然丢掉细节，但是照片会更有明快动感的气氛。在曲线中可以通过左移白场锚点实现这个效果。 最后我们把黑场的点再上移一段距离，可以理解成刚刚压缩成纯黑的暗部，提亮成了同一种深灰色。</p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754321.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><p><img src="/2018/12/18/photoshop曲线原理与应用/./20170209152754322.jpg" alt="Photoshop曲线工具的使用原理详细解析"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，不管是胶片曲线，暗调曲线，还是压黑漂白曲线，无论多么复杂的效果。其本质任然是提亮压暗，黑白场和对比度这3种基本曲线，在整体和各个局部组合而成的，所以我们并不需要死记硬背这些复杂效果的曲线长什么样。只要理解了三种基本曲线形态的作用，就可以根据需要，组合出自己想要的各种影调效果了。</p><p>PS曲线不仅可以调整照片的影调，各个色彩通道的曲线还可以影响照片的色调，这些就只能在未来的教程中继续展开了。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> photoshop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> photoshop </tag>
            
            <tag> 曲线 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式必知必会</title>
      <link href="/2018/12/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2018/12/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>正则表达式必知必会的笔记</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="元字符表"><a href="#元字符表" class="headerlink" title="元字符表"></a>元字符表</h2><p>下面介绍的是在正则表达式中有特殊意义的字符，称为元字符</p><p><img src="/2018/12/18/正则表达式必知必会/./正则表达式符号表.jpg" alt="正则表达式符号表"></p><h3 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h3><p>如果要查找这些字符本身，需要用<code>\</code>进行转义，比如想匹配点号<code>.</code> 就需要这样写<code>\.</code>  有个特殊的例子：如果想匹配<code>\</code>就需要这样<code>\\</code></p><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><h3 id="匹配字符中的一个"><a href="#匹配字符中的一个" class="headerlink" title="匹配字符中的一个"></a>匹配字符中的一个</h3><ul><li><code>.</code>：  匹配任意一个字符（除了换行符）</li><li><code>[]</code>： 匹配多个字符中的一个<ul><li>自定义字符：[akm]，匹配a、k、m中的一个</li><li>字符区间：[ASCII1-ASCII2]，可以是ASCII中的任意字符作为起始字符（<strong>ASCII1小于ASCII2</strong>），常用的有：[a-z]、[A-Z]、[0-9]、[A-Za-z]（<strong>可以有多个字符区间</strong>）</li><li>取反操作：[^a-z] 表示匹配不是a到z的任意字符，<strong>^的作用效果是整个区间</strong>，而不仅仅是跟在其后的字符<blockquote><p>-是一个元字符，表示区间，不会匹配减号，因此不需要转义</p><p>^是一个元字符，表示在[ ]中表示非匹配，不会匹配到^，因此不需要转义</p></blockquote></li></ul></li></ul><h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>也就是不可见的字符</p><table><thead><tr><th>符号</th><th>用途</th></tr></thead><tbody><tr><td>\f</td><td>匹配一个换页符。</td></tr><tr><td>\n</td><td>匹配一个换行符。</td></tr><tr><td>\r</td><td>匹配一个回车符。</td></tr><tr><td>\t</td><td>匹配一个制表符。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。</td></tr></tbody></table><h3 id="匹配特定一类的字符"><a href="#匹配特定一类的字符" class="headerlink" title="匹配特定一类的字符"></a>匹配特定一类的字符</h3><h4 id="不可见字符"><a href="#不可见字符" class="headerlink" title="不可见字符"></a>不可见字符</h4><table><thead><tr><th>符号</th><th>用途</th></tr></thead><tbody><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。<strong>等价于 [ \f\n\r\t\v]。</strong></td></tr><tr><td>\S</td><td>匹配任何非空白字符。<strong>等价于 [ ^\f\n\r\t\v]。</strong></td></tr></tbody></table><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><table><thead><tr><th>\d</th><th>等价于[0-9]</th></tr></thead><tbody><tr><td>\D</td><td>等价于[^0-9]</td></tr></tbody></table><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>匹配大小写字母、数字、下划线</p><table><thead><tr><th>\w</th><th>等价于[a-zA-Z0-9_]</th></tr></thead><tbody><tr><td>\W</td><td>等价于[^a-zA-Z0-9_]</td></tr></tbody></table><h4 id="匹配中文"><a href="#匹配中文" class="headerlink" title="匹配中文"></a>匹配中文</h4><p>需要切换匹配模式为‘u’，表示要匹配的内容为unicode编码内容,汉字的unicode起始编码是：0x4e00—0x9fa5，因此要匹配全部为中文的正则为：<code>$patern = &quot;/[\x{4e00}-\x{9fa5}]/u&quot;</code></p><h2 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h2><table><thead><tr><th>符号</th><th>用途</th></tr></thead><tbody><tr><td>+</td><td>出现1至多次</td></tr><tr><td>*</td><td>出现0至多次</td></tr><tr><td>？</td><td>出现0或1次</td></tr><tr><td>{n}</td><td>精确控制出现n次</td></tr><tr><td>{n,m}</td><td>区间控制，出现n至m次</td></tr><tr><td>{n,}</td><td>至少出现n次</td></tr></tbody></table><h3 id="贪心匹配"><a href="#贪心匹配" class="headerlink" title="贪心匹配"></a><strong>贪心匹配</strong></h3><p>+、*、{n,}会贪婪的进行匹配，比如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;text1&lt;/b&gt; &lt;b&gt;text2&lt;/b&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;[Bb]&gt;.*&lt;/[Bb]&gt;</code> 会匹配着整体字符串，而不是两个<code>&lt;b&gt;text1&lt;/b&gt;</code> <code>&lt;b&gt;text2&lt;/b&gt;</code> </p><p>因此需要<strong>懒惰匹配</strong> ：</p><p><code>&lt;[Bb]&gt;.*?&lt;/[Bb]&gt;</code> 会匹配到两个<code>&lt;b&gt;text1&lt;/b&gt;</code> <code>&lt;b&gt;text2&lt;/b&gt;</code> </p><table><thead><tr><th>贪婪版</th><th>懒惰版</th></tr></thead><tbody><tr><td>*</td><td>*？</td></tr><tr><td>+</td><td>+？</td></tr><tr><td>{n,}</td><td>{n,}？</td></tr></tbody></table><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="单词边界（boundary）"><a href="#单词边界（boundary）" class="headerlink" title="单词边界（boundary）"></a>单词边界（boundary）</h3><p>\b：匹配单词的开始或者结束位置，也就是单词边界：单词和符号之间的边界</p><blockquote><p>单词可以是中文字符,英文字符,数字</p><p>符号可以是中文符号,英文符号,空格,制表符,换行</p></blockquote><p>具体来说：\b匹配的位置是这样的位置，这个位置位于一个能够用来构成单词的字符（\w）和一个不能用来构成单词的字符（\W）之间</p><p>例子：</p><p><code>\bcat\b</code> 可以匹配到 <code>the cat catcat</code> 中的第一个cat，<strong>因为它前面与后面都有一个单词，因此存在单词分隔符</strong>，而不会匹配到后面的catcat</p><p>这里有个<strong>一开始看不懂</strong>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 为什么cat匹配不到，因为cat是单词，它前面与后面都有一个单词，因此存在单词分隔符</span><br><span class="line">&gt;&gt;&gt; re.findall(r&quot;\Bcat\B&quot;,&quot;the   cat  cao&quot;)</span><br><span class="line">[]</span><br><span class="line"># -却能匹配到，因为-不是单词，所以尽管它前后都有单词，但与-之间不存在单词分割符（除了-，其他\W也是一样的）</span><br><span class="line">&gt;&gt;&gt; re.findall(r&quot;\B-\B&quot;,&quot;color  -  code&quot;)</span><br><span class="line">[&apos;-&apos;]</span><br></pre></td></tr></table></figure><p>注意：java与python中有个地方不同，一个匹配失败，一个成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">" 2 "</span>;</span><br><span class="line">String rex = <span class="string">"\b2\b"</span>;</span><br><span class="line"></span><br><span class="line">Pattern pattern = Pattern.compile(rex);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (matcher.matches())</span><br><span class="line">System.out.println(<span class="string">"匹配成功"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"匹配不成功"</span>); <span class="comment">// 这是结果</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=<span class="string">" 2 "</span></span><br><span class="line">&gt;&gt;&gt; m=re.search(r<span class="string">'\b2\b'</span>,s)</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">1</span>, <span class="number">2</span>), match=<span class="string">'2'</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h3><table><thead><tr><th>符号</th><th>用途</th></tr></thead><tbody><tr><td>^</td><td>默认模式下：匹配整个字符串开始位置；<strong>在多行模式下：可以匹配换行符后的开始位置</strong></td></tr><tr><td>$</td><td>默认模式下：匹配整个字符串结束位置；<strong>在多行模式下：可以匹配换行符后的结束位置</strong></td></tr></tbody></table><h2 id="子表达式（分组）"><a href="#子表达式（分组）" class="headerlink" title="子表达式（分组）"></a>子表达式（分组）</h2><p>用<code>()</code>将正则表达式括起来的就是子表达式，子表达式可以嵌套</p><p>例子：</p><p>年份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19|20\d&#123;2&#125;    错误，这会匹配19或者20xx</span><br><span class="line">(19|20)\d&#123;2&#125;  正确</span><br></pre></td></tr></table></figure><p>IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 任意的1位或2位数字</span><br><span class="line">* 任意的以1开头的3位数字</span><br><span class="line">* 任意的以2开头，0-4为第二位的3位数字</span><br><span class="line">* 以25开头，第3位数字是0-5的3位数字</span><br><span class="line">如下，实现了匹配上面的合法的0-255之间的数字</span><br><span class="line">(\d&#123;1,2&#125;)  | (1\d&#123;2&#125;)  | (2[0-4]\d) | (25[0-5]) </span><br><span class="line">因此匹配IP的正则如下：</span><br><span class="line">(((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d)|(25[0-5]))\.)&#123;3&#125; ((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d) |(25[0-5]))</span><br></pre></td></tr></table></figure><h3 id="子表达式嵌套"><a href="#子表达式嵌套" class="headerlink" title="子表达式嵌套"></a>子表达式嵌套</h3><p>使用的是<strong>深度优先搜索</strong>，以下面的例子来解释：</p><ul><li>group(0)代表整个正则表达式</li><li>group(1)代表第1个子表达式，也就是最外层的括号</li><li>group(2)代表第2个子表达式<br><img src="/2018/12/18/正则表达式必知必会/./子表达式嵌套问题.jpg" alt="子表达式嵌套问题"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=&quot;jizx333hhhh&quot;</span><br><span class="line">&gt;&gt;&gt; m=re.search(r&quot;((\w+?)(\d(\d(\d)))(\w&#123;4&#125;))&quot;,s)</span><br><span class="line">&gt;&gt;&gt; m.group(0)</span><br><span class="line">&apos;jizx333hhhh&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(1)   # 上图中的根节点</span><br><span class="line">&apos;jizx333hhhh&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(2)</span><br><span class="line">&apos;jizx&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(3)</span><br><span class="line">&apos;333&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(4)</span><br><span class="line">&apos;33&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(5)</span><br><span class="line">&apos;3&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(6)</span><br><span class="line">&apos;hhhh&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(7)</span><br><span class="line">IndexError: no such group</span><br></pre></td></tr></table></figure><h3 id="不保存分组"><a href="#不保存分组" class="headerlink" title="不保存分组?:"></a>不保存分组<code>?:</code></h3><p><code>(:X)</code>在正则中表示所匹配的子组X不作为结果输出，称为非捕获分组，不想被捕获的时候使用，可以提高程序执行速度</p><p>正常情况(X)中的X会被作为新增的一个组序号输出，比如(A)(B)，A的序号1，B的序号2<br>如果(?:A)(B)，A将没有序号不输出，B的序号为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text=<span class="string">"我的电话是1234567890"</span></span><br><span class="line">pat1=<span class="string">r"(\d&#123;3&#125;)(\d&#123;3&#125;)(\d&#123;4&#125;)"</span></span><br><span class="line">pat2=<span class="string">r"(?:\d&#123;3&#125;)(\d&#123;3&#125;)(\d&#123;4&#125;)"</span></span><br><span class="line"></span><br><span class="line">match=re.search(pat1,s)</span><br><span class="line">print(match.groups())</span><br><span class="line"></span><br><span class="line">match=re.search(pat2,s)</span><br><span class="line">print(match.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('123', '456', '7890')</span></span><br><span class="line"><span class="comment"># ('456', '7890')</span></span><br></pre></td></tr></table></figure><h3 id="python中的一个坑"><a href="#python中的一个坑" class="headerlink" title="python中的一个坑"></a>python中的一个坑</h3><p>python中split方法，在匹配部分加上括号 <code>()</code>之后所切出的结果是不同的，匹配模式加<strong>括号</strong>表示<strong>保留匹配到的分隔子串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">res=re.split(<span class="string">"\|"</span> , <span class="string">' runoob|runoob|runoob.'</span>)</span><br><span class="line"><span class="comment"># [' runoob', 'runoob', 'runoob.']</span></span><br><span class="line"></span><br><span class="line">res=re.split(<span class="string">"(\|)"</span> , <span class="string">' runoob|runoob|runoob.'</span>) <span class="comment"># 添加括号，会保留分割符</span></span><br><span class="line"><span class="comment"># [' runoob', '|', 'runoob', '|', 'runoob.']</span></span><br></pre></td></tr></table></figure><p>如果你不想保留分割字符串到结果列表中去，但仍然需要使用到括号来分组正则表达式的话， 确保你的分组是非捕获分组，形如 <code>(?:pattern)</code></p><p>##回溯引用</p><p>回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式。</p><p>\0表示整个正则表达式、\1表示第一个子表达式、\2表示第二个子表达式，以此类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is is a apple,and and I like it it.</span><br><span class="line">[ ]+(\w+)[ ]+\1     匹配重复出现两次的单词，\1表示的就是(\w+)</span><br></pre></td></tr></table></figure><h3 id="子表达式-分组-命名"><a href="#子表达式-分组-命名" class="headerlink" title="子表达式(分组)命名"></a>子表达式(分组)命名</h3><p>除了使用上面\1 、\2的方式，来引用子表达式，还可以为子表达式命名，然后引用。</p><p>为子表达式命名：<code>(?P&lt;name&gt; rexp)</code></p><p>引用子表达式：<code>(?P=name)</code></p><p>例子：</p><p>匹配单、双引号包围的字符串</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">she said: &quot;I love you&quot;,and he replied &apos;me,too&apos;</span><br></pre></td></tr></table></figure><p>正则表达式：<code>(?P&lt;quote&gt;[&#39;&quot;]).*?(?P=quote)</code> 等价于<code>([&#39;&quot;]).*?\1</code></p><p>结果：</p><p>she said: <strong>“I love you”</strong>,and he replied <strong>‘me,too’</strong></p><h3 id="使用回溯替换"><a href="#使用回溯替换" class="headerlink" title="使用回溯替换"></a>使用回溯替换</h3><p>将电话格式进行修改：</p><p>文本：</p><p><code>我的电话是1234567890</code></p><p>搜索表达式：</p><p><code>(\d{3})(\d{3})(\d{4})</code></p><p>替换表达式：</p><p><code>\1***\2</code></p><p>结果：</p><p><code>我的电话是123***7890</code></p><blockquote><p>Javascript 在搜索表达式中使用\1，在替换表达式中使用$1来获取引用</p></blockquote><h3 id="使用回溯进行大小写"><a href="#使用回溯进行大小写" class="headerlink" title="使用回溯进行大小写"></a>使用回溯进行大小写</h3><p>不过支持该用法的不多（java不支持）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\E   end，表示大小写转换的结束范围</span><br><span class="line">\l   low，表示把下一个字符转为小写</span><br><span class="line">\L  Low，表示把\L与\E之间的字符转为小写</span><br><span class="line">\u   up，表示把下一个字符转为大写</span><br><span class="line">\U   Up，表示把\U与\E之间的字符转为大写</span><br></pre></td></tr></table></figure><p>举例：<br> 搜索正则表达式<br><code>&lt;([Hh][1-6])&gt;(.*?)&lt;/\1&gt;</code><br> 替换正则表达式<br><code>&lt;$1&gt;\U$2\E&lt;$1&gt;</code><br> 注意：字母有大小写之分，文字没有。</p><h2 id="前后查找"><a href="#前后查找" class="headerlink" title="前后查找"></a>前后查找</h2><p>向前查找、向后查找实际上都是子表达式。它们查找满足条件的字符串，但忽略掉其中指定的部分（不消费）。</p><blockquote><p>具体理解是：从字符串开始位置，有一个光标，光标每向前移动一次，就在光标所在的位置之前或之后判断某些字母是否符合条件，如果符合，就把光标所在位置之前的字符串返回，但忽略子表达式匹配到的字符串</p></blockquote><p>区别是：</p><ul><li>向前查找：真正需要的是<strong>前面部分</strong>的字符串( <strong>http</strong>: )。</li><li>向后查找：真正需要的是<strong>后面部分</strong>的字符串( $<strong>400</strong> )。</li><li>向前查找模式的<strong>长度是可变的</strong>，可以包含.和+之类的元字符</li><li>向后查找模式只能是<strong>固定长度的</strong>。（个人理解为：如果不是固定长度的话，可能会把后面需要输出的部分给隐藏起来）</li></ul><h3 id="向前查找-大部分语言支持"><a href="#向前查找-大部分语言支持" class="headerlink" title="向前查找(大部分语言支持)"></a>向前查找(大部分语言支持)</h3><p><code>(?=需要匹配但不在结果中的正则表达式)</code></p><p>向前查找指定了一个必须匹配但不在结果中返回的模式。</p><hr><p>例子1:</p><p><img src="/2018/12/18/正则表达式必知必会/./前瞻流程.png" alt="预查流程"></p><p>例子2:</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com</span><br><span class="line">https://www.baidu.com</span><br><span class="line">ftp://ftp.forta.com</span><br></pre></td></tr></table></figure><p>正则表达式：</p><p><code>.+(?=:)</code>  需要匹配到冒号，但在结果中不需要该冒号</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">https</span><br><span class="line">ftp</span><br></pre></td></tr></table></figure><h3 id="向后查找"><a href="#向后查找" class="headerlink" title="向后查找"></a>向后查找</h3><p><code>(?&lt;=需要匹配但不在结果中的正则表达式)</code></p><hr><p>例子1:</p><p><img src="/2018/12/18/正则表达式必知必会/./后瞻流程.png" alt="后瞻流程"></p><p>例子2:</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AAA:$23.45</span><br><span class="line">BBB:$567.45</span><br><span class="line">total items found:2</span><br></pre></td></tr></table></figure><p>正则表达式：</p><p><code>(?&lt;=\$)[0-9.]+</code>  需要匹配到美元$，但在结果中不需要$</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23.45</span><br><span class="line">567.45</span><br></pre></td></tr></table></figure><h3 id="向前向后结合"><a href="#向前向后结合" class="headerlink" title="向前向后结合"></a>向前向后结合</h3><p>目标：提取出\<title>标签内的文字</title></p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt; ben forta&apos;s homepage &lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>正则表达式：</p><p><code>(?&lt;=\&lt;title\&gt;).*(?=\&lt;/title\&gt;)</code></p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ben forta&apos;s homepage</span><br></pre></td></tr></table></figure><h3 id="对前后查找取非"><a href="#对前后查找取非" class="headerlink" title="对前后查找取非"></a>对前后查找取非</h3><p>前面介绍的用法称为 正向前查找 和 正向后查找 ，<strong>“正”指的是寻找匹配的事实</strong></p><p>前后查找还有一种不太常见的用法：负前后查找，“负”指的是寻找不相匹配的事实</p><ul><li>负向前查找：将向前查找 不与给定模式相匹配的文本</li><li>负向后查找：将向后查找 不与给定模式相匹配的文本</li></ul><p>使用！在进行取非</p><table><thead><tr><th>操作法</th><th>说明</th></tr></thead><tbody><tr><td>(?=)</td><td>正向前查找</td></tr><tr><td>(?!)</td><td>负向前查找</td></tr><tr><td>(?&lt;=)</td><td>正向后查找</td></tr><tr><td>(?&lt;!)</td><td>负向后查找</td></tr></tbody></table><p>例子：</p><p><strong>查找价格</strong></p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I paid $30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order.</span><br></pre></td></tr></table></figure><p>正则表达式：<code>(?&lt;=\$)\d+</code></p><p>结果：</p><p>I paid \$<strong>30</strong> for 100 apples, 50 oranges ,and 60 pears. I saved $<strong>5</strong> on this order.</p><p><strong>查找数量</strong></p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I paid $30 for 100 apples, 50 oranges ,and 60 pears. I saved $5 on this order.</span><br></pre></td></tr></table></figure><p>正则表达式：<code>\b(?&lt;!\$)\d+</code></p><p>结果：</p><p>I paid \$30 for <strong>100</strong> apples, <strong>50</strong> oranges ,and <strong>60</strong> pears. I saved $5 on this order.</p><blockquote><p>注意到这里有个\b，为什么要这样呢？看下面的结果就知道了</p><p>正则表达式：<code>(?&lt;!\$)\d+</code></p><p>结果：</p><p>I paid \$3<strong>0</strong> for <strong>100</strong> apples, <strong>50</strong> oranges ,and <strong>60</strong> pears. I saved $5 on this order.</p><p>$30中的0也被匹配上了。因为0前面的3不是\$，完全符合<code>(?&lt;!\$)\d+</code></p></blockquote><h2 id="嵌入条件"><a href="#嵌入条件" class="headerlink" title="嵌入条件"></a>嵌入条件</h2><p><strong><em>并非所有正则表达式实现都支持条件处理</em></strong></p><p>正则表达式里的条件要用<code>(?(condition)true_regx|false_regx)</code>来定义，可以没有false_regx。</p><p>之前见过几种非常特殊的条件了：</p><ul><li><code>.?</code>、<code>[]?</code>或<code>()?</code>匹配前一个字符或者表达式</li><li><code>(?=……)</code>和<code>(?&lt;=……)</code>匹配前面或后面的文本</li></ul><h3 id="回溯引用条件"><a href="#回溯引用条件" class="headerlink" title="回溯引用条件"></a>回溯引用条件</h3><p><code>(?(回溯引用的id)true-regx|false-regx)</code> ，当回溯引用存在时，匹配true-regx模式，否则匹配false-regx，</p><p>例子：匹配合法的电话</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123-456-7890</span><br><span class="line">(123)456-7890</span><br><span class="line">(123)-456-7890</span><br><span class="line">(123-456-7890</span><br><span class="line">1234567890</span><br><span class="line">123 456 7890</span><br></pre></td></tr></table></figure><p>正则表达式：</p><p><code>(\()? \d{3} (?(1)\)|-) \d{3}-\d{4}</code></p><p>结果：</p><p><strong>123-456-7890</strong><br><strong>(123)456-7890</strong><br>(123)-456-7890<br>(123-456-7890<br>1234567890<br>123 456 7890</p><p>其中<code>(?(1)\)|-)</code>就是回溯引用条件，<code>?(1)</code>表示子表达式1存在时，进行匹配右括号<code>)</code>，否则匹配连字符<code>-</code></p><h3 id="前后查找条件"><a href="#前后查找条件" class="headerlink" title="前后查找条件"></a>前后查找条件</h3><p><code>(?(向前向后查找表达式)true-regx|false-regx)</code></p><p>在实际工作中，该方法相当少见，因为有更简单的方法来到达同样的目的。</p><p>例子：</p><p>文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11111</span><br><span class="line">22222</span><br><span class="line">33333-</span><br><span class="line">44444-4444</span><br></pre></td></tr></table></figure><p>正则表达式：<code>\d{5}(?(?=-)-\d{4})</code></p><p>结果：</p><p><strong>11111</strong><br><strong>22222</strong><br>33333-<br><strong>44444-4444</strong></p><p><code>(?(?=-)-\d{4})</code> 中用<code>(?=-)</code>来进行向前匹配，如果条件成立，则<code>-\d{4}</code>将匹配连字符和随后的4位数字，这样<code>33333-</code> 将被排除在外。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>元字符可以分为2类：</p><ol><li>一种是本身就是元字符，转义后变为普通字符，比如<code>^ $ *</code> ，用\进行转义恢复成普通字符</li><li>另一种是需要\进行配合，才表示元字符，否则就是普通的字符，比如<code>\w \s \d</code></li></ol></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell通配符</title>
      <link href="/2018/12/18/shell%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/2018/12/18/shell%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>介绍linux中shell通配符的用法，以及其与正则表达式的关系</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="通配符（Wildcard）"><a href="#通配符（Wildcard）" class="headerlink" title="通配符（Wildcard）"></a>通配符（Wildcard）</h3><p>在 Shell 中命令中，通常会使用通配符表达式来匹配一些文件，如以下命令可以查找当前目录下所有后缀为 .xml 的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.xml&quot;</span><br></pre></td></tr></table></figure><p>Shell 中可以使用的通配符如下：</p><table><thead><tr><th>通配符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>*</td><td>匹配 0 或多个字符</td><td><code>a*b</code>，a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如 aabcb, axyzb, a012b, ab</td></tr><tr><td>?</td><td>匹配任意单个字符</td><td><code>a?b</code>，a与b之间有且只有一个字符, 可以是任意字符, 如 aab, abb, acb, a0b</td></tr><tr><td>[list]</td><td>匹配 list 中的任意单个字符</td><td><code>a[xyz]b</code>，a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如 axb, ayb, azb。</td></tr><tr><td>[!list]</td><td>匹配除 list 中的任意单一字符</td><td><code>a[!0-9]b</code>，a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如 axb, aab, a-b。</td></tr><tr><td>[c1-c2]</td><td>匹配 c1-c2 中的任意单一字符</td><td><code>a[0-9]b</code>，匹配0与9之间其中一个字符，如 a0b, a1b… a9b</td></tr><tr><td>{s1,s2,…}</td><td>匹配 s1 或 s2 (或更多)中的一个字符串</td><td><code>a{abc,xyz,123}b</code>，a与b之间只能是abc或xyz或123这三个字符串之一</td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>有的时候，我们匹配的内容里面会存在 <code>*</code>，<code>?</code>，<code>[</code>等通配符中的符号。为了表示他们原来的意思，我们需要使用转义字符 <code>\</code>，如 <code>a\[ac\]c</code> 表示匹配 <code>a[a]c</code> 或 <code>a[c]c</code>。<code>\</code> 本身用 <code>\\</code> 表示。</p><h3 id="分清楚通配符表达式和正则表达式"><a href="#分清楚通配符表达式和正则表达式" class="headerlink" title="分清楚通配符表达式和正则表达式"></a>分清楚通配符表达式和正则表达式</h3><p>通配符看起来和正则表达式很像，但他们并不是同一种东西。<strong>正则表达式中的那些量词的匹配规则和这里提到的几个通配符的匹配规则并不相同。</strong>如正则表达式中 <code>*</code> 表示重复前一个字符任意次，<code>ab*</code> 表示的是那些 <code>a</code> 后面跟 0 个或多个 <code>b</code> 的字符串， 而通配符表达式中 <code>*</code> 表示 0 或多个任意字符， <code>ab*</code> 表示的是那些 <code>ab</code> 后面跟任意个字符的字符串。</p><p>而且<strong>正则表达式一般是部分匹配的</strong>，用来匹配内容中的一部分，如用正则表达式 <code>a</code> 去匹配 <code>bac</code> 这段字符串时，匹配是成功的，匹配到的内容是 <code>a</code>。但是<strong>通配符表达式的话是全部匹配的</strong>，表达式要匹配整个字符串才算匹配成功，如用通配符表达式 <code>a</code> 取匹配 <code>bac</code> 这段字符串时，匹配是失败的。</p><p>在 Shell 命令中，通常<strong>用通配符表达式来匹配文件名</strong>，而<strong>用正则表达式来匹配一段文本内容</strong>。以 <code>grep</code> 命令为例，<code>grep</code> 命令可以在指定的文件中，挑选出和表达式匹配的那些行，其中指定文件是用的通配符表达式，而文本内容的匹配用的是正则表达式。</p><p>今天使用 <code>grep</code> 时，就因为没分清楚他们，忙活了半天。情况是这样的，我想看一个 jar 包里是不是有 pom 相关的文件，所以就输入了下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tf maven-model-builder-3.5.3.jar | grep <span class="string">'pom*'</span>  <span class="comment"># 这里是正则表达式，匹配有po、pom、pom+子串的字符串</span></span><br></pre></td></tr></table></figure><p>结果输入了一堆文件，而且很多文件都没有 pom 这串字符串的。输出内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">org/apache/maven/model/composition/</span><br><span class="line">org/apache/maven/model/interpolation/</span><br><span class="line">org/apache/maven/model/superpom/</span><br><span class="line">org/apache/maven/model/composition/DependencyManagementImporter.class</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这就是因为我把通配符表达式和正则表达式搞混了，后来知道原因后，用下面的命令才得到想要的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tf maven-model-builder-3.5.3.jar | grep <span class="string">'pom.*'</span></span><br></pre></td></tr></table></figure><p>使用 Shell 命令时，要分清楚哪里用的是通配符表达式，哪里用的是正则表达式。</p><p>作者：Happioo</p><p>链接：<a href="https://www.jianshu.com/p/25f3d0cd5fdc" target="_blank" rel="noopener">https://www.jianshu.com/p/25f3d0cd5fdc</a></p><p>來源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 通配符 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>window添加右键用atom打开</title>
      <link href="/2018/12/15/window%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E7%94%A8atom%E6%89%93%E5%BC%80/"/>
      <url>/2018/12/15/window%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E7%94%A8atom%E6%89%93%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>window添加右键功能，如用atom打开，用vs code打开，可以方便用指定的编辑器打开文件，或者打开文件夹</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>使用<code>regedit</code> 打开注册表，找到如下位置，按照图示添加项，即可</p><p><img src="/2018/12/15/window添加右键用atom打开/./图像 001.png" alt="图像 001"></p><p><img src="/2018/12/15/window添加右键用atom打开/./图像 002.png" alt="图像 002"></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统优化 </tag>
            
            <tag> 效率 </tag>
            
            <tag> atom </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>notepad常用插件与设置</title>
      <link href="/2018/12/12/notepad%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/12/12/notepad%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <ol><li>notepad如何安装插件</li><li>常用的插件推荐</li><li>设置与配置信息备份</li></ol><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>点击菜单中的“插件”—&gt;“plugin manager”—&gt;“show plugin manager”的选项</p><p><img src="/2018/12/12/notepad常用插件/./插件安装1.png" alt="插件安装1"></p><p>进入到插件的管理列表中，找需要的插件，比如“compare”的选项勾选上，点击“install”的进行按钮</p><p><img src="/2018/12/12/notepad常用插件/./插件安装2.png" alt="插件安装2"></p><blockquote><p><strong>插件列表不显示</strong>的情况：</p><ol><li>打开plugin manager 最下面的setting，将use development plugin list 勾选上，注意information那一栏，可能会给出关键的信息，如让你创建 allowAppDataPlugins.xml文件</li><li>缺少PluginManagerPlugins.xml文件<ol><li>先在文件资源管理器的查看在隐藏的项目打勾</li><li>把<a href="http://pan.baidu.com/s/1hsmjCBa" target="_blank" rel="noopener">PluginManagerPlugins.xml</a>放在这个目录下<code>C:\Users\用户\AppData\Roaming\Notepad++</code></li><li>重新打开软件，看时候可行</li></ol></li><li>可能防火墙禁止Notepad++连接网络<ol><li>可以从控制面板-&gt;系统与安全-&gt;windows防火墙-&gt;允许应用通过windows防火墙</li><li>查看notepad++后面对应的专用和公用是否打勾，如果找不到notepad++可以自行添加，从允许其他应用进去，找到你notepad++的安装目录，然后添加</li></ol></li></ol></blockquote><p>安装完成会自动重启Notepad++，重启完成之后，在菜单栏的插件中，即可找到新安装的插件</p><p><img src="/2018/12/12/notepad常用插件/./插件安装3.png" alt="插件安装3"></p><h3 id="常用的插件推荐"><a href="#常用的插件推荐" class="headerlink" title="常用的插件推荐"></a>常用的插件推荐</h3><ul><li><strong>compare</strong>   比较两个文件的修改情况</li><li><strong>JSON viewer</strong>   json文件查看、格式化</li><li><strong>converter</strong>   ASCII码与HEX转换</li></ul><h3 id="设置与配置信息备份"><a href="#设置与配置信息备份" class="headerlink" title="设置与配置信息备份"></a>设置与配置信息备份</h3><p>设置好的配置文件在：C:\Users\用户\AppData\Roaming\Notepad++目录下，建议将这个文件夹备份，避免重装是又要从头设置</p><ul><li>不记住最后打开的文件（标签栏会炸掉的）：备份-&gt;记住最后打开的文件 取消掉</li><li>utf8-无BOM：新建-&gt;编码</li></ul></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> notepad++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>chrome截取整个网页</title>
      <link href="/2018/12/04/chrome%E6%88%AA%E5%8F%96%E6%95%B4%E4%B8%AA%E7%BD%91%E9%A1%B5/"/>
      <url>/2018/12/04/chrome%E6%88%AA%E5%8F%96%E6%95%B4%E4%B8%AA%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>浏览器原生功能实现滚动截屏，截取整个页面</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>在Chrome 浏览器上滚动截屏，不需要插件和任何 app，利用 chrome 浏览器原生功能即可实现。</p><ol><li><p>打开 Chrome 浏览器，进入需要截图的网站页面</p></li><li><p>打开开发者工具：在页面任何地方点击鼠标右键，在弹出菜单中选择「检查」选项。或者使用快捷键组合：option + command + i。</p></li><li><p>打开命令行（command palette）：command + shift + p。</p></li><li><p>在命令行中输入「screen」，这时自动补齐功能会显示出一些包含 「Screen」 关键字的命令。移动方向键到「Capture full size screenshot」并回车，chrome就会自动下载整个页面截屏文件。</p><p><img src="/2018/12/04/chrome截取整个网页/./chrome截图.png" alt="chrome截图"></p></li></ol><p>原文：<a href="https://blog.csdn.net/ianly123/article/details/80565614" target="_blank" rel="noopener">https://blog.csdn.net/ianly123/article/details/80565614</a> </p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 截图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git教程</title>
      <link href="/2018/11/22/Git%E6%95%99%E7%A8%8B/"/>
      <url>/2018/11/22/Git%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>Git 教程</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/11/22/Git教程/./git常用命令流程图.png" alt=""></p><h2 id="Git本地基本"><a href="#Git本地基本" class="headerlink" title="Git本地基本"></a>Git本地基本</h2><h3 id="配置全局信息"><a href="#配置全局信息" class="headerlink" title="配置全局信息"></a>配置全局信息</h3><p>当安装完 Git 应该做的<strong>第一件事</strong>就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。在那个项目目录下运行没有<code>--global</code>选项的命令来配置。</p></blockquote><p>其他有用的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor <span class="string">"notepad"</span>  <span class="comment">#commit时的默认编辑器</span></span><br></pre></td></tr></table></figure><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git config--list</span><br><span class="line"></span><br><span class="line">user.name=JohnDoe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">Jizx</span><br></pre></td></tr></table></figure><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><h4 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h4><p>通过<code>git init</code>命令把这个目录(可以是非空目录)变成Git可以管理的仓库。</p><p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 <code>git add</code>命令来实现对指定文件的跟踪，然后执行<code>git commit</code> 提交</p><h4 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h4><p>克隆仓库的命令格式是 <code>git clone [url] 本地仓库名字</code>。可以不定义本地仓库名字，默认适应原仓库名字。比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p><p><code>$ git clonehttps://github.com/libgit2/libgit2  mylibgit2</code></p><p>这会在当前目录下创建一个名为 “mylibgit2”的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p><strong>第一步，</strong>用命令git add告诉Git，把文件添加到暂存区：</p><p><code>git add readme.txt</code></p><p>add一个文件之后，如果又对文件进行了修改，需要重新add，不然commit只会保存最后一次git add的文件内容。</p><p><strong>第二步，</strong>用命令git commit告诉Git，把文件提交到仓库：</p><p><code>git commit -m &quot;wrote a readmefile&quot;</code></p><p>或者git commit，将会打开默认的文本编辑器（vim）进行文字输入。若实在不习惯 Vim，也可以设置为其它编辑器：</p><p><code>git config --global core.editor &quot;notepad&quot;</code></p><p>其中 notepad 可以替换为更好用的 wordpad、notepad++ 等（不过它们在命令行里无法直接访问，得先设置 PATH 变量）。</p><p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git addfile1.txt</span><br><span class="line">git addfile2.txt file3.txt</span><br><span class="line">git commit-m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure><p><strong>快速提交：</strong></p><p>Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，<code>git commit -a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，<strong>从而跳过 git add 步骤</strong>。</p><h3 id="重新提交"><a href="#重新提交" class="headerlink" title="重新提交"></a>重新提交</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有<code>--amend</code> 选项的提交命令尝试重新提交，命令执行后将暂存区中的文件提交，因此分为以下2种情况：</p><ol><li><p>修改提交信息：</p><p><code>git commit --amend</code></p></li><li><p>添加忘记/漏add的文件，同时修改提交信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'initial commit'</span>  <span class="comment"># 错误的提交</span></span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit –amend</span><br></pre></td></tr></table></figure></li></ol><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><p>要查看哪些文件处于什么状态，可以用 <code>git status</code> 命令。</p><p>使用 <code>git status -s</code> 命令或 <code>git status --short</code>命令，你将得到一种更为紧凑的格式输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><ul><li>?? 标记：新添加的未跟踪文件</li><li>A 标记：新添加到暂存区中的文件</li><li>M 标记：修改过的文件<ul><li>出现在<strong>右边的 M</strong>表示该文件被修改了但是还没放入暂存区</li><li>出现在<strong>左边的 M</strong>表示该文件被修改了并放入了暂存区。</li></ul></li></ul><p>例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区，lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。 而 <strong>Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了</strong>，所以在暂存区和工作区都有该文件被修改了的记录。</p><p><img src="/2018/11/22/Git教程/./文件状态周期.png" alt="文件状态周期"></p><p>Untracked未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件（比如新建的文件）；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。被追踪后处于3种状态：未修改-已修改-已暂存。将暂存的文件commit后就保存在git数据库中，文件就回到未修改状态了。<br>接下来介绍如何对修改的文件进行版本控制。</p><h3 id="查看文件修改内容diff"><a href="#查看文件修改内容diff" class="headerlink" title="查看文件修改内容diff"></a>查看文件修改内容diff</h3><p><img src="/2018/11/22/Git教程/./查看文件变化内容.png" alt="查看文件变化内容"></p><h4 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h4><p>查看<strong>尚未暂存的文件</strong>更新了哪些部分，输入<code>git diff</code><br>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p><p><code>git diff</code>不加参数即默认比较工作区与暂存区</p><p>比较工作区与最新本地版本库</p><p><code>git diff HEAD [&lt;path&gt;...]</code>  如果HEAD指向的是master分支，那么HEAD还可以换成master</p><p>比较工作区与指定commit-id的差异</p><p><code>git diff commit-id  [&lt;path&gt;...]</code></p><h4 id="–cached"><a href="#–cached" class="headerlink" title="–cached"></a>–cached</h4><p>查看<strong>暂存区里将要添加到下次提交</strong>里的内容，可以用 <code>git diff --cached</code>命令。<br>也就是查看暂存区里与最新本地版本库的区别（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。）</p><p>比较暂存区与指定commit-id的差异</p><p><code>git diff --cached [&lt;commit-id&gt;][...]</code></p><p>比较两个commit-id之间的差异</p><p><code>git diff [&lt;commit-id&gt;][]</code></p><h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><p>使用git diff打补丁<code>git diff &gt; patch</code></p><p> patch的命名是随意的，不加其他参数时作用是当我们希望将我们本仓库工作区的修改拷贝一份到其他机器上使用，但是修改的文件比较多，拷贝量比较大，此时我们可以将修改的代码做成补丁，之后在其他机器上对应目录下使用 <code>git apply patch</code> 将补丁打上即可</p><p><code>git diff --cached &gt; patch</code> //是将我们暂存区与版本库的差异做成补丁</p><p> <code>git diff --HEAD &gt; patch</code>//是将工作区与版本库的差异做成补丁</p><p><code>git diff Testfile &gt; patch</code>//将单个文件做成一个单独的补丁</p><p>拓展：git apply patch 应用补丁，应用补丁之前我们可以先检验一下补丁能否应用，<code>git apply --check patch</code> 如果没有任何输出，那么表示可以顺利接受这个补丁</p><p>另外可以使用<code>git apply --reject patch</code>将能打的补丁先打上，有冲突的会生成.rej文件，此时可以找到这些文件进行手动打补丁</p><h3 id="忽略文件（不追踪文件）"><a href="#忽略文件（不追踪文件）" class="headerlink" title="忽略文件（不追踪文件）"></a>忽略文件（不追踪文件）</h3><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，（window下直接新建不了，最好用命令行创建）使用命令<code>cat .gitignore</code>或者<code>touch .gitignore</code>，然后把要忽略的文件名或者目录填进去，Git就会自动忽略这些文件、文件夹。最后一步就是把<code></code>.gitignore`也提交到Git，就完成了！</p><blockquote><p>注意：<code>.gitignore</code>文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。如果要忽略被提交了的文件，请看【删除文件、取消追踪、恢复误删】这节内容</p></blockquote><h4 id="gitignore编写规则"><a href="#gitignore编写规则" class="headerlink" title="gitignore编写规则"></a>gitignore编写规则</h4><ol><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li></ol><ol start="2"><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（/）开头防止递归。</li><li>以（/）结尾 指定目录，忽略该目录下全部内容。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ol><p>所谓的 <strong>glob 模式</strong>是指shell 所使用的简化了的正则表达式。</p><ul><li>星号<code>*</code>匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符</li><li>问号<code>?</code>只匹配一个任意字符；</li><li>如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</li><li>使用两个星号<code>**</code> 表示匹配<strong>任意中间目录</strong>，比如<code>a/**/z</code> 可以匹配 <code>a/z, a/b/z 或 a/b/c/z</code>等。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略任何 以 .a 结尾文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># 但不忽略 lib.a 这个例外</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略当前文件夹下的 TODO ，不忽略子文件夹下的 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略全部在 build/ 文件夹下的文件</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略doc文件夹下的.txt,子目录下的doc/server/arch.txt 不受影响，</span></span><br><span class="line">doc/*.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有doc文件夹下的 .pdf 文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p>GitHub 在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">github/gitignore</a>仓库 提供了一个官方推荐的 .gitignore 文件列表，包括各种流行的操作系统、环境、开发语言。</p><h4 id="强制添加"><a href="#强制添加" class="headerlink" title="强制添加"></a>强制添加</h4><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line"></span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">    App.class</span><br><span class="line">Use -f <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure><p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：<br><code>git add -f App.class</code><br>当然也可以在.gitignore里使用<code>!</code>排除这个文件。</p><h4 id="忽略已经添加到git的文件"><a href="#忽略已经添加到git的文件" class="headerlink" title="忽略已经添加到git的文件"></a>忽略已经添加到git的文件</h4><p>如果你已经将文件提交到到git中，那么git不会处理你后来添加的gitignore规则。这种情况就需要通过下面的命令先取消追踪文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure><h4 id="测试规则"><a href="#测试规则" class="headerlink" title="测试规则"></a>测试规则</h4><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.class    App.class</span><br></pre></td></tr></table></figure><p>Git会告诉我们：.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h4 id="全局忽略"><a href="#全局忽略" class="headerlink" title="全局忽略"></a>全局忽略</h4><p>可以为你的电脑上每个仓库创建一份全局的忽略文件，这样就不必每个仓库都单独创建一个gitignore文件。</p><ol><li>在home目录创建<code>~/.gitignore_global</code>文件</li><li>在命令行中执行<code>git config --global core.excludesfile ~/.gitignore_global</code></li></ol><p>The Octocat 提供了一个推荐列表 方便添加到全局忽略文件中 <a href="https://gist.github.com/octocat/9257657" target="_blank" rel="noopener">a Gist containing some good rules</a> </p><h4 id="本地忽略"><a href="#本地忽略" class="headerlink" title="本地忽略"></a>本地忽略</h4><p><code>.gitignore</code> 这个文件本身会提交到版本库中去，用来保存的是公共的需要排除的文件。</p><p>如果你不想创建一份与他人共享的<code>.gitignore</code>，比如由你的编辑器产生的附属文件，而别人不会产生的情况。可以订制一份本地的忽略规则，这份规则不会提交到git中。</p><p>打开仓库中的<code>.git/info/exclude</code> 文件，在这里添加忽略规则即可，这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。</p><h3 id="撤销修改、提交"><a href="#撤销修改、提交" class="headerlink" title="撤销修改、提交"></a>撤销修改、提交</h3><h4 id="取消本地修改"><a href="#取消本地修改" class="headerlink" title="取消本地修改"></a>取消本地修改</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时， 使用命令<code>git checkout –– filename</code>。<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h4 id="取消add"><a href="#取消add" class="headerlink" title="取消add"></a>取消add</h4><p>场景2：当你不但改乱了工作区某个<strong>已经追踪的文件</strong>的内容，还添加到了暂存区时(<code>git add</code>)，想丢弃修改，分两步：</p><ol><li>第一步用命令<code>git reset HEAD fileName</code>（取消add到暂存区），就回到了场景1（即文件未暂存到暂存区中，仍为被修改过的状态）</li><li>第二步按场景1操作。</li></ol><p>如果是新文件（未提交到git中），那么应该使用<code>git rm --cached &lt;file&gt;</code> 来取消add操作。</p><p><img src="/2018/11/22/Git教程/./撤销修改.png" alt=""></p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>场景3：当你不但添加到了暂存区时(<code>git add</code>)，还提交了(<code>git commit</code>)，那就得进行版本回退了</p><p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>上面的方法仅适合近期恢复，如果忘记应该回退到哪个版本或者要回退到比较久之前的版本，应该通过<code>git log</code> 查看commit id，即可回退到你需要的时间点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit c0ce54b1ce75f69259d7f615bf280ff7a07e3eac (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: jizx &lt;1822980003@qq.com&gt;</span><br><span class="line">Date:   Sun Nov 18 23:16:49 2018 +0800</span><br><span class="line"></span><br><span class="line">    git命令行中文乱码解决方法</span><br><span class="line"></span><br><span class="line">commit 0c0bfca1e3208d83a89366c5be76982d24e03dee</span><br><span class="line">Author: jizx &lt;1822980003@qq.com&gt;</span><br><span class="line">Date:   Sun Nov 18 20:52:07 2018 +0800</span><br><span class="line"></span><br><span class="line">    过滤上根目录的DS_Store</span><br></pre></td></tr></table></figure><p>其中commit 后面的一串字符串就是commit id</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^     <span class="comment"># 回退到上一个版本</span></span><br><span class="line">$ git reset --hard commit_id <span class="comment"># 通过git log 获取的commit id</span></span><br></pre></td></tr></table></figure><p>第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的，Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令，这样就可以找到你全部提交过的commit id。</p><h3 id="删除文件、取消追踪、恢复误删"><a href="#删除文件、取消追踪、恢复误删" class="headerlink" title="删除文件、取消追踪、恢复误删"></a>删除文件、取消追踪、恢复误删</h3><ul><li><p>同时删除库中的文件与工作目录的文件：</p><p>使用命令<code>git rm fileName</code>删掉，并且<code>git commit –m “someLog”</code></p></li><li><p>仅删除库中的文件（取消追踪/恢复未追踪状态）：</p><p>换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪,可以输入命令：<code>git rm –cached filename/dir</code></p></li><li><p>另一种情况是<strong>在文件夹里误删了</strong>，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<code>git checkout -- test.txt</code></p></li></ul><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>要在 Git 中对文件改名，可以这么做：</p><p> <code>git mv README.md NewName.md</code></p><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv README.md NewName.md</span><br><span class="line">git rm README.md</span><br><span class="line">git add NewName.md</span><br></pre></td></tr></table></figure><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。两者唯一的区别是，<code>git mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code>轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p><h3 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h3><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p><code>git log</code>   显示从最近到最远的提交日志</p><p><code>git log -p -2</code>  一个常用的选项是 -p，用来显示每次提交的内容差异。你也可以加上 -2 来仅显示最近两次提交<br><code>git log --decorate</code>  命令查看各个分支当前所指的对象。</p><p><code>git log --pretty=oneline</code><br>另外一个常用的选项是<code>--pretty</code>。 这个选项可以<strong>指定使用不同于默认格式的方式展示</strong>提交历史。 这个选项有一些内建的子选项供你使用。 比如用<code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有<code>short，full 和 fuller</code>可以用（不过不怎么实用）。</p><p><code>git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</code> 最有意思的是format，可以定制要显示的记录格式</p><table><thead><tr><th style="text-align:center"><strong>选项</strong></th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>%H</strong></td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td style="text-align:center"><strong>%h</strong></td><td>提交对象的简短哈希字串</td></tr><tr><td style="text-align:center"><strong>%T</strong></td><td>树对象（tree）的完整哈希字串</td></tr><tr><td style="text-align:center"><strong>%t</strong></td><td>树对象的简短哈希字串</td></tr><tr><td style="text-align:center"><strong>%P</strong></td><td>父对象（parent）的完整哈希字串</td></tr><tr><td style="text-align:center"><strong>%p</strong></td><td>父对象的简短哈希字串</td></tr><tr><td style="text-align:center"><strong>%an</strong></td><td>作者（author）的名字</td></tr><tr><td style="text-align:center"><strong>%ae</strong></td><td>作者的电子邮件地址</td></tr><tr><td style="text-align:center"><strong>%ad</strong></td><td>作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td style="text-align:center"><strong>%ar</strong></td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td style="text-align:center"><strong>%cn</strong></td><td>提交者(committer)的名字</td></tr><tr><td style="text-align:center"><strong>%ce</strong></td><td>提交者的电子邮件地址</td></tr><tr><td style="text-align:center"><strong>%cd</strong></td><td>提交日期</td></tr><tr><td style="text-align:center"><strong>%cr</strong></td><td>提交日期，按多久以前的方式显示</td></tr><tr><td style="text-align:center"><strong>%s</strong></td><td>提交说明</td></tr></tbody></table><blockquote><p><strong>作者</strong>指的是实际作出修改的人，<strong>提交者</strong>指的是最后将此工作成果提交到仓库的人</p></blockquote><p>图像化展示提交记录</p><p><code>$ git log --graph</code></p><p><code>$ git log --graph --pretty=oneline --abbrev-commit</code> 简洁视图版本</p><p>当 oneline 或 format 与另一个 log 选项 –graph 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史。</p><p> <strong>git log</strong> 的常用选项，可以一起使用                                     </p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-p</strong></td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td><strong>–stat</strong></td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td><strong>–shortstat</strong></td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td><strong>–name-only</strong></td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td><strong>–name-status</strong></td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td><strong>–abbrev-commit</strong></td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td><strong>–relative-date</strong></td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td><strong>–graph</strong></td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td><strong>–pretty</strong></td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><p>限制<code>git log</code>输出的选项</p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>-(n)</strong></td><td>仅显示最近的 n 条提交</td></tr><tr><td><strong>–since</strong>, <strong>–after</strong></td><td>仅显示指定时间之后的提交。</td></tr><tr><td><strong>–until</strong>, <strong>–before</strong></td><td>仅显示指定时间之前的提交。</td></tr><tr><td><strong>–author</strong></td><td>仅显示指定作者相关的提交。</td></tr><tr><td><strong>–committer</strong></td><td>仅显示指定提交者相关的提交。</td></tr><tr><td><strong>–grep</strong></td><td>仅显示含指定关键字的提交</td></tr><tr><td><strong>-S</strong></td><td>仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><p>例子：<br><code>git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; --before=&quot;2008-11-01&quot;</code></p><h4 id="git-relog"><a href="#git-relog" class="headerlink" title="git relog"></a>git relog</h4><p><code>$ git reflog</code>  //查看全部命令记录，以及HEAD指针</p><h3 id="git-help-命令提示"><a href="#git-help-命令提示" class="headerlink" title="git help 命令提示"></a>git help 命令提示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help command # 可以显示某条command的使用方法</span><br></pre></td></tr></table></figure><h2 id="Git远程"><a href="#Git远程" class="headerlink" title="Git远程"></a>Git远程</h2><h3 id="从远程仓库克隆到本地"><a href="#从远程仓库克隆到本地" class="headerlink" title="从远程仓库克隆到本地"></a>从远程仓库克隆到本地</h3><p>在某个目录下，打开命令行，运行以下命令，就可以把远程的仓库克隆到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用命令</span></span><br><span class="line">$ git <span class="built_in">clone</span> username@host:/path/to/repository</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果远程服务器是github</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:你的GitHub用户名/你的某一个仓库名.git</span><br><span class="line"><span class="comment"># .git可以不用写</span></span><br></pre></td></tr></table></figure><p>默认远程仓库别名为 origin，如果要自定义，可以在克隆时运行命令：<br><code>git clone -o jizx git@github.com:你的GitHub用户名/你的某一个仓库名.git</code>，那么你默认的远程分支名字将会是 <code>jizx/master</code><br>注意：克隆后本地只有master分支，如果想要把别的分支如dev克隆下来，需要使用:<code>git checkout -b dev origin/dev</code><br>也就是说，当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<code>git checkout -b dev origin/dev</code><br>git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）</p><h3 id="本地关联到远程仓库"><a href="#本地关联到远程仓库" class="headerlink" title="本地关联到远程仓库"></a>本地关联到远程仓库</h3><h4 id="空文件夹"><a href="#空文件夹" class="headerlink" title="空文件夹"></a>空文件夹</h4><p>新建一个文件夹，进入文件夹后使用git init命令，然后再使用<code>git remote add</code>命令关联一个远程仓库，再使用<code>git pull</code> 命令就可以把管理仓库的所有文件复制到本文件夹中，同样可以修改文件并完成push。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用命令</span></span><br><span class="line">$ git remote add remoteName  git@server-name:path/仓库名.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># github服务器命令</span></span><br><span class="line">$ git remote add remoteName  git@github.com:你的用户名/你的某一个仓库名.git</span><br></pre></td></tr></table></figure><p>或者在一个文件夹下直接使用<code>git clone</code>命令，会把远程仓库整个复制到这个文件夹下，然后进入这个文件夹就可以修改文件并完成push。 这时默认远程的url别名为origin</p><h4 id="非空仓库-TODO非空文件怎么关联"><a href="#非空仓库-TODO非空文件怎么关联" class="headerlink" title="非空仓库(TODO非空文件怎么关联)"></a>非空仓库(TODO非空文件怎么关联)</h4><h3 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h3><p>用<code>git remote</code>可以查看到默认的远程库：<code>origin</code></p><p>用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote-v</span><br><span class="line">origin  git@github.com:jizxgit/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:jizxgit/learngit.git (push)</span><br></pre></td></tr></table></figure><h3 id="remote-详细用法"><a href="#remote-详细用法" class="headerlink" title="remote 详细用法"></a>remote 详细用法</h3><p><code>git help remote</code> 即可显示详细命令用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git remote [-v | --verbose]</span><br><span class="line">git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;</span><br><span class="line">git remote rename  &lt;old&gt;  &lt;new&gt;</span><br><span class="line">git remote remove  &lt;name&gt;</span><br><span class="line">git remote rm  &lt;name&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">git remote <span class="built_in">set</span>-branches [--add] &lt;name&gt; &lt;branch&gt;…</span><br><span class="line">git remote get-url [--push] [--all] &lt;name&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">git remote <span class="built_in">set</span>-url --add [--push] &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…</span><br><span class="line">git remote prune [-n | --dry-run] &lt;name&gt;…</span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…]</span><br></pre></td></tr></table></figure><h3 id="本地推送到远程仓库"><a href="#本地推送到远程仓库" class="headerlink" title="本地推送到远程仓库"></a>本地推送到远程仓库</h3><p>第一次更新时： <code>git push -u origin master</code></p><p>origin：远程服务器url别名  master：本地仓库的一个分支</p><p>加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p><p>以后更新时： <code>git push origin master</code></p><p>如果要推送本地其他分支，比如dev，就改成：<br><code>git push origin dev</code></p><p>以上其实做了一定的简化，完整的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin 本地分支：远程分支</span><br></pre></td></tr></table></figure><p>如果并不想让远程仓库上的分支叫做 serverfix，可以运行 <code>git push origin serverfix:awesomebranch</code>来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。</p><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li>master分支是主分支，因此要时刻与远程同步；</li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h4 id="冲突、推送失败"><a href="#冲突、推送失败" class="headerlink" title="冲突、推送失败"></a>冲突、推送失败</h4><p>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取pull下来并将其合并进你的工作后才能推送。</p><p>相当于是从远程获取最新版本并merge到本地</p><h3 id="从远程仓库获取数据"><a href="#从远程仓库获取数据" class="headerlink" title="从远程仓库获取数据"></a>从远程仓库获取数据</h3><p><code>$ git fetch [remote-name]</code></p><p>这个命令会访问远程仓库，从中拉取所有你<strong>还没有的数据</strong>。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看，它并<strong>不会自动合并或修改你当前的工作</strong>。</p><p><code>$ git pull [remote-name]</code></p><p>如果你有一个分支设置为<strong>跟踪一个远程分支</strong>，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并<strong>自动尝试合并到当前所在的分支</strong>。</p><p>如果git pull失败，一般是因为没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream dev origin/dev</span><br><span class="line"></span><br><span class="line">Branch dev <span class="built_in">set</span> up to track remote branch dev from origin.</span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了，也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有<code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line"></span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line">  - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h2 id="Git-本地高级操作"><a href="#Git-本地高级操作" class="headerlink" title="Git 本地高级操作"></a>Git 本地高级操作</h2><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><h4 id="创建、切换分支"><a href="#创建、切换分支" class="headerlink" title="创建、切换分支"></a>创建、切换分支</h4><p>创建并切换到新的分支dev</p><p><code>$ git branch dev</code></p><p><code>$ git checkout dev</code></p><p>等价于<code>$ git checkout -b dev</code>  </p><p>​       </p><p>复制远程分支到本地</p><p><code>$ git checkout -b dev origin/dev</code></p><p>dev是本地新建的分支名字，origin/dev是远程分支</p><p>查看所有分支，以及当前所在分支，*表示当前分支</p><p><code>$ git branch</code>  </p><p>切换分支</p><p><code>$ git checkout dev</code></p><p>切换出去前，要保存好编辑过的文件，用<code>add commit</code>，或者保存现场</p><h4 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h4><p><code>$ git stash</code></p><p>当在一个分支的开发工作未完成，却又要切换到另外一个分支进行开发的时候，并不是不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。除了commit原分支的代码改动的方法外，我觉得保存现场是一个更加便捷的选择，暂时冻结开发现场，等待其他分支完成后继续回来完成。</p><p>查看现场</p><p><code>git stash list</code></p><p>恢复现场</p><p><code>git stash apply，</code>默认恢复最新的现场，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除</p><p><code>git stash pop，</code>恢复的同时把stash内容也删了</p><p>可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：<code>$ git stash apply stash@{0}</code></p><p>删除合并后的分支</p><p><code>$ git branch -d dev</code> </p><p> 丢弃一个没有被合并过的分支</p><p><code>$ git branch -D dev</code>强行删除。</p><h3 id="分支详解"><a href="#分支详解" class="headerlink" title="分支详解"></a>分支详解</h3><p>当使用<code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中这些校验和被保存为树对象。随后，Git 便会创建一个提交对象（98ca9），它除了包含上面提到的那些信息外，还包含指向这个树对象（92ec2）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：一个提交对象（包含着指向前述树对象的指针和所有提交信息） 、一个树对象（记录着目录结构和 blob 对象索引）以及三个 blob 对象（保存着文件快照）。</p><p><img src="/2018/11/22/Git教程/./commit操作解释.png" alt="commit 操作解释"></p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>快速合并：<code>$ git merge dev</code></p><p><img src="/2018/11/22/Git教程/./快速合并1.png" alt="快速合并1"></p><p><img src="/2018/11/22/Git教程/./快速合并2.png" alt="快速合并2"></p><p>关闭快速合并，这样在Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p><code>$ git merge --no-ff -m &quot;merge withno-ff&quot; dev</code></p><p><img src="/2018/11/22/Git教程/./关闭快速合并.png" alt="关闭快速合并"></p><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的<u>同一个部分</u>进行了<u>不同的修改</u>，Git 就没法干净的合并它们。此时 Git 做了部分合并工作，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。</p><p>例子：</p><p><code>master</code>分支和<code>feature1</code>分支各自都分别对同一部分修改并有新的提交，就会产生冲突</p><p><img src="/2018/11/22/Git教程/./合并冲突1.png" alt="合并冲突1"></p><p>Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交，可以直接查看readme.txt的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under theGPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">Creating a new branchis quick &amp; simple.</span><br><span class="line">=========</span><br><span class="line">Creating a new branchis quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容。</p><p><img src="/2018/11/22/Git教程/./合并冲突2.png" alt="合并冲突2"></p><p>为了冲突解决，你可以选择使用由<code>=======</code>分割的两部分中的一个，或者你也可以自行合并这些内容（可以是完全新的内容），并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> ,<code>=======</code> , 和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行要被完全删除了。</p><p> 在你解决了所有文件里的冲突之后，对每个文件<strong>使用<code>git add</code> 命令来将其标记为冲突已解决</strong>。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决，然后commit保存入仓库。</p><p><img src="/2018/11/22/Git教程/./合并冲突3.png" alt="合并冲突3"></p><p>如果你想使用图形化工具来解决冲突，你可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><p><code>$ git mergetool</code></p><p>查看已合并的分支，从而删除没用的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>查看未合并的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>Git鼓励大量使用分支：</p><ul><li>查看分支：git branch</li><li><p>创建分支：git branch <name></name></p></li><li><p>切换分支：git checkout <name></name></p></li><li>创建+切换分支：git checkout -b <name></name></li><li>合并某分支到当前分支：git merge <name></name></li><li>删除分支：git branch -d <name></name></li></ul><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支，这个本地分支就叫做“跟踪分支”（有时候也叫做 “上游分支”）。 <strong>跟踪分支是与远程分支有直接关系的本地分支</strong>。 如果在一个跟踪分支上输入<code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><ul><li><p>创建跟踪分支：<code>git checkout -b [branch][remotename]/[branch]</code></p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line"></span><br><span class="line">Branch sf <span class="built_in">set</span> upto track remote branch serverfix from origin.</span><br><span class="line"></span><br><span class="line">Switched to a newbranch <span class="string">'sf'</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置已有的本地分支</strong>跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -uorigin/serverfix</span><br><span class="line"></span><br><span class="line">Branch serverfixset up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure></li></ul><p>可以使用 <code>git branch -vv</code> 。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line"></span><br><span class="line">  iss53    7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line"></span><br><span class="line">  master   1ae2a45 [origin/master] deploying index fix</span><br><span class="line"></span><br><span class="line">* serverfix  f8674d9 [teamone/server-fix-good: ahead 3, behind 1]this should <span class="keyword">do</span> it</span><br><span class="line"></span><br><span class="line">  testing  5ea463a trying something new</span><br></pre></td></tr></table></figure><p>可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。<br>这些数字的值来自于你从每个服务器上最后一次抓取(fetch)的数据。 这个命令(branch -vv)并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。<br>可以像这样做：<br><code>git fetch --all; git branch –vv</code></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>Git 可以给历史中的某一个提交打上标签，以示重要。</p><p>Git 使用两种主要类型的标签：<strong>轻量标签</strong>（lightweight）与<strong>附注标签</strong>（annotated）。</p><ul><li>轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</li><li>附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；通常建议创建附注标签，这样你可以拥有以上所有信息</li></ul><p><strong>标签创建</strong></p><p><code>$ `</code>git tag` 查看标签，<strong>注意</strong>，标签不是按时间顺序列出，而是按字母排序的。</p><p><code>$ git tagv1.0</code> 标签默认是打在最新提交的commit上的,标签名为v1.0</p><p><code>$ git tag -a v1.0 -m &quot;version 1.0released&quot; commit_id</code> 可以创建带有说明的附注标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字。</p><p><strong>补打标签</strong></p><p><code>$ git  tag  v1.0 commit_id</code> 你也可以对过去的提交打标签，指定某个历史打标签，通过<code>$ git log --pretty=oneline --abbrev-commit</code>查找到对应要打标签的<code>commit_id</code>。</p><p><code>$ git show &lt;tagname&gt;</code>可以看到说明文字。</p><p><strong>标签推送</strong></p><p>默认情况下，<strong><code>git push</code>命令并<u>不会</u>传送标签到远程仓库服务器</strong>上。 在创建完标签后你必须显式地推送标签到共享服务器上</p><p><code>$ git push origin &lt;tagname&gt;</code> 推送某个标签到远程。</p><p><code>$ git push origin –-tags</code>  一次性推送全部尚未推送到远程的本地标签.</p><p><strong>标签删除</strong></p><p><code>$ git tag -d v1.0</code>如果标签打错了，也可以删除。</p><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v1.0</span><br><span class="line"></span><br><span class="line">Deleted tag <span class="string">'v1.0'</span> (was 6224937)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><p><code>$ git pushorigin :refs/tags/v1.0</code>//可以删除一个远程标签。</p><p><strong>标签切换</strong></p><p>如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 <code>git checkout -b[branchname][tagname]</code>在特定的标签上创建一个新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b version2 v2.0.0</span><br><span class="line"></span><br><span class="line">Switched to a new branch <span class="string">'version2'</span></span><br></pre></td></tr></table></figure><p>当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。</p><h3 id="大文件更新Update-TODO未看"><a href="#大文件更新Update-TODO未看" class="headerlink" title="大文件更新Update(TODO未看)"></a>大文件更新Update(TODO未看)</h3><p>我们知道 Git 不仅仅是用来做代码版本管理的，很多其他领域的项目也会使用 Git。比如说我公司曾经一个客户的项目涉及到精密零件图纸文档的版本管理，他们也用Git。有一种使用场景是<strong>对一些体积庞大的文件进行修改</strong>，但是每一次保存 Git 都要计算文件的变化并更新工作区，这在硬盘慢的时候延迟卡顿非常明显。</p><p>git update-index –assume-unchanged 的真正用法是这样的：</p><ol><li>你正在修改一个巨大的文件，你先对其 git update-index –assume-unchanged，这样 Git 暂时不会理睬你对文件做的修改；</li><li>当你的工作告一段落决定可以提交的时候，重置改标识：git update-index –no-assume-unchanged，于是 Git 只需要做一次更新，这是完全可以接受的了；</li><li>提交＋推送。</li></ol><h3 id="配置命令别名"><a href="#配置命令别名" class="headerlink" title="配置命令别名"></a>配置命令别名</h3><ul><li>配置别名有点像C语言里的宏，进行简单的替换。</li><li><strong>替换单个词</strong>，告诉Git，以后<code>st</code>就表示<code>status</code></li></ul><p><code>$ git config--global alias.st status</code></p><p>当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config--global alias.co checkout</span><br><span class="line">$ git config--global alias.ci commit</span><br><span class="line">$ git config --globalalias.br branch</span><br></pre></td></tr></table></figure><ul><li><strong>替换多个词</strong>（用单引号包含着多个词）；</li></ul><ol><li><p>命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：<code>$ git config --global alias.unstage &#39;reset HEAD&#39;</code></p></li><li><p>配置格式化打印log的：（将<code>log--pretty=format:&quot;%h - %an - %ar : %s&quot;</code>定义为linelog）：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config--global alias.linelog &apos;log --pretty=format:&quot;%h - %an - %ar : %s&quot;&apos;</span><br></pre></td></tr></table></figure></li></ol><ul><li>撤销别名，打开配置文件删除即可，详见【配置文件】章节</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Git的时候，加上–global是针对当前用户（整个软件）起作用的，如果不加，那只针对当前的仓库（当前文件夹）起作用。</p><ul><li><p><strong>当前仓库配置文件</strong>：每个仓库的Git配置文件都放在.git/config文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">    ignorecase = <span class="literal">true</span></span><br><span class="line">    precomposeunicode = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    last = <span class="built_in">log</span> -1</span><br></pre></td></tr></table></figure><p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p></li></ul><ul><li><p><strong>全局配置文</strong>件：放在用户主目录（window系统中的用户目录下）下的一个隐藏文件.gitconfig中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.gitconfig</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">email = your@email.com</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p></li></ul><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="参与Github开源项目"><a href="#参与Github开源项目" class="headerlink" title="参与Github开源项目"></a>参与Github开源项目</h3><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap" target="_blank" rel="noopener">https://github.com/twbs/bootstrap</a>，点“<code>Fork</code>”，将别人的仓库在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：<code>git‍ clone ‍git@github.com:jizxGit/bootstrap.git</code></p><p>一定要从自己的账号下clone仓库，这样你才能推送修改，因为你在github添加了SSH。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><p><img src="/2018/11/22/Git教程/./参与Github开源项目1.png" alt="参与Github开源项目1"></p><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个<code>pull request</code>。当然，对方是否接受你的pull request就不一定了。</p><p><img src="/2018/11/22/Git教程/./参与Github开源项目2.png" alt="参与Github开源项目2"></p><h3 id="小组合作"><a href="#小组合作" class="headerlink" title="小组合作"></a>小组合作</h3><ol><li><p>首先在github上创建一个需要与团队共享的仓库</p></li><li><p>然后在仓库的Settings中添加队友的github帐户： </p><p> <img src="/2018/11/22/Git教程/./小组合作1.png" alt="小组合作1">         </p><p><img src="/2018/11/22/Git教程/./小组合作2.png" alt="小组合作2">                  </p></li><li><p>添加完成后，对方会收到请求，如下图，需要对方同意请求，才算是加入到这个团队中，拥有push的权限。</p><p><img src="/2018/11/22/Git教程/./小组合作3.png" alt="小组合作3"> </p></li></ol><p><strong>流程会像这样</strong>：</p><p>A拥有repository，想要让B也能更新自己的repository，就把B加入collaborators，这样B要一起合作这份code的时候，clone A 的clone repo到本地，然后B就可以在自己的本机尽情修改code (用branch、commit、merge)，最后在push的时候输入B自己的帐密，会更新A的repository(A仍就可以继续更新自己的repository)，但B自己的github账户并不会有一份和A相同的repository(只会有A的repo连结)</p><h2 id="Git-bash-快捷键（window）"><a href="#Git-bash-快捷键（window）" class="headerlink" title="Git bash 快捷键（window）"></a>Git bash 快捷键（window）</h2><h3 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h3><p><code>ATL+ENTER</code></p><h3 id="字体变化"><a href="#字体变化" class="headerlink" title="字体变化"></a>字体变化</h3><p><code>CTRL+PLUS/MINUS/ZERO</code></p><h3 id="右键"><a href="#右键" class="headerlink" title="右键"></a>右键</h3><p><code>ALT+SPACE</code></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python编码问题</title>
      <link href="/2018/11/19/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2018/11/19/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>理清楚 从编写python文件的编码，到运行时的编码，最后print打印显示这一整根流程中的各种编码问题</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p>计算机最早是只有英文ASCII码，但世界上除了英语，还有很多其他语言，因此只有ASCII码编码显然不适合这种情况。</p><p>于是后来在中国、日本等其他国家都有了自己的一套编码，但是这样就出现问题了，不同国家之间数据传输，就会出现乱码。</p><p>为了让全世界都可以使用计算机，于是有了Unicode编码方式，俗称万国码，可以存储好几万个字符。（unicode专题TODO）</p><p><strong>因此计算机内存中，对字符串的编码使用的都是Unicode，作为中间者。</strong></p><p>但是又有新的问题出现了，<strong>Unicode是定长编码，不适合存储</strong>，非常浪费存储空间，这里又有了一种新的编码方式：utf-8。<strong>utf-8采用的是不定长编码</strong>，大大节约了存储空间。在数据存储和传输方面非常方便。</p><p>当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码(或者其他编码)。</p><p><img src="/2018/11/19/python编码问题/./1.png" alt=""></p><hr><p><img src="/2018/11/19/python编码问题/./2.png" alt=""></p><h4 id="pyhton2-中的编码过程"><a href="#pyhton2-中的编码过程" class="headerlink" title="pyhton2 中的编码过程"></a>pyhton2 中的编码过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line">s = <span class="string">"中文"</span></span><br><span class="line">print(type(s)) <span class="comment"># &lt;type 'str'&gt;</span></span><br><span class="line"></span><br><span class="line">s2=s.encode(<span class="string">'utf8'</span>) <span class="comment"># unicode解码错误，无法以ASCII解码字节 0xe4，超出了range（128）：UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">u'中文'</span>  <span class="comment"># &lt;type 'unicode'&gt;</span></span><br><span class="line">s3=s2.encode(<span class="string">'utf8'</span>)</span><br><span class="line">print(type(s3)) <span class="comment"># &lt;type 'str'&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>在运行前</strong>，python解释器默认以ASCII码解码文件，因此如果文件中有中文就会报错：<code>Non-ASCII character &#39;\xe9&#39;</code> ，表示出现了超出ASCII码（0-127）以外的字节，因此需要在文件第一行添加：<code># _*_ coding:utf8 _*_</code> ，让编译器以指定的字符集进行解码然后编译。</p></li><li><p><strong>在运行时</strong>，Python2 中字符串有2种类型：<code>&lt;type &#39;str&#39;&gt;</code> 和<code>&lt;type &#39;unicode&#39;&gt;</code>，默认是<code>str</code>类型 。变量<code>s</code> 的类型是<code>&lt;type &#39;str&#39;&gt;</code> ，可以理解为保存了“中文”以utf8编码的二进制数据。<code>s.encode(&#39;utf8&#39;)</code>命令实际上过程是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.decode(defaultencoding).encode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型的转变过程</span></span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;  ——以defaultencoding解码——&gt;   &lt;type <span class="string">'unicode'</span>&gt;——以encode方法指定的字符集编码——&gt;   &lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.getdefaultencoding()) <span class="comment"># ascii</span></span><br></pre></td></tr></table></figure><p><code>defaultencoding</code>在python2中默认是ASCII，而<code>s</code>是以utf8编码的，因此在str—&gt;unicode的时候就会出现<code>UnicodeDecodeError</code></p></li><li><p><strong>解决办法</strong>有2种：</p><ol><li><p>显式进行解码<code>s.decode(&#39;utf8&#39;).encode(&#39;utf8&#39;)</code></p></li><li><p>修改系统默认字符集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)<span class="comment"># Python2.5初始化后会删除sys.setdefaultencoding这个方法，因此需要重新载入</span></span><br><span class="line">print(sys.getdefaultencoding()) <span class="comment"># ascii</span></span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line">print(sys.getdefaultencoding()) <span class="comment"># utf-8</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h5 id="u前缀"><a href="#u前缀" class="headerlink" title="u前缀"></a>u前缀</h5><p>在python2里面，<code>u</code>表示unicode string，类型是unicode, 没有<code>u</code>表示byte string，类型是 str。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'中文'</span>   <span class="comment"># '\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line">print(type(s1)) <span class="comment"># &lt;type 'str'&gt;</span></span><br><span class="line">print(len(s1))  <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">u'中文'</span>     <span class="comment"># u'\u4e2d\u6587'</span></span><br><span class="line">print(type(s2)) <span class="comment"># &lt;type 'unicode'&gt;</span></span><br><span class="line">print(len(s2))  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">print(s1 == s2) <span class="comment"># False (警告 UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal)</span></span><br><span class="line">print(s2 == s1) <span class="comment"># False 不会有警告</span></span><br><span class="line">print(s1 <span class="keyword">is</span> s2) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">s3=s.encode(<span class="string">'utf8'</span>)</span><br><span class="line">print(type(s3))</span><br></pre></td></tr></table></figure><h5 id="字符串长度问题"><a href="#字符串长度问题" class="headerlink" title="字符串长度问题"></a>字符串长度问题</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2.7</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">msg=<span class="string">'中文'</span>   <span class="comment"># '\xe4\xb8\xad\xe6\x96\x87'此时msg被编码为utf-8,而不是ascii ,</span></span><br><span class="line">type(msg)   <span class="comment"># &lt;type 'str'&gt;</span></span><br><span class="line">len(msg) <span class="comment"># 6 因为utf8每个汉字占3个字节</span></span><br><span class="line"></span><br><span class="line">umsg=unicode(msg) <span class="comment"># u'\u4e2d\u6587'</span></span><br><span class="line">type(umsg)  <span class="comment"># &lt;type 'unicode'&gt;</span></span><br><span class="line">len(umsg)   <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h4 id="Python3-中的编码过程"><a href="#Python3-中的编码过程" class="headerlink" title="Python3 中的编码过程"></a>Python3 中的编码过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'中文'</span>   <span class="comment"># '中文'</span></span><br><span class="line">print(type(s1)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(len(s1))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">u'中文'</span>     <span class="comment"># '中文' 与s1没有区别</span></span><br><span class="line">print(type(s2)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(len(s2))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">print(s1 == s2) <span class="comment"># True</span></span><br><span class="line">print(s1 <span class="keyword">is</span> s2) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">s3=s1.encode(<span class="string">"utf8"</span>)</span><br><span class="line">print(type(s3))  <span class="comment">#&lt;class 'bytes'&gt;</span></span><br><span class="line">print(s3) <span class="comment"># b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"></span><br><span class="line">s4=s3.decode(<span class="string">"utf8"</span>) </span><br><span class="line">print(type(s4)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(s4) <span class="comment"># 中文</span></span><br></pre></td></tr></table></figure><p>python3的改进：</p><ol><li>Python3在编译时，文件默认就是以<code>utf-8</code>进行解码然后编译</li><li>python3中<strong>所有字符串都是以unicode格式(\uXXXX)保存在内存中</strong>，<strong><code>u</code>前缀没有特殊含义了</strong>。只有<code>&lt;class str&gt;</code> 类型，对应的就是python2中的 <code>&lt;type &#39;unicode&#39;&gt;</code> 。而<code>&lt;class byte&gt;</code>  类似于python2的<code>&lt;type &#39;str&#39;&gt;</code> 。</li><li><code>encode</code>函数根据参数指定的编码方式，把str类型的字符串转换为bytes类型。而在python3中字符串没有<code>decode</code>函数，<code>byte</code>类型才有。</li><li>在python3中，我们将不能直接看到unicode字节串，它会被显示为中文的“中文”；因为python3默认使用unicode编码，<strong>unicode字节串将被直接处理为中文显示出来。</strong></li></ol><h4 id="获取字符的unicode"><a href="#获取字符的unicode" class="headerlink" title="获取字符的unicode"></a>获取字符的unicode</h4><ul><li>根据unicode获取字符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chr参数支持10进制、16进制</span></span><br><span class="line">chr(<span class="number">0x4e2d</span>)  <span class="comment"># '中' </span></span><br><span class="line">chr(<span class="number">20013</span>)   <span class="comment"># '中'</span></span><br></pre></td></tr></table></figure><ul><li>根据字符获取unicode码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回值：10进制的unicode码</span></span><br><span class="line">ord(<span class="string">"中"</span>)  <span class="comment"># 20013</span></span><br></pre></td></tr></table></figure><h4 id="Python2中的print过程"><a href="#Python2中的print过程" class="headerlink" title="Python2中的print过程"></a>Python2中的print过程</h4><p>Python2.7中调用print打印<code>var</code>变量时，操作系统会对<code>var</code>做一定的字符处理：</p><ul><li>如果<code>var</code>是str类型的变量，则直接将<code>var</code>变量交付给终端进行显示；</li><li>如果<code>var</code>变量是unicode类型，则操作系统首先将var编码成str类型的对象（编码格式取决于stdout的编码格式<code>print(sys.stdout.encoding)</code>），然后再交由终端进行显示。</li><li>在终端显示时，如果str类型的<strong>变量的编码方式</strong>和<strong>终端设置的编码方式</strong>不一致，很可能会出现乱码问题。</li></ul><h4 id="Python2-与3-读取文件的编码问题"><a href="#Python2-与3-读取文件的编码问题" class="headerlink" title="Python2 与3 读取文件的编码问题"></a>Python2 与3 读取文件的编码问题</h4><p><code>codecs</code>会按照指定的字符集解码文件，然后将字符串转为<code>&lt;type &#39;unicode&#39;&gt;</code> </p><p><code>open</code>读取文件后的字符串是<code>&lt;type &#39;str&#39;&gt;</code> 类型，而且a.txt是以utf8编码保存的，与‘分’是同一种编码（<code># _*_ coding:utf8 _*_</code>），因此可以直接split</p><p>a.txt中的内容是：中文分国家</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line=f.read()</span><br><span class="line">    print(type(line)) <span class="comment"># &lt;type 'unicode'&gt;</span></span><br><span class="line">    ss=line.split(<span class="string">'分'</span>.decode(<span class="string">'utf8'</span>))</span><br><span class="line">    <span class="comment"># 相当于下面2行</span></span><br><span class="line">    <span class="comment"># c='分'  # &lt;type 'str'&gt;  </span></span><br><span class="line">    <span class="comment"># ss=line.split(c.decode('utf8')) #因为line是unicode，而c是str，因此必须进行decode</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line2=f.readline()</span><br><span class="line">    print(type(line2)) <span class="comment">#&lt;type 'str'&gt;</span></span><br><span class="line">    ss=line2.split(<span class="string">'分'</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        print(s)</span><br></pre></td></tr></table></figure><p>python3中都是unicode存储字符串，因此没有上面的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line=f.read()</span><br><span class="line">    print(type(line)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">    ss=line.split(<span class="string">'分'</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line2=f.readline()</span><br><span class="line">    print(type(line2)) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">    ss=line2.split(<span class="string">'分'</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ss:</span><br><span class="line">        print(s)</span><br></pre></td></tr></table></figure><h4 id="JSON-保存中文文件"><a href="#JSON-保存中文文件" class="headerlink" title="JSON 保存中文文件"></a>JSON 保存中文文件</h4><p>使得JSON保存的文件中文可读，必须有<code>ensure_ascii</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(json.dumps(custs,encoding=<span class="string">'UTF-8'</span>,ensure_ascii=<span class="keyword">False</span>))</span><br></pre></td></tr></table></figure></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编码问题 </tag>
            
            <tag> 打印 </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java方法传参问题</title>
      <link href="/2018/07/04/java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/04/java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="一、基本类型-和-引用类型的不同之处"><a href="#一、基本类型-和-引用类型的不同之处" class="headerlink" title="一、基本类型 和 引用类型的不同之处"></a>一、基本类型 和 引用类型的不同之处</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>首先变量其实是堆栈中的地址索引。然后 基本类型的数据直接保存在堆栈中，而对象是保存在堆中，堆栈中保存的是该对象在堆中的地址，这个地址就是所谓的<strong>引用</strong></p><p><img src="/2018/07/04/java方法传参问题/java传参1.png" alt=""></p><h3 id="二、赋值运算符（-）的作用"><a href="#二、赋值运算符（-）的作用" class="headerlink" title="二、赋值运算符（=）的作用"></a>二、赋值运算符（=）的作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">20</span>;</span><br><span class="line">str = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/04/java方法传参问题/java传参2.png" alt=""></p><p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<strong>但是原来的对象不会被改变（重要）。</strong><br>如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p><h3 id="三、调用方法时发生了什么？参数传递基本上就是赋值操作。"><a href="#三、调用方法时发生了什么？参数传递基本上就是赋值操作。" class="headerlink" title="三、调用方法时发生了什么？参数传递基本上就是赋值操作。"></a>三、调用方法时发生了什么？<strong>参数传递基本上就是赋值操作</strong>。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">20</span>;</span><br><span class="line">str = <span class="string">"java"</span>;</span><br><span class="line">func(num,str);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n,String s)</span></span>&#123;</span><br><span class="line">    n=<span class="number">30</span>;</span><br><span class="line">    s+=<span class="string">"haha"</span>;</span><br><span class="line">    <span class="comment">// do something with s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/04/java方法传参问题/java传参3.png" alt=""></p><p>n变为30，num不受影响；s虽然是对象类型，但是由于String是不可变类型，因此并不会影响到原来的str变量。所以结果如下：</p><p><img src="/2018/07/04/java方法传参问题/java传参4.png" alt=""></p><p>如果str是StringBuilder对象的话，就会改变，结果如下：</p><p><img src="/2018/07/04/java方法传参问题/java传参5.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在java中，不管原始参数的类型是什么，<strong>参数都是按值传递的</strong>。</p><p>每当一个方法被执行时，在堆栈中就会为每个参数创建一个拷贝，这个拷贝被传递到方法的内部，这个拷贝分以下2种情况：</p><ul><li>如果参数是基本类型，那么在堆栈中复制的就是这个参数的值</li><li>如果是对象，那么在堆栈中传递的便是指向真正对象数据的新的引用。这个新的引用被传递到方法内部。</li></ul><p>因此关于参数在方法中被修改后，会不会影响到原始变量，根据上面的原理：</p><ol><li>修改一个基础类型的参数，不会影响原始数据；</li><li>修改一个对象参数(数组、集合、map、类)的引用时，永远不会影响到原始的引用；</li><li>修改一个对象参数的属性时，会影响原始对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DuplicatenNum app = <span class="keyword">new</span> DuplicatenNum();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a1=<span class="number">5</span>;</span><br><span class="line">        app.fun1(a1);</span><br><span class="line">        System.out.println(a1);</span><br><span class="line"></span><br><span class="line">        TreeNode a2=<span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        app.fun2(a2);</span><br><span class="line">        System.out.println(a2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a2_2=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        app.fun2_2(a2_2);</span><br><span class="line">        System.out.println(a2_2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        app.fun3(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        a=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2_2</span><span class="params">(<span class="keyword">int</span> []  arr)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">TreeNode&#123;val=5, left=null, right=null&#125;</span><br><span class="line">1</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure><p>参考： <a href="https://www.zhihu.com/question/31203609" target="_blank" rel="noopener">Java 到底是值传递还是引用传递？</a> </p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 传参 </tag>
            
            <tag> 方法调用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何有效批评而不是吵架</title>
      <link href="/2018/06/17/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%89%B9%E8%AF%84%E8%80%8C%E4%B8%8D%E6%98%AF%E5%90%B5%E6%9E%B6/"/>
      <url>/2018/06/17/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%89%B9%E8%AF%84%E8%80%8C%E4%B8%8D%E6%98%AF%E5%90%B5%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>一般情况下，如果一个问题刚刚出现，你就把它指出来，那对方很快就能改正，不要堆积容忍太久。同时要学会如何有效指出问题，有效批评。</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/06/17/如何有效批评而不是吵架/如何有效批评而不是吵架.png" alt=""></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 心理 </category>
          
          <category> 人际交往 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
            <tag> 批评 </tag>
            
            <tag> 吵架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer</title>
      <link href="/2018/06/17/%E5%89%91%E6%8C%87offer/"/>
      <url>/2018/06/17/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>剑指offer题目（持续更新）</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，防止外部使用new创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例模式1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>有人提出在getInstance()方法上同步锁，但是锁住一整个方法可能粒度过大，不利于效率。既然锁方法不太好，那么锁代码呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 构造方法私有化，防止外部使用new创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例模式2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样做看似解决了线程安全问题，其实不然</strong>。设现有线程A和B，在t1时刻线程A和B均已通过判空语句但都未取得锁资源；t2时刻时，A先取得锁资源进入临界区（被锁的代码块），执行new操作创建实例对象，然后退出临界区，释放锁资源。t3时刻，B取得被A释放的锁资源进入临界区，执行new操作创建实例对象，然后退出临界区，释放锁资源。明显地，Singleton被实例化两次。</p><p>改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全，但是如果instance已经存在不能直接返回，也会被锁住，效率很低下，还可以优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例模式3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双检查锁机制（推荐）"><a href="#双检查锁机制（推荐）" class="headerlink" title="双检查锁机制（推荐）"></a>双检查锁机制（推荐）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意此处加上了volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"单例模式4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK1.5以前，DCL（双检查锁机制）是不稳定的，有时也可能创建多个实例，在1.5以后开始提供volatile关键字修饰变量来达到稳定效果。</p><h4 id="多线程测试入口"><a href="#多线程测试入口" class="headerlink" title="多线程测试入口"></a>多线程测试入口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建实现了Runnable接口的匿名类</span></span><br><span class="line">        Runnable run = () -&gt; Singleton2.getInstance();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(run);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>单例是为了保证系统中只有一个实例，其关键点有：</p><ol><li>私有构造函数</li><li>声明静态单例对象</li><li>构造单例对象之前要加锁（lock一个静态的object对象）</li><li>需要两次检测单例实例是否已经被构造，分别在锁之前和锁之后</li></ol><p><strong>1.为何要检测两次？</strong></p><p>如上面所述，有可能延迟加载或者缓存原因，造成构造多个实例，违反了单例的初衷。</p><p><strong>2.构造函数能否公有化？</strong></p><p>不行，单例类的构造函数必须私有化，单例类不能被实例化，单例实例只能静态调用</p><p><strong>3.lock住的对象为什么要是object对象，可以是int吗？</strong></p><p>不行，锁住的必须是个引用类型。如果锁值类型，<strong>每个不同的线程在声明的时候值类型变量的地址都不一样，那么上个线程锁住的东西下个线程进来会认为根本没锁，相当于每次都锁了不同的门，</strong>没有任何卵用。而引用类型的变量地址是相同的，每个线程进来判断锁多想是否被锁的时候都是判断同一个地址，相当于是锁在通一扇门，起到了锁的作用。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="二维有序数组中查找"><a href="#二维有序数组中查找" class="headerlink" title="二维有序数组中查找"></a>二维有序数组中查找</h4><p><img src="/2018/06/17/剑指offer/3.png" alt=""></p><p>思路：用target与数组右上角的值进行比较，小于右上角，则跳过该列，大于右上角，则跳过该行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] arr2 = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(find(arr, <span class="number">11</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = arr[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用target与数组右上角的值进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; i &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// target小于右上角，则跳过该列</span></span><br><span class="line">            <span class="keyword">while</span> (target &lt; arr[i][j] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// target大于右上角，则跳过该行</span></span><br><span class="line">            <span class="keyword">while</span> (target &gt; arr[i][j] &amp;&amp; i &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target == arr[i][j]) &#123;</span><br><span class="line">                System.out.println(<span class="string">"i:"</span> + (i + <span class="number">1</span>) + <span class="string">",j:"</span> + (j + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h4><p><img src="/2018/06/17/剑指offer/8.png" alt=""></p><p>主要考虑三种情况：</p><ol><li>正常情况：{7,8,1,2,3,4,5,6}</li><li>有序情况：{1, 2, 3, 4, 5, 6}</li><li>相等情况：{1, 1, 0, 1, 1, 1, 1, 1}</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int[] a = &#123;5,6,7,8,1,2,3,4&#125;;</span></span><br><span class="line">        <span class="comment">// int[] a = &#123;1, 1, 0, 1, 1, 1, 1, 1&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(findMin(a));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用二分法进行查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left;<span class="comment">//初始值原因见下方</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 正常情况，左边会大于等于右边，否则就已经是有序的数组，第一个就是最小值，因此mid初始为left</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &gt;= arr[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">                mid = right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 左边=中间=右边，只能遍历,&#123;1, 1, 0, 1, 1, 1, 1, 1&#125;;</span></span><br><span class="line">            <span class="keyword">if</span> (arr[left] == arr[right] &amp;&amp; arr[right] == arr[mid]) &#123;</span><br><span class="line">                <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min &gt; arr[i]) &#123;</span><br><span class="line">                        min = arr[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> min;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 左边&lt;=中间，说明最小值在[mid,right]</span></span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt;= arr[mid]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右边&gt;=中间，说明最小值在[left,mid]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[right] &gt;= arr[mid]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[mid];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="调整数组-使奇数在偶数前面"><a href="#调整数组-使奇数在偶数前面" class="headerlink" title="调整数组 使奇数在偶数前面"></a>调整数组 使奇数在偶数前面</h4><p><img src="/2018/06/17/剑指offer/14.png" alt=""></p><p>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>基本解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((numbers[left] &amp; <span class="number">0x1</span>) == <span class="number">1</span>) left++;</span><br><span class="line">            <span class="keyword">while</span> ((numbers[right] &amp; <span class="number">0x1</span>) == <span class="number">0</span>) right--;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = numbers[left];</span><br><span class="line">                numbers[left] = numbers[right];</span><br><span class="line">                numbers[right] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可扩展的实现，解耦，完成各种条件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可扩展的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        sort(arr, <span class="keyword">new</span> Condition() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ((a &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] numbers, Condition c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; c.check(numbers[left])) left++;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; !c.check(numbers[right])) right--;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = numbers[left];</span><br><span class="line">                numbers[left] = numbers[right];</span><br><span class="line">                numbers[right] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保证顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//O(n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; array[j - <span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                    array[j - <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(n),辅助空间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray2</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从前向后扫描奇数</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; array.length ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                copy[i++] = array[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后向前扫描偶数</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[right] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                copy[j--] = array[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;array.length;k++)&#123;</span><br><span class="line">            array[k]=copy[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><p><img src="/2018/06/17/剑指offer/20.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                <span class="comment">// &#123;10,9,8,7&#125;,</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = printMatrix(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">// 因为每次打印都是从对角线[0,0]、[1,1]……的开始，因此只需要一个变量来标记</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        ArrayList&lt;Integer&gt; printList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (start * <span class="number">2</span> &lt; row &amp;&amp; start * <span class="number">2</span> &lt; col) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; result = print(matrix, row, col, start);</span><br><span class="line">            printList.addAll(result);</span><br><span class="line">            ++start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> printList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endX = col - start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endY = row - start - <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 打印从左到右的上面一行 :第一行肯定要打印的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endX; i++) &#123;</span><br><span class="line">            list.add(matrix[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印从上到下的右面的一列：第二行能不能打印的条件在循环中了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY; i++) &#123;</span><br><span class="line">            list.add(matrix[i][endX]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; endX &amp;&amp; start &lt; endY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">                list.add(matrix[endY][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; endX &amp;&amp; start &lt; endY - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt; start; i--) &#123;</span><br><span class="line">                list.add(matrix[i][start]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中超过一半的数字（还有一种解法）"><a href="#数组中超过一半的数字（还有一种解法）" class="headerlink" title="数组中超过一半的数字（还有一种解法）"></a>数组中超过一半的数字（还有一种解法）</h4><p><img src="/2018/06/17/剑指offer/29.png" alt=""></p><p>解法1：基于partition的函数的O(n)算法，因为数字超过半数，因此将原数组排序后，中位数一定就是那个数值（如果输入是）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解法2：一个数字出现次数超过数组长度的一半，说明他出现的次数比其他所有数字出现的次数还多。因此可以用result，time来分别保存统计的数字，以及出现的次数。遍历时如果相同time+1，不同time-1，当time=0时，result更新为当前数字，time重置为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.输入合法性验证</span></span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.统计超过半数的数字</span></span><br><span class="line">        <span class="keyword">int</span> result = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">//当time=0时，result更新为当前数字，time重置为1</span></span><br><span class="line">            <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">                result = array[i];</span><br><span class="line">                time = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//遍历时如果相同time+1，不同time-1</span></span><br><span class="line">            <span class="keyword">if</span> (result == array[i])</span><br><span class="line">                time++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                time--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.是否超过半数验证</span></span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result == array[i]) &#123;</span><br><span class="line">                time++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (time * <span class="number">2</span> &lt;= array.length)</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="最小的k个数（包含海量数据）"><a href="#最小的k个数（包含海量数据）" class="headerlink" title="最小的k个数（包含海量数据）"></a>最小的k个数（包含海量数据）</h4><p><img src="/2018/06/17/剑指offer/30.png" alt=""></p><p>解法1，小数据量：快排方法 O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; re = GetLeastNumbers_Solution(array, <span class="number">10</span>);</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入检验</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || k &gt; input.length) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = parttition(input, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = input.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index = parttition(input, start, end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parttition</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        swap(input, mid, low);</span><br><span class="line">        <span class="keyword">int</span> pivot = input[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (input[j] &gt;= pivot &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span> (input[i] &lt;= pivot &amp;&amp; i &lt; j) i++;</span><br><span class="line">            swap(input, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(input, i, low);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = input[i];</span><br><span class="line">        input[i] = input[j];</span><br><span class="line">        input[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2，海量数据：使用红黑树 O(nlogk)，类似下面介绍的方法5</p><p>常见解法思路：</p><ul><li>最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求，该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。</li><li>第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字与容器内的最小数字相比，如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。</li><li>第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。</li></ul><ul><li>第四种方法是Hash法。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。</li></ul><ul><li>第五种方法采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（n*mlogm），空间复杂度是10000（常数）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; re = GetLeastNumbers_Solution(array, <span class="number">10</span>);</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="comment">//输入检验</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || k &gt; input.length) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; topk=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (topk.size() &lt; k) &#123;</span><br><span class="line">                topk.add(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(topk.last()&gt;val)&#123;</span><br><span class="line">                    topk.pollLast();</span><br><span class="line">                    topk.add(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.addAll(topk);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问次数最多的IP"><a href="#访问次数最多的IP" class="headerlink" title="访问次数最多的IP"></a>访问次数最多的IP</h4><p>参考：<a href="http://yueyemaitian.iteye.com/blog/1180299" target="_blank" rel="noopener">http://yueyemaitian.iteye.com/blog/1180299</a></p><p>算法思想：分而治之+Hash</p><p>1、IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；</p><p>2、可以考虑采用分而治之的思想，按照IP地址的Hash(IP) % 1024值，把海量IP日志分别存储到1024个小文件中，这样，每个小文件最多包含4MB个IP地址；</p><p>​     <strong>这里解释一下为什么用Hash(IP) % 1024值，如果不用，而直接分类的话，可能会出现这样一种情况，就是有个IP在每个小文件中都存在，而且这个IP并不一定在那个小文件中是数量最多的，那么最终可能选择的结果会有问题，所以这里用了Hash(IP)%1024值，这样的话，通过计算IP的Hash值，相同IP肯定会放到一个文件中，当然了不同的IP的Hash值也可能相同，就存在一个小文件中。</strong></p><p>3、对于每一个小文件，可以构建一个IP为key，出现的次数为value的Hash Map，同时记录当前出现次数最多的那个IP地址；</p><p>4、可以得到1024个小文件中的出现次数最多的那个IP，再依据常规的排序算法得出总体上出现次数最多的IP。</p><h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><p><img src="/2018/06/17/剑指offer/31.png" alt=""></p><p>解法1 <strong>O(n)，思路如下：</strong></p><p><img src="/2018/06/17/剑指offer/31-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,-<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(FindGreatestSumOfSubArray(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = array[<span class="number">0</span>];  <span class="comment">// 初始化为数组中的第一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果之前的和&lt;=0，说明从之前某个位置开始的子数组的和 会小于 从当前位置开始的子数组的和</span></span><br><span class="line">            <span class="comment">// 因此可以不考虑之前的子数组，Sum重置为当前位置的值</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                end = i;</span><br><span class="line">                sum = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum = sum + array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大和</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                end = i; <span class="comment">//更新子数组最后的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"["</span>+start+<span class="string">","</span>+end+<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> len = array.length;</span><br><span class="line">       <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">       f[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">           <span class="comment">// 递归公式</span></span><br><span class="line">           <span class="comment">// f[i] = array[i]             # i=0 或者 f[i-1]&lt;=0</span></span><br><span class="line">           <span class="comment">// f(i) = f[i - 1] + array[i]  # f[i-1]&gt;0</span></span><br><span class="line">           f[i] = f[i - <span class="number">1</span>] &lt;= <span class="number">0</span> ? array[i] : f[i - <span class="number">1</span>] + array[i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : f) &#123;</span><br><span class="line">           <span class="keyword">if</span> (max &lt; i) &#123;</span><br><span class="line">               max = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>解法3：分治（未实现）</p><h4 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h4><p><img src="/2018/06/17/剑指offer/33.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输入合法性检测</span></span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数字转为字符串类型</span></span><br><span class="line">        ArrayList&lt;String&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : numbers) &#123;</span><br><span class="line">            nums.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义的规则 进行排序</span></span><br><span class="line">        Collections.sort(nums, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//为了避免长度问题，将其拼接后再进行字符串比较</span></span><br><span class="line">                <span class="keyword">return</span> (s1 + s2).compareTo(s2 + s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理最后的结果</span></span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">""</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h4><p><img src="/2018/06/17/剑指offer/36.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countInverse(array, <span class="number">0</span>, array.length - <span class="number">1</span>) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countInverse</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftCount = countInverse(array, low, mid);</span><br><span class="line">        <span class="keyword">int</span> rightCount = countInverse(array, mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝一份数组的左右部分，用于排序并统计，注意copyOfRange[begin,end)，不包括end位置</span></span><br><span class="line">        <span class="keyword">int</span>[] leftCopy = Arrays.copyOfRange(array, low, mid + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] rightCopy = Arrays.copyOfRange(array, mid + <span class="number">1</span>, high + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序并统计逆序对</span></span><br><span class="line">        <span class="keyword">int</span> i = leftCopy.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = rightCopy.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = high;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftCopy[i] &lt;= rightCopy[j]) &#123;</span><br><span class="line">                array[index--] = rightCopy[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[index--] = leftCopy[i--];</span><br><span class="line">                count += (j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 避免数据溢出，进行取余</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1000000007</span>) count %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的部分拷贝回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            array[index--] = leftCopy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            array[index--] = rightCopy[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免数据溢出，进行取余</span></span><br><span class="line">        <span class="keyword">int</span> result = leftCount + rightCount + count;</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">1000000007</span>) result %= <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h4><p><img src="/2018/06/17/剑指offer/38.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (array != <span class="keyword">null</span> || array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 先找到第一个位置</span></span><br><span class="line">        <span class="keyword">int</span> start = getFirstK(array, k, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (start == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 查找不到在则直接返回</span></span><br><span class="line">        <span class="comment">// 再找最后出现的位置</span></span><br><span class="line">        <span class="keyword">int</span> end = getLastK(array, k, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        count = end - start + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midData = array[mid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (midData == k) &#123;</span><br><span class="line">        <span class="comment">// 如果已经是数组第一个 或者 mid前一个位置小于k，则说明已经找到第一个k的位置了</span></span><br><span class="line">        <span class="keyword">if</span> (mid == <span class="number">0</span> || (mid &gt; <span class="number">0</span> &amp;&amp; array[mid - <span class="number">1</span>] &lt; k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = high - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midData &lt; k) &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getFirstK(array, k, low, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midData = array[mid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (midData == k) &#123;</span><br><span class="line">        <span class="comment">// 如果已经是数组最后一个 或者 mid后一个位置大于k，则说明已经找到最后一个k的位置了</span></span><br><span class="line">        <span class="keyword">if</span> (mid == high || (mid &lt; high &amp;&amp; array[mid + <span class="number">1</span>] &gt; k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midData &lt; k) &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getLastK(array, k, low, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h4><p><img src="/2018/06/17/剑指offer/40.png" alt=""></p><p><img src="/2018/06/17/剑指offer/40-1.png" alt=""></p><p><img src="/2018/06/17/剑指offer/40-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] num1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] num2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        FindNumsAppearOnce(array, num1, num2);</span><br><span class="line">        System.out.println(num1[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(num2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历一遍求出异或的结果</span></span><br><span class="line">        <span class="keyword">int</span> xorResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">            xorResult ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = findFirstBit(xorResult); <span class="comment">//找到第一个bit为1的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用第一个bit为1的下标将数组分割为两部分，每部分index位置的bit相同</span></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSameBit(i, index))</span><br><span class="line">                n1 ^= i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n2 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = n1;</span><br><span class="line">        num2[<span class="number">0</span>] = n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右往左寻找第一个为1的二进制下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstBit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; Integer.SIZE) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; num) == i) <span class="keyword">break</span>;</span><br><span class="line">            i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断指定下标的位置的二进制是否为1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameBit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> leftShift)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; leftShift;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; i) == i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似题：leetcode：single-number、 single-number-ii</p><h4 id="在数组中寻找-和为s的两个数字"><a href="#在数组中寻找-和为s的两个数字" class="headerlink" title="在数组中寻找 和为s的两个数字"></a>在数组中寻找 和为s的两个数字</h4><p><img src="/2018/06/17/剑指offer/41.png" alt=""></p><p>思路：分别从最左和最右逼近，如果和小于s，则i++，如果和大于s，则j–</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有多对数字的和等于S，输出两个数的乘积最小的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] + array[j] == sum) &#123;</span><br><span class="line">                result.add(array[i]);</span><br><span class="line">                result.add(array[j]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] + array[j] &lt; sum) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="寻找和为s的连续序列"><a href="#寻找和为s的连续序列" class="headerlink" title="寻找和为s的连续序列"></a>寻找和为s的连续序列</h4><p><img src="/2018/06/17/剑指offer/41-1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    if (sum &lt;= 0) return result;</span><br><span class="line"></span><br><span class="line">    // 初始化将sum分为一大一小的2个数字</span><br><span class="line">    int small = sum / 2;</span><br><span class="line">    int big = sum / 2 + 1;</span><br><span class="line">    int curSum = small + big;</span><br><span class="line"></span><br><span class="line">    while (small &gt;= 1) &#123;</span><br><span class="line">        if (curSum == sum) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            for (int i = small; i &lt;= big; i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">            // 通过添加更小的small，获得产生新的序列</span><br><span class="line">            small--;</span><br><span class="line">            curSum += small;</span><br><span class="line">        &#125; else if (curSum &gt; sum) &#123;</span><br><span class="line">            // 偏大，则剪去big，加上更小的small</span><br><span class="line">            small--;</span><br><span class="line">            curSum = curSum - big + small;</span><br><span class="line">            big--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 偏小则再加一个更小的small</span><br><span class="line">            small--;</span><br><span class="line">            curSum += small;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br><span class="line">    result.sort(Comparator.comparingInt(c -&gt; c.get(0)));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (numbers[i] != i) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = numbers[i];</span><br><span class="line">                <span class="comment">// 如果m和第m个数字相等，则说明m该去的位置被人占了，就找到了第一个重复的数字</span></span><br><span class="line">                <span class="keyword">if</span> (m == numbers[m]) &#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = m;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则交换m到对应的第m个位置</span></span><br><span class="line">                numbers[i] = numbers[m];</span><br><span class="line">                numbers[m] = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h4><p><img src="/2018/06/17/剑指offer/66.png" alt=""></p><p><img src="/2018/06/17/剑指offer/66-1.png" alt=""></p><p>先算左边部分A0–Ai，再乘以右边部分Ai-1—An-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> offer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建乘积数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/24 17:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiply</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自底向上地累乘A[i-1]</span></span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            B[i] = B[i - <span class="number">1</span>] * A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自上向下地在原来基础上，再累成A[i]</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;<span class="comment">//这就是右半部分的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B[i] = B[i] * temp;</span><br><span class="line">            temp = temp * A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序数组的交集"><a href="#有序数组的交集" class="headerlink" title="有序数组的交集"></a>有序数组的交集</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有序数组的交集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/08/19 10:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jiaoji</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        jiaoji(a, b, result);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jiaoji</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> || a.length == <span class="number">0</span> || b.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] min = a;</span><br><span class="line">        <span class="keyword">int</span>[] max = b;</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; b.length) &#123;</span><br><span class="line">            min = b;</span><br><span class="line">            max = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(max, min[min.length / <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(max[index]);</span><br><span class="line">            <span class="comment">// min中去除min[min.length / 2]，max中去除max[index]因为以及找到了</span></span><br><span class="line">            jiaoji(Arrays.copyOfRange(min, <span class="number">0</span>, min.length / <span class="number">2</span>), Arrays.copyOfRange(max, <span class="number">0</span>, index), result);</span><br><span class="line">            jiaoji(Arrays.copyOfRange(min, min.length / <span class="number">2</span> + <span class="number">1</span>, min.length), Arrays.copyOfRange(max, index + <span class="number">1</span>, max</span><br><span class="line">                    .length), result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = -index - <span class="number">1</span>;</span><br><span class="line">            jiaoji(Arrays.copyOfRange(min, <span class="number">0</span>, min.length / <span class="number">2</span>), Arrays.copyOfRange(max, <span class="number">0</span>, index), result);</span><br><span class="line">            jiaoji(Arrays.copyOfRange(min, min.length / <span class="number">2</span> + <span class="number">1</span>, min.length), Arrays.copyOfRange(max, index, max.length),</span><br><span class="line">                    result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="4-字符串替换空格（未实现）"><a href="#4-字符串替换空格（未实现）" class="headerlink" title="4.字符串替换空格（未实现）"></a>4.字符串替换空格（未实现）</h4><p><img src="/2018/06/17/剑指offer/4.png" alt=""></p><p><img src="/2018/06/17/剑指offer/4-2.png" alt=""></p><ol><li>先遍历一次字符串，这样就能统计出字符串中空格的总数</li><li>准备两个指针p1，p2,。p1指向原始字符串的末尾，p2指向替换后的字符串的末尾</li><li>p1、p2同时移动，先前复制，直到p1遇到空格</li><li>p2向前插入‘%20’</li><li>p1、p2继续同时先前移动，直到p1与p2相遇</li></ol><p><img src="/2018/06/17/剑指offer/4-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="35-第一个只出现一次的字符"><a href="#35-第一个只出现一次的字符" class="headerlink" title="35.第一个只出现一次的字符"></a>35.第一个只出现一次的字符</h4><p><img src="/2018/06/17/剑指offer/35.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非法输入检测</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || <span class="string">""</span>.equals(str)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一遍遍历进行统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = counter.get(c) != <span class="keyword">null</span> ? counter.get(c) + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            counter.put(c, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二遍遍历进行搜索</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter.get(c) == <span class="number">1</span>) <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h4><p><img src="/2018/06/17/剑指offer/42.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ReverseSentence(<span class="string">"student. a am I"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">// 先将整个字符串翻转</span></span><br><span class="line">        reverseChars(chars, <span class="number">0</span>, chars.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过空格来定位每个单词的位置，然后进行单词的翻转</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">//指向单词第一个字符</span></span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;<span class="comment">//指向单词后的第一个空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">if</span> (end == chars.length)</span><br><span class="line">                    reverseChars(chars, start, end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// start与end之间是一个单词的情况</span></span><br><span class="line">                <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">                    reverseChars(chars, start, end);</span><br><span class="line">                &#125;</span><br><span class="line">                end++;</span><br><span class="line">                start = end;<span class="comment">// start移动到end位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// start：翻转的开始位置，不包括end位置的字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseChars</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str[i];</span><br><span class="line">            str[i] = str[j];</span><br><span class="line">            str[j] = c;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="左旋转字符串-循环左移字符串"><a href="#左旋转字符串-循环左移字符串" class="headerlink" title="左旋转字符串(循环左移字符串)"></a>左旋转字符串(循环左移字符串)</h4><p>题目描述（推荐）：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p><p><img src="/2018/06/17/剑指offer/42-2.png" alt=""></p><p><img src="/2018/06/17/剑指offer/42-3.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(LeftRotateString(<span class="string">"abcXYZdef"</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">// 通过3次翻转即可实现</span></span><br><span class="line">        reverseChars(chars,<span class="number">0</span>,n);</span><br><span class="line">        reverseChars(chars,n,chars.length);</span><br><span class="line">        reverseChars(chars,<span class="number">0</span>,chars.length);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 字符翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseChars</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str[i];</span><br><span class="line">            str[i] = str[j];</span><br><span class="line">            str[j] = c;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将字符串转换为整数"><a href="#将字符串转换为整数" class="headerlink" title="将字符串转换为整数"></a>将字符串转换为整数</h4><p>题目描述：</p><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例有:+123,-123,234k234</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMinus = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果不是数字，则判断是否是在第一位的正负号</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] &lt; <span class="string">'0'</span> || chars[i] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i != <span class="number">0</span>) || (chars[i] != <span class="string">'+'</span> &amp;&amp; chars[i] != <span class="string">'-'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i] == <span class="string">'-'</span>) isMinus = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + chars[i] - <span class="string">'0'</span>;<span class="comment">// 注意字符要与‘0’进行相减，才是真正对应的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMinus ? -<span class="number">1</span> * result : result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="字符串判断是否为有效数值"><a href="#字符串判断是否为有效数值" class="headerlink" title="字符串判断是否为有效数值"></a>字符串判断是否为有效数值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> offer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否为有效的数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/24 17:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsNumeric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IsNumeric app=<span class="keyword">new</span> IsNumeric();</span><br><span class="line">        System.out.println(app.isNumeric(<span class="string">"-1.e0"</span>.toCharArray()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> dot = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> e = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) sign = <span class="keyword">true</span>;<span class="comment">// 首位</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str[i - <span class="number">1</span>] == <span class="string">'e'</span> || str[i - <span class="number">1</span>] == <span class="string">'E'</span>) &#123;&#125;  <span class="comment">// 紧跟在e后面</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">true</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 已经有e了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == str.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// e后面没有数字了</span></span><br><span class="line">                <span class="keyword">else</span> e = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="comment">// 在e后面，不能有小数点、或者已经有小数点了</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">true</span> || dot == <span class="keyword">true</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> dot = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 其他非法字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h4><p><img src="/2018/06/17/剑指offer/28.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        permutation(<span class="number">0</span>, chars);</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">        HashSet&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(result);</span><br><span class="line">        result.clear();</span><br><span class="line">        result.addAll(set);</span><br><span class="line">        Collections.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> prefix, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix == str.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> String(str));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [a,b,c]，prefix表示固定的位置，比如a，然后将a与后面的字符依次进行交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prefix; i &lt; str.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将固定位置的值与数组中的第i个字符交换</span></span><br><span class="line">            <span class="keyword">char</span> temp = str[i];</span><br><span class="line">            str[i] = str[prefix];</span><br><span class="line">            str[prefix] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归处理[b,c]</span></span><br><span class="line">            permutation(prefix + <span class="number">1</span>, str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//还原交换</span></span><br><span class="line">            temp = str[i];</span><br><span class="line">            str[i] = str[prefix];</span><br><span class="line">            str[prefix] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="java实现链表"><a href="#java实现链表" class="headerlink" title="java实现链表"></a>java实现链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/04/20 15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="string">"bb"</span>);</span><br><span class="line">        list.insert(<span class="number">3</span>, <span class="string">"1"</span>);</span><br><span class="line">        list.printList();</span><br><span class="line">        <span class="comment">// System.out.println(list.find("2"));</span></span><br><span class="line">        System.out.println(list.search(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        list.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> E data;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            data = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = head;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        tail.next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> position, E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            Node current = head;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; position) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            Node temp = current.next;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">            newNode.next = temp;</span><br><span class="line">            current.next = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"超出范围"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        Node pre = head;</span><br><span class="line">        Node current = head.next;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data.equals(data)) &#123;</span><br><span class="line">                pre.next = current.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> position, E data)</span> </span>&#123;</span><br><span class="line">        Node current = head.next;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data.equals(data)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        E result = <span class="keyword">null</span>;</span><br><span class="line">        Node current = head.next;</span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.data.equals(data)) &#123;</span><br><span class="line">                <span class="keyword">return</span> position;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">                position++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">search</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; position) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (E) current.data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"超出范围"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node current = head.next;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(current.data);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><p><img src="/2018/06/17/剑指offer/5.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="O-1-时间删除链表结点-未实现"><a href="#O-1-时间删除链表结点-未实现" class="headerlink" title="O(1)时间删除链表结点(未实现)"></a>O(1)时间删除链表结点(未实现)</h4><p><img src="/2018/06/17/剑指offer/13.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h4><p><img src="/2018/06/17/剑指offer/15.png" alt=""></p><p><img src="/2018/06/17/剑指offer/15-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ListNode newHead = findKNode(head, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(newHead.val);</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findKNode</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>|| k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode ahead = head;</span><br><span class="line">        ListNode behind = ahead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两者相差k-1个位置，因此ahead先走k-1个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ahead.next != <span class="keyword">null</span>)</span><br><span class="line">                ahead = ahead.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后两者一起移动</span></span><br><span class="line">        <span class="keyword">while</span> (ahead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ahead = ahead.next;</span><br><span class="line">            behind = behind.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> behind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p><img src="/2018/06/17/剑指offer/16.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ListNode newHead = ReverseList(head);</span><br><span class="line">            <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(newHead.val);</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)  <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode remainHead = <span class="keyword">null</span>;      <span class="comment">// h:剩余未反转的链表头</span></span><br><span class="line">        ListNode handlingNode = head;    <span class="comment">// i:正在处理的结点，从head开始，它的next指向原方向，因此正要反转</span></span><br><span class="line">        ListNode reversedHead = <span class="keyword">null</span>;    <span class="comment">// j:已经反转的链表头</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (handlingNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 原来  reversedHead  handlingNode --&gt; remainHead --&gt;k</span></span><br><span class="line">            <span class="comment">// 反转  reversedHead &lt;-- handlingNode   remainHead --&gt;k</span></span><br><span class="line">            remainHead = handlingNode.next;</span><br><span class="line">            handlingNode.next = reversedHead;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新结点为下一次要处理的位置</span></span><br><span class="line">            reversedHead = handlingNode;</span><br><span class="line">            handlingNode = remainHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reversedHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h4><p><img src="/2018/06/17/剑指offer/17.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode list1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode list2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ListNode node1 = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            ListNode node2 = <span class="keyword">new</span> ListNode(++i);</span><br><span class="line">            cur1.next = node1;</span><br><span class="line">            cur2.next = node2;</span><br><span class="line">            cur1 = node1;</span><br><span class="line">            cur2 = node2;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = Merge(list1, list2);</span><br><span class="line">        <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(newHead.val + <span class="string">" "</span>);</span><br><span class="line">            newHead = newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有一个链表为空，直接返回另一个链表</span></span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="keyword">null</span>)  <span class="keyword">return</span> list1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新链表的头结点初始化为较小的链表的头结点</span></span><br><span class="line">        ListNode head = list1.val &lt; list2.val ? list1 : list2;</span><br><span class="line">        ListNode temp;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                temp = list1.next;</span><br><span class="line">                list1.next = list2;</span><br><span class="line">                list1 = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = list2.next;</span><br><span class="line">                list2.next = list1;</span><br><span class="line">                list2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h4><p><img src="/2018/06/17/剑指offer/26.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        copyChain(pHead);</span><br><span class="line">        copySibling(pHead);</span><br><span class="line">        <span class="keyword">return</span> splitChain(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**第一步：复制链表，暂时不考虑random 字段</span></span><br><span class="line"><span class="comment">     *  A-&gt;B-&gt;C 变为 A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyChain</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode n = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            n.next = cur.next;</span><br><span class="line">            cur.next = n;</span><br><span class="line">            cur = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**第二步：考虑复制sibling字段*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copySibling</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode clone = cur.next;</span><br><span class="line">            RandomListNode sibling = cur.random;</span><br><span class="line">            <span class="keyword">if</span> (sibling != <span class="keyword">null</span>) &#123;</span><br><span class="line">                clone.random = sibling.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**第三步：拆分链表，抽取出copy链表*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">splitChain</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        RandomListNode copy = pHead.next;</span><br><span class="line">        RandomListNode cur1 = pHead;</span><br><span class="line">        RandomListNode cur2 = pHead.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur1.next = cur2.next;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            <span class="keyword">if</span>(cur1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur2.next=cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur2=cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找链表的中间节点（未实现）"><a href="#查找链表的中间节点（未实现）" class="headerlink" title="查找链表的中间节点（未实现）"></a>查找链表的中间节点（未实现）</h4><p>思路：采用快慢指针的方式查找单链表的中间节点，快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针刚好到达中间节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h4><p><img src="/2018/06/17/剑指offer/37.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ListNode a1=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode a2=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode a3=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode a4=<span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode a5=<span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode a6=<span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        ListNode a7=<span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">        a1.next=a2;</span><br><span class="line">        a2.next=a3;</span><br><span class="line">        a3.next=a6;</span><br><span class="line">        a4.next=a5;</span><br><span class="line">        a5.next=a6;</span><br><span class="line">        a6.next=a7;</span><br><span class="line">        System.out.println(FindFirstCommonNode(a1,a4));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历一遍找出两个链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> len1 = getLength(pHead1);</span><br><span class="line">        <span class="keyword">int</span> len2 = getLength(pHead2);</span><br><span class="line"></span><br><span class="line">        ListNode longList = pHead1;</span><br><span class="line">        ListNode shortList = pHead2;</span><br><span class="line">        <span class="keyword">int</span> diff = len1 - len2;</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">            longList = pHead2;</span><br><span class="line">            shortList = pHead1;</span><br><span class="line">            diff = len2 - len1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后让长的链表先走多的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; i++) &#123;</span><br><span class="line">            longList = longList.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一起走，第一个相同结点就是公共结点</span></span><br><span class="line">        <span class="keyword">while</span> (longList != <span class="keyword">null</span> &amp;&amp; shortList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (longList == shortList)&#123;</span><br><span class="line">                <span class="keyword">return</span> longList;</span><br><span class="line">            &#125;</span><br><span class="line">            longList = longList.next;</span><br><span class="line">            shortList = shortList.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode current = list;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h4><p>如果一个链表中包含环，如何找出环的入口节点？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表中环的入口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/03 18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryNodeOfLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EntryNodeOfLoop app = <span class="keyword">new</span> EntryNodeOfLoop();</span><br><span class="line">        ListNode a1=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode a2=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode a3=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode a4=<span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode a5=<span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode a6=<span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        a1.next=a2;</span><br><span class="line">        a2.next=a3;</span><br><span class="line">        a3.next=a4;</span><br><span class="line">        a4.next=a5;</span><br><span class="line">        a5.next=a6;</span><br><span class="line">        a6.next=a3;</span><br><span class="line">        System.out.println(app.EntryNodeOfLoop(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.判断是否有环,如果有则返回环内的一个节点</span></span><br><span class="line">        ListNode loopNode = meetingNode(pHead);</span><br><span class="line">        <span class="keyword">if</span> (loopNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计数环的长度</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        ListNode search = loopNode.next;</span><br><span class="line">        <span class="keyword">while</span> (loopNode != search) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            search = search.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.找到入口</span></span><br><span class="line">        ListNode behind = pHead;<span class="comment">// 慢指针</span></span><br><span class="line">        ListNode prev = pHead;<span class="comment">//快指针</span></span><br><span class="line">        <span class="comment">// 让快指针先走count个节点，这样才能保证他们相遇的节点是入口节点</span></span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(prev!=behind)&#123;</span><br><span class="line">            prev=prev.next;</span><br><span class="line">            behind=behind.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用快慢指针，当其相遇时有环，快指针==null时无环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">meetingNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode slow = head;<span class="comment">// 慢指针</span></span><br><span class="line">        ListNode fast = slow.next;<span class="comment">//快指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果快慢指针相遇、快指针的下一个是慢指针，则有环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast || fast.next == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新快慢指针位置</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast != <span class="keyword">null</span>) fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中重复的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/06 10:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDuplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeleteDuplication app = <span class="keyword">new</span> DeleteDuplication();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        ListNode a1 = app.create(nums);</span><br><span class="line">        a1 = app.deleteDuplication(a1);</span><br><span class="line">        <span class="keyword">while</span> (a1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(a1.val + <span class="string">"--&gt;"</span>);</span><br><span class="line">            a1 = a1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// null或者只有一个结点时 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">// 新链表的头结点</span></span><br><span class="line">        newHead.next = pHead;</span><br><span class="line">        ListNode pre = newHead;<span class="comment">// 记录前一个不重复的结点</span></span><br><span class="line">        ListNode cur = pre.next;<span class="comment">// 当前结点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前结点与下一结点相等</span></span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == cur.val);</span><br><span class="line">                cur = cur.next; <span class="comment">// 更新到这个暂时不重复的点</span></span><br><span class="line">                pre.next = cur; <span class="comment">// pre的next连接到这个暂时不重复的点</span></span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 当前结点与下一结点不相等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur;<span class="comment">// 则pre更新到这个可以确认是不重复的点上</span></span><br><span class="line">                cur = cur.next; <span class="comment">// 移动cur</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 保留一个重复结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication2</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode q = p;</span><br><span class="line">            <span class="keyword">while</span> (q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.val == q.next.val) &#123;</span><br><span class="line">                    q.next = q.next.next;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">create</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        ListNode cur = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(nums[i]);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p><img src="/2018/06/17/剑指offer/6.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先取【先序】的第一个元素，作为根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//然后遍历【中序】，找到对应的根结点，进行划分数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="comment">//注意i对应的是中序的下标，因此是截取pre[1，i+1]</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i + <span class="number">1</span>,</span><br><span class="line">                        in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p><img src="/2018/06/17/剑指offer/23.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      queue.offer(root);</span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          TreeNode node=queue.poll();</span><br><span class="line">          result.add(node.val);</span><br><span class="line">          <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.offer(node.left);   </span><br><span class="line">          <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.offer(node.right);   </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><p><img src="/2018/06/17/剑指offer/18.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isTree = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前两个根结点相等，则进行检查</span></span><br><span class="line">            <span class="keyword">if</span> (root1.val == root2.val) isTree = isSubTree(root1, root2);</span><br><span class="line">            <span class="comment">// 否则递归对root1的左子树判断</span></span><br><span class="line">            <span class="keyword">if</span> (!isTree) isTree = HasSubtree(root1.left, root2);</span><br><span class="line">            <span class="comment">// 左子树也没有，则递归对root1的右子树判断</span></span><br><span class="line">            <span class="keyword">if</span> (!isTree) isTree = HasSubtree(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isTree;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//root2匹配完了，因此true</span></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//root2不为null而root1==null，则不相同</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当前结点相等，则判断左子树，然后判断右子树</span></span><br><span class="line">        <span class="keyword">return</span>  isSubTree(root1.left, root2.left) &amp;&amp;  isSubTree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h4><p><img src="/2018/06/17/剑指offer/19.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先序遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换子节点</span></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        <span class="comment">// 递归处理子节点</span></span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h4><p><img src="/2018/06/17/剑指offer/24.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] c = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">14</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] d = &#123;&#125;;</span><br><span class="line">        System.out.println(VerifySquenceOfBST(d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为空则false</span></span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个点，则为true，直接返回不用递归了</span></span><br><span class="line">        <span class="keyword">if</span> (sequence.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = sequence.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> root = sequence[high];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以root判断大小，寻找划分点，i最终会落在第一个大于root的位置</span></span><br><span class="line">        <span class="keyword">while</span> (sequence[i] &lt; root) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断右子树是否都大于root，否则就不可能是后序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root &gt; sequence[j]) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//  copyOfRange : [begin,end),不包含end</span></span><br><span class="line">        <span class="keyword">int</span>[] leftTree = Arrays.copyOfRange(sequence, <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">int</span>[] rightTree = Arrays.copyOfRange(sequence, i, high);</span><br><span class="line">        <span class="keyword">boolean</span> leftResult = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> rightResult = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftTree.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            leftResult = VerifySquenceOfBST(leftTree);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightTree.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            rightResult = VerifySquenceOfBST(rightTree);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftResult &amp;&amp; rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/06/17/剑指offer/24-1.png" alt=""></p><h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><p><img src="/2018/06/17/剑指offer/25.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allRoad = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Stack&lt;Integer&gt; road = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            path(root, target, road, <span class="number">0</span>, allRoad);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allRoad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode root, <span class="keyword">int</span> target, Stack&lt;Integer&gt; road, <span class="keyword">int</span> currentSum, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allRoad)</span> </span>&#123;</span><br><span class="line">        currentSum = root.val + currentSum;</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        <span class="comment">// 超过目标值，不必向下继续</span></span><br><span class="line">        <span class="keyword">if</span> (currentSum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶结点,但值不等于目标值,返回</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span> &amp;&amp; currentSum != target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        road.push(root.val);</span><br><span class="line">        <span class="comment">// 叶结点，值等于目标值，添加路径</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span> &amp;&amp; currentSum == target) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : road) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            allRoad.add(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            path(left, target, road, currentSum, allRoad);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            path(right, target, road, currentSum, allRoad);</span><br><span class="line">        &#125;</span><br><span class="line">        road.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树与双向链表转换"><a href="#二叉搜索树与双向链表转换" class="headerlink" title="二叉搜索树与双向链表转换"></a>二叉搜索树与双向链表转换</h4><p><img src="/2018/06/17/剑指offer/27.png" alt="二叉搜索树与双向链表转换"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode n1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode n2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode n3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode n4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        TreeNode n5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        TreeNode n6 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        TreeNode n7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//构建树</span></span><br><span class="line">        n4.left = n2;</span><br><span class="line">        n4.right = n6;</span><br><span class="line">        n2.left = n1;</span><br><span class="line">        n2.right = n3;</span><br><span class="line">        n6.left = n5;</span><br><span class="line">        n6.right = n7;</span><br><span class="line">        Convert(n4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        TreeNode lastVisitNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 注意，不可以将lastVisitNode直接传入，因为就像传入null，不会赋值给lastVisitNode</span></span><br><span class="line">        lastVisitNode = convertNode(pRootOfTree, lastVisitNode);</span><br><span class="line">        <span class="comment">// 完成转换，从lastVisitNode往前遍历，到头结点</span></span><br><span class="line">        TreeNode first = lastVisitNode;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first.left==<span class="keyword">null</span>)  <span class="keyword">break</span>;</span><br><span class="line">            first = first.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * currentNode：当前节点</span></span><br><span class="line"><span class="comment">     * lastVisitNode：最后访问的节点，同时也是双向链表的最右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">convertNode</span><span class="params">(TreeNode currentNode, TreeNode lastVisitNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先处理左子树，同时获得左子树最右边的点（最大点）</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastVisitNode = convertNode(currentNode.left, lastVisitNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//互相连接，当前节点的left连接lastVisitNode,同时lastVisitNode的right连接当前节点</span></span><br><span class="line">        currentNode.left = lastVisitNode;</span><br><span class="line">        <span class="keyword">if</span> (lastVisitNode != <span class="keyword">null</span>) lastVisitNode.right = currentNode;</span><br><span class="line">        lastVisitNode = currentNode; <span class="comment">//最后访问的节点更新为当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理右子树</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastVisitNode = convertNode(currentNode.right, lastVisitNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastVisitNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;   <span class="comment">// 连接小的结点</span></span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;  <span class="comment">// 连接大的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的深度-以及是否是平衡二叉树"><a href="#二叉树的深度-以及是否是平衡二叉树" class="headerlink" title="二叉树的深度,以及是否是平衡二叉树"></a>二叉树的深度,以及是否是平衡二叉树</h4><p><img src="/2018/06/17/剑指offer/39.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftDepth = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/06/17/剑指offer/39-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode a1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode a2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode a3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode a4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        TreeNode a5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        TreeNode a6 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        TreeNode a7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        TreeNode a8 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        a1.left=a2;</span><br><span class="line">        a1.right=a3;</span><br><span class="line">        a2.left=a4;</span><br><span class="line">        a2.right=a5;</span><br><span class="line">        a5.right=a7;</span><br><span class="line">        a3.left=a8;</span><br><span class="line">        a3.right=a6;</span><br><span class="line">        System.out.println(IsBalanced_Solution(a1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值 -1：非平衡树，0：null结点，正数：树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = isBalanced(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = isBalanced(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左右子树都是平衡树，则进行深度比较；如果深度差满足要求，则返回最大深度</span></span><br><span class="line">        <span class="keyword">if</span> (leftDepth != -<span class="number">1</span> &amp;&amp; rightDepth != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历二叉树-求某一节点的下一中序节点"><a href="#中序遍历二叉树-求某一节点的下一中序节点" class="headerlink" title="中序遍历二叉树,求某一节点的下一中序节点"></a>中序遍历二叉树,求某一节点的下一中序节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.有右结点，则找该右结点的最左结点</span></span><br><span class="line">    <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pNode = pNode.right;</span><br><span class="line">        <span class="keyword">while</span> (pNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.没有右节点，则向上找父节点</span></span><br><span class="line"><span class="comment">             a          a</span></span><br><span class="line"><span class="comment">       b                    b</span></span><br><span class="line"><span class="comment">           c                    c</span></span><br><span class="line"><span class="comment">        d                     d</span></span><br><span class="line"><span class="comment">    c是当前节点。确定c是在某个节点(a)的左子树中，还是(a)的右子树中；</span></span><br><span class="line"><span class="comment">    如果在左子树中，则找到的第一个包含c的节点就是下一个中序输出的节点；</span></span><br><span class="line"><span class="comment">    否则，就没有下一个节点了</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    TreeLinkNode parent = pNode.next;</span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.left == pNode) <span class="keyword">return</span> parent;</span><br><span class="line">        pNode = parent;</span><br><span class="line">        parent = parent.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h4><p>给定一颗二叉搜索树，请找出其中的第k小的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 序列化</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        String node = Integer.toString(root.val);</span><br><span class="line">        node += <span class="string">","</span>;<span class="comment">//父节点后添加逗号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>)</span><br><span class="line">            node += <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node += Serialize(root.left);</span><br><span class="line">        node += <span class="string">","</span>;<span class="comment">//左节点后添加逗号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span>)</span><br><span class="line">            node += <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node += Serialize(root.right);</span><br><span class="line">        <span class="comment">//右节点后 不添加逗号</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] nodes = str.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Deserialize2(nodes);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正在处理的结点下标</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize2</span><span class="params">(String[] nodes)</span> </span>&#123;</span><br><span class="line">        String node = nodes[index++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"#"</span>.equals(node)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(node));</span><br><span class="line">        root.left = Deserialize2(nodes);</span><br><span class="line">        root.right = Deserialize2(nodes);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h3><h4 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h4><p><img src="/2018/06/17/剑指offer/7.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; inStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();<span class="comment">// 入队保存的栈</span></span><br><span class="line">    Stack&lt;Integer&gt; outStack = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">// 出队保存的栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        inStack.push(node);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用两个队列实现栈（未实现）"><a href="#用两个队列实现栈（未实现）" class="headerlink" title="用两个队列实现栈（未实现）"></a>用两个队列实现栈（未实现）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><p><img src="/2018/06/17/剑指offer/21.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span> (minStack.empty()) &#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node &lt; minStack.peek()) &#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minStack.push(minStack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty()) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><p><img src="/2018/06/17/剑指offer/22.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] b=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(IsPopOrder(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, lena = pushA.length, lenb = popA.length;</span><br><span class="line">        <span class="keyword">boolean</span> isPopOrder = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; lena) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// 栈顶与popA[j]相同，则出栈，否则继续进栈</span></span><br><span class="line">            <span class="keyword">while</span> (stack.peek() == popA[j] &amp;&amp; j &lt; lenb) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 栈不为空，或者popA没有遍历完，则不是</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() || j != lenb) &#123;</span><br><span class="line">            isPopOrder = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isPopOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="员工年龄排序"><a href="#员工年龄排序" class="headerlink" title="员工年龄排序"></a>员工年龄排序</h4><p><img src="/2018/06/17/剑指offer/8-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">23</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">23</span>&#125;;</span><br><span class="line">        sortAge(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortAge(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> oldest = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 创建0-100的数组来统计每个年龄有多少人</span></span><br><span class="line">        <span class="keyword">int</span>[] ages = <span class="keyword">new</span> <span class="keyword">int</span>[oldest + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组进行统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> age = arr[i];</span><br><span class="line">            ages[age]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历统计的数组，将年龄存回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> age = <span class="number">0</span>; age &lt;= oldest; age++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ages[age]; i++) &#123;</span><br><span class="line">                arr[index] = age;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><p><img src="/2018/06/17/剑指offer/矩阵中的路径.png" alt="矩阵中的路径"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断矩阵中是否有路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/09 20:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasPath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HasPath app = <span class="keyword">new</span> HasPath();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] matrix = <span class="string">"ABCESFCSADEE"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str = <span class="string">"ABCB"</span>.toCharArray();</span><br><span class="line">        System.out.println(app.hasPath(matrix, <span class="number">3</span>, <span class="number">4</span>, str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历矩阵中每个位置，穷举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findStr(matrix, rows, cols, i, j, str, visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findStr</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span>[] str, <span class="keyword">boolean</span>[][]  visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strIndex == str.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 矩阵中matrix[row][col] 的字符 与 str[strIndex]的相同，则继续探索该位置的四周与str[strIndex++]是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; !visited[row][col] &amp;&amp; matrix[row * cols + col] == str[strIndex]) &#123;</span><br><span class="line">            strIndex++;</span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            find = findStr(matrix, rows, cols, row - <span class="number">1</span>, col, str, visited) ||</span><br><span class="line">                    findStr(matrix, rows, cols, row + <span class="number">1</span>, col, str, visited) ||</span><br><span class="line">                    findStr(matrix, rows, cols, row, col - <span class="number">1</span>, str, visited) ||</span><br><span class="line">                    findStr(matrix, rows, cols, row, col + <span class="number">1</span>, str, visited);</span><br><span class="line">            <span class="comment">// 如果该点的四周都没有找到符合下一字符的，则退回，重置该位置的状态，以及字符匹配的位置</span></span><br><span class="line">            <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">                visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line">                strIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h4><p><img src="/2018/06/17/剑指offer/机器人的运动范围.png" alt="机器人的运动范围"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 机器人的运动范围</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jizx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/09 21:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotMovingCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RobotMovingCount app = <span class="keyword">new</span> RobotMovingCount();</span><br><span class="line">        System.out.println(app.movingCount(<span class="number">18</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rows &lt; <span class="number">0</span> || cols &lt; <span class="number">0</span> || threshold &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> movingCount(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (canIn(rows, cols, row, col, threshold, visited)) &#123;</span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 能够到达的位置：当前位置+其他四个方向能够到达的总和</span></span><br><span class="line">            count = <span class="number">1</span> + movingCount(threshold, rows, cols, row - <span class="number">1</span>, col, visited) +</span><br><span class="line">                    movingCount(threshold, rows, cols, row + <span class="number">1</span>, col, visited) +</span><br><span class="line">                    movingCount(threshold, rows, cols, row, col - <span class="number">1</span>, visited) +</span><br><span class="line">                    movingCount(threshold, rows, cols, row, col + <span class="number">1</span>, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否能进入该位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIn</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> threshold, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[row][col] &amp;&amp; row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (row != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += row % <span class="number">10</span>;</span><br><span class="line">                row /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (col != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += col % <span class="number">10</span>;</span><br><span class="line">                col /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum &lt;= threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="斐波那契数数列"><a href="#斐波那契数数列" class="headerlink" title="斐波那契数数列"></a>斐波那契数数列</h4><p><img src="/2018/06/17/剑指offer/9.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] initial = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">//初始化第0项、第1项</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> initial[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fn=f(n-1)+f(n-2)</span></span><br><span class="line">        <span class="keyword">int</span> fn_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fn_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fn = fn_1 + fn_2;</span><br><span class="line">            fn_2 = fn_1;</span><br><span class="line">            fn_1 = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h5><p><img src="/2018/06/17/剑指offer/9-1.png" alt=""></p><p>但是要注意<strong>与斐波那契数列的下标起始位置不太一样</strong> ，第0 项是1,即：1 1 2 3 5 。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] initial = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">2</span>) <span class="keyword">return</span> initial[target];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> jumpn_1 = <span class="number">1</span>; <span class="comment">//第1项是1</span></span><br><span class="line">    <span class="keyword">int</span> jumpn_2 = <span class="number">1</span>; <span class="comment">//第0项是1</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        num = jumpn_1 + jumpn_2;</span><br><span class="line">        jumpn_2 = jumpn_1;</span><br><span class="line">        jumpn_1 = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="/2018/06/17/剑指offer/9-2.png" alt=""></p><hr><h5 id="矩阵覆盖问题"><a href="#矩阵覆盖问题" class="headerlink" title="矩阵覆盖问题"></a>矩阵覆盖问题</h5><p><img src="/2018/06/17/剑指offer/9-3.png" alt=""></p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h4 id="10-二进制中1的个数"><a href="#10-二进制中1的个数" class="headerlink" title="10.二进制中1的个数"></a>10.二进制中1的个数</h4><p><img src="/2018/06/17/剑指offer/10.png" alt=""></p><p>用1扫描法：</p><p><img src="/2018/06/17/剑指offer/10-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> matcher = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (matcher != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// n与matcher按位 与运算，如果matcer的1 对应n的1，就不会为0</span></span><br><span class="line">        <span class="comment">// n:0000101</span></span><br><span class="line">        <span class="comment">// m:0000100</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; matcher) != <span class="number">0</span>) count++;</span><br><span class="line">        <span class="comment">//让matcer左移，进行扫描</span></span><br><span class="line">        matcher = matcher &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减1法</p><p><img src="/2018/06/17/剑指offer/10-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 把一个整数减去1，再和原整数做 与运算，就会把该整数最右边一个1变成0</span></span><br><span class="line">         n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><h4 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h4><p>由于精度原因，<strong>不能用等号判断两个double 小数是否相等</strong>。</p><p>当小数点后位数 大于15位时，jvm就会忽略这个精度，这种情况，我们在开发时如果需要更精确的比较double类型，就要用到 BigDecimal 这个类了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// jdk1.8</span><br><span class="line">double x1= 4.000000000000002;</span><br><span class="line">double x2= 4.000000000000005;</span><br><span class="line">x1&lt;x2  true</span><br><span class="line"></span><br><span class="line">BigDecimal x3=new BigDecimal(4.0000000000000002);</span><br><span class="line">BigDecimal x4=new BigDecimal(4.0000000000000005);</span><br><span class="line">x3&lt;x4 true</span><br><span class="line"></span><br><span class="line">000000000000002      // double(15位)</span><br><span class="line">0000000000000002     // BigDecimal（16位）</span><br></pre></td></tr></table></figure><h4 id="数值的整数次方pow-x-n"><a href="#数值的整数次方pow-x-n" class="headerlink" title="数值的整数次方pow(x,n)"></a>数值的整数次方pow(x,n)</h4><p>思路：分治</p><p>简洁版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 底数为0,不可以直接用等号判断，因为有精度的问题</span></span><br><span class="line">    <span class="keyword">if</span> (Double.compare(x, <span class="number">0.0</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指数&lt;0的情况，取绝对值，最后进行求倒数即可</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span> / powWithUnsign(x, -n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> powWithUnsign(x, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">powWithUnsign</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">double</span> result = powWithUnsign(x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ((n&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result * result * x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> result * result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> basse, <span class="keyword">int</span> exponent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 输入底数为0，指数小于0</span></span><br><span class="line">        <span class="keyword">if</span> (Double.compare(basse, <span class="number">0.0</span>) == <span class="number">0</span> &amp;&amp; exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"非法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> absExponent = exponent;<span class="comment">//指数取绝对值</span></span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            absExponent = exponent * -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> result = PowerWithUnsignedExponent(basse, absExponent);</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">1.0</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断人为输入为0的情况，并不是右移产生的</span></span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span> ((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="打印1到最大的n位数"><a href="#打印1到最大的n位数" class="headerlink" title="打印1到最大的n位数"></a>打印1到最大的n位数</h4><p><img src="/2018/06/17/剑指offer/12.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNMax</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">char</span>[] number = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length; i++) &#123;</span><br><span class="line">         number[i] = <span class="string">'0'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> a = number[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">while</span> (!increase(number, <span class="number">8</span>)) &#123;</span><br><span class="line">         printNum(number);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increase</span><span class="params">(<span class="keyword">char</span>[] number, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> takeOver = <span class="number">0</span>;<span class="comment">// 进位</span></span><br><span class="line">     <span class="keyword">boolean</span> isMax = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 从最后一位开始加一</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = number.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         sum = number[i] - <span class="string">'0'</span> + takeOver;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 个位进行加一</span></span><br><span class="line">         <span class="keyword">if</span> (i == number.length - <span class="number">1</span>) &#123;</span><br><span class="line">             sum += add;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 和大于10，则有进位，否则就可以结束循环</span></span><br><span class="line">         <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果是最高位，则结束</span></span><br><span class="line">             <span class="keyword">if</span> (i == <span class="number">0</span>) isMax = <span class="keyword">true</span>;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 sum -= <span class="number">10</span>;</span><br><span class="line">                 takeOver = <span class="number">1</span>;</span><br><span class="line">                 number[i] = (<span class="keyword">char</span>) (<span class="string">'0'</span> + sum);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             number[i] = (<span class="keyword">char</span>) (<span class="string">'0'</span> + sum);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> isMax;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">boolean</span> isStart = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">while</span> (i &lt; number.length) &#123;</span><br><span class="line">         <span class="keyword">if</span> (number[i] == <span class="string">'0'</span> &amp;&amp; !isStart) &#123;</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             isStart = <span class="keyword">true</span>;</span><br><span class="line">             System.out.print(number[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="34-丑数"><a href="#34-丑数" class="headerlink" title="34.丑数"></a>34.丑数</h4><p><img src="/2018/06/17/剑指offer/34.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存丑数的数组，并初始化第一个丑数</span></span><br><span class="line">        <span class="keyword">int</span>[] uglyNum = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        uglyNum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 指向对应乘积刚好大于当前找到的丑数的下标</span></span><br><span class="line">        <span class="keyword">int</span> base2 = <span class="number">0</span>;<span class="comment">// 乘以2后的值，刚好略大于当前丑数的下标</span></span><br><span class="line">        <span class="keyword">int</span> base3 = <span class="number">0</span>;<span class="comment">// 乘以3后的值，刚好略大于当前丑数的下标</span></span><br><span class="line">        <span class="keyword">int</span> base5 = <span class="number">0</span>;<span class="comment">// 乘以5后的值，刚好略大于当前丑数的下标</span></span><br><span class="line">        <span class="keyword">int</span> currentIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentIndex &lt; index) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextNum = Math.min(Math.min(uglyNum[base2] * <span class="number">2</span>, uglyNum[base3] * <span class="number">3</span>), uglyNum[base5] * <span class="number">5</span>);</span><br><span class="line">            uglyNum[currentIndex] = nextNum;</span><br><span class="line">            <span class="comment">// 更新下标，使得下标在刚好略大于当前丑数的下标</span></span><br><span class="line">            <span class="keyword">while</span> (uglyNum[base2] * <span class="number">2</span> &lt;= nextNum) base2++;</span><br><span class="line">            <span class="keyword">while</span> (uglyNum[base3] * <span class="number">3</span> &lt;= nextNum) base3++;</span><br><span class="line">            <span class="keyword">while</span> (uglyNum[base5] * <span class="number">5</span> &lt;= nextNum) base5++;</span><br><span class="line">            currentIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglyNum[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h4><p><img src="/2018/06/17/剑指offer/47.png" alt=""></p><p>思路：</p><p><img src="/2018/06/17/剑指offer/47-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125; <span class="keyword">while</span> (carry != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不使用新变量交换两个变量的值"><a href="#不使用新变量交换两个变量的值" class="headerlink" title="不使用新变量交换两个变量的值"></a>不使用新变量交换两个变量的值</h4><p><img src="/2018/06/17/剑指offer/47-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于加减法</span></span><br><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br><span class="line"><span class="comment">// 基于异或</span></span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h3 id="抽象建模"><a href="#抽象建模" class="headerlink" title="抽象建模"></a>抽象建模</h3><h4 id="44-扑克牌的顺子"><a href="#44-扑克牌的顺子" class="headerlink" title="44.扑克牌的顺子"></a>44.扑克牌的顺子</h4><p><img src="/2018/06/17/剑指offer/44.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length != <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计大王的个数</span></span><br><span class="line">        <span class="keyword">int</span> king = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) king++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计不连续间隔</span></span><br><span class="line">        <span class="keyword">int</span> gaps = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// i=king的个数+1，从而跳过王</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = king+<span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 出现对子，不可能是顺子</span></span><br><span class="line">            gaps += numbers[i] - numbers[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gaps &lt;= king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>运动后不能马上洗澡</title>
      <link href="/2018/03/23/%E8%BF%90%E5%8A%A8%E5%90%8E%E4%B8%8D%E8%83%BD%E9%A9%AC%E4%B8%8A%E6%B4%97%E6%BE%A1/"/>
      <url>/2018/03/23/%E8%BF%90%E5%8A%A8%E5%90%8E%E4%B8%8D%E8%83%BD%E9%A9%AC%E4%B8%8A%E6%B4%97%E6%BE%A1/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>运动后不要马上洗澡</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/03/23/运动后不能马上洗澡/运动后不要马上洗澡.png" alt=""></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 所见所闻 </category>
          
          <category> 健康 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>喜欢人的理由为什么说不出来</title>
      <link href="/2018/03/23/%E5%96%9C%E6%AC%A2%E4%BA%BA%E7%9A%84%E7%90%86%E7%94%B1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%B8%8D%E5%87%BA%E6%9D%A5/"/>
      <url>/2018/03/23/%E5%96%9C%E6%AC%A2%E4%BA%BA%E7%9A%84%E7%90%86%E7%94%B1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%B8%8D%E5%87%BA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>喜欢人的理由为什么说不出来</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/03/23/喜欢人的理由为什么说不出来/2018-03-23-喜欢人的理由为什么说不出来.jpg" alt=""></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 所见所闻 </category>
          
          <category> 爱情 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>全球公认的最健康的一天作息图解</title>
      <link href="/2018/03/23/%E5%85%A8%E7%90%83%E5%85%AC%E8%AE%A4%E7%9A%84%E6%9C%80%E5%81%A5%E5%BA%B7%E7%9A%84%E4%B8%80%E5%A4%A9%E4%BD%9C%E6%81%AF%E5%9B%BE%E8%A7%A3/"/>
      <url>/2018/03/23/%E5%85%A8%E7%90%83%E5%85%AC%E8%AE%A4%E7%9A%84%E6%9C%80%E5%81%A5%E5%BA%B7%E7%9A%84%E4%B8%80%E5%A4%A9%E4%BD%9C%E6%81%AF%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <p>全球公认的最健康的一天作息安排图解</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><p><img src="/2018/03/23/全球公认的最健康的一天作息图解/2018-03-23-全球公认的最健康的一天作息图解.jpg" alt=""></p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 健康 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何提高「钝感力」，从此不再「想太多」</title>
      <link href="/2018/03/23/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E3%80%8C%E9%92%9D%E6%84%9F%E5%8A%9B%E3%80%8D%EF%BC%8C%E4%BB%8E%E6%AD%A4%E4%B8%8D%E5%86%8D%E3%80%8C%E6%83%B3%E5%A4%AA%E5%A4%9A%E3%80%8D/"/>
      <url>/2018/03/23/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E3%80%8C%E9%92%9D%E6%84%9F%E5%8A%9B%E3%80%8D%EF%BC%8C%E4%BB%8E%E6%AD%A4%E4%B8%8D%E5%86%8D%E3%80%8C%E6%83%B3%E5%A4%AA%E5%A4%9A%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""> <blockquote><p>室友跟我说「你是不是该倒个垃圾」，结果我一晚上没睡好，一直在想，他是不是觉得我很懒？</p><p>和朋友一起坐公交，掏了好久才摸到公交卡，特别担心她嫌我傻，不想和我玩了。</p><p>期末考试漏做了一个题，害怕排名会掉下来，好几天了，心里一直很难受。</p></blockquote><blockquote><p>……</p></blockquote><p>虽然这样写出来，你看了可能会觉得不可思议，但实际上，这样的琐事每天都在发生。</p><p><strong>「因为一点小事胡思乱想」</strong>的情况人人都有份，你一定也不例外。</p><p>偶尔一次两次没什么，但如果<strong>每天都为这些琐事心烦意乱，就会觉得「心很累」。</strong></p><p>这么敏感的根源是什么呢？</p><p>@@@来至微信公众号：<a href="https://mp.weixin.qq.com/s?__biz=MzIyNDI0NTQ1Nw==&amp;mid=2247485463&amp;idx=1&amp;sn=e90212bf8f09c998f4dfba0c1c295ad8&amp;chksm=e810aba9df6722bf88714ef5d74725d661feeb1caef7102f7d422e95fd553c33780ea6f1e41f&amp;mpshare=1&amp;scene=1&amp;srcid=0321jNkEseClP7eBH3VnhFG7##" target="_blank" rel="noopener">重构自己</a></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="敏感的根源"><a href="#敏感的根源" class="headerlink" title="敏感的根源"></a><strong>敏感的根源</strong></h2><blockquote><p>同理心太强</p></blockquote><p>同理心（empathy）又称为换位思考、神入或共情，指<strong>站在对方立场设身处地思考的一种方式。</strong></p><p>同理心有两种，其中，认知同理心（cognitive empathy）是指你「辨别他人心智状态」的能力。</p><p>简单来说，就是<strong>你对周围人的情绪的「嗅觉」</strong>。</p><p>敏感的人常常会有很丰富的的情绪「嗅觉」，不仅自己容易陷入不必要的负面情绪，对周围人的感受也<strong>觉察的更敏锐</strong>。</p><p>对方皱了一下眉头，或者抿了抿嘴，你就会「感觉」到他在生气或者伤心。</p><blockquote><p>「自我价值感」来自外界</p></blockquote><p><strong>敏感的人常常过分担心「他人的看法」。</strong></p><p>失败了怕被嘲笑，成功了怕被嫉妒。永远都在担心「我给别人带来了什么影响、留下了什么印象」，整天惴惴不安。</p><p>这是因为，你把<strong>「自己的价值」和「别人的评价」</strong>混为了一谈，<strong>把衡量自己的标准交到了别人手里。</strong></p><p>当你一次考试失利，没获得认可，你就会觉得自己「全完了」；而一旦被别人批评、指责，那就更是「天都塌了」。</p><p>但是，一个很重要的事实是：<strong>你的价值并不取决于别人</strong>，基于外界的自我价值其实是一种<strong>「伪自尊」</strong>。</p><p>如果你的价值由他人决定，那岂不是被赞美的人就是最有价值、最幸福的人？</p><p>而实际上，<strong>赞美可以让人满足，但不能带来快乐，至少绝对不是长久的。</strong>过多的赞美甚至会引起空虚和焦虑。</p><p>很多自杀的名人都很成功，有无数人追捧。而大多数的抑郁症患者也并不缺少「爱」。</p><h2 id="敏感的影响"><a href="#敏感的影响" class="headerlink" title="敏感的影响"></a>敏感的影响</h2><p>欣赏一张图片时，如果你为了观察某个细节，把它不断放大，你会发现自己没法看清整张图了。</p><p>同样，当你过于在意一件「小事」，就会失掉对「全局」的观察和判断，甚至会<strong>把这个小事当成全部</strong>。</p><p>这时，你就对「全局」产生了<strong>「认知扭曲」</strong>。</p><p>常见的认知扭曲有这几种：</p><p><strong>1. 非此即彼</strong></p><p>这通常是由于「过度完美主义」导致的。</p><p><strong>你会害怕自己有一丁点的失败</strong>。比如你七门课都得了 A，第八门得了 B，就会觉得「连全 A 都没拿到，我真是个废物！」</p><p>其实，在「全 A」和「废物」之间，难道没有别的容身之处了吗？</p><p><strong>2. 以偏概全</strong></p><p>这种想法会让你认为：这件事如果发生了一次，就<strong>肯定会发生无数次</strong>。</p><p>当你某次表白失败了，你会开始想：这就是我的命，我这辈子「注孤生」了！实际上，这怎么可能呢？</p><p><strong>3. 心理过滤</strong></p><p>如果你一整天都为些小事心烦意乱，那很可能你的记忆会<strong>被这些不好的东西充斥</strong>。</p><p>你会发现自己只能想起那些负面的事：「做错了三个题」，「昨天被人插队了」，「快递被挤坏了」……而不记得任何好的事情。</p><p>这时，你就要提醒自己：你陷入「心理过滤」的扭曲认知里了。</p><p><strong>4. 妄下结论</strong></p><p>这也可以叫「读心术」。意思是，你总觉得<strong>你知道别人的想法</strong>。</p><p>当你的朋友和你擦肩而过，没打招呼，你会认为他一定是「生你的气、讨厌你了」。而事实上，他可能是没戴眼镜，压根没认出来是你。</p><p><strong>5. 归咎自己</strong></p><p>敏感的人擅长觉察别人的情绪，这倒没什么，但糟糕的是他们经常<strong>把那些情绪归成自己的「责任」</strong>。</p><p>比如你的室友看起来不太高兴，尽管可能他掩饰的很好，但你还是一眼就看出来了。然后你可能就会想：他生气是因为我吗？我是不是哪里做的不好，让他不高兴了？</p><p>这么一来，你就陷进了<strong>毫无必要</strong>的不安和内疚里。</p><h2 id="敏感的解决方法"><a href="#敏感的解决方法" class="headerlink" title="敏感的解决方法"></a>敏感的解决方法</h2><p>这只是一篇文章，不是一针抗敏药。<strong>重要的是你看完之后要去做。</strong></p><p><strong>▍看看真正的「全局」</strong></p><p>当你发现自己在执着于某个小事，先告诉自己：停住，别陷进去！想这些根本没有意义，全是浪费时间！</p><p>问问自己：<strong>五年</strong>、<strong>十年之后</strong>，<strong>你还会记得这件事吗</strong>？它到底能有多少影响？</p><p>把你那幅「放大了无数倍」的画缩回正常尺寸，从时间的「全局」上来看这件事，<strong>它还值得你这么纠结吗</strong>？</p><p>除了时间，还有生活的全局。</p><p>比如当你纠结于室友的那句「该倒个垃圾了」的时候，先告诉自己：别老琢磨了，有啥用？</p><p>然后去想想，你昨天还跟他一块儿打排位，上周末还约了火锅，他难道会因为一个垃圾桶跟你「断交」吗？</p><p>再说了，<strong>你的生活难道只有一个垃圾桶</strong>、<strong>一个室友吗</strong>？这让你爸妈、闺蜜还有你最爱去的那家火锅店，情何以堪？</p><p>除了想，你还可以动起来，<strong>去找点儿事做</strong>。</p><p>很多负面情绪其实都是「闲」出来的。你如果没有躺在床上「琢磨」，而是去追剧，或者吸猫，你根本就不会想起室友的那句话。</p><p>看看生活的全貌，让自己投入进去，<strong>别留太多时间给你「琢磨」</strong>。</p><p><strong>▍不要猜测，把话说出来</strong></p><p>如果你就是控制不住，一直在想「他是不是觉得我懒？我真的很懒吗？」那就把你的疑问说出来。</p><p><strong>不要「猜」</strong>，<strong>直接去问他</strong>：你昨天那样说是因为，你觉得我不经常倒垃圾吗？</p><p>如果他说不是，那你的不安就彻底解决了；如果他说是，那你也不用担心，<strong>这本来就是个「小事」</strong>，<strong>还怕解决不了吗</strong>？</p><p>跟他商量一下，轮流打扫卫生，或者买两个垃圾桶，一人一个，这不就完事了？</p><p><strong>▍卸下不必要的责任</strong></p><p>当你察觉到别人生气或者伤心了，开始担心这是「你的错」，告诉自己：这不关我的事。</p><p>这不是「不善良」或者「自私」，而是因为，每个人都得为自己的行为和情绪负责。这是他自己的难题，<strong>他必须，也只能自己去解决。</strong></p><p>如果他向你寻求帮助，你可以开解或安慰他，但是<strong>不管**</strong>成不成功，你都没有「责任」。</p><h2 id="终极必杀：提高自我认知"><a href="#终极必杀：提高自我认知" class="headerlink" title="终极必杀：提高自我认知"></a>终极必杀：提高自我认知</h2><p>如果你习惯于用别人的评价定义自己，那你一定很敏感。因为你需要不停的「察言观色」，去猜别人的想法。</p><p>那怎么才能不依赖外界，让自己来决定你的价值？</p><p><strong>▍不要物化自己</strong></p><p><strong>你不是学积分，也不是体重秤，更不是别人嘴里的几个「形容词」。</strong>你是一个完整的，有思想、感觉和情绪的人。</p><p>当你因为别人的评价质疑自己的时候，提醒自己：<strong>你是什么样的人，他说了不算。</strong></p><p>不管他是谁，你的父母、老师还是最好的朋友，他都不能定义你。别人看到的只是「他眼中的你」，那不完整。</p><p><strong>你不是一成不变的。</strong>你每一天、每一分钟都在改变。这些变化别人不清楚，但你自己知道。</p><p><strong>▍了解自己</strong></p><p>拿出一张纸，<strong>把这些问题的答案写出来</strong>：</p><blockquote><p>最了解我的人是</p><p>我的一个人生梦想是</p><p>用三个形容词描述我自己</p><p>我最喜欢自己的这一点</p><p>我最不喜欢这一点</p><p>我比较擅长</p><p>我不太擅长</p><p>我喜欢</p><p>我讨厌</p><p>吸引我的三个职业是</p><p>我的人生目标是</p></blockquote><p>回答完毕后，你是不是对自己有了更<strong>明确、稳定</strong>的认知？</p><p>你可以每隔一段时间就回答一次，看看有什么变化，这样会更了解自己。</p><p>当你逐渐认识了自己，你会开始树立出一个<strong>「理想的自我」</strong>。</p><p>朝着这个方向去努力，你会发现，<strong>你不再需要他人的认可来确定自己的「进步」</strong>。你自己心里很清楚，你哪里做得好，哪里还要继续改进。</p><p>当你不再依赖于外界去获取动力，你的前进也就从容起来了。</p></the></excerpt>]]></content>
      
      
      <categories>
          
          <category> 所见所闻 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 所见所闻 </tag>
            
            <tag> 同理心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java嵌套类</title>
      <link href="/2018/03/03/java%E5%B5%8C%E5%A5%97%E7%B1%BB/"/>
      <url>/2018/03/03/java%E5%B5%8C%E5%A5%97%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>讲解java中嵌套类的概念，也就是在类中定义另一个类的概念（未完待续。。。）</excerpt></p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>java语言允许你在一个类中定义另一个类，这样的类称为嵌套类，形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>术语: 嵌套类分为2类：静态、非静态。静态的嵌套类称为静态嵌套类，非静态的嵌套类称为内部类，如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套类是包围它的外部类（enclosing class）的一个成员，非静态嵌套类（内部类）可以访问到其他成员，即使它们被定义为私有的（private）。静态嵌套类不能访问其他成员。作为外部类的成员，嵌套类可以被声明为 private, public, protected, 或者 package private 四种访问权限</p><p><strong>为什么要使用嵌套类呢?</strong></p><ul><li>这是一种有效组织那种只在某一处使用到的类的方法：比如一个类只对另外一个类有用，那么把它们两放在一起，嵌套在一起是合乎逻辑的，将这样的辅助类（helper classes）嵌套在一起使得java包更加简洁合理.</li><li>增强了封装性: 考虑两个顶层类（top-level classes）, A 和 B, 其中B需要访问A的成员，否则这些成员将被声明为私有。如果将B藏在A中, A的成员即使被定义为私有的，B也可以访问到， 另外，B本身也与外界隔离开来</li><li>更加可读，并且有利于维护代码: Nesting small classes within top-level classes places the code closer to where it is used.</li></ul><h3 id="静态嵌套类（Static-Nested-Classes）"><a href="#静态嵌套类（Static-Nested-Classes）" class="headerlink" title="静态嵌套类（Static Nested Classes）"></a>静态嵌套类（Static Nested Classes）</h3><p>与类方法、类变量成员一样，一个静态嵌套类与外部类是相关联的，而且与静态方法类似，静态嵌套类不能直接获取到外部类的实例变量或者其中的函数：它只能通过类引用来使用它们。</p><p>注意：静态嵌套类与其外部类（或者其他类）的实例成员之间的交互，就像其他顶层类之间一样。实际上，一个静态嵌套类在表现上像是一个顶级类，其实是嵌套在另一个顶级类中的，以方便打包。<br>使用到静态嵌套类时必须通过外部类，形如：<code>OuterClass.StaticNestedClass</code><br>比如要创建一个静态嵌套类的实例，语法如下：<br><code>OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();</code><br>​     </p><h3 id="内部类（Inner-Classes）"><a href="#内部类（Inner-Classes）" class="headerlink" title="内部类（Inner Classes）"></a>内部类（Inner Classes）</h3><p>与实例方法、实例变量成员一样，一个内部类与外部类的一个实例是相关联的，而且能够直接访问到外部类实例中的方法与变量，而且因为内部类是与实例相关联的，因此内部类中是无法定义静态成员的。</p><p>内部类的实例只能与外部类的实例同时存在，无法独立实例化，并且能够直接访问到外部类的方法与变量<br>想要实例化一个内部类，你必须先实例化一个外部类，然后才能通过外部类创建一个内部类的实例，语法如下：</p><p><code>OuterClass.InnerClass innerObject = outerObject.new InnerClass();</code><br>内部类中有两种特殊的类：局部类、匿名类</p><h4 id="局部类（Local-Classes）"><a href="#局部类（Local-Classes）" class="headerlink" title="局部类（Local Classes）"></a>局部类（Local Classes）</h4><p>Local classes are classes that are defined in a <em>block</em>, which is a group of zero or more statements between balanced braces. You typically find local classes defined in the body of a method.</p><p>This section covers the following topics:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#declaring-local-classes" target="_blank" rel="noopener">Declaring Local Classes</a></li><li>Accessing Members of an Enclosing Class<ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#shadowing-and-local-classes" target="_blank" rel="noopener">Shadowing and Local Classes</a></li></ul></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#local-classes-are-similar-to-inner-classes" target="_blank" rel="noopener">Local Classes Are Similar To Inner Classes</a></li></ul><h5 id="Declaring-Local-Classes"><a href="#Declaring-Local-Classes" class="headerlink" title="Declaring Local Classes"></a><a href="">Declaring Local Classes</a></h5><p>You can define a local class inside any block (see <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html" target="_blank" rel="noopener">Expressions, Statements, and Blocks</a> for more information). For example, you can define a local class in a method body, a <code>for</code> loop, or an <code>if</code> clause.</p><p>The following example, <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LocalClassExample.java" target="_blank" rel="noopener"><code>LocalClassExample</code></a>, validates two phone numbers. It defines the local class <code>PhoneNumber</code> in the method <code>validatePhoneNumber</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class LocalClassExample &#123;</span><br><span class="line">  </span><br><span class="line">    static String regularExpression = &quot;[^0-9]&quot;;</span><br><span class="line">  </span><br><span class="line">    public static void validatePhoneNumber(</span><br><span class="line">        String phoneNumber1, String phoneNumber2) &#123;</span><br><span class="line">      </span><br><span class="line">        final int numberLength = 10;</span><br><span class="line">        </span><br><span class="line">        // Valid in JDK 8 and later:</span><br><span class="line">       </span><br><span class="line">        // int numberLength = 10;</span><br><span class="line">       </span><br><span class="line">        class PhoneNumber &#123;</span><br><span class="line">            </span><br><span class="line">            String formattedPhoneNumber = null;</span><br><span class="line"></span><br><span class="line">            PhoneNumber(String phoneNumber)&#123;</span><br><span class="line">                // numberLength = 7;</span><br><span class="line">                String currentNumber = phoneNumber.replaceAll(</span><br><span class="line">                  regularExpression, &quot;&quot;);</span><br><span class="line">                if (currentNumber.length() == numberLength)</span><br><span class="line">                    formattedPhoneNumber = currentNumber;</span><br><span class="line">                else</span><br><span class="line">                    formattedPhoneNumber = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public String getNumber() &#123;</span><br><span class="line">                return formattedPhoneNumber;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Valid in JDK 8 and later:</span><br><span class="line"></span><br><span class="line">//            public void printOriginalNumbers() &#123;</span><br><span class="line">//                System.out.println(&quot;Original numbers are &quot; + phoneNumber1 +</span><br><span class="line">//                    &quot; and &quot; + phoneNumber2);</span><br><span class="line">//            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);</span><br><span class="line">        PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);</span><br><span class="line">        </span><br><span class="line">        // Valid in JDK 8 and later:</span><br><span class="line"></span><br><span class="line">//        myNumber1.printOriginalNumbers();</span><br><span class="line"></span><br><span class="line">        if (myNumber1.getNumber() == null) </span><br><span class="line">            System.out.println(&quot;First number is invalid&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;First number is &quot; + myNumber1.getNumber());</span><br><span class="line">        if (myNumber2.getNumber() == null)</span><br><span class="line">            System.out.println(&quot;Second number is invalid&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;Second number is &quot; + myNumber2.getNumber());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        validatePhoneNumber(&quot;123-456-7890&quot;, &quot;456-7890&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The example validates a phone number by first removing all characters from the phone number except the digits 0 through 9. After, it checks whether the phone number contains exactly ten digits (the length of a phone number in North America). This example prints the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First number is 1234567890</span><br><span class="line">Second number is invalid</span><br></pre></td></tr></table></figure><h5 id="Accessing-Members-of-an-Enclosing-Class"><a href="#Accessing-Members-of-an-Enclosing-Class" class="headerlink" title="Accessing Members of an Enclosing Class"></a><a href="">Accessing Members of an Enclosing Class</a></h5><p>A local class has access to the members of its enclosing class. In the previous example, the <code>PhoneNumber</code> constructor accesses the member <code>LocalClassExample.regularExpression</code>.</p><p>In addition, a local class has access to local variables. However, a local class can only access local variables that are declared final. When a local class accesses a local variable or parameter of the enclosing block, it <em>captures</em> that variable or parameter. For example, the <code>PhoneNumber</code> constructor can access the local variable <code>numberLength</code> because it is declared final; <code>numberLength</code> is a <em>captured variable</em>.</p><p>However, starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or <em>effectively final</em>. A variable or parameter whose value is never changed after it is initialized is effectively final. For example, suppose that the variable <code>numberLength</code> is not declared final, and you add the highlighted assignment statement in the <code>PhoneNumber</code> constructor to change the length of a valid phone number to 7 digits:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumber(String phoneNumber) &#123;</span><br><span class="line">    numberLength = 7;</span><br><span class="line">    String currentNumber = phoneNumber.replaceAll(</span><br><span class="line">        regularExpression, &quot;&quot;);</span><br><span class="line">    if (currentNumber.length() == numberLength)</span><br><span class="line">        formattedPhoneNumber = currentNumber;</span><br><span class="line">    else</span><br><span class="line">        formattedPhoneNumber = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because of this assignment statement, the variable <code>numberLength</code> is not effectively final anymore. As a result, the Java compiler generates an error message similar to “local variables referenced from an inner class must be final or effectively final” where the inner class <code>PhoneNumber</code> tries to access the <code>numberLength</code> variable:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (currentNumber.length() == numberLength)</span><br></pre></td></tr></table></figure><p>Starting in Java SE 8, if you declare the local class in a method, it can access the method’s parameters. For example, you can define the following method in the <code>PhoneNumber</code> local class:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void printOriginalNumbers() &#123;</span><br><span class="line">    System.out.println(&quot;Original numbers are &quot; + phoneNumber1 +</span><br><span class="line">        &quot; and &quot; + phoneNumber2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The method <code>printOriginalNumbers</code> accesses the parameters <code>phoneNumber1</code> and <code>phoneNumber2</code> of the method <code>validatePhoneNumber</code>.</p><h6 id="Shadowing-and-Local-Classes"><a href="#Shadowing-and-Local-Classes" class="headerlink" title="Shadowing and Local Classes"></a><a href="">Shadowing and Local Classes</a></h6><p>Declarations of a type (such as a variable) in a local class shadow declarations in the enclosing scope that have the same name. See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing" target="_blank" rel="noopener">Shadowing</a> for more information.</p><h5 id="Local-Classes-Are-Similar-To-Inner-Classes"><a href="#Local-Classes-Are-Similar-To-Inner-Classes" class="headerlink" title="Local Classes Are Similar To Inner Classes"></a><a href="">Local Classes Are Similar To Inner Classes</a></h5><p>Local classes are similar to inner classes because they cannot define or declare any static members. Local classes in static methods, such as the class <code>PhoneNumber</code>, which is defined in the static method <code>validatePhoneNumber</code>, can only refer to static members of the enclosing class. For example, if you do not define the member variable <code>regularExpression</code> as static, then the Java compiler generates an error similar to “non-static variable <code>regularExpression</code> cannot be referenced from a static context.”</p><p>Local classes are non-static because they have access to instance members of the enclosing block. Consequently, they cannot contain most kinds of static declarations.</p><p>You cannot declare an interface inside a block; interfaces are inherently static. For example, the following code excerpt does not compile because the interface <code>HelloThere</code> is defined inside the body of the method <code>greetInEnglish</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void greetInEnglish() &#123;</span><br><span class="line">    interface HelloThere &#123;</span><br><span class="line">       public void greet();</span><br><span class="line">    &#125;</span><br><span class="line">    class EnglishHelloThere implements HelloThere &#123;</span><br><span class="line">        public void greet() &#123;</span><br><span class="line">            System.out.println(&quot;Hello &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HelloThere myGreeting = new EnglishHelloThere();</span><br><span class="line">    myGreeting.greet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You cannot declare static initializers or member interfaces in a local class. The following code excerpt does not compile because the method <code>EnglishGoodbye.sayGoodbye</code> is declared <code>static</code>. The compiler generates an error similar to “modifier ‘static’ is only allowed in constant variable declaration” when it encounters this method definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void sayGoodbyeInEnglish() &#123;</span><br><span class="line">    class EnglishGoodbye &#123;</span><br><span class="line">        public static void sayGoodbye() &#123;</span><br><span class="line">            System.out.println(&quot;Bye bye&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EnglishGoodbye.sayGoodbye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A local class can have static members provided that they are constant variables. (A <em>constant variable</em> is a variable of primitive type or type <code>String</code> that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html" target="_blank" rel="noopener">Understanding Class Members</a> for more information.) The following code excerpt compiles because the static member <code>EnglishGoodbye.farewell</code> is a constant variable:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void sayGoodbyeInEnglish() &#123;</span><br><span class="line">    class EnglishGoodbye &#123;</span><br><span class="line">        public static final String farewell = &quot;Bye bye&quot;;</span><br><span class="line">        public void sayGoodbye() &#123;</span><br><span class="line">            System.out.println(farewell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();</span><br><span class="line">    myEnglishGoodbye.sayGoodbye();</span><br><span class="line">&#125;待补充。。。</span><br></pre></td></tr></table></figure><h4 id="匿名类（Anonymous-Classes）"><a href="#匿名类（Anonymous-Classes）" class="headerlink" title="匿名类（Anonymous Classes）"></a>匿名类（Anonymous Classes）</h4><p>Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.</p><p>This section covers the following topics:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#declaring-anonymous-classes" target="_blank" rel="noopener">Declaring Anonymous Classes</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#syntax-of-anonymous-classes" target="_blank" rel="noopener">Syntax of Anonymous Classes</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#accessing" target="_blank" rel="noopener">Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#examples-of-anonymous-classes" target="_blank" rel="noopener">Examples of Anonymous Classes</a></li></ul><h5 id="Declaring-Anonymous-Classes"><a href="#Declaring-Anonymous-Classes" class="headerlink" title="Declaring Anonymous Classes"></a><a href="">Declaring Anonymous Classes</a></h5><p>While local classes are class declarations, anonymous classes are expressions, which means that you define the class in another expression. The following example, <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/HelloWorldAnonymousClasses.java" target="_blank" rel="noopener"><code>HelloWorldAnonymousClasses</code></a>, uses anonymous classes in the initialization statements of the local variables <code>frenchGreeting</code> and <code>spanishGreeting</code>, but uses a local class for the initialization of the variable <code>englishGreeting`</code>:`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldAnonymousClasses &#123;</span><br><span class="line">  </span><br><span class="line">    interface HelloWorld &#123;</span><br><span class="line">        public void greet();</span><br><span class="line">        public void greetSomeone(String someone);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        </span><br><span class="line">        class EnglishGreeting implements HelloWorld &#123;</span><br><span class="line">            String name = &quot;world&quot;;</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                greetSomeone(&quot;world&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            public void greetSomeone(String someone) &#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(&quot;Hello &quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        HelloWorld englishGreeting = new EnglishGreeting();</span><br><span class="line">        </span><br><span class="line">        HelloWorld frenchGreeting = new HelloWorld() &#123;</span><br><span class="line">            String name = &quot;tout le monde&quot;;</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                greetSomeone(&quot;tout le monde&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            public void greetSomeone(String someone) &#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(&quot;Salut &quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        HelloWorld spanishGreeting = new HelloWorld() &#123;</span><br><span class="line">            String name = &quot;mundo&quot;;</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                greetSomeone(&quot;mundo&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            public void greetSomeone(String someone) &#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(&quot;Hola, &quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        englishGreeting.greet();</span><br><span class="line">        frenchGreeting.greetSomeone(&quot;Fred&quot;);</span><br><span class="line">        spanishGreeting.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        HelloWorldAnonymousClasses myApp =</span><br><span class="line">            new HelloWorldAnonymousClasses();</span><br><span class="line">        myApp.sayHello();</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Syntax-of-Anonymous-Classes"><a href="#Syntax-of-Anonymous-Classes" class="headerlink" title="Syntax of Anonymous Classes"></a><a href="">Syntax of Anonymous Classes</a></h5><p>As mentioned previously, an anonymous class is an expression. The syntax of an anonymous class expression is like the invocation of a constructor, except that there is a class definition contained in a block of code.</p><p>Consider the instantiation of the <code>frenchGreeting</code> object:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld frenchGreeting = new HelloWorld() &#123;</span><br><span class="line">    String name = &quot;tout le monde&quot;;</span><br><span class="line">    public void greet() &#123;</span><br><span class="line">        greetSomeone(&quot;tout le monde&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void greetSomeone(String someone) &#123;</span><br><span class="line">        name = someone;</span><br><span class="line">        System.out.println(&quot;Salut &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The anonymous class expression consists of the following:</p><ul><li>The <code>new</code> operator</li><li>The name of an interface to implement or a class to extend. In this example, the anonymous class is implementing the interface <code>HelloWorld</code>.</li><li>Parentheses that contain the arguments to a constructor, just like a normal class instance creation expression. <strong>Note</strong>: When you implement an interface, there is no constructor, so you use an empty pair of parentheses, as in this example.</li><li>A body, which is a class declaration body. More specifically, in the body, method declarations are allowed but statements are not.</li></ul><p>Because an anonymous class definition is an expression, it must be part of a statement. In this example, the anonymous class expression is part of the statement that instantiates the <code>frenchGreeting</code> object. (This explains why there is a semicolon after the closing brace.)</p><h5 id="Accessing-Local-Variables-of-the-Enclosing-Scope-and-Declaring-and-Accessing-Members-of-the-Anonymous-Class"><a href="#Accessing-Local-Variables-of-the-Enclosing-Scope-and-Declaring-and-Accessing-Members-of-the-Anonymous-Class" class="headerlink" title="Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class"></a><a href="">Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class</a></h5><p>Like local classes, anonymous classes can <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#accessing-members-of-an-enclosing-class" target="_blank" rel="noopener">capture variables</a>; they have the same access to local variables of the enclosing scope:</p><ul><li>An anonymous class has access to the members of its enclosing class.</li><li>An anonymous class cannot access local variables in its enclosing scope that are not declared as <code>final</code> or effectively final.</li><li>Like a nested class, a declaration of a type (such as a variable) in an anonymous class shadows any other declarations in the enclosing scope that have the same name. See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing" target="_blank" rel="noopener">Shadowing</a> for more information.</li></ul><p>Anonymous classes also have the same restrictions as local classes with respect to their members:</p><ul><li>You cannot declare static initializers or member interfaces in an anonymous class.</li><li>An anonymous class can have static members provided that they are constant variables.</li></ul><p>Note that you can declare the following in anonymous classes:</p><ul><li>Fields</li><li>Extra methods (even if they do not implement any methods of the supertype)</li><li>Instance initializers</li><li>Local classes</li></ul><p>However, you cannot declare constructors in an anonymous class.</p><h5 id="Examples-of-Anonymous-Classes"><a href="#Examples-of-Anonymous-Classes" class="headerlink" title="Examples of Anonymous Classes"></a><a href="">Examples of Anonymous Classes</a></h5><p>Anonymous classes are often used in graphical user interface (GUI) applications.</p><p>Consider the JavaFX example <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm" target="_blank" rel="noopener"><code>HelloWorld.java</code></a> (from the section <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm" target="_blank" rel="noopener">Hello World, JavaFX Style</a> from <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/javafx_get_started.htm" target="_blank" rel="noopener">Getting Started with JavaFX</a>). This sample creates a frame that contains a <strong>Say ‘Hello World’</strong> button. The anonymous class expression is highlighted:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import javafx.event.ActionEvent;</span><br><span class="line">import javafx.event.EventHandler;</span><br><span class="line">import javafx.scene.Scene;</span><br><span class="line">import javafx.scene.control.Button;</span><br><span class="line">import javafx.scene.layout.StackPane;</span><br><span class="line">import javafx.stage.Stage;</span><br><span class="line"> </span><br><span class="line">public class HelloWorld extends Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        launch(args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void start(Stage primaryStage) &#123;</span><br><span class="line">        primaryStage.setTitle(&quot;Hello World!&quot;);</span><br><span class="line">        Button btn = new Button();</span><br><span class="line">        btn.setText(&quot;Say &apos;Hello World&apos;&quot;);</span><br><span class="line">        btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">            @Override</span><br><span class="line">            public void handle(ActionEvent event) &#123;</span><br><span class="line">                System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        StackPane root = new StackPane();</span><br><span class="line">        root.getChildren().add(btn);</span><br><span class="line">        primaryStage.setScene(new Scene(root, 300, 250));</span><br><span class="line">        primaryStage.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, the method invocation <code>btn.setOnAction</code> specifies what happens when you select the <strong>Say ‘Hello World’</strong> button. This method requires an object of type <code>EventHandler&lt;ActionEvent&gt;</code>. The <code>EventHandler&lt;ActionEvent&gt;</code> interface contains only one method, handle. Instead of implementing this method with a new class, the example uses an anonymous class expression. Notice that this expression is the argument passed to the <code>btn.setOnAction</code> method.</p><p>Because the <code>EventHandler&lt;ActionEvent&gt;</code> interface contains only one method, you can use a lambda expression instead of an anonymous class expression. See the section <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda Expressions</a> for more information.</p><p>Anonymous classes are ideal for implementing an interface that contains two or more methods. The following JavaFX example is from the section <a href="https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/custom.htm" target="_blank" rel="noopener">Customization of UI Controls</a>. The highlighted code creates a text field that only accepts numeric values. It redefines the default implementation of the <code>TextField</code> class with an anonymous class by overriding the <code>replaceText</code> and <code>replaceSelection</code> methods inherited from the <code>TextInputControl</code> class.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import javafx.application.Application;</span><br><span class="line">import javafx.event.ActionEvent;</span><br><span class="line">import javafx.event.EventHandler;</span><br><span class="line">import javafx.geometry.Insets;</span><br><span class="line">import javafx.scene.Group;</span><br><span class="line">import javafx.scene.Scene;</span><br><span class="line">import javafx.scene.control.*;</span><br><span class="line">import javafx.scene.layout.GridPane;</span><br><span class="line">import javafx.scene.layout.HBox;</span><br><span class="line">import javafx.stage.Stage;</span><br><span class="line"></span><br><span class="line">public class CustomTextFieldSample extends Application &#123;</span><br><span class="line">    </span><br><span class="line">    final static Label label = new Label();</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void start(Stage stage) &#123;</span><br><span class="line">        Group root = new Group();</span><br><span class="line">        Scene scene = new Scene(root, 300, 150);</span><br><span class="line">        stage.setScene(scene);</span><br><span class="line">        stage.setTitle(&quot;Text Field Sample&quot;);</span><br><span class="line"> </span><br><span class="line">        GridPane grid = new GridPane();</span><br><span class="line">        grid.setPadding(new Insets(10, 10, 10, 10));</span><br><span class="line">        grid.setVgap(5);</span><br><span class="line">        grid.setHgap(5);</span><br><span class="line"> </span><br><span class="line">        scene.setRoot(grid);</span><br><span class="line">        final Label dollar = new Label(&quot;$&quot;);</span><br><span class="line">        GridPane.setConstraints(dollar, 0, 0);</span><br><span class="line">        grid.getChildren().add(dollar);</span><br><span class="line">        </span><br><span class="line">        final TextField sum = new TextField() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void replaceText(int start, int end, String text) &#123;</span><br><span class="line">                if (!text.matches(&quot;[a-z, A-Z]&quot;)) &#123;</span><br><span class="line">                    super.replaceText(start, end, text);                     </span><br><span class="line">                &#125;</span><br><span class="line">                label.setText(&quot;Enter a numeric value&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            @Override</span><br><span class="line">            public void replaceSelection(String text) &#123;</span><br><span class="line">                if (!text.matches(&quot;[a-z, A-Z]&quot;)) &#123;</span><br><span class="line">                    super.replaceSelection(text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        sum.setPromptText(&quot;Enter the total&quot;);</span><br><span class="line">        sum.setPrefColumnCount(10);</span><br><span class="line">        GridPane.setConstraints(sum, 1, 0);</span><br><span class="line">        grid.getChildren().add(sum);</span><br><span class="line">        </span><br><span class="line">        Button submit = new Button(&quot;Submit&quot;);</span><br><span class="line">        GridPane.setConstraints(submit, 2, 0);</span><br><span class="line">        grid.getChildren().add(submit);</span><br><span class="line">        </span><br><span class="line">        submit.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handle(ActionEvent e) &#123;</span><br><span class="line">                label.setText(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        GridPane.setConstraints(label, 0, 1);</span><br><span class="line">        GridPane.setColumnSpan(label, 3);</span><br><span class="line">        grid.getChildren().add(label);</span><br><span class="line">        </span><br><span class="line">        scene.setRoot(grid);</span><br><span class="line">        stage.show();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        launch(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遮盖（Shadowing）、变量作用域问题"><a href="#遮盖（Shadowing）、变量作用域问题" class="headerlink" title="遮盖（Shadowing）、变量作用域问题"></a>遮盖（Shadowing）、变量作用域问题</h3><p>如果在特定范围内（比如在内部类或者方法中）有一个声明（成员变量声明或者方法参数名字）与该范围外的另一个声明拥有相同的名字，那么该范围内的声明就会遮盖掉范围外的声明。你就不能仅简单地通过名字来引用被遮盖的那个声明，请看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FirstLevel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">methodInFirstLevel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"x = "</span> + x);</span><br><span class="line">            System.out.println(<span class="string">"this.x = "</span> + <span class="keyword">this</span>.x);</span><br><span class="line">            System.out.println(<span class="string">"ShadowTest.this.x = "</span> + ShadowTest.<span class="keyword">this</span>.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        ShadowTest st = <span class="keyword">new</span> ShadowTest();</span><br><span class="line">        ShadowTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">23</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">ShadowTest.<span class="keyword">this</span>.x = <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>该例子中定义了3个名为x的变量：类ShadowTest的成员变量、内部类FirstLevel的成员变量、methodInFirstLevel方法的形参。methodInFirstLevel方法的形参遮盖住了内部类FirstLevel的成员变量，因此，当你在方法中使用x时，x表示的是方法的参数x。想要获得内部类FirstLevel的成员变量x，要通过关键字<strong>this</strong> 来代表外部的作用域（enclosing scope），也就是FirstLevel类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"this.x = "</span> + <span class="keyword">this</span>.x);</span><br></pre></td></tr></table></figure><p>要获取到更大作用域的成员变量时，需要通过其所属的类的类名来访问，比如以下的语句，在methodInFirstLevel方法中获取最外层的ShadowTest 类的成员变量x</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"ShadowTest.this.x = "</span> + ShadowTest.<span class="keyword">this</span>.x);</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html</a></p></the>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>英语语法——中级：第3章.完成时态</title>
      <link href="/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC3%E7%AB%A0-%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/"/>
      <url>/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC3%E7%AB%A0-%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>第3章.完成时态总结<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="/2018/02/11/英语语法——中级：第3章-完成时态/3.完成时态.png" alt="完成时态"></the></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时态 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>英语语法——中级：第2章.名词、定语、状语从句</title>
      <link href="/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC2%E7%AB%A0-%E5%90%8D%E8%AF%8D%E3%80%81%E5%AE%9A%E8%AF%AD%E3%80%81%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
      <url>/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC2%E7%AB%A0-%E5%90%8D%E8%AF%8D%E3%80%81%E5%AE%9A%E8%AF%AD%E3%80%81%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>第2章.名词、定语、状语从句总结<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="/2018/02/11/英语语法——中级：第2章-名词、定语、状语从句/2.名词、定语、状语从句.png" alt="名词、定语、状语从句"></the></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>英语语法——中级：第1章.简单句与复合句</title>
      <link href="/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC1%E7%AB%A0-%E7%AE%80%E5%8D%95%E5%8F%A5%E4%B8%8E%E5%A4%8D%E5%90%88%E5%8F%A5/"/>
      <url>/2018/02/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94%E4%B8%AD%E7%BA%A7%EF%BC%9A%E7%AC%AC1%E7%AB%A0-%E7%AE%80%E5%8D%95%E5%8F%A5%E4%B8%8E%E5%A4%8D%E5%90%88%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>第1章.简单句与复合句总结<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="/2018/02/11/英语语法——中级：第1章-简单句与复合句/1.简单句与复合句.png" alt="简单句与复合句"></the></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复合句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim常用按键总结</title>
      <link href="/2017/11/08/vim%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2017/11/08/vim%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>通过对linux中自带的vimtutor命令学习，然后对常用的vim命令进行总结，方便以后忘记了常看<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim file +n ：打开文件并跳到第N行</span><br><span class="line"></span><br><span class="line">默认显示行号：编辑或新建~/.vimrc   添加一行 set nu 即可，或者在/etc/vimrc 内编辑</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令的基本模式 <code>operation [number] range</code></p><h3 id="定位移动"><a href="#定位移动" class="headerlink" title="定位移动"></a>定位移动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        k上</span><br><span class="line">    h左       l右</span><br><span class="line">         j下</span><br><span class="line">    </span><br><span class="line">4h 左4个字符     4k 上4行     4j 下4行     4l 右4个字符</span><br><span class="line">    </span><br><span class="line">2gg                             "定位到第2行代码，等同于2G</span><br><span class="line">2G                              "定位到第2行代码</span><br><span class="line">gg                              "定位到整个代码的第1行</span><br><span class="line">G                               "定位到整个代码的最后一行</span><br><span class="line"></span><br><span class="line">0                               "行首</span><br><span class="line"><span class="meta">$</span>                               "行尾</span><br><span class="line"></span><br><span class="line">e                               "向后跳到该单词结束处</span><br><span class="line">w                               "向后跳一个单词的长度，即调到下一个单词的开始处</span><br><span class="line">b                               "向前跳一个单词的长度，即调到上一个单词的开始处</span><br><span class="line">2e,2w,2b表示移动2个单位</span><br><span class="line"></span><br><span class="line">H                               "当前屏幕可见的第一行</span><br><span class="line">M                               "当前屏幕可见的中间</span><br><span class="line">L                               "当前屏幕可见的最后一行</span><br></pre></td></tr></table></figure><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">i                               "光标处插入</span><br><span class="line">a                               "光标后一个字符处插入</span><br><span class="line">A                               "光标所在行末尾插入</span><br><span class="line">o                               "光标下方新建一行</span><br><span class="line">O                               "光标上方新建一行</span><br><span class="line"></span><br><span class="line">p                               "粘贴</span><br><span class="line">y                               "复制选择的文本</span><br><span class="line">yw或ye                          "复制一个单词</span><br><span class="line">yy                              "复制 光标所在的这一行</span><br><span class="line">4yy                             "复制 光标所在行开始向下的4行</span><br><span class="line"></span><br><span class="line">dd                              "剪切 光标所在的这一行</span><br><span class="line">2dd                             "剪切 光标所在行 向下 2行</span><br><span class="line">d0                              "从当前的光标开始剪切，一直到行首</span><br><span class="line">D                               "从当前的光标开始剪切，一直到行末</span><br><span class="line"></span><br><span class="line">dw                              "删除光标后的一个单词</span><br><span class="line">d2w                             "删除光标后2个单词</span><br><span class="line">x                               "删除当前的光标，每次只会删除一个</span><br><span class="line">X                               "删除当前光标前面的那个，每次只会删除一个</span><br><span class="line"></span><br><span class="line">r                               "替换光标后的一个字符</span><br><span class="line">R                               "连续替换光标后的字符</span><br><span class="line"></span><br><span class="line">ce或cw                          "修改该单词到单词结尾</span><br><span class="line"><span class="meta">c$</span>                              "修改光标后该行的全部内容</span><br><span class="line"></span><br><span class="line">.                               "重复执行上一次的命令</span><br><span class="line"></span><br><span class="line">u                               "撤销最后的操作</span><br><span class="line">U                               "撤销对整行的修改</span><br><span class="line">ctrl+r                          "反撤销</span><br></pre></td></tr></table></figure><h3 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f                          "向下翻一页代码</span><br><span class="line">ctrl+b                          "向上翻一页代码</span><br><span class="line"></span><br><span class="line">ctrl+d                          "向下翻半页代码</span><br><span class="line">ctrl+u                          "向上翻半页代码</span><br><span class="line"></span><br><span class="line">" 可视化模式，可以配合d,x,y等进行修改，也可以进来末行模式:w filename 进行另存</span><br><span class="line">v                               "字符可视化模式（Characterwise visual mode），文本选择是以字符为单位的，</span><br><span class="line">V                               "行可视化模式（Linewise visual mode)，文本选择是以行为单位的。</span><br><span class="line">ctrl-V                          "块可视化模式（Blockwise visual mode），可以选择一个矩形内的文本。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;                              "向右移动代码</span><br><span class="line">&lt;&lt;                              "向左移动代码</span><br><span class="line"></span><br><span class="line">shift+zz                        "相当于wq</span><br></pre></td></tr></table></figure><h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/xxx                            "向下查找关键字xxx</span><br><span class="line">/xxx\c                          "忽略大小写</span><br><span class="line">?xxx                            "向上查找关键字xxx</span><br><span class="line">?xxx\c                          "忽略大小写</span><br><span class="line">输入n则继续查找下一个匹配</span><br><span class="line">ctrl+o                          "光标跳转到查询到的上一个位置</span><br><span class="line">ctrl+i                          "光标跳转到查询到的下一个位置</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span>                               "快速查找光标所在处的括号所匹配的另一个括号 (),[],&#123;&#125;</span><br><span class="line"></span><br><span class="line">:s/old/new                      "替换该行第一个匹配串</span><br><span class="line">:s/old/new/g                    "替换该行全部匹配串</span><br><span class="line">:#,#s/old/new/g                 "替换#到"行之间的词</span><br><span class="line">:%s/old/new/gc                  "替换全文匹配串，并逐个询问是否替换</span><br></pre></td></tr></table></figure><h2 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:w                              "保存</span><br><span class="line">:w filename                     "保存为指定的文件</span><br><span class="line">:q                              "退出</span><br><span class="line">:wq                             "保存并且推出</span><br><span class="line">:x                              "等同于wq</span><br><span class="line">:r filename                     "读取外部文件粘贴到光标处</span><br><span class="line">:r !ls                          "获取命令输出内容粘贴到光标处</span><br></pre></td></tr></table></figure><h3 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h3><p>比较全面的内容参考全局配置那一节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">:set ic                         "查询关键字时忽略大小写</span><br><span class="line">:set is                         "查询关键字时显示部分匹配</span><br><span class="line">:set hls                        "高亮显示匹配到的关键字‘hlsearch’</span><br><span class="line">:set cp                         "兼容模式</span><br><span class="line">:set noxxx                      "关闭上面对应的设置</span><br><span class="line"></span><br><span class="line">:set encoding=utf-8             "设置编码</span><br><span class="line">:set number                     "显示行号</span><br><span class="line">:set ruler                      "右下角显示光标当前位置信息</span><br><span class="line">:set tabstop=4                  "设置缩进宽度</span><br><span class="line">:set shiftwidth=4               "设置缩进宽度</span><br><span class="line">"可以将这些设置偏好设置到 ~/.vimrc文件中</span><br></pre></td></tr></table></figure><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><ul><li>单次启用某个配置项，在命令模式下，先输入一个冒号，再输入配置</li><li>用户个人的配置在<code>~/.vimrc</code></li><li>Vim 的全局配置一般在<code>/etc/vim/vimrc</code>或者<code>/etc/vimrc</code>，对所有用户生效</li></ul><h3 id="查看配置状态"><a href="#查看配置状态" class="headerlink" title="查看配置状态"></a>查看配置状态</h3><p>查询某个配置项是打开还是关闭，可以在命令模式下，输入该配置，并在后面加上问号<code>?</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set nu?</span><br><span class="line">:set number?</span><br></pre></td></tr></table></figure><p>上面的命令会返回<code>number</code>或者<code>nonumber</code></p><h3 id="打开与关闭某项设置"><a href="#打开与关闭某项设置" class="headerlink" title="打开与关闭某项设置"></a>打开与关闭某项设置</h3><p>配置项一般都有”打开”和”关闭”两个设置。”关闭”就是在”打开”前面加上前缀”no”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">" 打开</span><br><span class="line">set nu</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">" 关闭</span><br><span class="line">set nonu</span><br><span class="line">set nonumber</span><br></pre></td></tr></table></figure><h3 id="末行命令自动补全"><a href="#末行命令自动补全" class="headerlink" title="末行命令自动补全"></a>末行命令自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">" 末行命令自动补全</span><br><span class="line">set wildmenu " (跟下面组合使用？没看出效果)</span><br><span class="line">set wildmode=longest:list,full    "命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。</span><br></pre></td></tr></table></figure><h3 id="推荐配置文件内容"><a href="#推荐配置文件内容" class="headerlink" title="推荐配置文件内容"></a>推荐配置文件内容</h3><p><a href="http://www.ruanyifeng.com/blog/2018/09/vimrc.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/09/vimrc.html</a></p><h4 id="外观、代码风格"><a href="#外观、代码风格" class="headerlink" title="外观、代码风格"></a>外观、代码风格</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">" 颜色相关</span><br><span class="line"></span><br><span class="line">syntax on                       "打开语法高亮，自动识别代码</span><br><span class="line">set hlsearch                    "搜索时，高亮显示匹配结果</span><br><span class="line">set showmatch                   "光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号</span><br><span class="line">set t_Co=256                    "启用256色</span><br><span class="line"></span><br><span class="line">" 换行相关</span><br><span class="line">set tabstop=4                   "按下Tab 键时，Vim 显示的空格数</span><br><span class="line">set wrap                        "自动折行，即太长的行分成几行显示。</span><br><span class="line">set linebreak                   "不会在单词内部折行。只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行</span><br><span class="line"></span><br><span class="line">" 光标位置相关</span><br><span class="line">set scrolloff=5                 "垂直滚动时，光标距离顶部/底部的行数，方便看到后面的内容</span><br><span class="line">set sidescrolloff=15            "水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用</span><br><span class="line"></span><br><span class="line">" 状态栏相关</span><br><span class="line">set ruler                       "在状态栏显示光标的当前位置（位于哪一行哪一列）</span><br><span class="line">set laststatus=2                "是否显示状态栏。0:不显示，1:只在多窗口时显示，2:显示</span><br><span class="line">set showmode                    "在底部显示，当前处于命令模式还是插入模式</span><br><span class="line">set showcmd                     "命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失。</span><br><span class="line"></span><br><span class="line">" 辅助显示</span><br><span class="line">set nu</span><br><span class="line">set number                      "显示行号</span><br><span class="line"></span><br><span class="line">set list                        "如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块。与listchars配合使用</span><br><span class="line">set listchars=tab:»■,trail:■ ,eol:$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"""""""""""""" 没效果或没用的😁</span><br><span class="line">" set cursorline                光标所在的当前行用下划线高亮(没什么用)</span><br><span class="line">" set relativenumber            显示光标所在的当前行的行号，其他行都为相对于该行的相对行号。(没什么用)</span><br><span class="line">" set spell spelllang=en_us     打开英语单词的拼写检查(不推荐，太亮了)</span><br><span class="line">" set textwidth=80              设置行宽，即一行显示多少个字符。(没效果？)</span><br><span class="line">" set wrapmargin=2              指定折行处与编辑窗口的右边缘之间空出的字符数</span><br></pre></td></tr></table></figure><h4 id="编辑相关"><a href="#编辑相关" class="headerlink" title="编辑相关"></a>编辑相关</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">set mouse=a                     "支持使用鼠标</span><br><span class="line">set encoding=utf-8              "使用 utf-8 编码。</span><br><span class="line"></span><br><span class="line">" 缩进相关</span><br><span class="line">set autoindent                  "按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致</span><br><span class="line">set expandtab                   "tab转为空格,而不是\t。</span><br><span class="line">set softtabstop=4               "Tab 转为多少个空格</span><br><span class="line">filetype indent on              "开启文件类型检查，并且载入与该类型对应的缩进规则。比如，如果编辑的是.py文件，Vim 就是会找 Python 的缩进规则~/.vim/indent/python.vim</span><br><span class="line"></span><br><span class="line">set history=1000                "Vim 需要记住多少次历史操作。</span><br><span class="line">set nocompatible                "不与 Vi 兼容（采用 Vim 自己的操作命令）。</span><br><span class="line"></span><br><span class="line">" 文件备份、历史相关</span><br><span class="line">set nobackup                    "不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）。</span><br><span class="line">set swapfile                    "创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.swp。</span><br><span class="line">set undofile                    "关闭文件后仍保留撤销历史。Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以.un~开头。</span><br><span class="line">set autochdir                   "自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。</span><br><span class="line">set backupdir=~/.vim/.backup//  "要新建这个文件夹</span><br><span class="line">set directory=~/.vim/.swp//     "要新建这个文件夹</span><br><span class="line">set undodir=~/.vim/.undo//      "要新建这个文件夹</span><br><span class="line">" 设置备份文件、交换文件、操作历史文件的保存位置。结尾的//表示生成的文件名带有绝对路径，路径中用%替换目录分隔符，这样可以防止文件重名。</span><br><span class="line"></span><br><span class="line">set autoread                    "打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 末行命令自动补全</span><br><span class="line">set wildmenu                    "(跟下面组合使用？没看出效果)</span><br><span class="line">set wildmode=longest:list,full  "命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。</span><br><span class="line"></span><br><span class="line">""""""" 暂时不知道有什么用的</span><br><span class="line">set shiftwidth=4                "在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者==（取消全部缩进）时，每一级的字符数</span><br></pre></td></tr></table></figure><h4 id="搜索相关"><a href="#搜索相关" class="headerlink" title="搜索相关"></a>搜索相关</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set incsearch </span><br><span class="line">set is                          "输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果</span><br><span class="line">set ignorecase </span><br><span class="line">set ic                          "搜索时忽略大小写</span><br><span class="line">set smartcase                   "如果同时打开了ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索Test时，将不匹配test；搜索test时，将匹配Test</span><br></pre></td></tr></table></figure><h3 id="关于粘贴缩进问题"><a href="#关于粘贴缩进问题" class="headerlink" title="关于粘贴缩进问题"></a>关于粘贴缩进问题</h3><p>结论：使用<code>:set paste</code></p><p>在Vim中粘贴Python代码后，缩进就全乱了。仔细研究了以下，原来是自动缩进的缘故，于是做如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set noai nosi</span><br></pre></td></tr></table></figure><p>取消了自动缩进和智能缩进，这样粘贴就不会错行了。但在有的vim中不行，还是排版错乱。</p><p>后来发现了<strong>更好用</strong>的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set paste</span><br></pre></td></tr></table></figure><p>进入paste模式以后，可以在插入模式下粘贴内容，不会有任何变形。这个真是灰常好用，情不自禁看了一下帮助，发现它做了这么多事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">textwidth设置为0</span><br><span class="line">wrapmargin设置为0</span><br><span class="line">set noai</span><br><span class="line">set nosi</span><br><span class="line">softtabstop设置为0</span><br><span class="line">revins重置</span><br><span class="line">ruler重置</span><br><span class="line">showmatch重置</span><br><span class="line">formatoptions使用空值</span><br><span class="line"></span><br><span class="line">下面的选项值不变，但却被禁用：</span><br><span class="line"></span><br><span class="line">lisp</span><br><span class="line">indentexpr</span><br><span class="line">cindent</span><br></pre></td></tr></table></figure><p>怪不得之前只设置noai和nosi不行，原来与这么多因素有关！</p><h4 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h4><p>但这样还是比较麻烦的，每次要粘贴的话，先set paste，然后粘贴，然后再set nopaste。<strong>更方便的方法</strong>是使用键盘映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:map &lt;F10&gt; :set paste&lt;CR&gt; </span><br><span class="line">:map &lt;F11&gt; :set nopaste&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>这样在粘贴前按F10键启动paste模式，粘贴后按F11取消paste模式即可。其实，paste有一个切换paste开关的选项，这就是pastetoggle。通过它可以绑定快捷键来激活/取消 paste模式。比如（暂时没试成功）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set pastetoggle=&lt;F11&gt;</span><br></pre></td></tr></table></figure><p>这样减少了一个快捷键的占用，使用起来也更方便一些。</p><p>以上这些设置只是打开这次回话才有效，想要永久有效，需要在<code>~/.vimrc</code>中添加上面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; 不需要冒号</span><br><span class="line">set pastetoggle=&lt;F11&gt;</span><br></pre></td></tr></table></figure></the>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
